/**
* @module vue-mdc-adapter 0.11.2
* @exports VueMDCAdapter
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.31.0"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.VueMDCAdapter = factory());
}(this, (function () { 'use strict';

function autoInit(plugin) {
  // Auto-install
  var _Vue = null;
  if (typeof window !== 'undefined') {
    _Vue = window.Vue;
  } else if (typeof global !== 'undefined') {
    /*global global*/
    _Vue = global.Vue;
  }
  if (_Vue) {
    _Vue.use(plugin);
  }
}

function BasePlugin(components) {
  return {
    version: '0.11.2',
    install: function install(vm) {
      for (var key in components) {
        var component = components[key];
        vm.component(component.name, component);
      }
    },
    components: components
  };
}

var CustomElement = {
  functional: true,
  render: function render(createElement, context) {
    return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
  }
};

var CustomElementMixin = {
  components: {
    CustomElement: CustomElement
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var CustomLink = {
  name: 'custom-link',
  functional: true,
  props: {
    tag: { type: String, default: 'a' },
    link: Object
  },
  render: function render(h, context) {
    var element = void 0;
    var data = _extends({}, context.data);

    if (context.props.link && context.parent.$router) {
      // router-link case
      element = context.parent.$root.$options.components['router-link'];
      data.props = _extends({ tag: context.props.tag }, context.props.link);
      if (data.on.click) {
        data.nativeOn = { click: data.on.click };
      }
    } else {
      // element fallback
      element = context.props.tag;
    }

    return h(element, data, context.children);
  }
};

var CustomLinkMixin = {
  props: {
    to: [String, Object],
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String
  },
  computed: {
    link: function link() {
      return this.to && {
        to: this.to,
        exact: this.exact,
        append: this.append,
        replace: this.replace,
        activeClass: this.activeClass,
        exactActiveClass: this.exactActiveClass
      };
    }
  },
  components: {
    CustomLink: CustomLink
  }
};

/* global CustomEvent */

function emitCustomEvent(el, evtType, evtData) {
  var shouldBubble = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var evt = void 0;
  if (typeof CustomEvent === 'function') {
    evt = new CustomEvent(evtType, {
      detail: evtData,
      bubbles: shouldBubble
    });
  } else {
    evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(evtType, shouldBubble, false, evtData);
  }
  el.dispatchEvent(evt);
}

var CustomButton = {
  name: 'custom-button',
  functional: true,
  props: {
    link: Object
  },
  render: function render(h, context) {
    var element = void 0;
    var data = _extends({}, context.data);

    if (context.props.link && context.parent.$router) {
      // router-link case
      element = context.parent.$root.$options.components['router-link'];
      data.props = _extends({ tag: context.props.tag }, context.props.link);
      data.attrs.role = 'button';
      if (data.on.click) {
        data.nativeOn = { click: data.on.click };
      }
    } else if (data.attrs && data.attrs.href) {
      // href case
      element = 'a';
      data.attrs.role = 'button';
    } else {
      // button fallback
      element = 'button';
    }

    return h(element, data, context.children);
  }
};

var CustomButtonMixin = {
  props: {
    href: String,
    disabled: Boolean,
    to: [String, Object],
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String
  },
  computed: {
    link: function link() {
      return this.to && {
        to: this.to,
        exact: this.exact,
        append: this.append,
        replace: this.replace,
        activeClass: this.activeClass,
        exactActiveClass: this.exactActiveClass
      };
    }
  },
  components: {
    CustomButton: CustomButton
  }
};

function extractIconProp(iconProp) {
  if (typeof iconProp === 'string') {
    return {
      classes: { 'material-icons': true },
      content: iconProp
    };
  } else if (iconProp instanceof Array) {
    return {
      classes: iconProp.reduce(function (result, value) {
        return _extends(result, defineProperty({}, value, true));
      }, {})
    };
  } else if ((typeof iconProp === 'undefined' ? 'undefined' : _typeof(iconProp)) === 'object') {
    return {
      classes: iconProp.className.split(' ').reduce(function (result, value) {
        return _extends(result, defineProperty({}, value, true));
      }, {}),
      content: iconProp.textContent
    };
  }
}

var DispatchEventMixin = {
  props: {
    'event': String,
    'event-target': Object,
    'event-args': Array
  },
  methods: {
    dispatchEvent: function dispatchEvent(evt) {
      this.$emit(evt.type);
      if (this.event) {
        var target = this.eventTarget || this.$root;
        var args = this.eventArgs || [];
        target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
      }
    }
  }
};

var DispatchFocusMixin = {
  data: function data() {
    return { hasFocus: false };
  },

  methods: {
    onMouseDown: function onMouseDown() {
      this._active = true;
    },
    onMouseUp: function onMouseUp() {
      this._active = false;
    },
    onFocusEvent: function onFocusEvent() {
      var _this = this;

      // dispatch async to let time to other focus event to propagate
      setTimeout(function () {
        return _this.dispatchFocusEvent();
      }, 0);
    },
    onBlurEvent: function onBlurEvent() {
      var _this2 = this;

      // dispatch async to let time to other focus event to propagate
      // also filtur blur if mousedown
      this._active || setTimeout(function () {
        return _this2.dispatchFocusEvent();
      }, 0);
    },
    dispatchFocusEvent: function dispatchFocusEvent() {
      var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
      if (hasFocus != this.hasFocus) {
        this.$emit(hasFocus ? 'focus' : 'blur');
        this.hasFocus = hasFocus;
      }
    }
  },
  mounted: function mounted() {
    this.$el.addEventListener('focusin', this.onFocusEvent);
    this.$el.addEventListener('focusout', this.onBlurEvent);
    this.$el.addEventListener('mousedown', this.onMouseDown);
    this.$el.addEventListener('mouseup', this.onMouseUp);
  },
  beforeDestroy: function beforeDestroy() {
    this.$el.removeEventListener('focusin', this.onFocusEvent);
    this.$el.removeEventListener('focusout', this.onBlurEvent);
    this.$el.removeEventListener('mousedown', this.onMouseDown);
    this.$el.removeEventListener('mouseup', this.onMouseUp);
  }
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
var MDCFoundation = function () {
  createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get$$1() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }

    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get$$1() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }

    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get$$1() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }

    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get$$1() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }

    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  createClass(MDCFoundation, [{
    key: "init",
    value: function init() {
      // Subclasses should override this method to perform initialization routines (registering events, etc.)
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    }
  }]);
  return MDCFoundation;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Ripple. Provides an interface for managing
 * - classes
 * - dom
 * - CSS variables
 * - position
 * - dimensions
 * - scroll position
 * - event handlers
 * - unbounded, active and disabled states
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCRippleAdapter = function () {
  function MDCRippleAdapter() {
    classCallCheck(this, MDCRippleAdapter);
  }

  createClass(MDCRippleAdapter, [{
    key: "browserSupportsCssVars",

    /** @return {boolean} */
    value: function browserSupportsCssVars() {}

    /** @return {boolean} */

  }, {
    key: "isUnbounded",
    value: function isUnbounded() {}

    /** @return {boolean} */

  }, {
    key: "isSurfaceActive",
    value: function isSurfaceActive() {}

    /** @return {boolean} */

  }, {
    key: "isSurfaceDisabled",
    value: function isSurfaceDisabled() {}

    /** @param {string} className */

  }, {
    key: "addClass",
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /** @param {!EventTarget} target */

  }, {
    key: "containsEventTarget",
    value: function containsEventTarget(target) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerDocumentInteractionHandler",
    value: function registerDocumentInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterDocumentInteractionHandler",
    value: function deregisterDocumentInteractionHandler(evtType, handler) {}

    /**
     * @param {!Function} handler
     */

  }, {
    key: "registerResizeHandler",
    value: function registerResizeHandler(handler) {}

    /**
     * @param {!Function} handler
     */

  }, {
    key: "deregisterResizeHandler",
    value: function deregisterResizeHandler(handler) {}

    /**
     * @param {string} varName
     * @param {?number|string} value
     */

  }, {
    key: "updateCssVariable",
    value: function updateCssVariable(varName, value) {}

    /** @return {!ClientRect} */

  }, {
    key: "computeBoundingRect",
    value: function computeBoundingRect() {}

    /** @return {{x: number, y: number}} */

  }, {
    key: "getWindowPageOffset",
    value: function getWindowPageOffset() {}
  }]);
  return MDCRippleAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
};

var strings = {
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
};

var numbers = {
  PADDING: 10,
  INITIAL_ORIGIN_SCALE: 0.6,
  DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
  FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
 * @private {boolean|undefined}
 */
var supportsCssVariables_ = void 0;

/**
 * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
 * @private {boolean|undefined}
 */
var supportsPassive_ = void 0;

/**
 * @param {!Window} windowObj
 * @return {boolean}
 */
function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  var document = windowObj.document;
  var node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node);

  // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  var computedStyle = windowObj.getComputedStyle(node);
  var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
  node.remove();
  return hasPseudoVarBug;
}

/**
 * @param {!Window} windowObj
 * @param {boolean=} forceRefresh
 * @return {boolean|undefined}
 */

function supportsCssVariables(windowObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables_;
  }

  var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
  if (!supportsFunctionPresent) {
    return;
  }

  var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
  // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari
  var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVariables_ = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVariables_ = false;
  }
  return supportsCssVariables_;
}

//
/**
 * Determine whether the current browser supports passive event listeners, and if so, use them.
 * @param {!Window=} globalObj
 * @param {boolean=} forceRefresh
 * @return {boolean|{passive: boolean}}
 */
function applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? { passive: true } : false;
}

/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */
function getMatchesProperty(HTMLElementPrototype) {
  return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
    return p in HTMLElementPrototype;
  }).pop();
}

/**
 * @param {!Event} ev
 * @param {!{x: number, y: number}} pageOffset
 * @param {!ClientRect} clientRect
 * @return {!{x: number, y: number}}
 */
function getNormalizedEventCoords(ev, pageOffset, clientRect) {
  var x = pageOffset.x,
      y = pageOffset.y;

  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;

  var normalizedX = void 0;
  var normalizedY = void 0;
  // Determine touch point relative to the ripple container.
  if (ev.type === 'touchstart') {
    normalizedX = ev.changedTouches[0].pageX - documentX;
    normalizedY = ev.changedTouches[0].pageY - documentY;
  } else {
    normalizedX = ev.pageX - documentX;
    normalizedY = ev.pageY - documentY;
  }

  return { x: normalizedX, y: normalizedY };
}

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Activation events registered on the root element of each instance for activation
var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

// Deactivation events registered on documentElement when a pointer-related down event occurs
var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

// Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
/** @type {!Array<!EventTarget>} */
var activatedTargets = [];

/**
 * @extends {MDCFoundation<!MDCRippleAdapter>}
 */

var MDCRippleFoundation = function (_MDCFoundation) {
  inherits(MDCRippleFoundation, _MDCFoundation);
  createClass(MDCRippleFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings;
    }
  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
        isUnbounded: function isUnbounded() /* boolean */{},
        isSurfaceActive: function isSurfaceActive() /* boolean */{},
        isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
        registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
        computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
        getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
      };
    }
  }]);

  function MDCRippleFoundation(adapter) {
    classCallCheck(this, MDCRippleFoundation);

    /** @private {number} */
    var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

    _this.layoutFrame_ = 0;

    /** @private {!ClientRect} */
    _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

    /** @private {!ActivationStateType} */
    _this.activationState_ = _this.defaultActivationState_();

    /** @private {number} */
    _this.initialSize_ = 0;

    /** @private {number} */
    _this.maxRadius_ = 0;

    /** @private {function(!Event)} */
    _this.activateHandler_ = function (e) {
      return _this.activate_(e);
    };

    /** @private {function(!Event)} */
    _this.deactivateHandler_ = function (e) {
      return _this.deactivate_(e);
    };

    /** @private {function(?Event=)} */
    _this.focusHandler_ = function () {
      return requestAnimationFrame(function () {
        return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    };

    /** @private {function(?Event=)} */
    _this.blurHandler_ = function () {
      return requestAnimationFrame(function () {
        return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    };

    /** @private {!Function} */
    _this.resizeHandler_ = function () {
      return _this.layout();
    };

    /** @private {!{left: number, top:number}} */
    _this.unboundedCoords_ = {
      left: 0,
      top: 0
    };

    /** @private {number} */
    _this.fgScale_ = 0;

    /** @private {number} */
    _this.activationTimer_ = 0;

    /** @private {number} */
    _this.fgDeactivationRemovalTimer_ = 0;

    /** @private {boolean} */
    _this.activationAnimationHasEnded_ = false;

    /** @private {!Function} */
    _this.activationTimerCallback_ = function () {
      _this.activationAnimationHasEnded_ = true;
      _this.runDeactivationUXLogicIfReady_();
    };

    /** @private {?Event} */
    _this.previousActivationEvent_ = null;
    return _this;
  }

  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   * @return {boolean}
   * @private
   */


  createClass(MDCRippleFoundation, [{
    key: 'isSupported_',
    value: function isSupported_() {
      return this.adapter_.browserSupportsCssVars();
    }

    /**
     * @return {!ActivationStateType}
     */

  }, {
    key: 'defaultActivationState_',
    value: function defaultActivationState_() {
      return {
        isActivated: false,
        hasDeactivationUXRun: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false,
        activationEvent: null,
        isProgrammatic: false
      };
    }
  }, {
    key: 'init',
    value: function init() {
      var _this2 = this;

      if (!this.isSupported_()) {
        return;
      }
      this.registerRootHandlers_();

      var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
          ROOT = _MDCRippleFoundation$.ROOT,
          UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

      requestAnimationFrame(function () {
        _this2.adapter_.addClass(ROOT);
        if (_this2.adapter_.isUnbounded()) {
          _this2.adapter_.addClass(UNBOUNDED);
        }
        _this2.layoutInternal_();
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      if (!this.isSupported_()) {
        return;
      }
      this.deregisterRootHandlers_();
      this.deregisterDeactivationHandlers_();

      var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
          ROOT = _MDCRippleFoundation$2.ROOT,
          UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

      requestAnimationFrame(function () {
        _this3.adapter_.removeClass(ROOT);
        _this3.adapter_.removeClass(UNBOUNDED);
        _this3.removeCssVars_();
      });
    }

    /** @private */

  }, {
    key: 'registerRootHandlers_',
    value: function registerRootHandlers_() {
      var _this4 = this;

      ACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
      });
      this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
      this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      this.adapter_.registerResizeHandler(this.resizeHandler_);
    }

    /**
     * @param {!Event} e
     * @private
     */

  }, {
    key: 'registerDeactivationHandlers_',
    value: function registerDeactivationHandlers_(e) {
      var _this5 = this;

      if (e.type === 'keydown') {
        this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
      } else {
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
        });
      }
    }

    /** @private */

  }, {
    key: 'deregisterRootHandlers_',
    value: function deregisterRootHandlers_() {
      var _this6 = this;

      ACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
      });
      this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
      this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }

    /** @private */

  }, {
    key: 'deregisterDeactivationHandlers_',
    value: function deregisterDeactivationHandlers_() {
      var _this7 = this;

      this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
      });
    }

    /** @private */

  }, {
    key: 'removeCssVars_',
    value: function removeCssVars_() {
      var _this8 = this;

      var strings$$1 = MDCRippleFoundation.strings;

      Object.keys(strings$$1).forEach(function (k) {
        if (k.indexOf('VAR_') === 0) {
          _this8.adapter_.updateCssVariable(strings$$1[k], null);
        }
      });
    }

    /**
     * @param {?Event} e
     * @private
     */

  }, {
    key: 'activate_',
    value: function activate_(e) {
      var _this9 = this;

      if (this.adapter_.isSurfaceDisabled()) {
        return;
      }

      var activationState = this.activationState_;
      if (activationState.isActivated) {
        return;
      }

      // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
      var previousActivationEvent = this.previousActivationEvent_;
      var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
      if (isSameInteraction) {
        return;
      }

      activationState.isActivated = true;
      activationState.isProgrammatic = e === null;
      activationState.activationEvent = e;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

      var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
        return _this9.adapter_.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        // Immediately reset activation state, while preserving logic that prevents touch follow-on events
        this.resetActivationState_();
        return;
      }

      if (e) {
        activatedTargets.push( /** @type {!EventTarget} */e.target);
        this.registerDeactivationHandlers_(e);
      }

      requestAnimationFrame(function () {
        // This needs to be wrapped in an rAF call b/c web browsers
        // report active states inconsistently when they're called within
        // event handling code:
        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
        activationState.wasElementMadeActive = e && e.type === 'keydown' ? _this9.adapter_.isSurfaceActive() : true;
        if (activationState.wasElementMadeActive) {
          _this9.animateActivation_();
        } else {
          // Reset activation state immediately if element was not made active.
          _this9.activationState_ = _this9.defaultActivationState_();
        }

        // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
        activatedTargets = [];
      });
    }

    /**
     * @param {?Event=} event Optional event containing position information.
     */

  }, {
    key: 'activate',
    value: function activate() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.activate_(event);
    }

    /** @private */

  }, {
    key: 'animateActivation_',
    value: function animateActivation_() {
      var _this10 = this;

      var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
          VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
          VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
      var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
          FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
          FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


      var translateStart = '';
      var translateEnd = '';

      if (!this.adapter_.isUnbounded()) {
        var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
            startPoint = _getFgTranslationCoor.startPoint,
            endPoint = _getFgTranslationCoor.endPoint;

        translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
        translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
      }

      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      // Cancel any ongoing activation/deactivation animations
      clearTimeout(this.activationTimer_);
      clearTimeout(this.fgDeactivationRemovalTimer_);
      this.rmBoundedActivationClasses_();
      this.adapter_.removeClass(FG_DEACTIVATION);

      // Force layout in order to re-trigger the animation.
      this.adapter_.computeBoundingRect();
      this.adapter_.addClass(FG_ACTIVATION);
      this.activationTimer_ = setTimeout(function () {
        return _this10.activationTimerCallback_();
      }, DEACTIVATION_TIMEOUT_MS);
    }

    /**
     * @private
     * @return {{startPoint: PointType, endPoint: PointType}}
     */

  }, {
    key: 'getFgTranslationCoordinates_',
    value: function getFgTranslationCoordinates_() {
      var _activationState_ = this.activationState_,
          activationEvent = _activationState_.activationEvent,
          wasActivatedByPointer = _activationState_.wasActivatedByPointer;


      var startPoint = void 0;
      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords(
        /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame_.width / 2,
          y: this.frame_.height / 2
        };
      }
      // Center the element around the start point.
      startPoint = {
        x: startPoint.x - this.initialSize_ / 2,
        y: startPoint.y - this.initialSize_ / 2
      };

      var endPoint = {
        x: this.frame_.width / 2 - this.initialSize_ / 2,
        y: this.frame_.height / 2 - this.initialSize_ / 2
      };

      return { startPoint: startPoint, endPoint: endPoint };
    }

    /** @private */

  }, {
    key: 'runDeactivationUXLogicIfReady_',
    value: function runDeactivationUXLogicIfReady_() {
      var _this11 = this;

      // This method is called both when a pointing device is released, and when the activation animation ends.
      // The deactivation animation should only run after both of those occur.
      var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
      var _activationState_2 = this.activationState_,
          hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
          isActivated = _activationState_2.isActivated;

      var activationHasEnded = hasDeactivationUXRun || !isActivated;

      if (activationHasEnded && this.activationAnimationHasEnded_) {
        this.rmBoundedActivationClasses_();
        this.adapter_.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer_ = setTimeout(function () {
          _this11.adapter_.removeClass(FG_DEACTIVATION);
        }, numbers.FG_DEACTIVATION_MS);
      }
    }

    /** @private */

  }, {
    key: 'rmBoundedActivationClasses_',
    value: function rmBoundedActivationClasses_() {
      var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

      this.adapter_.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded_ = false;
      this.adapter_.computeBoundingRect();
    }
  }, {
    key: 'resetActivationState_',
    value: function resetActivationState_() {
      var _this12 = this;

      this.previousActivationEvent_ = this.activationState_.activationEvent;
      this.activationState_ = this.defaultActivationState_();
      // Touch devices may fire additional events for the same interaction within a short time.
      // Store the previous event until it's safe to assume that subsequent events are for new interactions.
      setTimeout(function () {
        return _this12.previousActivationEvent_ = null;
      }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
    }

    /**
     * @param {?Event} e
     * @private
     */

  }, {
    key: 'deactivate_',
    value: function deactivate_(e) {
      var _this13 = this;

      var activationState = this.activationState_;
      // This can happen in scenarios such as when you have a keyup event that blurs the element.
      if (!activationState.isActivated) {
        return;
      }

      var state = /** @type {!ActivationStateType} */_extends({}, activationState);

      if (activationState.isProgrammatic) {
        var evtObject = null;
        requestAnimationFrame(function () {
          return _this13.animateDeactivation_(evtObject, state);
        });
        this.resetActivationState_();
      } else {
        this.deregisterDeactivationHandlers_();
        requestAnimationFrame(function () {
          _this13.activationState_.hasDeactivationUXRun = true;
          _this13.animateDeactivation_(e, state);
          _this13.resetActivationState_();
        });
      }
    }

    /**
     * @param {?Event=} event Optional event containing position information.
     */

  }, {
    key: 'deactivate',
    value: function deactivate() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.deactivate_(event);
    }

    /**
     * @param {Event} e
     * @param {!ActivationStateType} options
     * @private
     */

  }, {
    key: 'animateDeactivation_',
    value: function animateDeactivation_(e, _ref) {
      var wasActivatedByPointer = _ref.wasActivatedByPointer,
          wasElementMadeActive = _ref.wasElementMadeActive;

      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady_();
      }
    }
  }, {
    key: 'layout',
    value: function layout() {
      var _this14 = this;

      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }
      this.layoutFrame_ = requestAnimationFrame(function () {
        _this14.layoutInternal_();
        _this14.layoutFrame_ = 0;
      });
    }

    /** @private */

  }, {
    key: 'layoutInternal_',
    value: function layoutInternal_() {
      var _this15 = this;

      this.frame_ = this.adapter_.computeBoundingRect();
      var maxDim = Math.max(this.frame_.height, this.frame_.width);

      // Surface diameter is treated differently for unbounded vs. bounded ripples.
      // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
      // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
      // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
      // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
      // `overflow: hidden`.
      var getBoundedRadius = function getBoundedRadius() {
        var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
        return hypotenuse + MDCRippleFoundation.numbers.PADDING;
      };

      this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

      // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
      this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
      this.fgScale_ = this.maxRadius_ / this.initialSize_;

      this.updateLayoutCssVars_();
    }

    /** @private */

  }, {
    key: 'updateLayoutCssVars_',
    value: function updateLayoutCssVars_() {
      var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
          VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
          VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
          VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
          VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


      this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
      this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

      if (this.adapter_.isUnbounded()) {
        this.unboundedCoords_ = {
          left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
          top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
        };

        this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
        this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
      }
    }

    /** @param {boolean} unbounded */

  }, {
    key: 'setUnbounded',
    value: function setUnbounded(unbounded) {
      var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

      if (unbounded) {
        this.adapter_.addClass(UNBOUNDED);
      } else {
        this.adapter_.removeClass(UNBOUNDED);
      }
    }
  }]);
  return MDCRippleFoundation;
}(MDCFoundation);

var RippleBase = function (_MDCRippleFoundation) {
  inherits(RippleBase, _MDCRippleFoundation);
  createClass(RippleBase, null, [{
    key: 'isSurfaceActive',
    value: function isSurfaceActive(ref) {
      return ref[RippleBase.MATCHES](':active');
    }
  }, {
    key: 'MATCHES',
    get: function get$$1() {
      /* global HTMLElement */
      return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
    }
  }]);

  function RippleBase(vm, options) {
    classCallCheck(this, RippleBase);
    return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
      browserSupportsCssVars: function browserSupportsCssVars() {
        return supportsCssVariables(window);
      },
      isUnbounded: function isUnbounded() {
        return false;
      },
      isSurfaceActive: function isSurfaceActive() {
        return vm.$el[RippleBase.MATCHES](':active');
      },
      isSurfaceDisabled: function isSurfaceDisabled() {
        return vm.disabled;
      },
      addClass: function addClass(className) {
        vm.$set(vm.classes, className, true);
      },
      removeClass: function removeClass(className) {
        vm.$delete(vm.classes, className);
      },

      containsEventTarget: function containsEventTarget(target) {
        return vm.$el.contains(target);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        vm.$el.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        vm.$el.removeEventListener(evt, handler);
      },
      registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
        return document.documentElement.addEventListener(evtType, handler, applyPassive());
      },
      deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
        return document.documentElement.removeEventListener(evtType, handler, applyPassive());
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        return window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        return window.removeEventListener('resize', handler);
      },
      updateCssVariable: function updateCssVariable(varName, value) {
        vm.$set(vm.styles, varName, value);
      },
      computeBoundingRect: function computeBoundingRect() {
        return vm.$el.getBoundingClientRect();
      },
      getWindowPageOffset: function getWindowPageOffset() {
        return { x: window.pageXOffset, y: window.pageYOffset };
      }
    }, options)));
  }

  return RippleBase;
}(MDCRippleFoundation);

var RippleMixin = {
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },
  mounted: function mounted() {
    this.ripple = new RippleBase(this);
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple.destroy();
  }
};

var mdcRipple = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-ripple", attrs: { "tag": _vm.tag, "classes": _vm.classes, "styles": _vm.styles } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-ripple',
  mixins: [CustomElementMixin, RippleMixin],
  props: {
    tag: String
  }
};

var VueMDCRipple = BasePlugin({
  mdcRipple: mdcRipple
});

var mdcButtonBase = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', { ref: "root", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link, "disabled": _vm.disabled }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-button-base',
  mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  }
};

var mdcButton = {
  name: 'mdc-button',
  extends: mdcButtonBase,
  props: {
    raised: Boolean,
    unelevated: Boolean,
    stroked: Boolean,
    dense: Boolean,
    compact: Boolean,
    accent: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-button': true,
        'mdc-button--raised': this.raised,
        'mdc-button--unelevated': this.unelevated,
        'mdc-button--stroked': this.stroked,
        'mdc-button--dense': this.dense,
        'mdc-button--compact': this.compact,
        'mdc-button--accent': this.accent
      }
    };
  },

  watch: {
    raised: function raised() {
      this.$set(this.classes, 'mdc-button--raised', this.raised);
    },
    unelevated: function unelevated() {
      this.$set(this.classes, 'mdc-button--unelevated', this.unelevated);
    },
    stroked: function stroked() {
      this.$set(this.classes, 'mdc-button--stroked', this.stroked);
    },
    dense: function dense() {
      this.$set(this.classes, 'mdc-button--dense', this.dense);
    },
    compact: function compact() {
      this.$set(this.classes, 'mdc-button--compact', this.compact);
    },
    accent: function accent() {
      this.$set(this.classes, 'mdc-button--accent', this.accent);
    }
  }
};

var VueMDCButton = BasePlugin({
  mdcButton: mdcButton
});

var mdcCard = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card", class: { 'mdc-card--stroked': _vm.stroked } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: "mdc-card",
  props: {
    stroked: Boolean
  }
};

var mdcCardPrimaryAction = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-card-primary-action mdc-card__primary-action", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-primary-action',
  mixins: [DispatchEventMixin, CustomLinkMixin, RippleMixin],
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  }
};

var mdcCardMedia = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-media mdc-card__media", class: _vm.classes, style: _vm.styles }, [_vm.$slots.default ? _c('div', { staticClass: "mdc-card__media-content" }, [_vm._t("default")], 2) : _vm._e()]);
  }, staticRenderFns: [],
  name: "mdc-card-media",
  props: {
    src: String,
    'square': Boolean
  },
  computed: {
    styles: function styles() {
      var styles = {
        backgroundImage: 'url(' + this.src + ')'
      };

      return styles;
    },
    classes: function classes() {
      return this.square ? 'mdc-card__media--square' : 'mdc-card__media--16-9';
    }
  }
};

var mdcCardHeader = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-header mdc-card__primary" }, [_vm._t("default", [_vm.title ? _c('h1', { staticClass: "mdc-card__title", class: { 'mdc-card__title--large': _vm.largeTitle } }, [_vm._v(" " + _vm._s(_vm.title) + " ")]) : _vm._e(), _vm._v(" "), _vm.subtitle ? _c('h2', { staticClass: "mdc-card__subtitle" }, [_vm._v(" " + _vm._s(_vm.subtitle) + " ")]) : _vm._e()])], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-header',
  props: {
    'title': String,
    'subtitle': String,
    'large-title': { type: Boolean, default: true }
  }
};

var mdcCardTitle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h1', { staticClass: "mdc-card-title mdc-card__title", class: { 'mdc-card__title--large': _vm.large } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-title',
  props: {
    'large': Boolean
  }
};

var mdcCardSubtitle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h2', { staticClass: "mdc-card-subtitle mdc-card__subtitle" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-subtitle'
};

var mdcCardText = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-text mdc-card__supporting-text" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-text'
};

var mdcCardActions = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-actions mdc-card__actions", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-actions',
  props: {
    fullBleed: Boolean
  },
  computed: {
    classes: function classes() {
      return {
        'mdc-card__actions--full-bleed': this.fullBleed
      };
    }
  }
};

var mdcCardActionButtons = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-buttons mdc-card__action-buttons" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: "mdc-card-action-buttons"
};

var mdcCardActionButton = {
  name: 'mdc-card-action-button',
  extends: mdcButtonBase,
  props: {
    compact: Boolean,
    accent: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-button': true,
        'mdc-card__action': true,
        'mdc-card-action-button': true,
        'mdc-button--compact': this.compact,
        'mdc-button--accent': this.accent
      }
    };
  },

  watch: {
    compact: function compact() {
      this.$set(this.classes, 'mdc-button--compact', this.compact);
    },
    accent: function accent() {
      this.$set(this.classes, 'mdc-button--accent', this.accent);
    }
  }
};

var mdcCardActionIcons = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-icons mdc-card__action-icons" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: "mdc-card-action-icons"
};

var mdcCardActionIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { class: _vm.classes, style: _vm.styles, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-action-icon',
  mixins: [DispatchEventMixin],
  props: {
    icon: String
  },
  data: function data() {
    return {
      classes: {
        'mdc-card-action-icon': true,
        'material-icons': !!this.icon,
        'mdc-card__action': true,
        'mdc-card__action--icon': true,
        'mdc-icon-toggle': true
      },
      styles: {}
    };
  },

  watch: {
    icon: function icon() {
      this.$set(this.classes, 'material-icons', !!this.icon);
    }
  },
  mounted: function mounted() {
    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      }
    });
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple.destroy();
  }
};

var VueMDCCard = BasePlugin({
  mdcCard: mdcCard,
  mdcCardPrimaryAction: mdcCardPrimaryAction,
  mdcCardMedia: mdcCardMedia,
  mdcCardHeader: mdcCardHeader,
  mdcCardTitle: mdcCardTitle,
  mdcCardSubtitle: mdcCardSubtitle,
  mdcCardText: mdcCardText,
  mdcCardActions: mdcCardActions,
  mdcCardActionButtons: mdcCardActionButtons,
  mdcCardActionButton: mdcCardActionButton,
  mdcCardActionIcons: mdcCardActionIcons,
  mdcCardActionIcon: mdcCardActionIcon
});

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template F
 */

var MDCComponent = function () {
  createClass(MDCComponent, null, [{
    key: 'attachTo',

    /**
     * @param {!Element} root
     * @return {!MDCComponent}
     */
    value: function attachTo(root) {
      // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
      // returns an instantiated component with its root set to that element. Also note that in the cases of
      // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
      // from getDefaultFoundation().
      return new MDCComponent(root, new MDCFoundation());
    }

    /**
     * @param {!Element} root
     * @param {F=} foundation
     * @param {...?} args
     */

  }]);

  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args);
    // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.
    /** @protected {!F} */
    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  createClass(MDCComponent, [{
    key: 'initialize',
    value: function initialize() /* ...args */{}
    // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.


    /**
     * @return {!F} foundation
     */

  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      // Subclasses must override this method to return a properly configured foundation class for the
      // component.
      throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      // Subclasses should override this method if they need to perform work to synchronize with a host DOM
      // object. An example of this would be a form control wrapper that needs to synchronize its internal state
      // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
      // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      // Subclasses may implement this method to release any resources / deregister any listeners they have
      // attached. An example of this might be deregistering a resize event from the window object.
      this.foundation_.destroy();
    }

    /**
     * Wrapper method to add an event listener to the component's root element. This is most useful when
     * listening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'listen',
    value: function listen(evtType, handler) {
      this.root_.addEventListener(evtType, handler);
    }

    /**
     * Wrapper method to remove an event listener to the component's root element. This is most useful when
     * unlistening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'unlisten',
    value: function unlisten(evtType, handler) {
      this.root_.removeEventListener(evtType, handler);
    }

    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type,
     * with the given data.
     * @param {string} evtType
     * @param {!Object} evtData
     * @param {boolean=} shouldBubble
     */

  }, {
    key: 'emit',
    value: function emit(evtType, evtData) {
      var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var evt = void 0;
      if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
          detail: evtData,
          bubbles: shouldBubble
        });
      } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }

      this.root_.dispatchEvent(evt);
    }
  }]);
  return MDCComponent;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends MDCComponent<!MDCRippleFoundation>
 */

var MDCRipple = function (_MDCComponent) {
  inherits(MDCRipple, _MDCComponent);

  /** @param {...?} args */
  function MDCRipple() {
    var _ref;

    classCallCheck(this, MDCRipple);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @type {boolean} */
    var _this = possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));

    _this.disabled = false;

    /** @private {boolean} */
    _this.unbounded_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @param {{isUnbounded: (boolean|undefined)}=} options
   * @return {!MDCRipple}
   */


  createClass(MDCRipple, [{
    key: 'setUnbounded_',


    /**
     * Closure Compiler throws an access control error when directly accessing a
     * protected or private property inside a getter/setter, like unbounded above.
     * By accessing the protected property inside a method, we solve that problem.
     * That's why this function exists.
     * @private
     */
    value: function setUnbounded_() {
      this.foundation_.setUnbounded(this.unbounded_);
    }
  }, {
    key: 'activate',
    value: function activate() {
      this.foundation_.activate();
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.foundation_.deactivate();
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.foundation_.layout();
    }

    /** @return {!MDCRippleFoundation} */

  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      return new MDCRippleFoundation(MDCRipple.createAdapter(this));
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
    }
  }, {
    key: 'unbounded',


    /** @return {boolean} */
    get: function get$$1() {
      return this.unbounded_;
    }

    /** @param {boolean} unbounded */
    ,
    set: function set$$1(unbounded) {
      this.unbounded_ = Boolean(unbounded);
      this.setUnbounded_();
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$isUnbounded = _ref2.isUnbounded,
          isUnbounded = _ref2$isUnbounded === undefined ? undefined : _ref2$isUnbounded;

      var ripple = new MDCRipple(root);
      // Only override unbounded behavior if option is explicitly specified
      if (isUnbounded !== undefined) {
        ripple.unbounded = /** @type {boolean} */isUnbounded;
      }
      return ripple;
    }

    /**
     * @param {!RippleCapableSurface} instance
     * @return {!MDCRippleAdapter}
     */

  }, {
    key: 'createAdapter',
    value: function createAdapter(instance) {
      var MATCHES = getMatchesProperty(HTMLElement.prototype);

      return {
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return instance.unbounded;
        },
        isSurfaceActive: function isSurfaceActive() {
          return instance.root_[MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return instance.disabled;
        },
        addClass: function addClass(className) {
          return instance.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return instance.root_.classList.remove(className);
        },
        containsEventTarget: function containsEventTarget(target) {
          return instance.root_.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          return instance.root_.addEventListener(evtType, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          return instance.root_.removeEventListener(evtType, handler, applyPassive());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          return instance.root_.style.setProperty(varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return instance.root_.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      };
    }
  }]);
  return MDCRipple;
}(MDCComponent);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/**
 * @record
 */

var MDCSelectionControl = function () {
  function MDCSelectionControl() {
    classCallCheck(this, MDCSelectionControl);
  }

  createClass(MDCSelectionControl, [{
    key: 'ripple',

    /** @return {?MDCRipple} */
    get: function get$$1() {}
  }]);
  return MDCSelectionControl;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Checkbox. Provides an interface for managing
 * - classes
 * - dom
 * - event handlers
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */

var MDCCheckboxAdapter = function () {
  function MDCCheckboxAdapter() {
    classCallCheck(this, MDCCheckboxAdapter);
  }

  createClass(MDCCheckboxAdapter, [{
    key: 'addClass',

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: 'removeClass',
    value: function removeClass(className) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'registerAnimationEndHandler',
    value: function registerAnimationEndHandler(handler) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'deregisterAnimationEndHandler',
    value: function deregisterAnimationEndHandler(handler) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'registerChangeHandler',
    value: function registerChangeHandler(handler) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'deregisterChangeHandler',
    value: function deregisterChangeHandler(handler) {}

    /** @return {!MDCSelectionControlState} */

  }, {
    key: 'getNativeControl',
    value: function getNativeControl() {}
  }, {
    key: 'forceLayout',
    value: function forceLayout() {}

    /** @return {boolean} */

  }, {
    key: 'isAttachedToDOM',
    value: function isAttachedToDOM() {}
  }]);
  return MDCCheckboxAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const {string} */
var ROOT = 'mdc-checkbox';

/** @enum {string} */
var cssClasses$1 = {
  UPGRADED: 'mdc-checkbox--upgraded',
  CHECKED: 'mdc-checkbox--checked',
  INDETERMINATE: 'mdc-checkbox--indeterminate',
  DISABLED: 'mdc-checkbox--disabled',
  ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
  ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
  ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
  ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
  ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
  ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
};

/** @enum {string} */
var strings$1 = {
  NATIVE_CONTROL_SELECTOR: '.' + ROOT + '__native-control',
  TRANSITION_STATE_INIT: 'init',
  TRANSITION_STATE_CHECKED: 'checked',
  TRANSITION_STATE_UNCHECKED: 'unchecked',
  TRANSITION_STATE_INDETERMINATE: 'indeterminate'
};

/** @enum {number} */
var numbers$1 = {
  ANIM_END_LATCH_MS: 250
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint-enable no-unused-vars */
/** @const {!Array<string>} */
var CB_PROTO_PROPS = ['checked', 'indeterminate'];

/**
 * @extends {MDCFoundation<!MDCCheckboxAdapter>}
 */

var MDCCheckboxFoundation = function (_MDCFoundation) {
  inherits(MDCCheckboxFoundation, _MDCFoundation);
  createClass(MDCCheckboxFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$1;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$1;
    }

    /** @return enum {numbers} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$1;
    }

    /** @return {!MDCCheckboxAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCCheckboxAdapter} */{
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerAnimationEndHandler: function registerAnimationEndHandler() /* handler: EventListener */{},
          deregisterAnimationEndHandler: function deregisterAnimationEndHandler() /* handler: EventListener */{},
          registerChangeHandler: function registerChangeHandler() /* handler: EventListener */{},
          deregisterChangeHandler: function deregisterChangeHandler() /* handler: EventListener */{},
          getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{},
          forceLayout: function forceLayout() {},
          isAttachedToDOM: function isAttachedToDOM() /* boolean */{}
        }
      );
    }
  }]);

  function MDCCheckboxFoundation(adapter) {
    classCallCheck(this, MDCCheckboxFoundation);

    /** @private {string} */
    var _this = possibleConstructorReturn(this, (MDCCheckboxFoundation.__proto__ || Object.getPrototypeOf(MDCCheckboxFoundation)).call(this, _extends(MDCCheckboxFoundation.defaultAdapter, adapter)));

    _this.currentCheckState_ = strings$1.TRANSITION_STATE_INIT;

    /** @private {string} */
    _this.currentAnimationClass_ = '';

    /** @private {number} */
    _this.animEndLatchTimer_ = 0;

    _this.animEndHandler_ = /** @private {!EventListener} */function () {
      return _this.handleAnimationEnd();
    };

    _this.changeHandler_ = /** @private {!EventListener} */function () {
      return _this.handleChange();
    };
    return _this;
  }

  createClass(MDCCheckboxFoundation, [{
    key: 'init',
    value: function init() {
      this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
      this.adapter_.addClass(cssClasses$1.UPGRADED);
      this.adapter_.registerChangeHandler(this.changeHandler_);
      this.installPropertyChangeHooks_();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterChangeHandler(this.changeHandler_);
      this.uninstallPropertyChangeHooks_();
    }

    /** @return {boolean} */

  }, {
    key: 'isChecked',
    value: function isChecked() {
      return this.getNativeControl_().checked;
    }

    /** @param {boolean} checked */

  }, {
    key: 'setChecked',
    value: function setChecked(checked) {
      this.getNativeControl_().checked = checked;
    }

    /** @return {boolean} */

  }, {
    key: 'isIndeterminate',
    value: function isIndeterminate() {
      return this.getNativeControl_().indeterminate;
    }

    /** @param {boolean} indeterminate */

  }, {
    key: 'setIndeterminate',
    value: function setIndeterminate(indeterminate) {
      this.getNativeControl_().indeterminate = indeterminate;
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.getNativeControl_().disabled;
    }

    /** @param {boolean} disabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      this.getNativeControl_().disabled = disabled;
      if (disabled) {
        this.adapter_.addClass(cssClasses$1.DISABLED);
      } else {
        this.adapter_.removeClass(cssClasses$1.DISABLED);
      }
    }

    /** @return {?string} */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.getNativeControl_().value;
    }

    /** @param {?string} value */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.getNativeControl_().value = value;
    }

    /**
     * Handles the animationend event for the checkbox
     */

  }, {
    key: 'handleAnimationEnd',
    value: function handleAnimationEnd() {
      var _this2 = this;

      clearTimeout(this.animEndLatchTimer_);
      this.animEndLatchTimer_ = setTimeout(function () {
        _this2.adapter_.removeClass(_this2.currentAnimationClass_);
        _this2.adapter_.deregisterAnimationEndHandler(_this2.animEndHandler_);
      }, numbers$1.ANIM_END_LATCH_MS);
    }

    /**
     * Handles the change event for the checkbox
     */

  }, {
    key: 'handleChange',
    value: function handleChange() {
      this.transitionCheckState_();
    }

    /** @private */

  }, {
    key: 'installPropertyChangeHooks_',
    value: function installPropertyChangeHooks_() {
      var _this3 = this;

      var nativeCb = this.getNativeControl_();
      var cbProto = Object.getPrototypeOf(nativeCb);

      CB_PROTO_PROPS.forEach(function (controlState) {
        var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
        // We have to check for this descriptor, since some browsers (Safari) don't support its return.
        // See: https://bugs.webkit.org/show_bug.cgi?id=49739
        if (validDescriptor(desc)) {
          var nativeCbDesc = /** @type {!ObjectPropertyDescriptor} */{
            get: desc.get,
            set: function set$$1(state) {
              desc.set.call(nativeCb, state);
              _this3.transitionCheckState_();
            },
            configurable: desc.configurable,
            enumerable: desc.enumerable
          };
          Object.defineProperty(nativeCb, controlState, nativeCbDesc);
        }
      });
    }

    /** @private */

  }, {
    key: 'uninstallPropertyChangeHooks_',
    value: function uninstallPropertyChangeHooks_() {
      var nativeCb = this.getNativeControl_();
      var cbProto = Object.getPrototypeOf(nativeCb);

      CB_PROTO_PROPS.forEach(function (controlState) {
        var desc = /** @type {!ObjectPropertyDescriptor} */Object.getOwnPropertyDescriptor(cbProto, controlState);
        if (validDescriptor(desc)) {
          Object.defineProperty(nativeCb, controlState, desc);
        }
      });
    }

    /** @private */

  }, {
    key: 'transitionCheckState_',
    value: function transitionCheckState_() {
      var nativeCb = this.adapter_.getNativeControl();
      if (!nativeCb) {
        return;
      }
      var oldState = this.currentCheckState_;
      var newState = this.determineCheckState_(nativeCb);
      if (oldState === newState) {
        return;
      }

      // Check to ensure that there isn't a previously existing animation class, in case for example
      // the user interacted with the checkbox before the animation was finished.
      if (this.currentAnimationClass_.length > 0) {
        clearTimeout(this.animEndLatchTimer_);
        this.adapter_.forceLayout();
        this.adapter_.removeClass(this.currentAnimationClass_);
      }

      this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
      this.currentCheckState_ = newState;

      // Check for parentNode so that animations are only run when the element is attached
      // to the DOM.
      if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
        this.adapter_.addClass(this.currentAnimationClass_);
        this.adapter_.registerAnimationEndHandler(this.animEndHandler_);
      }
    }

    /**
     * @param {!MDCSelectionControlState} nativeCb
     * @return {string}
     * @private
     */

  }, {
    key: 'determineCheckState_',
    value: function determineCheckState_(nativeCb) {
      var TRANSITION_STATE_INDETERMINATE = strings$1.TRANSITION_STATE_INDETERMINATE,
          TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
          TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;


      if (nativeCb.indeterminate) {
        return TRANSITION_STATE_INDETERMINATE;
      }
      return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
    }

    /**
     * @param {string} oldState
     * @param {string} newState
     * @return {string}
     */

  }, {
    key: 'getTransitionAnimationClass_',
    value: function getTransitionAnimationClass_(oldState, newState) {
      var TRANSITION_STATE_INIT = strings$1.TRANSITION_STATE_INIT,
          TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
          TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;
      var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
          ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
          ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
          ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
          ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
          ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
          ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;


      switch (oldState) {
        case TRANSITION_STATE_INIT:
          if (newState === TRANSITION_STATE_UNCHECKED) {
            return '';
          }
        // fallthrough
        case TRANSITION_STATE_UNCHECKED:
          return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
        case TRANSITION_STATE_CHECKED:
          return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
        // TRANSITION_STATE_INDETERMINATE
        default:
          return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
      }
    }

    /**
     * @return {!MDCSelectionControlState}
     * @private
     */

  }, {
    key: 'getNativeControl_',
    value: function getNativeControl_() {
      return this.adapter_.getNativeControl() || {
        checked: false,
        indeterminate: false,
        disabled: false,
        value: null
      };
    }
  }]);
  return MDCCheckboxFoundation;
}(MDCFoundation);

/**
 * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
 * @return {boolean}
 */


function validDescriptor(inputPropDesc) {
  return !!inputPropDesc && typeof inputPropDesc.set === 'function';
}

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Form Field. Provides an interface for managing
 * - event handlers
 * - ripple activation
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCFormFieldAdapter = function () {
  function MDCFormFieldAdapter() {
    classCallCheck(this, MDCFormFieldAdapter);
  }

  createClass(MDCFormFieldAdapter, [{
    key: "registerInteractionHandler",

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */
    value: function registerInteractionHandler(type, handler) {}

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}
  }, {
    key: "activateInputRipple",
    value: function activateInputRipple() {}
  }, {
    key: "deactivateInputRipple",
    value: function deactivateInputRipple() {}
  }]);
  return MDCFormFieldAdapter;
}();

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$2 = {
  ROOT: 'mdc-form-field'
};

/** @enum {string} */
var strings$2 = {
  LABEL_SELECTOR: '.mdc-form-field > label'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCFormFieldAdapter>}
 */

var MDCFormFieldFoundation = function (_MDCFoundation) {
  inherits(MDCFormFieldFoundation, _MDCFoundation);
  createClass(MDCFormFieldFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$2;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$2;
    }

    /** @return {!MDCFormFieldAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        activateInputRipple: function activateInputRipple() {},
        deactivateInputRipple: function deactivateInputRipple() {}
      };
    }
  }]);

  function MDCFormFieldFoundation(adapter) {
    classCallCheck(this, MDCFormFieldFoundation);

    /** @private {!EventListener} */
    var _this = possibleConstructorReturn(this, (MDCFormFieldFoundation.__proto__ || Object.getPrototypeOf(MDCFormFieldFoundation)).call(this, _extends(MDCFormFieldFoundation.defaultAdapter, adapter)));

    _this.clickHandler_ = /** @type {!EventListener} */function () {
      return _this.handleClick_();
    };
    return _this;
  }

  createClass(MDCFormFieldFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
    }

    /** @private */

  }, {
    key: 'handleClick_',
    value: function handleClick_() {
      var _this2 = this;

      this.adapter_.activateInputRipple();
      requestAnimationFrame(function () {
        return _this2.adapter_.deactivateInputRipple();
      });
    }
  }]);
  return MDCFormFieldFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @typedef {{
 *   noPrefix: string,
 *   webkitPrefix: string,
 *   styleProperty: string
 * }}
 */
/** @const {Object<string, !VendorPropertyMapType>} */
var eventTypeMap = {
  'animationstart': {
    noPrefix: 'animationstart',
    webkitPrefix: 'webkitAnimationStart',
    styleProperty: 'animation'
  },
  'animationend': {
    noPrefix: 'animationend',
    webkitPrefix: 'webkitAnimationEnd',
    styleProperty: 'animation'
  },
  'animationiteration': {
    noPrefix: 'animationiteration',
    webkitPrefix: 'webkitAnimationIteration',
    styleProperty: 'animation'
  },
  'transitionend': {
    noPrefix: 'transitionend',
    webkitPrefix: 'webkitTransitionEnd',
    styleProperty: 'transition'
  }
};

/** @const {Object<string, !VendorPropertyMapType>} */
var cssPropertyMap = {
  'animation': {
    noPrefix: 'animation',
    webkitPrefix: '-webkit-animation'
  },
  'transform': {
    noPrefix: 'transform',
    webkitPrefix: '-webkit-transform'
  },
  'transition': {
    noPrefix: 'transition',
    webkitPrefix: '-webkit-transition'
  }
};

/**
 * @param {!Object} windowObj
 * @return {boolean}
 */
function hasProperShape(windowObj) {
  return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
}

/**
 * @param {string} eventType
 * @return {boolean}
 */
function eventFoundInMaps(eventType) {
  return eventType in eventTypeMap || eventType in cssPropertyMap;
}

/**
 * @param {string} eventType
 * @param {!Object<string, !VendorPropertyMapType>} map
 * @param {!Element} el
 * @return {string}
 */
function getJavaScriptEventName(eventType, map, el) {
  return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
}

/**
 * Helper function to determine browser prefix for CSS3 animation events
 * and property names.
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getAnimationName(windowObj, eventType) {
  if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
    return eventType;
  }

  var map = /** @type {!Object<string, !VendorPropertyMapType>} */eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
  var el = windowObj['document']['createElement']('div');
  var eventName = '';

  if (map === eventTypeMap) {
    eventName = getJavaScriptEventName(eventType, map, el);
  } else {
    eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  return eventName;
}

// Public functions to access getAnimationName() for JavaScript events or CSS
// property names.

var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getCorrectEventName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}

/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getCorrectPropertyName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}

/* global HTMLElement */
var mdcCheckbox = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-checkbox-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-checkbox", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-checkbox__native-control", attrs: { "id": _vm._uid, "type": "checkbox", "name": _vm.name }, domProps: { "value": _vm.value }, on: { "change": _vm.onChange } }), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__background" }, [_c('svg', { staticClass: "mdc-checkbox__checkmark", attrs: { "viewBox": "0 0 24 24" } }, [_c('path', { staticClass: "checkbox__checkmark-path", attrs: { "fill": "none", "stroke": "white", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__mixedmark" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-checkbox',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    'checked': Boolean,
    'indeterminate': Boolean,
    'disabled': Boolean,
    'label': String,
    'align-end': Boolean,
    'value': { type: String, default: function _default() {
        return 'on';
      }
    },
    'name': String
  },
  data: function data() {
    return {
      styles: {},
      classes: {}
    };
  },

  computed: {
    hasLabel: function hasLabel() {
      return this.label || this.$slots.default;
    },
    formFieldClasses: function formFieldClasses() {
      return {
        'mdc-form-field': this.hasLabel,
        'mdc-form-field--align-end': this.hasLabel && this.alignEnd
      };
    }
  },
  watch: {
    'checked': function checked(value) {
      this.foundation.setChecked(value);
    },
    'disabled': function disabled(value) {
      this.foundation.setDisabled(value);
    },
    'indeterminate': function indeterminate(value) {
      this.foundation.setIndeterminate(value);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCCheckboxFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      registerAnimationEndHandler: function registerAnimationEndHandler(handler) {
        return _this.$refs.root.addEventListener(getCorrectEventName(window, 'animationend'), handler);
      },
      deregisterAnimationEndHandler: function deregisterAnimationEndHandler(handler) {
        return _this.$refs.root.removeEventListener(getCorrectEventName(window, 'animationend'), handler);
      },
      registerChangeHandler: function registerChangeHandler(handler) {
        return _this.$refs.control.addEventListener('change', handler);
      },
      deregisterChangeHandler: function deregisterChangeHandler(handler) {
        return _this.$refs.control.removeEventListener('change', handler);
      },
      getNativeControl: function getNativeControl() {
        return _this.$refs.control;
      },
      forceLayout: function forceLayout() {
        return _this.$refs.root.offsetWidth;
      },
      isAttachedToDOM: function isAttachedToDOM() {
        return Boolean(_this.$el.parentNode);
      }
    });

    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      },
      isSurfaceActive: function isSurfaceActive() {
        return RippleBase.isSurfaceActive(_this.$refs.control);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$refs.control.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$refs.control.addEventListener(evt, handler);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this.$refs.root.getBoundingClientRect();
      }
    });

    this.formField = new MDCFormFieldFoundation({
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        _this.$refs.label.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        _this.$refs.label.removeEventListener(type, handler);
      },
      activateInputRipple: function activateInputRipple() {
        _this.ripple && _this.ripple.activate();
      },
      deactivateInputRipple: function deactivateInputRipple() {
        _this.ripple && _this.ripple.deactivate();
      }
    });

    this.foundation.init();
    this.ripple.init();
    this.formField.init();
    this.foundation.setChecked(this.checked);
    this.foundation.setDisabled(this.disabled);
    this.foundation.setIndeterminate(this.indeterminate);
  },
  beforeDestroy: function beforeDestroy() {
    this.formField.destroy();
    this.ripple.destroy();
    this.foundation.destroy();
  },

  methods: {
    onChange: function onChange() {
      this.$emit('update:indeterminate', this.foundation.isIndeterminate());
      this.$emit('change', this.foundation.isChecked());
    }
  }
};

var VueMDCCheckbox = BasePlugin({
  mdcCheckbox: mdcCheckbox
});

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Chip.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Chip into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCChipAdapter = function () {
  function MDCChipAdapter() {
    classCallCheck(this, MDCChipAdapter);
  }

  createClass(MDCChipAdapter, [{
    key: "registerInteractionHandler",

    /**
     * Registers an event listener on the root element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */
    value: function registerInteractionHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the root element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}

    /**
     * Emits a custom "MDCChip:interaction" event denoting the chip has been
     * interacted with (typically on click or keydown).
     */

  }, {
    key: "notifyInteraction",
    value: function notifyInteraction() {}
  }]);
  return MDCChipAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$3 = {
  INTERACTION_EVENT: 'MDCChip:interaction'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCChipAdapter>}
 * @final
 */

var MDCChipFoundation = function (_MDCFoundation) {
  inherits(MDCChipFoundation, _MDCFoundation);
  createClass(MDCChipFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$3;
    }

    /**
     * {@see MDCChipAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCChipAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCChipAdapter} */{
          registerInteractionHandler: function registerInteractionHandler() {},
          deregisterInteractionHandler: function deregisterInteractionHandler() {},
          notifyInteraction: function notifyInteraction() {}
        }
      );
    }

    /**
     * @param {!MDCChipAdapter} adapter
     */

  }]);

  function MDCChipFoundation(adapter) {
    classCallCheck(this, MDCChipFoundation);

    /** @private {function(!Event): undefined} */
    var _this = possibleConstructorReturn(this, (MDCChipFoundation.__proto__ || Object.getPrototypeOf(MDCChipFoundation)).call(this, _extends(MDCChipFoundation.defaultAdapter, adapter)));

    _this.interactionHandler_ = function (evt) {
      return _this.handleInteraction_(evt);
    };
    return _this;
  }

  createClass(MDCChipFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
      });
    }

    /**
     * Handles an interaction event on the root element.
     * @param {!Event} evt
     */

  }, {
    key: 'handleInteraction_',
    value: function handleInteraction_(evt) {
      if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
        this.adapter_.notifyInteraction();
      }
    }
  }]);
  return MDCChipFoundation;
}(MDCFoundation);

var mdcChip = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-chip", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "0" } }, [_vm.haveleadingIcon ? _c('i', { staticClass: "mdc-chip__icon mdc-chip__icon--leading", class: _vm.leadingClasses }, [_vm._v(_vm._s(_vm.leadingIcon))]) : _vm._e(), _vm._v(" "), _c('div', { attrs: { "classes": "mdc-chip__text" } }, [_vm._t("default")], 2), _vm._v(" "), _vm.havetrailingIcon ? _c('i', { staticClass: "mdc-chip__icon mdc-chip__icon--trailing", class: _vm.trailingClasses, attrs: { "tabindex": "0", "role": "button" } }, [_vm._v(_vm._s(_vm.trailingIcon))]) : _vm._e()]);
  }, staticRenderFns: [],
  name: "mdc-chip",
  mixins: [CustomLinkMixin, DispatchEventMixin],
  props: {
    leadingIcon: [String],
    trailingIcon: [String],
    leadingIconClasses: [Object],
    trailingIconClasses: [Object]
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  methods: {},
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCChipFoundation({
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$el.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$el.removeEventListener(type, handler);
      },
      notifyInteraction: function notifyInteraction() {
        _this.dispatchEvent({ type: 'click' });
      }
    });

    this.foundation.init();

    this.ripple = new RippleBase(this);
    this.ripple.init();
  },

  computed: {
    haveleadingIcon: function haveleadingIcon() {
      return !!this.leadingIcon || this.leadingIconClasses;
    },
    havetrailingIcon: function havetrailingIcon() {
      return !!this.trailingIcon || this.trailingIconClasses;
    },
    leadingClasses: function leadingClasses() {
      return _extends({}, {
        "material-icons": !!this.leadingIcon
      }, this.leadingIconClasses);
    },
    trailingClasses: function trailingClasses() {
      return _extends({}, {
        "material-icons": !!this.trailingIcon
      }, this.trailingIconClasses);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple.destroy();
    this.foundation.destroy();
  }
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Chip Set.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Chip Set into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCChipSetAdapter = function () {
  function MDCChipSetAdapter() {
    classCallCheck(this, MDCChipSetAdapter);
  }

  createClass(MDCChipSetAdapter, [{
    key: "hasClass",

    /**
     * Returns true if the root element contains the given class name.
     * @param {string} className
     */
    value: function hasClass(className) {}
  }]);
  return MDCChipSetAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$4 = {
  CHIP_SELECTOR: '.mdc-chip'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCChipSetAdapter>}
 * @final
 */

var MDCChipSetFoundation = function (_MDCFoundation) {
  inherits(MDCChipSetFoundation, _MDCFoundation);
  createClass(MDCChipSetFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$4;
    }

    /**
     * {@see MDCChipSetAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCChipSetAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCChipSetAdapter} */{
          hasClass: function hasClass() {}
        }
      );
    }

    /**
     * @param {!MDCChipSetAdapter} adapter
     */

  }]);

  function MDCChipSetFoundation(adapter) {
    classCallCheck(this, MDCChipSetFoundation);
    return possibleConstructorReturn(this, (MDCChipSetFoundation.__proto__ || Object.getPrototypeOf(MDCChipSetFoundation)).call(this, _extends(MDCChipSetFoundation.defaultAdapter, adapter)));
  }

  return MDCChipSetFoundation;
}(MDCFoundation);

var mdcChipSet = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-chip-set", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-chip-set',
  props: {},
  data: function data() {
    return {
      classes: {}
    };
  },

  methods: {},
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCChipSetFoundation({
      hasClass: function hasClass(className) {
        return _this.$refs.root.classList.contains(className);
      }
    });

    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCChipSet = BasePlugin({
  mdcChip: mdcChip,
  mdcChipSet: mdcChipSet
});

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$3 = {
  ROOT: 'mdc-dialog',
  OPEN: 'mdc-dialog--open',
  ANIMATING: 'mdc-dialog--animating',
  BACKDROP: 'mdc-dialog__backdrop',
  SCROLL_LOCK: 'mdc-dialog-scroll-lock',
  ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
  CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
};

var strings$5 = {
  OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
  DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
  ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
  ACCEPT_EVENT: 'MDCDialog:accept',
  CANCEL_EVENT: 'MDCDialog:cancel'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCDialogFoundation = function (_MDCFoundation) {
  inherits(MDCDialogFoundation, _MDCFoundation);
  createClass(MDCDialogFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$3;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$5;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        eventTargetHasClass: function eventTargetHasClass() {
          return (/* target: EventTarget, className: string */ /* boolean */false
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
        registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        notifyAccept: function notifyAccept() {},
        notifyCancel: function notifyCancel() {},
        trapFocusOnSurface: function trapFocusOnSurface() {},
        untrapFocusOnSurface: function untrapFocusOnSurface() {},
        isDialog: function isDialog() {
          return (/* el: Element */ /* boolean */false
          );
        },
        layoutFooterRipples: function layoutFooterRipples() {}
      };
    }
  }]);

  function MDCDialogFoundation(adapter) {
    classCallCheck(this, MDCDialogFoundation);

    var _this = possibleConstructorReturn(this, (MDCDialogFoundation.__proto__ || Object.getPrototypeOf(MDCDialogFoundation)).call(this, _extends(MDCDialogFoundation.defaultAdapter, adapter)));

    _this.isOpen_ = false;
    _this.componentClickHandler_ = function (evt) {
      if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$3.BACKDROP)) {
        _this.cancel(true);
      }
    };
    _this.dialogClickHandler_ = function (evt) {
      return _this.handleDialogClick_(evt);
    };
    _this.documentKeydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        _this.cancel(true);
      }
    };
    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd_(evt);
    };
    return _this;
  }

  createClass(MDCDialogFoundation, [{
    key: 'destroy',
    value: function destroy() {
      // Ensure that dialog is cleaned up when destroyed
      if (this.isOpen_) {
        this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.untrapFocusOnSurface();
        this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
        this.enableScroll_();
      }
    }
  }, {
    key: 'open',
    value: function open() {
      this.isOpen_ = true;
      this.disableScroll_();
      this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
      this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
      this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
    }
  }, {
    key: 'close',
    value: function close() {
      this.isOpen_ = false;
      this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
      this.adapter_.untrapFocusOnSurface();
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
    }
  }, {
    key: 'isOpen',
    value: function isOpen() {
      return this.isOpen_;
    }
  }, {
    key: 'accept',
    value: function accept(shouldNotify) {
      if (shouldNotify) {
        this.adapter_.notifyAccept();
      }

      this.close();
    }
  }, {
    key: 'cancel',
    value: function cancel(shouldNotify) {
      if (shouldNotify) {
        this.adapter_.notifyCancel();
      }

      this.close();
    }
  }, {
    key: 'handleDialogClick_',
    value: function handleDialogClick_(evt) {
      var target = evt.target;

      if (this.adapter_.eventTargetHasClass(target, cssClasses$3.ACCEPT_BTN)) {
        this.accept(true);
      } else if (this.adapter_.eventTargetHasClass(target, cssClasses$3.CANCEL_BTN)) {
        this.cancel(true);
      }
    }
  }, {
    key: 'handleTransitionEnd_',
    value: function handleTransitionEnd_(evt) {
      if (this.adapter_.isDialog(evt.target)) {
        this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
        if (this.isOpen_) {
          this.adapter_.trapFocusOnSurface();
          this.adapter_.layoutFooterRipples();
        } else {
          this.enableScroll_();
        }
      }
    }
  }, {
    key: 'disableScroll_',
    value: function disableScroll_() {
      this.adapter_.addBodyClass(cssClasses$3.SCROLL_LOCK);
    }
  }, {
    key: 'enableScroll_',
    value: function enableScroll_() {
      this.adapter_.removeBodyClass(cssClasses$3.SCROLL_LOCK);
    }
  }]);
  return MDCDialogFoundation;
}(MDCFoundation);

var tabbable = function (el, options) {
  options = options || {};

  var elementDocument = el.ownerDocument || el;
  var basicTabbables = [];
  var orderedTabbables = [];

  // A node is "available" if
  // - it's computed style
  var isUnavailable = createIsUnavailable(elementDocument);

  var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];

  var candidates = el.querySelectorAll(candidateSelectors.join(','));

  if (options.includeContainer) {
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    if (candidateSelectors.some(function (candidateSelector) {
      return matches.call(el, candidateSelector);
    })) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var candidate, candidateIndex;
  for (var i = 0, l = candidates.length; i < l; i++) {
    candidate = candidates[i];
    candidateIndex = parseInt(candidate.getAttribute('tabindex'), 10) || candidate.tabIndex;

    if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
      continue;
    }

    if (candidateIndex === 0) {
      basicTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        index: i,
        tabIndex: candidateIndex,
        node: candidate
      });
    }
  }

  var tabbableNodes = orderedTabbables.sort(function (a, b) {
    return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
  }).map(function (a) {
    return a.node;
  });

  Array.prototype.push.apply(tabbableNodes, basicTabbables);

  return tabbableNodes;
};

function createIsUnavailable(elementDocument) {
  // Node cache must be refreshed on every check, in case
  // the content of the element has changed
  var isOffCache = [];

  // "off" means `display: none;`, as opposed to "hidden",
  // which means `visibility: hidden;`. getComputedStyle
  // accurately reflects visiblity in context but not
  // "off" state, so we need to recursively check parents.

  function isOff(node, nodeComputedStyle) {
    if (node === elementDocument.documentElement) return false;

    // Find the cached node (Array.prototype.find not available in IE9)
    for (var i = 0, length = isOffCache.length; i < length; i++) {
      if (isOffCache[i][0] === node) return isOffCache[i][1];
    }

    nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = isOff(node.parentNode);
    }

    isOffCache.push([node, result]);

    return result;
  }

  return function isUnavailable(node) {
    if (node === elementDocument.documentElement) return false;

    var computedStyle = elementDocument.defaultView.getComputedStyle(node);

    if (isOff(node, computedStyle)) return true;

    return computedStyle.visibility === 'hidden';
  };
}

var listeningFocusTrap = null;

function focusTrap(element, userOptions) {
  var tabbableNodes = [];
  var firstTabbableNode = null;
  var lastTabbableNode = null;
  var nodeFocusedBeforeActivation = null;
  var active = false;
  var paused = false;
  var tabEvent = null;

  var container = typeof element === 'string' ? document.querySelector(element) : element;

  var config = userOptions || {};
  config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
  config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };

  return trap;

  function activate(activateOptions) {
    if (active) return;

    var defaultedActivateOptions = {
      onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
    };

    active = true;
    paused = false;
    nodeFocusedBeforeActivation = document.activeElement;

    if (defaultedActivateOptions.onActivate) {
      defaultedActivateOptions.onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!active) return;

    var defaultedDeactivateOptions = {
      returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
      onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
    };

    removeListeners();

    if (defaultedDeactivateOptions.onDeactivate) {
      defaultedDeactivateOptions.onDeactivate();
    }

    if (defaultedDeactivateOptions.returnFocus) {
      setTimeout(function () {
        tryFocus(nodeFocusedBeforeActivation);
      }, 0);
    }

    active = false;
    paused = false;
    return this;
  }

  function pause() {
    if (paused || !active) return;
    paused = true;
    removeListeners();
  }

  function unpause() {
    if (!paused || !active) return;
    paused = false;
    addListeners();
  }

  function addListeners() {
    if (!active) return;

    // There can be only one listening focus trap at a time
    if (listeningFocusTrap) {
      listeningFocusTrap.pause();
    }
    listeningFocusTrap = trap;

    updateTabbableNodes();
    tryFocus(firstFocusNode());
    document.addEventListener('focus', checkFocus, true);
    document.addEventListener('click', checkClick, true);
    document.addEventListener('mousedown', checkPointerDown, true);
    document.addEventListener('touchstart', checkPointerDown, true);
    document.addEventListener('keydown', checkKey, true);

    return trap;
  }

  function removeListeners() {
    if (!active || listeningFocusTrap !== trap) return;

    document.removeEventListener('focus', checkFocus, true);
    document.removeEventListener('click', checkClick, true);
    document.removeEventListener('mousedown', checkPointerDown, true);
    document.removeEventListener('touchstart', checkPointerDown, true);
    document.removeEventListener('keydown', checkKey, true);

    listeningFocusTrap = null;

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = document.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function firstFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(document.activeElement)) {
      node = document.activeElement;
    } else {
      node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error('You can\'t have a focus-trap without at least one focusable element');
    }

    return node;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event
  function checkPointerDown(e) {
    if (config.clickOutsideDeactivates && !container.contains(e.target)) {
      deactivate({ returnFocus: false });
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function checkFocus(e) {
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
    // Checking for a blur method here resolves a Firefox issue (#15)
    if (typeof e.target.blur === 'function') e.target.blur();

    if (tabEvent) {
      readjustFocus(tabEvent);
    }
  }

  function checkKey(e) {
    if (e.key === 'Tab' || e.keyCode === 9) {
      handleTab(e);
    }

    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      deactivate();
    }
  }

  function handleTab(e) {
    updateTabbableNodes();

    if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
      return tabEvent = e;
    }

    e.preventDefault();
    var currentFocusIndex = tabbableNodes.indexOf(e.target);

    if (e.shiftKey) {
      if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
        return tryFocus(lastTabbableNode);
      }
      return tryFocus(tabbableNodes[currentFocusIndex - 1]);
    }

    if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

    tryFocus(tabbableNodes[currentFocusIndex + 1]);
  }

  function updateTabbableNodes() {
    tabbableNodes = tabbable(container);
    firstTabbableNode = tabbableNodes[0];
    lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
  }

  function readjustFocus(e) {
    if (e.shiftKey) return tryFocus(lastTabbableNode);

    tryFocus(firstTabbableNode);
  }
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function tryFocus(node) {
  if (!node || !node.focus) return;
  if (node === document.activeElement) return;

  node.focus();
  if (node.tagName.toLowerCase() === 'input') {
    node.select();
  }
}

var focusTrap_1 = focusTrap;

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
  var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focusTrap_1;

  return focusTrapFactory(surfaceEl, {
    initialFocus: acceptButtonEl,
    clickOutsideDeactivates: true
  });
}

var mdcDialog = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { ref: "root", staticClass: "mdc-dialog", class: _vm.classes, style: _vm.styles, attrs: { "role": "alertdialog", "aria-labelledby": 'label' + _vm._uid, "aria-describedby": 'desc' + _vm._uid } }, [_c('div', { ref: "surface", staticClass: "mdc-dialog__surface", class: _vm.surfaceClasses }, [_c('header', { staticClass: "mdc-dialog__header" }, [_c('h2', { staticClass: "mdc-dialog__header__title", attrs: { "id": 'label' + _vm._uid } }, [_vm._v(" " + _vm._s(_vm.title) + " ")])]), _vm._v(" "), _c('section', { staticClass: "mdc-dialog__body", class: _vm.bodyClasses, attrs: { "id": 'desc' + _vm._uid } }, [_vm._t("default")], 2), _vm._v(" "), _c('footer', { staticClass: "mdc-dialog__footer" }, [_vm.cancel ? _c('mdcButton', { ref: "cancel", staticClass: "mdc-dialog__footer__button", class: { 'mdc-dialog__action': _vm.accent }, on: { "click": _vm.onCancel } }, [_vm._v(_vm._s(_vm.cancel))]) : _vm._e(), _vm._v(" "), _c('mdcButton', { ref: "accept", staticClass: "mdc-dialog__footer__button", class: { 'mdc-dialog__action': _vm.accent }, attrs: { "disabled": _vm.acceptDisabled }, on: { "click": _vm.onAccept } }, [_vm._v(_vm._s(_vm.accept))])], 1)]), _vm._v(" "), _c('div', { staticClass: "mdc-dialog__backdrop" })]);
  }, staticRenderFns: [],
  name: 'mdc-dialog',
  props: {
    title: { type: String, required: true },
    accept: { type: String, default: 'Ok' },
    acceptDisabled: Boolean,
    cancel: { type: String, default: 'Cancel' },
    accent: Boolean,
    scrollable: Boolean
  },
  components: {
    mdcButton: mdcButton
  },
  data: function data() {
    return {
      classes: {
        'mdc-theme--dark': this.dark
      },
      styles: {},
      surfaceClasses: {},
      bodyClasses: {
        'mdc-dialog__body--scrollable': this.scrollable
      }
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.focusTrap = createFocusTrapInstance(this.$refs.surface, this.$refs.accept);

    this.foundation = new MDCDialogFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      },
      eventTargetHasClass: function eventTargetHasClass(target, className) {
        return target.classList.contains(className);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        return _this.$refs.root.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        return _this.$refs.root.removeEventListener(evt, handler);
      },
      registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /*evt, handler*/{
        // VMA_HACK: handle button clicks ourselves
        // this.$refs.surface.addEventListener(evt, handler)
      },
      deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /*evt, handler*/{
        // VMA_HACK: handle button clicks ourselves
        // this.$refs.surface.removeEventListener(evt, handler)
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        return document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        return document.removeEventListener('keydown', handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        return _this.$refs.surface.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        return _this.$refs.surface.removeEventListener('transitionend', handler);
      },
      notifyAccept: function notifyAccept() {
        return _this.$emit('accept');
      },
      notifyCancel: function notifyCancel() {
        return _this.$emit('cancel');
      },
      trapFocusOnSurface: function trapFocusOnSurface() {
        return _this.focusTrap.activate();
      },
      untrapFocusOnSurface: function untrapFocusOnSurface() {
        return _this.focusTrap.deactivate();
      },
      isDialog: function isDialog(el) {
        return _this.$refs.surface === el;
      },
      layoutFooterRipples: function layoutFooterRipples() {
        _this.$refs.accept.ripple.layout();
        _this.cancel && _this.$refs.cancel.ripple.layout();
      }
    });

    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  },

  methods: {
    onCancel: function onCancel() {
      this.foundation.cancel(true);
    },
    onAccept: function onAccept() {
      var _this2 = this;

      if (this.$listeners['validate']) {
        this.$emit('validate', {
          accept: function accept() {
            var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            return _this2.foundation.accept(notify);
          }
        });
      } else {
        this.foundation.accept(true);
      }
    },
    show: function show() {
      this.foundation.open();
    },
    close: function close() {
      this.foundation.close();
    }
  }
};

var VueMDCDialog = BasePlugin({
  mdcDialog: mdcDialog
});

var mdcPermanentDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography" }, [_c('nav', { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-permanent-drawer',
  props: {
    'toolbar-spacer': Boolean
  }
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
  inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
  createClass(MDCSlidableDrawerFoundation, null, [{
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        hasClass: function hasClass() /* className: string */{},
        hasNecessaryDom: function hasNecessaryDom() {
          return (/* boolean */false
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
        setTranslateX: function setTranslateX() /* value: number | null */{},
        getFocusableElements: function getFocusableElements() /* NodeList */{},
        saveElementTabState: function saveElementTabState() /* el: Element */{},
        restoreElementTabState: function restoreElementTabState() /* el: Element */{},
        makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
        notifyOpen: function notifyOpen() {},
        notifyClose: function notifyClose() {},
        isRtl: function isRtl() {
          return (/* boolean */false
          );
        },
        getDrawerWidth: function getDrawerWidth() {
          return (/* number */0
          );
        }
      };
    }
  }]);

  function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
    classCallCheck(this, MDCSlidableDrawerFoundation);

    var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

    _this.rootCssClass_ = rootCssClass;
    _this.animatingCssClass_ = animatingCssClass;
    _this.openCssClass_ = openCssClass;

    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd_(evt);
    };

    _this.inert_ = false;

    _this.componentTouchStartHandler_ = function (evt) {
      return _this.handleTouchStart_(evt);
    };
    _this.componentTouchMoveHandler_ = function (evt) {
      return _this.handleTouchMove_(evt);
    };
    _this.componentTouchEndHandler_ = function (evt) {
      return _this.handleTouchEnd_(evt);
    };
    _this.documentKeydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        _this.close();
      }
    };
    return _this;
  }

  createClass(MDCSlidableDrawerFoundation, [{
    key: 'init',
    value: function init() {
      var ROOT = this.rootCssClass_;
      var OPEN = this.openCssClass_;

      if (!this.adapter_.hasClass(ROOT)) {
        throw new Error(ROOT + ' class required in root element.');
      }

      if (!this.adapter_.hasNecessaryDom()) {
        throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
      }

      if (this.adapter_.hasClass(OPEN)) {
        this.isOpen_ = true;
      } else {
        this.detabinate_();
        this.isOpen_ = false;
      }

      this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
      this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
      this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
      this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
      this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
      // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
    }
  }, {
    key: 'open',
    value: function open() {
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.addClass(this.animatingCssClass_);
      this.adapter_.addClass(this.openCssClass_);
      this.retabinate_();
      // Debounce multiple calls
      if (!this.isOpen_) {
        this.adapter_.notifyOpen();
      }
      this.isOpen_ = true;
    }
  }, {
    key: 'close',
    value: function close() {
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.addClass(this.animatingCssClass_);
      this.adapter_.removeClass(this.openCssClass_);
      this.detabinate_();
      // Debounce multiple calls
      if (this.isOpen_) {
        this.adapter_.notifyClose();
      }
      this.isOpen_ = false;
    }
  }, {
    key: 'isOpen',
    value: function isOpen() {
      return this.isOpen_;
    }

    /**
     *  Render all children of the drawer inert when it's closed.
     */

  }, {
    key: 'detabinate_',
    value: function detabinate_() {
      if (this.inert_) {
        return;
      }

      var elements = this.adapter_.getFocusableElements();
      if (elements) {
        for (var i = 0; i < elements.length; i++) {
          this.adapter_.saveElementTabState(elements[i]);
          this.adapter_.makeElementUntabbable(elements[i]);
        }
      }

      this.inert_ = true;
    }

    /**
     *  Make all children of the drawer tabbable again when it's open.
     */

  }, {
    key: 'retabinate_',
    value: function retabinate_() {
      if (!this.inert_) {
        return;
      }

      var elements = this.adapter_.getFocusableElements();
      if (elements) {
        for (var i = 0; i < elements.length; i++) {
          this.adapter_.restoreElementTabState(elements[i]);
        }
      }

      this.inert_ = false;
    }
  }, {
    key: 'handleTouchStart_',
    value: function handleTouchStart_(evt) {
      if (!this.adapter_.hasClass(this.openCssClass_)) {
        return;
      }
      if (evt.pointerType && evt.pointerType !== 'touch') {
        return;
      }

      this.direction_ = this.adapter_.isRtl() ? -1 : 1;
      this.drawerWidth_ = this.adapter_.getDrawerWidth();
      this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      this.currentX_ = this.startX_;

      this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
    }
  }, {
    key: 'handleTouchMove_',
    value: function handleTouchMove_(evt) {
      if (evt.pointerType && evt.pointerType !== 'touch') {
        return;
      }

      this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
    }
  }, {
    key: 'handleTouchEnd_',
    value: function handleTouchEnd_(evt) {
      if (evt.pointerType && evt.pointerType !== 'touch') {
        return;
      }

      this.prepareForTouchEnd_();

      // Did the user close the drawer by more than 50%?
      if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
        this.close();
      } else {
        // Triggering an open here means we'll get a nice animation back to the fully open state.
        this.open();
      }
    }
  }, {
    key: 'prepareForTouchEnd_',
    value: function prepareForTouchEnd_() {
      cancelAnimationFrame(this.updateRaf_);
      this.adapter_.setTranslateX(null);
    }
  }, {
    key: 'updateDrawer_',
    value: function updateDrawer_() {
      this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      this.adapter_.setTranslateX(this.newPosition_);
    }
  }, {
    key: 'isRootTransitioningEventTarget_',
    value: function isRootTransitioningEventTarget_() {
      // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
      // if the event target is the root event target currently transitioning.
      return false;
    }
  }, {
    key: 'handleTransitionEnd_',
    value: function handleTransitionEnd_(evt) {
      if (this.isRootTransitioningEventTarget_(evt.target)) {
        this.adapter_.removeClass(this.animatingCssClass_);
        this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
      }
    }
  }, {
    key: 'newPosition_',
    get: function get$$1() {
      var newPos = null;

      if (this.direction_ === 1) {
        newPos = Math.min(0, this.currentX_ - this.startX_);
      } else {
        newPos = Math.max(0, this.currentX_ - this.startX_);
      }

      return newPos;
    }
  }]);
  return MDCSlidableDrawerFoundation;
}(MDCFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$4 = {
  ROOT: 'mdc-drawer--persistent',
  OPEN: 'mdc-drawer--open',
  ANIMATING: 'mdc-drawer--animating'
};

var strings$6 = {
  DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
  FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCPersistentDrawer:open',
  CLOSE_EVENT: 'MDCPersistentDrawer:close'
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
  inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
  createClass(MDCPersistentDrawerFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$4;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$6;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
        isDrawer: function isDrawer() {
          return false;
        }
      });
    }
  }]);

  function MDCPersistentDrawerFoundation(adapter) {
    classCallCheck(this, MDCPersistentDrawerFoundation);
    return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
  }

  createClass(MDCPersistentDrawerFoundation, [{
    key: 'isRootTransitioningEventTarget_',
    value: function isRootTransitioningEventTarget_(el) {
      return this.adapter_.isDrawer(el);
    }
  }]);
  return MDCPersistentDrawerFoundation;
}(MDCSlidableDrawerFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TAB_DATA = 'data-mdc-tabindex';
var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

var storedTransformPropertyName_ = void 0;
var supportsPassive_$1 = void 0;

// Remap touch events to pointer events, if the browser doesn't support touch events.
function remapEvent(eventName) {
  var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

  if (!('ontouchstart' in globalObj.document)) {
    switch (eventName) {
      case 'touchstart':
        return 'pointerdown';
      case 'touchmove':
        return 'pointermove';
      case 'touchend':
        return 'pointerup';
      default:
        return eventName;
    }
  }

  return eventName;
}

// Choose the correct transform property to use on the current browser.
function getTransformPropertyName() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (storedTransformPropertyName_ === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
    storedTransformPropertyName_ = transformPropertyName;
  }

  return storedTransformPropertyName_;
}

// Determine whether the current browser supports CSS properties.
function supportsCssCustomProperties() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

  if ('CSS' in globalObj) {
    return globalObj.CSS.supports('(--color: red)');
  }
  return false;
}

// Determine whether the current browser supports passive event listeners, and if so, use them.
function applyPassive$1() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_$1 === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_$1 = isSupported;
  }

  return supportsPassive_$1 ? { passive: true } : false;
}

// Save the tab state for an element.
function saveElementTabState(el) {
  if (el.hasAttribute('tabindex')) {
    el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
  }
  el.setAttribute(TAB_DATA_HANDLED, true);
}

// Restore the tab state for an element, if it was saved.
function restoreElementTabState(el) {
  // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
  if (el.hasAttribute(TAB_DATA_HANDLED)) {
    if (el.hasAttribute(TAB_DATA)) {
      el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
      el.removeAttribute(TAB_DATA);
    } else {
      el.removeAttribute('tabindex');
    }
    el.removeAttribute(TAB_DATA_HANDLED);
  }
}

var mdcPersistentDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-persistent-drawer',
  model: {
    prop: 'open',
    event: 'change'
  },
  props: {
    'toolbar-spacer': Boolean,
    'open': Boolean
  },
  data: function data() {
    return {
      classes: {}
    };
  },

  watch: {
    open: function open() {
      this._refresh();
    }
  },
  methods: {
    _refresh: function _refresh() {
      if (this.open) {
        this.foundation && this.foundation.open();
      } else {
        this.foundation && this.foundation.close();
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


    this.foundation = new MDCPersistentDrawerFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.classes, className);
      },
      hasClass: function hasClass(className) {
        return _this.$el.classList.contains(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return !!_this.$refs.drawer;
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
      },
      deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        _this.$refs.drawer.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        _this.$refs.drawer.removeEventListener('transitionend', handler);
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        document.removeEventListener('keydown', handler);
      },
      getDrawerWidth: function getDrawerWidth() {
        return _this.$refs.drawer.offsetWidth;
      },
      setTranslateX: function setTranslateX(value) {
        _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
      },
      getFocusableElements: function getFocusableElements() {
        return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
      },
      saveElementTabState: function saveElementTabState$$1(el) {
        saveElementTabState(el);
      },
      restoreElementTabState: function restoreElementTabState$$1(el) {
        restoreElementTabState(el);
      },
      makeElementUntabbable: function makeElementUntabbable(el) {
        el.setAttribute('tabindex', -1);
      },
      notifyOpen: function notifyOpen() {
        _this.$emit('change', true);
        _this.$emit('open');
      },
      notifyClose: function notifyClose() {
        _this.$emit('change', false);
        _this.$emit('close');
      },
      isRtl: function isRtl() {
        /* global getComputedStyle */
        return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
      },
      isDrawer: function isDrawer(el) {
        return el === _this.$refs.drawer;
      }
    });
    this.foundation && this.foundation.init();
    this._refresh();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation && this.foundation.destroy();
    this.foundation = null;
  }
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$5 = {
  ROOT: 'mdc-drawer--temporary',
  OPEN: 'mdc-drawer--open',
  ANIMATING: 'mdc-drawer--animating',
  SCROLL_LOCK: 'mdc-drawer-scroll-lock'
};

var strings$7 = {
  DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
  OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
  FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCTemporaryDrawer:open',
  CLOSE_EVENT: 'MDCTemporaryDrawer:close'
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
  inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
  createClass(MDCTemporaryDrawerFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$5;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$7;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        isDrawer: function isDrawer() {
          return false;
        },
        updateCssVariable: function updateCssVariable() /* value: string */{},
        eventTargetHasClass: function eventTargetHasClass() {
          return (/* target: EventTarget, className: string */ /* boolean */false
          );
        }
      });
    }
  }]);

  function MDCTemporaryDrawerFoundation(adapter) {
    classCallCheck(this, MDCTemporaryDrawerFoundation);

    var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

    _this.componentClickHandler_ = function (evt) {
      if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$5.ROOT)) {
        _this.close(true);
      }
    };
    return _this;
  }

  createClass(MDCTemporaryDrawerFoundation, [{
    key: 'init',
    value: function init() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

      // Make browser aware of custom property being used in this element.
      // Workaround for certain types of hard-to-reproduce heisenbugs.
      this.adapter_.updateCssVariable(0);
      this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

      this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
      this.enableScroll_();
    }
  }, {
    key: 'open',
    value: function open() {
      this.disableScroll_();
      // Make sure custom property values are cleared before starting.
      this.adapter_.updateCssVariable('');

      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
    }
  }, {
    key: 'close',
    value: function close() {
      // Make sure custom property values are cleared before making any changes.
      this.adapter_.updateCssVariable('');

      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
    }
  }, {
    key: 'prepareForTouchEnd_',
    value: function prepareForTouchEnd_() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

      this.adapter_.updateCssVariable('');
    }
  }, {
    key: 'updateDrawer_',
    value: function updateDrawer_() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

      var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
      this.adapter_.updateCssVariable(newOpacity);
    }
  }, {
    key: 'isRootTransitioningEventTarget_',
    value: function isRootTransitioningEventTarget_(el) {
      return this.adapter_.isDrawer(el);
    }
  }, {
    key: 'handleTransitionEnd_',
    value: function handleTransitionEnd_(evt) {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
      if (!this.isOpen_) {
        this.enableScroll_();
      }
    }
  }, {
    key: 'disableScroll_',
    value: function disableScroll_() {
      this.adapter_.addBodyClass(cssClasses$5.SCROLL_LOCK);
    }
  }, {
    key: 'enableScroll_',
    value: function enableScroll_() {
      this.adapter_.removeBodyClass(cssClasses$5.SCROLL_LOCK);
    }
  }]);
  return MDCTemporaryDrawerFoundation;
}(MDCSlidableDrawerFoundation);

var mdcTemporaryDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-temporary-drawer',
  model: {
    prop: 'open',
    event: 'change'
  },
  props: {
    'open': Boolean,
    'toolbar-spacer': Boolean
  },
  data: function data() {
    return {
      classes: {}
    };
  },

  watch: {
    open: function open() {
      this._refresh();
    }
  },
  methods: {
    _refresh: function _refresh() {
      if (this.open) {
        this.foundation && this.foundation.open();
      } else {
        this.foundation && this.foundation.close();
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
        FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
        OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


    this.foundation = new MDCTemporaryDrawerFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.classes, className);
      },
      hasClass: function hasClass(className) {
        return _this.$el.classList.contains(className);
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      },
      eventTargetHasClass: function eventTargetHasClass(target, className) {
        return target.classList.contains(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return !!_this.$refs.drawer;
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
      },
      deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        _this.$refs.drawer.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        _this.$refs.drawer.removeEventListener('transitionend', handler);
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        document.removeEventListener('keydown', handler);
      },
      getDrawerWidth: function getDrawerWidth() {
        return _this.$refs.drawer.offsetWidth;
      },
      setTranslateX: function setTranslateX(value) {
        _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
      },
      updateCssVariable: function updateCssVariable(value) {
        if (supportsCssCustomProperties()) {
          _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
        }
      },
      getFocusableElements: function getFocusableElements() {
        return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
      },
      saveElementTabState: function saveElementTabState$$1(el) {
        saveElementTabState(el);
      },
      restoreElementTabState: function restoreElementTabState$$1(el) {
        restoreElementTabState(el);
      },
      makeElementUntabbable: function makeElementUntabbable(el) {
        el.setAttribute('tabindex', -1);
      },
      notifyOpen: function notifyOpen() {
        _this.$emit('change', true);
        _this.$emit('open');
      },
      notifyClose: function notifyClose() {
        _this.$emit('change', false);
        _this.$emit('close');
      },
      isRtl: function isRtl() {
        /* global getComputedStyle */
        return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
      },
      isDrawer: function isDrawer(el) {
        return el === _this.$refs.drawer;
      }
    });
    this.foundation && this.foundation.init();
    this._refresh();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation && this.foundation.destroy();
    this.foundation = null;
  }
};

var media = new (function () {
  function _class() {
    classCallCheck(this, _class);
  }

  createClass(_class, [{
    key: 'small',
    get: function get$$1() {
      return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
    }
  }, {
    key: 'large',
    get: function get$$1() {
      return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
    }
  }]);
  return _class;
}())();

var mdcDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { ref: "drawer", tag: "component", staticClass: "mdc-drawer", attrs: { "toolbar-spacer": _vm.toolbarSpacer }, on: { "change": function change($event) {
          _vm.$root.$emit('mdc:layout');
        }, "open": function open($event) {
          _vm.$emit('open');
        }, "close": function close($event) {
          _vm.$emit('close');
        } }, model: { value: _vm.open_, callback: function callback($$v) {
          _vm.open_ = $$v;
        }, expression: "open_" } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer',
  props: {
    permanent: Boolean,
    persistent: Boolean,
    temporary: Boolean,
    drawerType: {
      type: String,
      validator: function validator(val) {
        return val in ['temporary', 'persistent', 'permanent'];
      }
    },
    toolbarSpacer: Boolean,
    toggleOn: String,
    toggleOnSource: { type: Object, required: false },
    openOn: String,
    openOnSource: { type: Object, required: false },
    closeOn: String,
    closeOnSource: { type: Object, required: false }
  },
  provide: function provide() {
    return { mdcDrawer: this };
  },
  data: function data() {
    return {
      small: false,
      large: false,
      open_: false
    };
  },

  components: {
    'mdc-permanent-drawer': mdcPermanentDrawer,
    'mdc-persistent-drawer': mdcPersistentDrawer,
    'mdc-temporary-drawer': mdcTemporaryDrawer
  },
  computed: {
    type: function type() {
      if (this.permanent) {
        return 'mdc-permanent-drawer';
      } else if (this.persistent) {
        return 'mdc-persistent-drawer';
      } else if (this.temporary) {
        return 'mdc-temporary-drawer';
      } else {
        switch (this.drawerType) {
          case 'permanent':
            return 'mdc-permanent-drawer';
          case 'persistent':
            return 'mdc-persistent-drawer';
          case 'temporary':
            return 'mdc-temporary-drawer';
          default:
            return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
        }
      }
    },
    isPermanent: function isPermanent() {
      return this.permanent || this.type === 'mdc-permanent-drawer';
    },
    isPersistent: function isPersistent() {
      return this.persistent || this.type === 'mdc-persistent-drawer';
    },
    isTemporary: function isTemporary() {
      return this.temporary || this.type === 'mdc-temporary-drawer';
    },
    isResponsive: function isResponsive() {
      return !(this.permanent || this.persistent || this.temporary || this.drawerType);
    }
  },
  methods: {
    open: function open() {
      this.open_ = true;
    },
    close: function close() {
      this.isPermanent || (this.open_ = false);
    },
    toggle: function toggle() {
      this.isPermanent || (this.isOpen() ? this.close() : this.open());
    },
    isOpen: function isOpen() {
      return this.isPermanent || this.open_;
    },
    refreshMedia: function refreshMedia() {
      this.small = media.small.matches;
      this.large = media.large.matches;
      if (this.isResponsive) {
        if (this.large) {
          this.open();
        } else {
          this.close();
        }
      }
    }
  },
  created: function created() {
    if (window && window.matchMedia) {
      this.small = media.small.matches;
      this.large = media.large.matches;
    }
  },
  mounted: function mounted() {
    var _this = this;

    if (this.toggleOn) {
      var source = this.toggleOnSource || this.$root;
      source.$on(this.toggleOn, function () {
        return _this.toggle();
      });
    }
    if (this.openOn) {
      var _source = this.openOnSource || this.$root;
      _source.$on(this.openOn, function () {
        return _this.open();
      });
    }
    if (this.closeOn) {
      var _source2 = this.closeOnSource || this.$root;
      _source2.$on(this.closeOn, function () {
        return _this.close();
      });
    }
    media.small.addListener(this.refreshMedia);
    media.large.addListener(this.refreshMedia);
    this.$nextTick(function () {
      return _this.refreshMedia();
    });
  },
  beforeDestroy: function beforeDestroy() {
    media.small.removeListener(this.refreshMedia);
    media.large.removeListener(this.refreshMedia);
  }
};

var mdcDrawerLayout = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer-layout'
};

var mdcDrawerHeader = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.show ? _c('header', { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c('div', { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
  }, staticRenderFns: [],
  name: 'mdc-drawer-header',
  props: {
    'permanent': Boolean,
    'persistent': Boolean,
    'temporary': Boolean
  },
  inject: ['mdcDrawer'],
  computed: {
    show: function show() {
      if (this.temporary || this.persistent || this.permanent) {
        return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
      } else {
        return true;
      }
    }
  }
};

var mdcDrawerList = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer-list',
  props: {
    'dense': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-list--dense': this.dense
      }
    };
  }
};

var mdcDrawerItem = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-drawer-item mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.onClick } }, [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c('i', { staticClass: "material-icons", attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer-item',
  inject: ['mdcDrawer'],
  mixins: [DispatchEventMixin, CustomLinkMixin],
  props: {
    startIcon: String,
    temporaryClose: {
      type: Boolean,
      default: true
    },
    activated: Boolean,
    exactActiveClass: {
      type: String,
      default: 'mdc-list-item--activated'
    }
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    itemClasses: function itemClasses() {
      return {
        'mdc-list-item--activated': this.activated
      };
    },
    hasStartDetail: function hasStartDetail() {
      return this.startIcon || this.$slots['start-detail'];
    }
  },
  methods: {
    onClick: function onClick(evt) {
      this.mdcDrawer.isTemporary && this.temporaryClose && this.mdcDrawer.close();
      this.dispatchEvent(evt);
    }
  },
  mounted: function mounted() {
    this.ripple = new RippleBase(this);
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple && this.ripple.destroy();
    this.ripple = null;
  }
};

var mdcDrawerDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-divider" });
  }, staticRenderFns: [],
  name: 'mdc-drawer-divider'
};

var VueMDCDrawer = BasePlugin({
  mdcDrawer: mdcDrawer,
  mdcDrawerLayout: mdcDrawerLayout,
  mdcDrawerHeader: mdcDrawerHeader,
  mdcDrawerList: mdcDrawerList,
  mdcDrawerItem: mdcDrawerItem,
  mdcDrawerDivider: mdcDrawerDivider
});

var mdcElevation = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-elevation" });
  }, staticRenderFns: [],
  name: 'mdc-elevation',
  props: {}
};

var VueMDCElevation = BasePlugin({
  mdcElevation: mdcElevation
});

var mdcFAB = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', { staticClass: "mdc-fab", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [_c('span', { staticClass: "mdc-fab__icon" }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-fab',
  mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
  props: {
    icon: String,
    mini: Boolean,
    absolute: Boolean,
    fixed: Boolean
  },
  data: function data() {
    return {
      classes: {
        'material-icons': this.icon,
        'mdc-fab--mini': this.mini,
        'mdc-fab--absolute': this.absolute,
        'mdc-fab--fixed': this.fixed
      },
      styles: {}
    };
  },

  watch: {
    icon: function icon() {
      this.$set(this.classes, 'material-icons', this.icon);
    },
    mini: function mini() {
      this.$set(this.classes, 'mdc-fab--mini', this.mini);
    }
  }
};

var VueMDCFab = BasePlugin({
  mdcFAB: mdcFAB
});

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var strings$8 = {
  TILES_SELECTOR: '.mdc-grid-list__tiles',
  TILE_SELECTOR: '.mdc-grid-tile'
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCGridListFoundation = function (_MDCFoundation) {
  inherits(MDCGridListFoundation, _MDCFoundation);
  createClass(MDCGridListFoundation, null, [{
    key: 'strings',
    get: function get$$1() {
      return strings$8;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        getOffsetWidth: function getOffsetWidth() {
          return (/* number */0
          );
        },
        getNumberOfTiles: function getNumberOfTiles() {
          return (/* number */0
          );
        },
        getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
          return (/* index: number */ /* number */0
          );
        },
        setStyleForTilesElement: function setStyleForTilesElement() /* property: string, value: string */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{}
      };
    }
  }]);

  function MDCGridListFoundation(adapter) {
    classCallCheck(this, MDCGridListFoundation);

    var _this = possibleConstructorReturn(this, (MDCGridListFoundation.__proto__ || Object.getPrototypeOf(MDCGridListFoundation)).call(this, _extends(MDCGridListFoundation.defaultAdapter, adapter)));

    _this.resizeHandler_ = function () {
      return _this.alignCenter();
    };
    _this.resizeFrame_ = 0;
    return _this;
  }

  createClass(MDCGridListFoundation, [{
    key: 'init',
    value: function init() {
      this.alignCenter();
      this.adapter_.registerResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'alignCenter',
    value: function alignCenter() {
      var _this2 = this;

      if (this.resizeFrame_ !== 0) {
        cancelAnimationFrame(this.resizeFrame_);
      }
      this.resizeFrame_ = requestAnimationFrame(function () {
        _this2.alignCenter_();
        _this2.resizeFrame_ = 0;
      });
    }
  }, {
    key: 'alignCenter_',
    value: function alignCenter_() {
      if (this.adapter_.getNumberOfTiles() == 0) {
        return;
      }
      var gridWidth = this.adapter_.getOffsetWidth();
      var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
      var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
      this.adapter_.setStyleForTilesElement('width', tilesWidth + 'px');
    }
  }]);
  return MDCGridListFoundation;
}(MDCFoundation);

var mdcGridList = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-grid-list" }, [_c('ul', { staticClass: "mdc-grid-list__tiles", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-grid-list',
  props: {
    'width': [String, Number],
    'ratio': String,
    'narrow-gutter': Boolean,
    'header-caption': Boolean,
    'icon-align-start': Boolean,
    'icon-align-end': Boolean,
    'with-support-text': Boolean,
    'interactive': Boolean
  },
  provide: function provide() {
    return { mdcGrid: this };
  },

  computed: {
    classes: function classes() {
      var classes = {};

      classes['mdc-grid-list--tile-gutter-1'] = this.narrowGutter;
      classes['mdc-grid-list--header-caption'] = this.headerCaption;
      classes['mdc-grid-list--tile-aspect-' + this.ratio] = this.ratio;
      classes['mdc-grid-list--with-icon-align-start'] = this.iconAlignStart;
      classes['mdc-grid-list--with-icon-align-end'] = this.iconAlignEnd;
      classes['mdc-grid-list--twoline-caption'] = this.withSupportText;
      classes['mdc-grid-list--non-interactive'] = !this.interactive;

      return classes;
    },
    styles: function styles() {
      return {
        '--mdc-grid-list-tile-width': this.width + 'px'
      };
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCGridListFoundation({
      getOffsetWidth: function getOffsetWidth() {
        return _this.$el.offsetWidth;
      },
      getNumberOfTiles: function getNumberOfTiles() {
        return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
      },
      getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
        return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
      },
      setStyleForTilesElement: function setStyleForTilesElement(property, value) {
        _this.$el.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        window.removeEventListener('resize', handler);
      }
    });
    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var mdcGridTile = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-grid-tile", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined }, on: { "click": _vm.onClick } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.cover ? _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('div', { staticClass: "mdc-grid-tile__primary-content", style: { backgroundImage: 'url(' + _vm.src + ')' } })]) : _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('img', { staticClass: "mdc-grid-tile__primary-content", attrs: { "src": _vm.src } })]), _vm._v(" "), _vm.title || _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__secondary" }, [_vm.icon ? _c('i', { staticClass: "mdc-grid-tile__icon material-icons" }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), _vm.title ? _c('span', { staticClass: "mdc-grid-tile__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._v(" "), _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__support-text" }, [_vm._v(_vm._s(_vm.supportText))]) : _vm._e()]) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-grid-tile',
  inject: ['mdcGrid'],
  mixins: [DispatchEventMixin],
  props: {
    'src': String,
    'cover': Boolean,
    'icon': String,
    'title': String,
    'support-text': String,
    'selected': Boolean,
    'activated': Boolean
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    itemClasses: function itemClasses() {
      return {
        'mdc-grid-tile--selected': this.selected,
        'mdc-grid-tile--activated': this.activated
      };
    },
    isInteractive: function isInteractive() {
      return this.mdcGrid && this.mdcGrid.interactive;
    },
    hasStartDetail: function hasStartDetail() {
      return this.startIcon || this.$slots['start-detail'];
    },
    hasEndDetail: function hasEndDetail() {
      return this.endIcon || this.$slots['end-detail'];
    }
  },
  watch: {
    isInteractive: function isInteractive(value) {
      if (value) {
        this.addRipple();
      } else {
        this.removeRipple();
      }
    }
  },
  methods: {
    onClick: function onClick(evt) {
      this.dispatchEvent(evt);
    },
    addRipple: function addRipple() {
      if (!this.ripple) {
        var ripple = new RippleBase(this);
        ripple.init();
        this.ripple = ripple;
      }
    },
    removeRipple: function removeRipple() {
      if (this.ripple) {
        var ripple = this.ripple;
        this.ripple = null;
        ripple.destroy();
      }
    }
  },
  mounted: function mounted() {
    this.isInteractive && this.addRipple();
    /* eslint-disable no-console */
    console.log(this);
    console.log(this.$el.getBoundingClientRect());
    console.log(this.ripple);
    /* eslint-enable no-console */
  },
  beforeDestroy: function beforeDestroy() {
    this.removeRipple();
  }
};

var VueMDCGridList = BasePlugin({
  mdcGridList: mdcGridList,
  mdcGridTile: mdcGridTile
});

var mdcIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon mdc-icon--material", class: { 'material-icons': !!_vm.icon } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-icon',
  props: {
    icon: String
  }
};

var VueMDCIcon = BasePlugin({
  mdcIcon: mdcIcon
});

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Icon Toggle. Provides an interface for managing
 * - classes
 * - dom
 * - inner text
 * - event handlers
 * - event dispatch
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */

var MDCIconToggleAdapter = function () {
  function MDCIconToggleAdapter() {
    classCallCheck(this, MDCIconToggleAdapter);
  }

  createClass(MDCIconToggleAdapter, [{
    key: "addClass",

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(type, handler) {}

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}

    /** @param {string} text */

  }, {
    key: "setText",
    value: function setText(text) {}

    /** @return {number} */

  }, {
    key: "getTabIndex",
    value: function getTabIndex() {}

    /** @param {number} tabIndex */

  }, {
    key: "setTabIndex",
    value: function setTabIndex(tabIndex) {}

    /**
     * @param {string} name
     * @return {string}
     */

  }, {
    key: "getAttr",
    value: function getAttr(name) {}

    /**
     * @param {string} name
     * @param {string} value
     */

  }, {
    key: "setAttr",
    value: function setAttr(name, value) {}

    /** @param {string} name */

  }, {
    key: "rmAttr",
    value: function rmAttr(name) {}

    /** @param {!IconToggleEvent} evtData */

  }, {
    key: "notifyChange",
    value: function notifyChange(evtData) {}
  }]);
  return MDCIconToggleAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$6 = {
  ROOT: 'mdc-icon-toggle',
  DISABLED: 'mdc-icon-toggle--disabled'
};

/** @enum {string} */
var strings$9 = {
  DATA_TOGGLE_ON: 'data-toggle-on',
  DATA_TOGGLE_OFF: 'data-toggle-off',
  ARIA_PRESSED: 'aria-pressed',
  ARIA_DISABLED: 'aria-disabled',
  ARIA_LABEL: 'aria-label',
  CHANGE_EVENT: 'MDCIconToggle:change'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/**
 * @extends {MDCFoundation<!MDCIconToggleAdapter>}
 */

var MDCIconToggleFoundation = function (_MDCFoundation) {
  inherits(MDCIconToggleFoundation, _MDCFoundation);
  createClass(MDCIconToggleFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$6;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$9;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        setText: function setText() /* text: string */{},
        getTabIndex: function getTabIndex() {
          return (/* number */0
          );
        },
        setTabIndex: function setTabIndex() /* tabIndex: number */{},
        getAttr: function getAttr() {
          return (/* name: string */ /* string */''
          );
        },
        setAttr: function setAttr() /* name: string, value: string */{},
        rmAttr: function rmAttr() /* name: string */{},
        notifyChange: function notifyChange() /* evtData: IconToggleEvent */{}
      };
    }
  }]);

  function MDCIconToggleFoundation(adapter) {
    classCallCheck(this, MDCIconToggleFoundation);

    /** @private {boolean} */
    var _this = possibleConstructorReturn(this, (MDCIconToggleFoundation.__proto__ || Object.getPrototypeOf(MDCIconToggleFoundation)).call(this, _extends(MDCIconToggleFoundation.defaultAdapter, adapter)));

    _this.on_ = false;

    /** @private {boolean} */
    _this.disabled_ = false;

    /** @private {number} */
    _this.savedTabIndex_ = -1;

    /** @private {?IconToggleState} */
    _this.toggleOnData_ = null;

    /** @private {?IconToggleState} */
    _this.toggleOffData_ = null;

    _this.clickHandler_ = /** @private {!EventListener} */function () {
      return _this.toggleFromEvt_();
    };

    /** @private {boolean} */
    _this.isHandlingKeydown_ = false;

    _this.keydownHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
      if (isSpace(evt)) {
        _this.isHandlingKeydown_ = true;
        return evt.preventDefault();
      }
    };

    _this.keyupHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
      if (isSpace(evt)) {
        _this.isHandlingKeydown_ = false;
        _this.toggleFromEvt_();
      }
    };
    return _this;
  }

  createClass(MDCIconToggleFoundation, [{
    key: 'init',
    value: function init() {
      this.refreshToggleData();
      this.savedTabIndex_ = this.adapter_.getTabIndex();
      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
    }
  }, {
    key: 'refreshToggleData',
    value: function refreshToggleData() {
      var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
          DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
          DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;

      this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
      this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
    }

    /** @private */

  }, {
    key: 'toggleFromEvt_',
    value: function toggleFromEvt_() {
      this.toggle();
      var isOn = this.on_;

      this.adapter_.notifyChange( /** @type {!IconToggleEvent} */{ isOn: isOn });
    }

    /** @return {boolean} */

  }, {
    key: 'isOn',
    value: function isOn() {
      return this.on_;
    }

    /** @param {boolean=} isOn */

  }, {
    key: 'toggle',
    value: function toggle() {
      var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;

      this.on_ = isOn;

      var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
          ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
          ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;


      if (this.on_) {
        this.adapter_.setAttr(ARIA_PRESSED, 'true');
      } else {
        this.adapter_.setAttr(ARIA_PRESSED, 'false');
      }

      var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
          classToRemove = _ref.cssClass;

      if (classToRemove) {
        this.adapter_.removeClass(classToRemove);
      }

      var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
          content = _ref2.content,
          label = _ref2.label,
          cssClass = _ref2.cssClass;

      if (cssClass) {
        this.adapter_.addClass(cssClass);
      }
      if (content) {
        this.adapter_.setText(content);
      }
      if (label) {
        this.adapter_.setAttr(ARIA_LABEL, label);
      }
    }

    /**
     * @param {string} dataAttr
     * @return {!IconToggleState}
     */

  }, {
    key: 'parseJsonDataAttr_',
    value: function parseJsonDataAttr_(dataAttr) {
      var val = this.adapter_.getAttr(dataAttr);
      if (!val) {
        return {};
      }
      return (/** @type {!IconToggleState} */JSON.parse(val)
      );
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.disabled_;
    }

    /** @param {boolean} isDisabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(isDisabled) {
      this.disabled_ = isDisabled;

      var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
      var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;


      if (this.disabled_) {
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.setTabIndex(-1);
        this.adapter_.setAttr(ARIA_DISABLED, 'true');
        this.adapter_.addClass(DISABLED);
      } else {
        this.adapter_.setTabIndex(this.savedTabIndex_);
        this.adapter_.rmAttr(ARIA_DISABLED);
        this.adapter_.removeClass(DISABLED);
      }
    }

    /** @return {boolean} */

  }, {
    key: 'isKeyboardActivated',
    value: function isKeyboardActivated() {
      return this.isHandlingKeydown_;
    }
  }]);
  return MDCIconToggleFoundation;
}(MDCFoundation);

/**
 * @param {!KeyboardKey} keyboardKey
 * @return {boolean}
 */
function isSpace(keyboardKey) {
  return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
}

var mdcIConToggle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon-toggle", class: _vm.classes, style: _vm.styles, attrs: { "role": "button", "aria-pressed": "false", "tabindex": _vm.tabIndex, "data-toggle-on": _vm.toggleOnData, "data-toggle-off": _vm.toggleOffData } }, [_c('i', { class: _vm.iconClasses, attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.text))])]);
  }, staticRenderFns: [],
  name: 'mdc-icon-toggle',
  props: {
    toggleOn: [String, Object],
    toggleOff: [String, Object],
    value: Boolean,
    disabled: Boolean,
    accent: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-icon-toggle--accent': this.accent
      },
      styles: {},
      iconClasses: {},
      tabIndex: 0,
      text: ''
    };
  },

  watch: {
    value: function value(_value) {
      this.foundation && this.foundation.toggle(_value);
    },
    disabled: function disabled(_disabled) {
      this.foundation && this.foundation.setDisabled(_disabled);
    },
    toggleOnData: function toggleOnData() {
      this.foundation && this.foundation.refreshToggleData();
    },
    toggleOffData: function toggleOffData() {
      this.foundation && this.foundation.refreshToggleData();
    },
    accent: function accent(value) {
      this.$set(this.classes, 'mdc-icon-toggle--secondary', value);
    }
  },
  computed: {
    toggleOnData: function toggleOnData() {
      var toggle = this.toggleOn;
      return toggle && JSON.stringify(typeof toggle === 'string' ? {
        content: toggle,
        cssClass: 'material-icons'
      } : {
        content: toggle.icon || toggle.content,
        label: toggle.label,
        cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
      });
    },
    toggleOffData: function toggleOffData() {
      var toggle = this.toggleOff;
      return toggle && JSON.stringify(typeof toggle === 'string' ? {
        content: toggle,
        cssClass: 'material-icons'
      } : {
        content: toggle.icon || toggle.content,
        label: toggle.label,
        cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
      });
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCIconToggleFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.iconClasses, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.iconClasses, className);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        return _this.$el.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        return _this.$el.removeEventListener(evt, handler);
      },
      setText: function setText(text) {
        _this.text = text;
      },
      getTabIndex: function getTabIndex() {
        return _this.tabIndex;
      },
      setTabIndex: function setTabIndex(tabIndex) {
        _this.tabIndex = tabIndex;
      },
      getAttr: function getAttr(name, value) {
        return _this.$el.getAttribute(name, value);
      },
      setAttr: function setAttr(name, value) {
        _this.$el.setAttribute(name, value);
      },
      rmAttr: function rmAttr(name) {
        _this.$el.removeAttribute(name);
      },
      notifyChange: function notifyChange(evtData) {
        _this.$emit('input', evtData.isOn);
      }
    });
    this.foundation.init();
    this.foundation.toggle(this.value);
    this.foundation.setDisabled(this.disabled);

    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      },
      isSurfaceActive: function isSurfaceActive() {
        return _this.foundation.isKeyboardActivated();
      }
    });
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
    this.ripple.destroy();
  }
};

var VueMDCIconToggle = BasePlugin({
  mdcIConToggle: mdcIConToggle
});

var mdcLayoutApp = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-app" }, [_c('div', { staticClass: "mdc-layout-app--toolbar-wrapper" }, [_vm._t("toolbar")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--main-container" }, [_c('div', { staticClass: "mdc-layout-app--drawer-wrapper" }, [_vm._t("drawer")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--content-wrapper" }, [_vm._t("default")], 2)])]);
  }, staticRenderFns: [],
  name: 'mdc-layout-app'
};

var VueMDCLayoutApp = BasePlugin({
  mdcLayoutApp: mdcLayoutApp
});

var mdcLayoutGrid = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-grid", class: _vm.classes }, [_c('div', { staticClass: "mdc-layout-grid__inner" }, [_vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-layout-grid',
  props: {
    'fixed-column-width': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-layout-grid--fixed-column-width': this.fixedColumnWidth
      }
    };
  }
};

var spanOptions = {
  type: [String, Number],
  default: null,
  validator: function validator(value) {
    var num = Number(value);
    return isFinite(num) && num <= 12 && num > 0;
  }
};

var mdcLayoutCell = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-cell mdc-layout-grid__cell", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-layout-cell',
  props: {
    span: spanOptions,
    order: spanOptions,
    phone: spanOptions,
    tablet: spanOptions,
    desktop: spanOptions,
    align: {
      type: String,
      validator: function validator(value) {
        return ['top', 'bottom', 'middle'].indexOf(value) !== -1;
      }
    }
  },
  computed: {
    classes: function classes() {
      var classes = [];

      if (this.span) {
        classes.push("mdc-layout-grid__cell--span-" + this.span);
      }

      if (this.order) {
        classes.push("mdc-layout-grid__cell--order-" + this.order);
      }

      if (this.phone) {
        classes.push("mdc-layout-grid__cell--span-" + this.phone + "-phone");
      }

      if (this.tablet) {
        classes.push("mdc-layout-grid__cell--span-" + this.tablet + "-tablet");
      }

      if (this.desktop) {
        classes.push("mdc-layout-grid__cell--span-" + this.desktop + "-desktop");
      }

      if (this.align) {
        classes.push("mdc-layout-grid__cell--align-" + this.align);
      }

      return classes;
    }
  }
};

var mdcLayoutInnerGrid = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-inner-grid mdc-layout-grid__inner" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-layout-inner-grid'
};

var VueMDCLayoutGrid = BasePlugin({
  mdcLayoutGrid: mdcLayoutGrid,
  mdcLayoutCell: mdcLayoutCell,
  mdcLayoutInnerGrid: mdcLayoutInnerGrid
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$7 = {
  CLOSED_CLASS: 'mdc-linear-progress--closed',
  INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
  REVERSED_CLASS: 'mdc-linear-progress--reversed'
};

var strings$10 = {
  PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
  BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCLinearProgressFoundation = function (_MDCFoundation) {
  inherits(MDCLinearProgressFoundation, _MDCFoundation);
  createClass(MDCLinearProgressFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$7;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$10;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        getPrimaryBar: function getPrimaryBar() /* el: Element */{},
        getBuffer: function getBuffer() /* el: Element */{},
        hasClass: function hasClass() {
          return (/* className: string */false
          );
        },
        removeClass: function removeClass() /* className: string */{},
        setStyle: function setStyle() /* el: Element, styleProperty: string, value: string */{}
      };
    }
  }]);

  function MDCLinearProgressFoundation(adapter) {
    classCallCheck(this, MDCLinearProgressFoundation);
    return possibleConstructorReturn(this, (MDCLinearProgressFoundation.__proto__ || Object.getPrototypeOf(MDCLinearProgressFoundation)).call(this, _extends(MDCLinearProgressFoundation.defaultAdapter, adapter)));
  }

  createClass(MDCLinearProgressFoundation, [{
    key: 'init',
    value: function init() {
      this.determinate_ = !this.adapter_.hasClass(cssClasses$7.INDETERMINATE_CLASS);
      this.reverse_ = this.adapter_.hasClass(cssClasses$7.REVERSED_CLASS);
      this.progress_ = 0;
    }
  }, {
    key: 'setDeterminate',
    value: function setDeterminate(isDeterminate) {
      this.determinate_ = isDeterminate;
      if (this.determinate_) {
        this.adapter_.removeClass(cssClasses$7.INDETERMINATE_CLASS);
        this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
      } else {
        this.adapter_.addClass(cssClasses$7.INDETERMINATE_CLASS);
        this.setScale_(this.adapter_.getPrimaryBar(), 1);
        this.setScale_(this.adapter_.getBuffer(), 1);
      }
    }
  }, {
    key: 'setProgress',
    value: function setProgress(value) {
      this.progress_ = value;
      if (this.determinate_) {
        this.setScale_(this.adapter_.getPrimaryBar(), value);
      }
    }
  }, {
    key: 'setBuffer',
    value: function setBuffer(value) {
      if (this.determinate_) {
        this.setScale_(this.adapter_.getBuffer(), value);
      }
    }
  }, {
    key: 'setReverse',
    value: function setReverse(isReversed) {
      this.reverse_ = isReversed;
      if (this.reverse_) {
        this.adapter_.addClass(cssClasses$7.REVERSED_CLASS);
      } else {
        this.adapter_.removeClass(cssClasses$7.REVERSED_CLASS);
      }
    }
  }, {
    key: 'open',
    value: function open() {
      this.adapter_.removeClass(cssClasses$7.CLOSED_CLASS);
    }
  }, {
    key: 'close',
    value: function close() {
      this.adapter_.addClass(cssClasses$7.CLOSED_CLASS);
    }
  }, {
    key: 'setScale_',
    value: function setScale_(el, scaleValue) {
      var _this2 = this;

      var value = 'scaleX(' + scaleValue + ')';
      transformStyleProperties.forEach(function (transformStyleProperty) {
        _this2.adapter_.setStyle(el, transformStyleProperty, value);
      });
    }
  }]);
  return MDCLinearProgressFoundation;
}(MDCFoundation);

var ProgressPropType = {
  type: [Number, String],
  validator: function validator(value) {
    return Number(value) >= 0 && Number(value) <= 1;
  }
};

var mdcLinearProgress = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress", class: _vm.classes, style: _vm.styles, attrs: { "role": "progressbar" } }, [_c('div', { staticClass: "mdc-linear-progress__buffering-dots" }), _vm._v(" "), _c('div', { ref: "buffer", staticClass: "mdc-linear-progress__buffer" }), _vm._v(" "), _c('div', { ref: "primary", staticClass: "mdc-linear-progress__bar mdc-linear-progress__primary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]), _vm._v(" "), _vm._m(0)]);
  }, staticRenderFns: [function () {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress__bar mdc-linear-progress__secondary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]);
  }],
  name: 'mdc-linear-progress',
  props: {
    'open': { type: Boolean, default: true },
    'indeterminate': Boolean,
    'reverse': Boolean,
    'accent': Boolean,
    'progress': ProgressPropType,
    'buffer': ProgressPropType
  },
  data: function data() {
    return {
      classes: { 'mdc-linear-progress--accent': this.accent },
      styles: {}
    };
  },

  watch: {
    open: function open() {
      if (this.open) {
        this.foundation.open();
      } else {
        this.foundation.close();
      }
    },
    progress: function progress() {
      this.foundation.setProgress(Number(this.progress));
    },
    buffer: function buffer() {
      this.foundation.setBuffer(Number(this.buffer));
    },
    indeterminate: function indeterminate() {
      this.foundation.setDeterminate(!this.indeterminate);
    },
    reverse: function reverse() {
      this.foundation.setReverse(this.reverse);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCLinearProgressFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.classes, className, true);
      },
      getPrimaryBar: function getPrimaryBar() /* el: Element */{
        return _this.$refs.primary;
      },
      getBuffer: function getBuffer() /* el: Element */{
        return _this.$refs.buffer;
      },
      hasClass: function hasClass(className) {
        _this.$el.classList.contains(className);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.classes, className);
      },
      setStyle: function setStyle(el, styleProperty, value) {
        el.style[styleProperty] = value;
      }
    });
    this.foundation.init();

    this.foundation.setReverse(this.reverse);
    this.foundation.setProgress(Number(this.progress));
    this.foundation.setBuffer(Number(this.buffer));
    this.foundation.setDeterminate(!this.indeterminate);
    if (this.open) {
      this.foundation.open();
    } else {
      this.foundation.close();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCLinearProgress = BasePlugin({
  mdcLinearProgress: mdcLinearProgress
});

var mdcList = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('ul', { staticClass: "mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-list',
  props: {
    dense: Boolean,
    avatarList: Boolean,
    twoLine: Boolean,
    bordered: Boolean,
    interactive: Boolean
  },
  provide: function provide() {
    return { mdcList: this };
  },

  computed: {
    classes: function classes() {
      return {
        'mdc-list--dense': this.dense,
        'mdc-list--avatar-list': this.avatarList,
        'mdc-list--two-line': this.twoLine,
        'mdc-list--bordered': this.bordered,
        'mdc-list--non-interactive': !this.interactive
      };
    }
  }
};

var mdcListItem = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail")], 2) : _vm._e(), _vm._v(" "), _vm.hasSecondary ? _c('span', { staticClass: "mdc-list-item__text" }, [_vm._t("default"), _vm._v(" "), _c('span', { staticClass: "mdc-list-item__secondary-text" }, [_vm._t("secondary")], 2)], 2) : _vm._t("default"), _vm._v(" "), _vm.hasEndDetail ? _c('span', { staticClass: "mdc-list-item__meta" }, [_vm._t("end-detail")], 2) : _vm._e()], 2);
  }, staticRenderFns: [],
  name: 'mdc-list-item',
  inject: ['mdcList'],
  props: {
    selected: Boolean,
    activated: Boolean
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    itemClasses: function itemClasses() {
      return {
        'mdc-list-item--selected': this.selected,
        'mdc-list-item--activated': this.activated
      };
    },
    isInteractive: function isInteractive() {
      return this.mdcList && this.mdcList.interactive;
    },
    hasSecondary: function hasSecondary() {
      return this.$slots['secondary'] && this.mdcList && this.mdcList.twoLine;
    },
    hasEndDetail: function hasEndDetail() {
      return !!this.$slots['end-detail'];
    },
    hasStartDetail: function hasStartDetail() {
      return !!this.$slots['start-detail'];
    }
  },
  watch: {
    isInteractive: function isInteractive(value) {
      if (value) {
        this.addRipple();
      } else {
        this.removeRipple();
      }
    }
  },
  mounted: function mounted() {
    this.isInteractive && this.addRipple();
  },
  beforeDestroy: function beforeDestroy() {
    this.removeRipple();
  },

  methods: {
    addRipple: function addRipple() {
      if (!this.ripple) {
        var ripple = new RippleBase(this);
        ripple.init();
        this.ripple = ripple;
      }
    },
    removeRipple: function removeRipple() {
      if (this.ripple) {
        var ripple = this.ripple;
        this.ripple = null;
        ripple.destroy();
      }
    }
  }

};

var mdcListDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-list-divider", class: _vm.classes, attrs: { "role": "separator" } });
  }, staticRenderFns: [],
  name: 'mdc-list-divider',
  props: {
    inset: Boolean,
    padded: Boolean
  },
  computed: {
    classes: function classes() {
      return {
        'mdc-list-divider--inset': this.inset,
        'mdc-list-divider--padded': this.padded
      };
    }
  }
};

var mdcListGroup = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-list-group" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-list-group'
};

var mdcListGroupHeader = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h3', { staticClass: "mdc-list-group-header mdc-list-group__subheader" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-list-group-header'
};

var mdcListGroupDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-group-divider mdc-list-divider" });
  }, staticRenderFns: [],
  name: 'mdc-list-group-divider'
};

var VueMDCList = BasePlugin({
  mdcList: mdcList,
  mdcListItem: mdcListItem,
  mdcListDivider: mdcListDivider,
  mdcListGroup: mdcListGroup,
  mdcListGroupHeader: mdcListGroupHeader,
  mdcListGroupDivider: mdcListGroupDivider
});

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Menu. Provides an interface for managing
 * - classes
 * - dom
 * - focus
 * - position
 * - dimensions
 * - event handlers
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCMenuAdapter = function () {
  function MDCMenuAdapter() {
    classCallCheck(this, MDCMenuAdapter);
  }

  createClass(MDCMenuAdapter, [{
    key: "addClass",

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /** @return {boolean} */

  }, {
    key: "hasNecessaryDom",
    value: function hasNecessaryDom() {}

    /**
     * @param {EventTarget} target
     * @param {string} attributeName
     * @return {string}
     */

  }, {
    key: "getAttributeForEventTarget",
    value: function getAttributeForEventTarget(target, attributeName) {}

    /** @return {{ width: number, height: number }} */

  }, {
    key: "getInnerDimensions",
    value: function getInnerDimensions() {}

    /** @return {boolean} */

  }, {
    key: "hasAnchor",
    value: function hasAnchor() {}

    /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

  }, {
    key: "getAnchorDimensions",
    value: function getAnchorDimensions() {}

    /** @return {{ width: number, height: number }} */

  }, {
    key: "getWindowDimensions",
    value: function getWindowDimensions() {}

    /** @return {number} */

  }, {
    key: "getNumberOfItems",
    value: function getNumberOfItems() {}

    /**
     * @param {string} type
     * @param {function(!Event)} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(type, handler) {}

    /**
     * @param {string} type
     * @param {function(!Event)} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}

    /** @param {function(!Event)} handler */

  }, {
    key: "registerBodyClickHandler",
    value: function registerBodyClickHandler(handler) {}

    /** @param {function(!Event)} handler */

  }, {
    key: "deregisterBodyClickHandler",
    value: function deregisterBodyClickHandler(handler) {}

    /**
     * @param {EventTarget} target
     * @return {number}
     */

  }, {
    key: "getIndexForEventTarget",
    value: function getIndexForEventTarget(target) {}

    /** @param {{index: number}} evtData */

  }, {
    key: "notifySelected",
    value: function notifySelected(evtData) {}
  }, {
    key: "notifyCancel",
    value: function notifyCancel() {}
  }, {
    key: "saveFocus",
    value: function saveFocus() {}
  }, {
    key: "restoreFocus",
    value: function restoreFocus() {}

    /** @return {boolean} */

  }, {
    key: "isFocused",
    value: function isFocused() {}
  }, {
    key: "focus",
    value: function focus() {}

    /** @return {number} */

  }, {
    key: "getFocusedItemIndex",
    value: function getFocusedItemIndex() /* number */{}

    /** @param {number} index */

  }, {
    key: "focusItemAtIndex",
    value: function focusItemAtIndex(index) {}

    /** @return {boolean} */

  }, {
    key: "isRtl",
    value: function isRtl() {}

    /** @param {string} origin */

  }, {
    key: "setTransformOrigin",
    value: function setTransformOrigin(origin) {}

    /** @param {{
    *   top: (string|undefined),
    *   right: (string|undefined),
    *   bottom: (string|undefined),
    *   left: (string|undefined)
    * }} position */

  }, {
    key: "setPosition",
    value: function setPosition(position) {}

    /** @param {string} height */

  }, {
    key: "setMaxHeight",
    value: function setMaxHeight(height) {}

    /**
     * @param {number} index
     * @param {string} attr
     * @param {string} value
     */

  }, {
    key: "setAttrForOptionAtIndex",
    value: function setAttrForOptionAtIndex(index, attr, value) {}

    /**
     * @param {number} index
     * @param {string} attr
     */

  }, {
    key: "rmAttrForOptionAtIndex",
    value: function rmAttrForOptionAtIndex(index, attr) {}

    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "addClassForOptionAtIndex",
    value: function addClassForOptionAtIndex(index, className) {}

    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "rmClassForOptionAtIndex",
    value: function rmClassForOptionAtIndex(index, className) {}
  }]);
  return MDCMenuAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$8 = {
  ROOT: 'mdc-menu',
  OPEN: 'mdc-menu--open',
  ANIMATING_OPEN: 'mdc-menu--animating-open',
  ANIMATING_CLOSED: 'mdc-menu--animating-closed',
  SELECTED_LIST_ITEM: 'mdc-list-item--selected'
};

/** @enum {string} */
var strings$11 = {
  ITEMS_SELECTOR: '.mdc-menu__items',
  SELECTED_EVENT: 'MDCMenu:selected',
  CANCEL_EVENT: 'MDCMenu:cancel',
  ARIA_DISABLED_ATTR: 'aria-disabled'
};

/** @enum {number} */
var numbers$2 = {
  // Amount of time to wait before triggering a selected event on the menu. Note that this time
  // will most likely be bumped up once interactive lists are supported to allow for the ripple to
  // animate before closing the menu
  SELECTED_TRIGGER_DELAY: 50,
  // Total duration of menu open animation.
  TRANSITION_OPEN_DURATION: 120,
  // Total duration of menu close animation.
  TRANSITION_CLOSE_DURATION: 75,
  // Margin left to the edge of the viewport when menu is at maximum possible height.
  MARGIN_TO_EDGE: 32,
  // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
  ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
  // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
  OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
};

/**
 * Enum for bits in the {@see Corner) bitmap.
 * @enum {number}
 */
var CornerBit = {
  BOTTOM: 1,
  CENTER: 2,
  RIGHT: 4,
  FLIP_RTL: 8
};

/**
 * Enum for representing an element corner for positioning the menu.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 *
 * @enum {number}
 */
var Corner = {
  TOP_LEFT: 0,
  TOP_RIGHT: CornerBit.RIGHT,
  BOTTOM_LEFT: CornerBit.BOTTOM,
  BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
  TOP_START: CornerBit.FLIP_RTL,
  TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
  BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
  BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @typedef {{
 *   top: number,
 *   right: number,
 *   bottom: number,
 *   left: number
 * }}
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCFoundation<!MDCMenuAdapter>}
 */

var MDCMenuFoundation = function (_MDCFoundation) {
  inherits(MDCMenuFoundation, _MDCFoundation);
  createClass(MDCMenuFoundation, null, [{
    key: 'cssClasses',

    /** @return enum{cssClasses} */
    get: function get$$1() {
      return cssClasses$8;
    }

    /** @return enum{strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$11;
    }

    /** @return enum{numbers} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$2;
    }

    /** @return enum{number} */

  }, {
    key: 'Corner',
    get: function get$$1() {
      return Corner;
    }

    /**
     * {@see MDCMenuAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCMenuAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCMenuAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {
            return false;
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return false;
          },
          getAttributeForEventTarget: function getAttributeForEventTarget() {},
          getInnerDimensions: function getInnerDimensions() {
            return {};
          },
          hasAnchor: function hasAnchor() {
            return false;
          },
          getAnchorDimensions: function getAnchorDimensions() {
            return {};
          },
          getWindowDimensions: function getWindowDimensions() {
            return {};
          },
          getNumberOfItems: function getNumberOfItems() {
            return 0;
          },
          registerInteractionHandler: function registerInteractionHandler() {},
          deregisterInteractionHandler: function deregisterInteractionHandler() {},
          registerBodyClickHandler: function registerBodyClickHandler() {},
          deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
          getIndexForEventTarget: function getIndexForEventTarget() {
            return 0;
          },
          notifySelected: function notifySelected() {},
          notifyCancel: function notifyCancel() {},
          saveFocus: function saveFocus() {},
          restoreFocus: function restoreFocus() {},
          isFocused: function isFocused() {
            return false;
          },
          focus: function focus() {},
          getFocusedItemIndex: function getFocusedItemIndex() {
            return -1;
          },
          focusItemAtIndex: function focusItemAtIndex() {},
          isRtl: function isRtl() {
            return false;
          },
          setTransformOrigin: function setTransformOrigin() {},
          setPosition: function setPosition() {},
          setMaxHeight: function setMaxHeight() {},
          setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
          rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
          addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
          rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
        }
      );
    }

    /** @param {!MDCMenuAdapter} adapter */

  }]);

  function MDCMenuFoundation(adapter) {
    classCallCheck(this, MDCMenuFoundation);

    /** @private {function(!Event)} */
    var _this = possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, _extends(MDCMenuFoundation.defaultAdapter, adapter)));

    _this.clickHandler_ = function (evt) {
      return _this.handlePossibleSelected_(evt);
    };
    /** @private {function(!Event)} */
    _this.keydownHandler_ = function (evt) {
      return _this.handleKeyboardDown_(evt);
    };
    /** @private {function(!Event)} */
    _this.keyupHandler_ = function (evt) {
      return _this.handleKeyboardUp_(evt);
    };
    /** @private {function(!Event)} */
    _this.documentClickHandler_ = function (evt) {
      return _this.handleDocumentClick_(evt);
    };
    /** @private {boolean} */
    _this.isOpen_ = false;
    /** @private {number} */
    _this.openAnimationEndTimerId_ = 0;
    /** @private {number} */
    _this.closeAnimationEndTimerId_ = 0;
    /** @private {number} */
    _this.selectedTriggerTimerId_ = 0;
    /** @private {number} */
    _this.animationRequestId_ = 0;
    /** @private {!{ width: number, height: number }} */
    _this.dimensions_;
    /** @private {number} */
    _this.itemHeight_;
    /** @private {Corner} */
    _this.anchorCorner_ = Corner.TOP_START;
    /** @private {AnchorMargin} */
    _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
    /** @private {?AutoLayoutMeasurements} */
    _this.measures_ = null;
    /** @private {number} */
    _this.selectedIndex_ = -1;
    /** @private {boolean} */
    _this.rememberSelection_ = false;
    /** @private {boolean} */
    _this.quickOpen_ = false;

    // A keyup event on the menu needs to have a corresponding keydown
    // event on the menu. If the user opens the menu with a keydown event on a
    // button, the menu will only get the key up event causing buggy behavior with selected elements.
    /** @private {boolean} */
    _this.keyDownWithinMenu_ = false;
    return _this;
  }

  createClass(MDCMenuFoundation, [{
    key: 'init',
    value: function init() {
      var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
          ROOT = _MDCMenuFoundation$cs.ROOT,
          OPEN = _MDCMenuFoundation$cs.OPEN;


      if (!this.adapter_.hasClass(ROOT)) {
        throw new Error(ROOT + ' class required in root element.');
      }

      if (!this.adapter_.hasNecessaryDom()) {
        throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
      }

      if (this.adapter_.hasClass(OPEN)) {
        this.isOpen_ = true;
      }

      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      clearTimeout(this.selectedTriggerTimerId_);
      clearTimeout(this.openAnimationEndTimerId_);
      clearTimeout(this.closeAnimationEndTimerId_);
      // Cancel any currently running animations.
      cancelAnimationFrame(this.animationRequestId_);
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
    }

    /**
     * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
     */

  }, {
    key: 'setAnchorCorner',
    value: function setAnchorCorner(corner) {
      this.anchorCorner_ = corner;
    }

    /**
     * @param {!AnchorMargin} margin 4-plet of margins from anchor.
     */

  }, {
    key: 'setAnchorMargin',
    value: function setAnchorMargin(margin) {
      this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
      this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
      this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
      this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
    }

    /** @param {boolean} rememberSelection */

  }, {
    key: 'setRememberSelection',
    value: function setRememberSelection(rememberSelection) {
      this.rememberSelection_ = rememberSelection;
      this.setSelectedIndex(-1);
    }

    /** @param {boolean} quickOpen */

  }, {
    key: 'setQuickOpen',
    value: function setQuickOpen(quickOpen) {
      this.quickOpen_ = quickOpen;
    }

    /**
     * @param {?number} focusIndex
     * @private
     */

  }, {
    key: 'focusOnOpen_',
    value: function focusOnOpen_(focusIndex) {
      if (focusIndex === null) {
        // If this instance of MDCMenu remembers selections, and the user has
        // made a selection, then focus the last selected item
        if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
          this.adapter_.focusItemAtIndex(this.selectedIndex_);
          return;
        }

        this.adapter_.focus();
        // If that doesn't work, focus first item instead.
        if (!this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(0);
        }
      } else {
        this.adapter_.focusItemAtIndex(focusIndex);
      }
    }

    /**
     * Handle clicks and cancel the menu if not a child list-item
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handleDocumentClick_',
    value: function handleDocumentClick_(evt) {
      var el = evt.target;

      while (el && el !== document.documentElement) {
        if (this.adapter_.getIndexForEventTarget(el) !== -1) {
          return;
        }
        el = el.parentNode;
      }

      this.adapter_.notifyCancel();
      this.close(evt);
    }
  }, {
    key: 'handleKeyboardDown_',


    /**
     * Handle keys that we want to repeat on hold (tab and arrows).
     * @param {!Event} evt
     * @return {boolean}
     * @private
     */
    value: function handleKeyboardDown_(evt) {
      // Do nothing if Alt, Ctrl or Meta are pressed.
      if (evt.altKey || evt.ctrlKey || evt.metaKey) {
        return true;
      }

      var keyCode = evt.keyCode,
          key = evt.key,
          shiftKey = evt.shiftKey;

      var isTab = key === 'Tab' || keyCode === 9;
      var isArrowUp = key === 'ArrowUp' || keyCode === 38;
      var isArrowDown = key === 'ArrowDown' || keyCode === 40;
      var isSpace = key === 'Space' || keyCode === 32;
      var isEnter = key === 'Enter' || keyCode === 13;
      // The menu needs to know if the keydown event was triggered on the menu
      this.keyDownWithinMenu_ = isEnter || isSpace;

      var focusedItemIndex = this.adapter_.getFocusedItemIndex();
      var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

      if (shiftKey && isTab && focusedItemIndex === 0) {
        this.adapter_.focusItemAtIndex(lastItemIndex);
        evt.preventDefault();
        return false;
      }

      if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
        this.adapter_.focusItemAtIndex(0);
        evt.preventDefault();
        return false;
      }

      // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling
      if (isArrowUp || isArrowDown || isSpace) {
        evt.preventDefault();
      }

      if (isArrowUp) {
        if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(lastItemIndex);
        } else {
          this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
        }
      } else if (isArrowDown) {
        if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(0);
        } else {
          this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
        }
      }

      return true;
    }

    /**
     * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
     * @param {!Event} evt
     * @return {boolean}
     * @private
     */

  }, {
    key: 'handleKeyboardUp_',
    value: function handleKeyboardUp_(evt) {
      // Do nothing if Alt, Ctrl or Meta are pressed.
      if (evt.altKey || evt.ctrlKey || evt.metaKey) {
        return true;
      }

      var keyCode = evt.keyCode,
          key = evt.key;

      var isEnter = key === 'Enter' || keyCode === 13;
      var isSpace = key === 'Space' || keyCode === 32;
      var isEscape = key === 'Escape' || keyCode === 27;

      if (isEnter || isSpace) {
        // If the keydown event didn't occur on the menu, then it should
        // disregard the possible selected event.
        if (this.keyDownWithinMenu_) {
          this.handlePossibleSelected_(evt);
        }
        this.keyDownWithinMenu_ = false;
      }

      if (isEscape) {
        this.adapter_.notifyCancel();
        this.close();
      }

      return true;
    }

    /**
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handlePossibleSelected_',
    value: function handlePossibleSelected_(evt) {
      var _this2 = this;

      if (this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true') {
        return;
      }
      var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);
      if (targetIndex < 0) {
        return;
      }
      // Debounce multiple selections
      if (this.selectedTriggerTimerId_) {
        return;
      }
      this.selectedTriggerTimerId_ = setTimeout(function () {
        _this2.selectedTriggerTimerId_ = 0;
        _this2.close();
        if (_this2.rememberSelection_) {
          _this2.setSelectedIndex(targetIndex);
        }
        _this2.adapter_.notifySelected({ index: targetIndex });
      }, numbers$2.SELECTED_TRIGGER_DELAY);
    }

    /**
     * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
     */

  }, {
    key: 'getAutoLayoutMeasurements_',
    value: function getAutoLayoutMeasurements_() {
      var anchorRect = this.adapter_.getAnchorDimensions();
      var viewport = this.adapter_.getWindowDimensions();

      return {
        viewport: viewport,
        viewportDistance: {
          top: anchorRect.top,
          right: viewport.width - anchorRect.right,
          left: anchorRect.left,
          bottom: viewport.height - anchorRect.bottom
        },
        anchorHeight: anchorRect.height,
        anchorWidth: anchorRect.width,
        menuHeight: this.dimensions_.height,
        menuWidth: this.dimensions_.width
      };
    }

    /**
     * Computes the corner of the anchor from which to animate and position the menu.
     * @return {Corner}
     * @private
     */

  }, {
    key: 'getOriginCorner_',
    value: function getOriginCorner_() {
      // Defaults: open from the top left.
      var corner = Corner.TOP_LEFT;

      var _measures_ = this.measures_,
          viewportDistance = _measures_.viewportDistance,
          anchorHeight = _measures_.anchorHeight,
          anchorWidth = _measures_.anchorWidth,
          menuHeight = _measures_.menuHeight,
          menuWidth = _measures_.menuWidth;

      var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
      var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
      var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;

      var topOverflow = menuHeight - availableTop;
      var bottomOverflow = menuHeight - availableBottom;
      if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
        corner |= CornerBit.BOTTOM;
      }

      var isRtl = this.adapter_.isRtl();
      var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
      var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
      var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
      var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
      var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;

      var leftOverflow = menuWidth - availableLeft;
      var rightOverflow = menuWidth - availableRight;

      if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
        corner |= CornerBit.RIGHT;
      }

      return corner;
    }

    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
     * @private
     */

  }, {
    key: 'getHorizontalOriginOffset_',
    value: function getHorizontalOriginOffset_(corner) {
      var anchorWidth = this.measures_.anchorWidth;

      var isRightAligned = Boolean(corner & CornerBit.RIGHT);
      var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
      var x = 0;
      if (isRightAligned) {
        var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
        x = rightOffset;
      } else {
        var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
        x = leftOffset;
      }
      return x;
    }

    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
     * @private
     */

  }, {
    key: 'getVerticalOriginOffset_',
    value: function getVerticalOriginOffset_(corner) {
      var _measures_2 = this.measures_,
          viewport = _measures_2.viewport,
          viewportDistance = _measures_2.viewportDistance,
          anchorHeight = _measures_2.anchorHeight,
          menuHeight = _measures_2.menuHeight;

      var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
      var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;

      var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
      var canOverlapVertically = !avoidVerticalOverlap;
      var y = 0;

      if (isBottomAligned) {
        y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
        // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
        // anchor corner. Bottom margin is ignored in such cases.
        if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
          y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
        }
      } else {
        y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
        // adjust for when menu can overlap anchor, but too tall to be aligned to top
        // anchor corners. Top margin is ignored in that case.
        if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
          y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
        }
      }
      return y;
    }

    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
     * @private
     */

  }, {
    key: 'getMenuMaxHeight_',
    value: function getMenuMaxHeight_(corner) {
      var maxHeight = 0;
      var viewportDistance = this.measures_.viewportDistance;

      var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);

      // When maximum height is not specified, it is handled from css.
      if (this.anchorCorner_ & CornerBit.BOTTOM) {
        if (isBottomAligned) {
          maxHeight = viewportDistance.top + this.anchorMargin_.top;
        } else {
          maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
        }
      }

      return maxHeight;
    }

    /** @private */

  }, {
    key: 'autoPosition_',
    value: function autoPosition_() {
      var _position;

      if (!this.adapter_.hasAnchor()) {
        return;
      }

      // Compute measurements for autoposition methods reuse.
      this.measures_ = this.getAutoLayoutMeasurements_();

      var corner = this.getOriginCorner_();
      var maxMenuHeight = this.getMenuMaxHeight_(corner);
      var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
      var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
      var horizontalOffset = this.getHorizontalOriginOffset_(corner);
      var verticalOffset = this.getVerticalOriginOffset_(corner);
      var position = (_position = {}, defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
      var _measures_3 = this.measures_,
          anchorWidth = _measures_3.anchorWidth,
          menuHeight = _measures_3.menuHeight,
          menuWidth = _measures_3.menuWidth;
      // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

      if (anchorWidth / menuWidth > numbers$2.ANCHOR_TO_MENU_WIDTH_RATIO) {
        horizontalAlignment = 'center';
      }

      // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
      // scale animation is "anchored" on the anchor.
      if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers$2.OFFSET_TO_MENU_HEIGHT_RATIO) {
        var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
        var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
        verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
      }

      this.adapter_.setTransformOrigin(horizontalAlignment + ' ' + verticalAlignment);
      this.adapter_.setPosition(position);
      this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');

      // Clear measures after positioning is complete.
      this.measures_ = null;
    }

    /**
     * Open the menu.
     * @param {{focusIndex: ?number}=} options
     */

  }, {
    key: 'open',
    value: function open() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$focusIndex = _ref.focusIndex,
          focusIndex = _ref$focusIndex === undefined ? null : _ref$focusIndex;

      this.adapter_.saveFocus();

      if (!this.quickOpen_) {
        this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
      }

      this.animationRequestId_ = requestAnimationFrame(function () {
        _this3.dimensions_ = _this3.adapter_.getInnerDimensions();
        _this3.autoPosition_();
        _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);
        _this3.focusOnOpen_(focusIndex);
        _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);
        if (!_this3.quickOpen_) {
          _this3.openAnimationEndTimerId_ = setTimeout(function () {
            _this3.openAnimationEndTimerId_ = 0;
            _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
          }, numbers$2.TRANSITION_OPEN_DURATION);
        }
      });
      this.isOpen_ = true;
    }

    /**
     * Closes the menu.
     * @param {Event=} evt
     */

  }, {
    key: 'close',
    value: function close() {
      var _this4 = this;

      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true' : false;

      if (targetIsDisabled) {
        return;
      }

      this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

      if (!this.quickOpen_) {
        this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
      }

      requestAnimationFrame(function () {
        _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);
        if (!_this4.quickOpen_) {
          _this4.closeAnimationEndTimerId_ = setTimeout(function () {
            _this4.closeAnimationEndTimerId_ = 0;
            _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
          }, numbers$2.TRANSITION_CLOSE_DURATION);
        }
      });
      this.isOpen_ = false;
      this.adapter_.restoreFocus();
    }

    /** @return {boolean} */

  }, {
    key: 'isOpen',
    value: function isOpen() {
      return this.isOpen_;
    }

    /** @return {number} */

  }, {
    key: 'getSelectedIndex',
    value: function getSelectedIndex() {
      return this.selectedIndex_;
    }

    /**
     * @param {number} index Index of the item to set as selected.
     */

  }, {
    key: 'setSelectedIndex',
    value: function setSelectedIndex(index) {
      if (index === this.selectedIndex_) {
        return;
      }

      var prevSelectedIndex = this.selectedIndex_;
      if (prevSelectedIndex >= 0) {
        this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
        this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses$8.SELECTED_LIST_ITEM);
      }

      this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;
      if (this.selectedIndex_ >= 0) {
        this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
        this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses$8.SELECTED_LIST_ITEM);
      }
    }
  }]);
  return MDCMenuFoundation;
}(MDCFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @type {string|undefined} */
var storedTransformPropertyName_$1 = void 0;

/**
 * Returns the name of the correct transform property to use on the current browser.
 * @param {!Window} globalObj
 * @param {boolean=} forceRefresh
 * @return {string}
 */
function getTransformPropertyName$1(globalObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
    storedTransformPropertyName_$1 = transformPropertyName;
  }

  return storedTransformPropertyName_$1;
}

var mdcMenu = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-menu mdc-simple-menu", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "-1" } }, [_c('ul', { ref: "items", staticClass: "mdc-simple-menu__items mdc-list", attrs: { "role": "menu", "aria-hidden": "true" } }, [_vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-menu',
  props: {
    'open-from-top-left': Boolean,
    'open-from-top-right': Boolean,
    'open-from-bottom-left': Boolean,
    'open-from-bottom-right': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-simple-menu--open-from-top-left': this.openFromTopLeft,
        'mdc-simple-menu--open-from-top-right': this.openFromTopRight,
        'mdc-simple-menu--open-from-bottom-left': this.openFromBottomLeft,
        'mdc-simple-menu--open-from-bottom-right': this.openFromBottomRight
      },
      styles: {},
      items: []
    };
  },

  methods: {
    show: function show(options) {
      this.foundation.open(options);
    },
    hide: function hide() {
      this.foundation.close();
    },
    isOpen: function isOpen() {
      return this.foundation ? this.foundation.isOpen() : false;
    }
  },
  mounted: function mounted() {
    var _this = this;

    var refreshItems = function refreshItems() {
      _this.items = [].slice.call(_this.$refs.items.querySelectorAll('.mdc-list-item[role]'));
      _this.$emit('update');
    };
    this.slotObserver = new MutationObserver(function () {
      return refreshItems();
    });
    this.slotObserver.observe(this.$el, { childList: true, subtree: true });

    this._previousFocus = undefined;

    this.foundation = new MDCMenuFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      hasClass: function hasClass(className) {
        return _this.$refs.root.classList.contains(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return Boolean(_this.$refs.items);
      },
      getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
        return target.getAttribute(attributeName);
      },
      getInnerDimensions: function getInnerDimensions() {
        return {
          width: _this.$refs.items.offsetWidth,
          height: _this.$refs.items.offsetHeight
        };
      },
      hasAnchor: function hasAnchor() {
        return _this.$refs.root.parentElement && _this.$refs.root.parentElement.classList.contains('mdc-menu-anchor');
      },
      getAnchorDimensions: function getAnchorDimensions() {
        return _this.$refs.root.parentElement.getBoundingClientRect();
      },
      getWindowDimensions: function getWindowDimensions() {
        return {
          width: window.innerWidth,
          height: window.innerHeight
        };
      },
      getNumberOfItems: function getNumberOfItems() {
        return _this.items.length;
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$refs.root.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$refs.root.removeEventListener(type, handler);
      },
      registerBodyClickHandler: function registerBodyClickHandler(handler) {
        return document.body.addEventListener('click', handler);
      },
      deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
        return document.body.removeEventListener('click', handler);
      },
      getIndexForEventTarget: function getIndexForEventTarget(target) {
        return _this.items.indexOf(target);
      },
      notifySelected: function notifySelected(evtData) {
        var evt = {
          index: evtData.index,
          item: _this.items[evtData.index]
        };
        _this.$emit('select', evt);
        emitCustomEvent(_this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, evt);
      },
      notifyCancel: function notifyCancel() {
        _this.$emit('cancel');
        emitCustomEvent(_this.$el, MDCMenuFoundation.strings.CANCEL_EVENT, {});
      },
      saveFocus: function saveFocus() {
        _this._previousFocus = document.activeElement;
      },
      restoreFocus: function restoreFocus() {
        if (_this._previousFocus) {
          _this._previousFocus.focus();
        }
      },
      isFocused: function isFocused() {
        return document.activeElement === _this.$refs.root;
      },
      focus: function focus() {
        return _this.$refs.root.focus();
      },
      getFocusedItemIndex: function getFocusedItemIndex() {
        return _this.items.indexOf(document.activeElement);
      },
      focusItemAtIndex: function focusItemAtIndex(index) {
        return _this.items[index].focus();
      },
      isRtl: function isRtl() {
        return getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
      },
      setTransformOrigin: function setTransformOrigin(origin) {
        _this.$set(_this.styles, getTransformPropertyName$1(window) + '-origin', origin);
      },
      setPosition: function setPosition(position) {
        _this.$set(_this.styles, 'left', position.left);
        _this.$set(_this.styles, 'right', position.right);
        _this.$set(_this.styles, 'top', position.top);
        _this.$set(_this.styles, 'bottom', position.bottom);
      },
      setMaxHeight: function setMaxHeight(height) {
        _this.$set(_this.styles, 'max-height', height);
      },
      setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
        _this.items[index].setAttribute(attr, value);
      },
      rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
        _this.items[index].removeAttribute(attr);
      },
      addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
        _this.items[index].classList.add(className);
      },
      rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
        _this.items[index].classList.remove(className);
      }
    });

    refreshItems();
    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this._previousFocus = null;
    this.slotObserver.disconnect();
    this.foundation.destroy();
  }
};

var mdcMenuItem = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-item mdc-list-item", attrs: { "role": "menuitem", "tabindex": _vm.disabled ? '-1' : '0', "aria-disabled": _vm.disabled } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-menu-item',
  props: {
    disabled: Boolean
  }
};

var mdcMenuDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-divider mdc-list-divider", attrs: { "role": "separator" } });
  }, staticRenderFns: [],
  name: 'mdc-menu-divider'
};

var mdcMenuAnchor = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-menu-anchor" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-menu-anchor'
};

var VueMDCMenu = BasePlugin({
  mdcMenu: mdcMenu,
  mdcMenuItem: mdcMenuItem,
  mdcMenuDivider: mdcMenuDivider,
  mdcMenuAnchor: mdcMenuAnchor
});

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Radio. Provides an interface for managing
 * - classes
 * - dom
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */

var MDCRadioAdapter = function () {
  function MDCRadioAdapter() {
    classCallCheck(this, MDCRadioAdapter);
  }

  createClass(MDCRadioAdapter, [{
    key: 'addClass',

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: 'removeClass',
    value: function removeClass(className) {}

    /** @return {!MDCSelectionControlState} */

  }, {
    key: 'getNativeControl',
    value: function getNativeControl() {}
  }]);
  return MDCRadioAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$12 = {
  NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
};

/** @enum {string} */
var cssClasses$9 = {
  ROOT: 'mdc-radio',
  DISABLED: 'mdc-radio--disabled'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint-enable no-unused-vars */
/**
 * @extends {MDCFoundation<!MDCRadioAdapter>}
 */

var MDCRadioFoundation = function (_MDCFoundation) {
  inherits(MDCRadioFoundation, _MDCFoundation);

  function MDCRadioFoundation() {
    classCallCheck(this, MDCRadioFoundation);
    return possibleConstructorReturn(this, (MDCRadioFoundation.__proto__ || Object.getPrototypeOf(MDCRadioFoundation)).apply(this, arguments));
  }

  createClass(MDCRadioFoundation, [{
    key: 'isChecked',


    /** @return {boolean} */
    value: function isChecked() {
      return this.getNativeControl_().checked;
    }

    /** @param {boolean} checked */

  }, {
    key: 'setChecked',
    value: function setChecked(checked) {
      this.getNativeControl_().checked = checked;
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.getNativeControl_().disabled;
    }

    /** @param {boolean} disabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;

      this.getNativeControl_().disabled = disabled;
      if (disabled) {
        this.adapter_.addClass(DISABLED);
      } else {
        this.adapter_.removeClass(DISABLED);
      }
    }

    /** @return {?string} */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.getNativeControl_().value;
    }

    /** @param {?string} value */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.getNativeControl_().value = value;
    }

    /**
     * @return {!MDCSelectionControlState}
     * @private
     */

  }, {
    key: 'getNativeControl_',
    value: function getNativeControl_() {
      return this.adapter_.getNativeControl() || {
        checked: false,
        disabled: false,
        value: null
      };
    }
  }], [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$9;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$12;
    }

    /** @return {!MDCRadioAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCRadioAdapter} */{
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{}
        }
      );
    }
  }]);
  return MDCRadioFoundation;
}(MDCFoundation);

var mdcRadio = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-radio-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-radio", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-radio__native-control", attrs: { "type": "radio", "id": _vm._uid, "name": _vm.name }, on: { "change": _vm.sync } }), _vm._v(" "), _c('div', { ref: "label", staticClass: "mdc-radio__background" }, [_c('div', { staticClass: "mdc-radio__outer-circle" }), _vm._v(" "), _c('div', { staticClass: "mdc-radio__inner-circle" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-radio',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'picked',
    event: 'change'
  },
  props: {
    'name': { type: String, required: true },
    'value': String,
    'picked': String,
    'checked': Boolean,
    'label': String,
    'align-end': Boolean,
    'disabled': Boolean
  },
  data: function data() {
    return {
      classes: {},
      styles: {},
      formFieldClasses: {
        'mdc-form-field': this.label,
        'mdc-form-field--align-end': this.label && this.alignEnd
      }
    };
  },
  mounted: function mounted() {
    var _this = this;

    // add foundation
    this.foundation = new MDCRadioFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      getNativeControl: function getNativeControl() {
        return _this.$refs.control;
      }
    });

    // add ripple
    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      },
      isSurfaceActive: function isSurfaceActive() {
        return false;
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$refs.control.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$refs.control.removeEventListener(evt, handler);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this.$refs.root.getBoundingClientRect();
      }
    });

    this.formField = new MDCFormFieldFoundation({
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        _this.$refs.label.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        _this.$refs.label.removeEventListener(type, handler);
      },
      activateInputRipple: function activateInputRipple() {
        _this.ripple && _this.ripple.activate();
      },
      deactivateInputRipple: function deactivateInputRipple() {
        _this.ripple && _this.ripple.deactivate();
      }
    });

    this.foundation.init();
    this.ripple.init();
    this.formField.init();

    this.foundation.setValue(this.value ? this.value : this.label);
    this.foundation.setDisabled(this.disabled);
    this.foundation.setChecked(this.checked || this.picked == this.foundation.getValue());

    // refresh model
    this.checked && this.sync();
  },
  beforeDestroy: function beforeDestroy() {
    this.formField.destroy();
    this.ripple.destroy();
    this.foundation.destroy();
  },

  watch: {
    disabled: function disabled(value) {
      this.foundation.setDisabled(value);
    }
  },
  methods: {
    isChecked: function isChecked() {
      return this.foundation.isChecked();
    },
    sync: function sync() {
      this.$emit('change', this.foundation.getValue());
    }
  }
};

var VueMDCRadio = BasePlugin({
  mdcRadio: mdcRadio
});

var MDCNativeSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('select', { directives: [{ name: "model", rawName: "v-model", value: _vm.selected, expression: "selected" }], ref: "root", staticClass: "mdc-select mdc-native-select", attrs: { "disabled": _vm.disabled }, on: { "change": [function ($event) {
          var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
            return o.selected;
          }).map(function (o) {
            var val = "_value" in o ? o._value : o.value;return val;
          });_vm.selected = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
        }, _vm.onChange] } }, [_vm.label ? _c('option', { attrs: { "disabled": "disabled", "value": "" } }, [_vm._v(_vm._s(_vm.label))]) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-native-select',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: [String, Array],
    disabled: Boolean,
    label: String
  },
  data: function data() {
    return {
      selected: this.value
    };
  },

  methods: {
    onChange: function onChange() {
      this.$emit('change', this.selected);
    }
  }
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var cssClasses$10 = {
  BOTTOM_LINE: 'mdc-select__bottom-line',
  BOTTOM_LINE_ACTIVE: 'mdc-select__bottom-line--active',
  BOX: 'mdc-select--box',
  DISABLED: 'mdc-select--disabled',
  OPEN: 'mdc-select--open',
  ROOT: 'mdc-select',
  SCROLL_LOCK: 'mdc-select-scroll-lock'
};

var strings$13 = {
  CHANGE_EVENT: 'MDCSelect:change',
  BOTTOM_LINE_SELECTOR: '.mdc-select__bottom-line',
  LABEL_SELECTOR: '.mdc-select__label',
  MENU_SELECTOR: '.mdc-select__menu',
  SURFACE_SELECTOR: '.mdc-select__surface',
  SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends MDCComponent<!MDCMenuFoundation>
 */

var MDCMenu = function (_MDCComponent) {
  inherits(MDCMenu, _MDCComponent);

  /** @param {...?} args */
  function MDCMenu() {
    var _ref;

    classCallCheck(this, MDCMenu);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @private {!Element} */
    var _this = possibleConstructorReturn(this, (_ref = MDCMenu.__proto__ || Object.getPrototypeOf(MDCMenu)).call.apply(_ref, [this].concat(args)));

    _this.previousFocus_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @return {!MDCMenu}
   */


  createClass(MDCMenu, [{
    key: 'show',


    /** @param {{focusIndex: ?number}=} options */
    value: function show() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$focusIndex = _ref2.focusIndex,
          focusIndex = _ref2$focusIndex === undefined ? null : _ref2$focusIndex;

      this.foundation_.open({ focusIndex: focusIndex });
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.foundation_.close();
    }

    /**
     * @param {Corner} corner Default anchor corner alignment of top-left
     *     menu corner.
     */

  }, {
    key: 'setAnchorCorner',
    value: function setAnchorCorner(corner) {
      this.foundation_.setAnchorCorner(corner);
    }

    /**
     * @param {AnchorMargin} margin
     */

  }, {
    key: 'setAnchorMargin',
    value: function setAnchorMargin(margin) {
      this.foundation_.setAnchorMargin(margin);
    }

    /**
     * Return the item container element inside the component.
     * @return {?Element}
     */

  }, {
    key: 'getOptionByIndex',


    /**
     * Return the item within the menu that is selected.
     * @param {number} index
     * @return {?Element}
     */
    value: function getOptionByIndex(index) {
      var items = this.items;

      if (index < items.length) {
        return this.items[index];
      } else {
        return null;
      }
    }

    /** @param {number} index */

  }, {
    key: 'getDefaultFoundation',


    /** @return {!MDCMenuFoundation} */
    value: function getDefaultFoundation() {
      var _this2 = this;

      return new MDCMenuFoundation({
        addClass: function addClass(className) {
          return _this2.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return _this2.root_.classList.remove(className);
        },
        hasClass: function hasClass(className) {
          return _this2.root_.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return Boolean(_this2.itemsContainer_);
        },
        getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
          return target.getAttribute(attributeName);
        },
        getInnerDimensions: function getInnerDimensions() {
          var itemsContainer = _this2.itemsContainer_;

          return { width: itemsContainer.offsetWidth, height: itemsContainer.offsetHeight };
        },
        hasAnchor: function hasAnchor() {
          return _this2.root_.parentElement && _this2.root_.parentElement.classList.contains('mdc-menu-anchor');
        },
        getAnchorDimensions: function getAnchorDimensions() {
          return _this2.root_.parentElement.getBoundingClientRect();
        },
        getWindowDimensions: function getWindowDimensions() {
          return { width: window.innerWidth, height: window.innerHeight };
        },
        getNumberOfItems: function getNumberOfItems() {
          return _this2.items.length;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this2.root_.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this2.root_.removeEventListener(type, handler);
        },
        registerBodyClickHandler: function registerBodyClickHandler(handler) {
          return document.body.addEventListener('click', handler);
        },
        deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
          return document.body.removeEventListener('click', handler);
        },
        getIndexForEventTarget: function getIndexForEventTarget(target) {
          return _this2.items.indexOf(target);
        },
        notifySelected: function notifySelected(evtData) {
          return _this2.emit(MDCMenuFoundation.strings.SELECTED_EVENT, {
            index: evtData.index,
            item: _this2.items[evtData.index]
          });
        },
        notifyCancel: function notifyCancel() {
          return _this2.emit(MDCMenuFoundation.strings.CANCEL_EVENT, {});
        },
        saveFocus: function saveFocus() {
          _this2.previousFocus_ = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          if (_this2.previousFocus_) {
            _this2.previousFocus_.focus();
          }
        },
        isFocused: function isFocused() {
          return document.activeElement === _this2.root_;
        },
        focus: function focus() {
          return _this2.root_.focus();
        },
        getFocusedItemIndex: function getFocusedItemIndex() {
          return _this2.items.indexOf(document.activeElement);
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          return _this2.items[index].focus();
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this2.root_.style[getTransformPropertyName$1(window) + '-origin'] = origin;
        },
        setPosition: function setPosition(position) {
          _this2.root_.style.left = 'left' in position ? position.left : null;
          _this2.root_.style.right = 'right' in position ? position.right : null;
          _this2.root_.style.top = 'top' in position ? position.top : null;
          _this2.root_.style.bottom = 'bottom' in position ? position.bottom : null;
        },
        setMaxHeight: function setMaxHeight(height) {
          _this2.root_.style.maxHeight = height;
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          return _this2.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          return _this2.items[index].removeAttribute(attr);
        },
        addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
          return _this2.items[index].classList.add(className);
        },
        rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
          return _this2.items[index].classList.remove(className);
        }
      });
    }
  }, {
    key: 'open',


    /** @return {boolean} */
    get: function get$$1() {
      return this.foundation_.isOpen();
    }

    /** @param {boolean} value */
    ,
    set: function set$$1(value) {
      if (value) {
        this.foundation_.open();
      } else {
        this.foundation_.close();
      }
    }
  }, {
    key: 'itemsContainer_',
    get: function get$$1() {
      return this.root_.querySelector(MDCMenuFoundation.strings.ITEMS_SELECTOR);
    }

    /**
     * Return the items within the menu. Note that this only contains the set of elements within
     * the items container that are proper list items, and not supplemental / presentational DOM
     * elements.
     * @return {!Array<!Element>}
     */

  }, {
    key: 'items',
    get: function get$$1() {
      var itemsContainer = this.itemsContainer_;

      return [].slice.call(itemsContainer.querySelectorAll('.mdc-list-item[role]'));
    }
  }, {
    key: 'selectedItemIndex',
    set: function set$$1(index) {
      this.foundation_.setSelectedIndex(index);
    }

    /** @return {number} */
    ,
    get: function get$$1() {
      return this.foundation_.getSelectedIndex();
    }

    /** @param {!boolean} rememberSelection */

  }, {
    key: 'rememberSelection',
    set: function set$$1(rememberSelection) {
      this.foundation_.setRememberSelection(rememberSelection);
    }

    /** @param {boolean} quickOpen */

  }, {
    key: 'quickOpen',
    set: function set$$1(quickOpen) {
      this.foundation_.setQuickOpen(quickOpen);
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      return new MDCMenu(root);
    }
  }]);
  return MDCMenu;
}(MDCComponent);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var OPENER_KEYS = [{ key: 'ArrowUp', keyCode: 38, forType: 'keydown' }, { key: 'ArrowDown', keyCode: 40, forType: 'keydown' }, { key: 'Space', keyCode: 32, forType: 'keyup' }];

var MDCSelectFoundation = function (_MDCFoundation) {
  inherits(MDCSelectFoundation, _MDCFoundation);
  createClass(MDCSelectFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$10;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$13;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        floatLabel: function floatLabel() /* value: boolean */{},
        addClassToBottomLine: function addClassToBottomLine() /* className: string */{},
        removeClassFromBottomLine: function removeClassFromBottomLine() /* className: string */{},
        setBottomLineAttr: function setBottomLineAttr() /* attr: string, value: string */{},
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        setAttr: function setAttr() /* attr: string, value: string */{},
        rmAttr: function rmAttr() /* attr: string */{},
        computeBoundingRect: function computeBoundingRect() {
          return (/* {left: number, top: number} */{ left: 0, top: 0 }
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        focus: function focus() {},
        makeTabbable: function makeTabbable() {},
        makeUntabbable: function makeUntabbable() {},
        getComputedStyleValue: function getComputedStyleValue() {
          return (/* propertyName: string */ /* string */''
          );
        },
        setStyle: function setStyle() /* propertyName: string, value: string */{},
        create2dRenderingContext: function create2dRenderingContext() {
          return (/* {font: string, measureText: (string) => {width: number}} */{
              font: '',
              measureText: function measureText() {
                return { width: 0 };
              }
            }
          );
        },
        setMenuElStyle: function setMenuElStyle() /* propertyName: string, value: string */{},
        setMenuElAttr: function setMenuElAttr() /* attr: string, value: string */{},
        rmMenuElAttr: function rmMenuElAttr() /* attr: string */{},
        getMenuElOffsetHeight: function getMenuElOffsetHeight() {
          return (/* number */0
          );
        },
        openMenu: function openMenu() /* focusIndex: number */{},
        isMenuOpen: function isMenuOpen() {
          return (/* boolean */false
          );
        },
        setSelectedTextContent: function setSelectedTextContent() /* textContent: string */{},
        getNumberOfOptions: function getNumberOfOptions() {
          return (/* number */0
          );
        },
        getTextForOptionAtIndex: function getTextForOptionAtIndex() {
          return (/* index: number */ /* string */''
          );
        },
        getValueForOptionAtIndex: function getValueForOptionAtIndex() {
          return (/* index: number */ /* string */''
          );
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex() /* index: number, attr: string, value: string */{},
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() /* index: number, attr: string */{},
        getOffsetTopForOptionAtIndex: function getOffsetTopForOptionAtIndex() {
          return (/* index: number */ /* number */0
          );
        },
        registerMenuInteractionHandler: function registerMenuInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterMenuInteractionHandler: function deregisterMenuInteractionHandler() /* type: string, handler: EventListener */{},
        notifyChange: function notifyChange() {},
        getWindowInnerHeight: function getWindowInnerHeight() {
          return (/* number */0
          );
        }
      };
    }
  }]);

  function MDCSelectFoundation(adapter) {
    classCallCheck(this, MDCSelectFoundation);

    var _this = possibleConstructorReturn(this, (MDCSelectFoundation.__proto__ || Object.getPrototypeOf(MDCSelectFoundation)).call(this, _extends(MDCSelectFoundation.defaultAdapter, adapter)));

    _this.ctx_ = null;
    _this.selectedIndex_ = -1;
    _this.disabled_ = false;
    _this.isFocused_ = false;

    /** @private {number} */
    _this.animationRequestId_ = 0;

    _this.displayHandler_ = function (evt) {
      evt.preventDefault();
      if (!_this.adapter_.isMenuOpen()) {
        _this.open_();
      }
    };
    _this.displayViaKeyboardHandler_ = function (evt) {
      return _this.handleDisplayViaKeyboard_(evt);
    };
    _this.selectionHandler_ = function (_ref) {
      var detail = _ref.detail;
      var index = detail.index;


      if (index !== _this.selectedIndex_) {
        _this.setSelectedIndex(index);
        _this.adapter_.notifyChange();
      }
      _this.close_();
    };
    _this.cancelHandler_ = function () {
      _this.close_();
      if (_this.selectedIndex_ === -1) {
        _this.adapter_.floatLabel(false);
      }
    };
    return _this;
  }

  createClass(MDCSelectFoundation, [{
    key: 'init',
    value: function init() {
      this.ctx_ = this.adapter_.create2dRenderingContext();
      this.adapter_.registerInteractionHandler('click', this.displayHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.displayViaKeyboardHandler_);
      this.adapter_.registerInteractionHandler('keyup', this.displayViaKeyboardHandler_);
      this.adapter_.registerMenuInteractionHandler(MDCMenuFoundation.strings.SELECTED_EVENT, this.selectionHandler_);
      this.adapter_.registerMenuInteractionHandler(MDCMenuFoundation.strings.CANCEL_EVENT, this.cancelHandler_);
      this.resize();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      // Drop reference to context object to prevent potential leaks
      this.ctx_ = null;
      cancelAnimationFrame(this.animationRequestId_);
      this.adapter_.deregisterInteractionHandler('click', this.displayHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.displayViaKeyboardHandler_);
      this.adapter_.deregisterInteractionHandler('keyup', this.displayViaKeyboardHandler_);
      this.adapter_.deregisterMenuInteractionHandler(MDCMenuFoundation.strings.SELECTED_EVENT, this.selectionHandler_);
      this.adapter_.deregisterMenuInteractionHandler(MDCMenuFoundation.strings.CANCEL_EVENT, this.cancelHandler_);
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.selectedIndex_ >= 0 ? this.adapter_.getValueForOptionAtIndex(this.selectedIndex_) : '';
    }
  }, {
    key: 'getSelectedIndex',
    value: function getSelectedIndex() {
      return this.selectedIndex_;
    }
  }, {
    key: 'setSelectedIndex',
    value: function setSelectedIndex(index) {
      var prevSelectedIndex = this.selectedIndex_;
      if (prevSelectedIndex >= 0) {
        this.adapter_.rmAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected');
      }

      this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfOptions() ? index : -1;
      var selectedTextContent = '';
      if (this.selectedIndex_ >= 0) {
        selectedTextContent = this.adapter_.getTextForOptionAtIndex(this.selectedIndex_).trim();
        this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
      }
      this.adapter_.setSelectedTextContent(selectedTextContent);
    }
  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.disabled_;
    }
  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      var DISABLED = MDCSelectFoundation.cssClasses.DISABLED;

      this.disabled_ = disabled;
      if (this.disabled_) {
        this.adapter_.addClass(DISABLED);
        this.adapter_.setAttr('aria-disabled', 'true');
        this.adapter_.makeUntabbable();
      } else {
        this.adapter_.removeClass(DISABLED);
        this.adapter_.rmAttr('aria-disabled');
        this.adapter_.makeTabbable();
      }
    }
  }, {
    key: 'resize',
    value: function resize() {
      var font = this.adapter_.getComputedStyleValue('font');
      var letterSpacing = parseFloat(this.adapter_.getComputedStyleValue('letter-spacing'));

      if (font) {
        this.ctx_.font = font;
      } else {
        var primaryFontFamily = this.adapter_.getComputedStyleValue('font-family').split(',')[0];
        var fontSize = this.adapter_.getComputedStyleValue('font-size');
        this.ctx_.font = fontSize + ' ' + primaryFontFamily;
      }

      var maxTextLength = 0;

      for (var i = 0, l = this.adapter_.getNumberOfOptions(); i < l; i++) {
        var surfacePaddingRight = parseInt(this.adapter_.getComputedStyleValue('padding-right'), 10);
        var surfacePaddingLeft = parseInt(this.adapter_.getComputedStyleValue('padding-left'), 10);
        var selectBoxAddedPadding = surfacePaddingRight + surfacePaddingLeft;
        var txt = this.adapter_.getTextForOptionAtIndex(i).trim();

        var _ctx_$measureText = this.ctx_.measureText(txt),
            width = _ctx_$measureText.width;

        var addedSpace = letterSpacing * txt.length;

        maxTextLength = Math.max(maxTextLength, Math.ceil(width + addedSpace + selectBoxAddedPadding));
      }

      this.adapter_.setStyle('width', maxTextLength + 'px');
    }
  }, {
    key: 'open_',
    value: function open_() {
      var _this2 = this;

      this.disableScroll_();
      var OPEN = MDCSelectFoundation.cssClasses.OPEN;

      var focusIndex = this.selectedIndex_ < 0 ? 0 : this.selectedIndex_;

      this.setMenuStylesForOpenAtIndex_(focusIndex);
      this.adapter_.floatLabel(true);
      this.adapter_.addClassToBottomLine(cssClasses$10.BOTTOM_LINE_ACTIVE);
      this.adapter_.addClass(OPEN);
      this.animationRequestId_ = requestAnimationFrame(function () {
        _this2.adapter_.openMenu(focusIndex);
        _this2.isFocused_ = true;
      });
    }
  }, {
    key: 'setMenuStylesForOpenAtIndex_',
    value: function setMenuStylesForOpenAtIndex_(index) {
      var innerHeight = this.adapter_.getWindowInnerHeight();

      var _adapter_$computeBoun = this.adapter_.computeBoundingRect(),
          left = _adapter_$computeBoun.left,
          top = _adapter_$computeBoun.top;

      this.adapter_.setMenuElAttr('aria-hidden', 'true');
      this.adapter_.setMenuElStyle('display', 'block');
      var menuHeight = this.adapter_.getMenuElOffsetHeight();
      var itemOffsetTop = this.adapter_.getOffsetTopForOptionAtIndex(index);
      this.adapter_.setMenuElStyle('display', '');
      this.adapter_.rmMenuElAttr('aria-hidden');

      var adjustedTop = top - itemOffsetTop;
      var overflowsTop = adjustedTop < 0;
      var overflowsBottom = adjustedTop + menuHeight > innerHeight;
      if (overflowsTop) {
        adjustedTop = 0;
      } else if (overflowsBottom) {
        adjustedTop = Math.max(0, innerHeight - menuHeight);
      }

      this.adapter_.setMenuElStyle('left', left + 'px');
      this.adapter_.setMenuElStyle('top', adjustedTop + 'px');
      this.adapter_.setMenuElStyle('transform-origin', 'center ' + itemOffsetTop + 'px');
    }
  }, {
    key: 'close_',
    value: function close_() {
      var OPEN = MDCSelectFoundation.cssClasses.OPEN;

      this.adapter_.removeClass(OPEN);
      this.adapter_.removeClassFromBottomLine(cssClasses$10.BOTTOM_LINE_ACTIVE);
      this.adapter_.focus();
      this.enableScroll_();
    }
  }, {
    key: 'handleDisplayViaKeyboard_',
    value: function handleDisplayViaKeyboard_(evt) {
      // We use a hard-coded 2 instead of Event.AT_TARGET to avoid having to reference a browser
      // global.
      var EVENT_PHASE_AT_TARGET = 2;
      if (evt.eventPhase !== EVENT_PHASE_AT_TARGET) {
        return;
      }

      // Prevent pressing space down from scrolling the page
      var isSpaceDown = evt.type === 'keydown' && (evt.key === 'Space' || evt.keyCode === 32);
      if (isSpaceDown) {
        evt.preventDefault();
      }

      var isOpenerKey = OPENER_KEYS.some(function (_ref2) {
        var key = _ref2.key,
            keyCode = _ref2.keyCode,
            forType = _ref2.forType;

        return evt.type === forType && (evt.key === key || evt.keyCode === keyCode);
      });

      if (isOpenerKey) {
        this.displayHandler_(evt);
      }
    }
  }, {
    key: 'disableScroll_',
    value: function disableScroll_() {
      this.adapter_.addBodyClass(cssClasses$10.SCROLL_LOCK);
    }
  }, {
    key: 'enableScroll_',
    value: function enableScroll_() {
      this.adapter_.removeBodyClass(cssClasses$10.SCROLL_LOCK);
    }
  }]);
  return MDCSelectFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Select Label.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Select label into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCSelectLabelAdapter = function () {
  function MDCSelectLabelAdapter() {
    classCallCheck(this, MDCSelectLabelAdapter);
  }

  createClass(MDCSelectLabelAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the label element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the label element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}
  }]);
  return MDCSelectLabelAdapter;
}();

var cssClasses$11 = {
  LABEL_FLOAT_ABOVE: 'mdc-select__label--float-above'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCSelectLabelAdapter>}
 * @final
 */

var MDCSelectLabelFoundation = function (_MDCFoundation) {
  inherits(MDCSelectLabelFoundation, _MDCFoundation);
  createClass(MDCSelectLabelFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$11;
    }

    /**
     * {@see MDCSelectLabelAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCSelectLabelAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCSelectLabelAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          getWidth: function getWidth() {}
        }
      );
    }

    /**
     * @param {!MDCSelectLabelAdapter} adapter
     */

  }]);

  function MDCSelectLabelFoundation(adapter) {
    classCallCheck(this, MDCSelectLabelFoundation);
    return possibleConstructorReturn(this, (MDCSelectLabelFoundation.__proto__ || Object.getPrototypeOf(MDCSelectLabelFoundation)).call(this, _extends(MDCSelectLabelFoundation.defaultAdapter, adapter)));
  }

  /**
   * Styles the label to float or defloat as necessary.
   * @param {string} value The value of the input.
   * @param {boolean} isFocused Whether the input is focused.
   * @param {boolean} isBadInput The input's `validity.badInput` value.
   */


  createClass(MDCSelectLabelFoundation, [{
    key: 'styleFloat',
    value: function styleFloat(value) {
      var LABEL_FLOAT_ABOVE = MDCSelectLabelFoundation.cssClasses.LABEL_FLOAT_ABOVE;

      if (!!value) {
        this.adapter_.addClass(LABEL_FLOAT_ABOVE);
      } else {
        this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
      }
    }
  }]);
  return MDCSelectLabelFoundation;
}(MDCFoundation);

var MDCMenuSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-select mdc-menu-select", class: _vm.classes, attrs: { "role": "listbox" } }, [_c('div', { ref: "surface", staticClass: "mdc-select__surface", style: _vm.surfaceStyles, attrs: { "tabindex": _vm.tabIndex } }, [_c('div', { ref: "label", staticClass: "mdc-select__label", class: _vm.labelClasses }, [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('div', { ref: "selectedContent", staticClass: "mdc-select__selected-text" }, [_vm._v(_vm._s(_vm.selectedTextContent))]), _vm._v(" "), _c('div', { ref: "bottomLine", staticClass: "mdc-select__bottom-line", class: _vm.bottomLineClasses })]), _vm._v(" "), _c('mdc-menu', { ref: "menu", staticClass: "mdc-select__menu", on: { "update": _vm.refreshIndex } }, [_vm._t("default")], 2)], 1);
  }, staticRenderFns: [],
  name: 'mdc-menu-select',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    multiple: Boolean,
    value: [String, Array],
    disabled: Boolean,
    label: String,
    box: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-select--box': this.box
      },
      labelClasses: {},
      bottomLineClasses: {},
      surfaceStyles: {},
      tabIndex: 0,
      selectedTextContent: ''
    };
  },

  components: {
    'mdc-menu': mdcMenu
  },
  watch: {
    disabled: function disabled(value) {
      this.foundation && this.foundation.setDisabled(value);
    },
    value: function value() {
      this.refreshIndex();
    },
    box: function box() {
      this.$set(this.classes, 'mdc-select--box', this.box);
    }
  },
  methods: {
    refreshIndex: function refreshIndex() {
      if (this.foundation) {
        var options = this.$refs.menu.items;
        for (var i = 0; i < options.length; i++) {
          var optionValue = options[i].getAttribute('data-value') || options[i].textContent.trim();
          if (this.value == optionValue) {
            this.foundation.setSelectedIndex(i);
            //TODO: MDCFIX force float above if value is valid
            this.$set(this.labelClasses, 'mdc-select__label--float-above', true);
            return;
          }
        }
        //TODO: MDCFIX force float above if value is valid
        this.foundation.setSelectedIndex(-1);
        this.$set(this.labelClasses, 'mdc-select__label--float-above', false);
        this.$emit('change', this.foundation.getValue()); // TODO: MDCFIX
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.labelFoundation = new MDCSelectLabelFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.labelClasses, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.labelClasses, className);
      }
    });

    this.foundation = new MDCSelectFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      floatLabel: function floatLabel(value) {
        _this.labelFoundation.styleFloat(value);
      },
      addClassToBottomLine: function addClassToBottomLine(className) {
        return _this.$set(_this.bottomLineClasses, className, true);
      },
      removeClassFromBottomLine: function removeClassFromBottomLine(className) {
        return _this.$delete(_this.bottomLineClasses, className);
      },
      setBottomLineAttr: function setBottomLineAttr(attr, value) {
        return _this.$refs.bottomLine.setAttribute(attr, value);
      },
      setAttr: function setAttr(attr, value) {
        return _this.$el.setAttribute(attr, value);
      },
      rmAttr: function rmAttr(attr, value) {
        return _this.$el.removeAttribute(attr, value);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this.$refs.surface.getBoundingClientRect();
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$refs.surface.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$refs.surface.removeEventListener(type, handler);
      },
      focus: function focus() {
        return _this.$refs.surface.focus();
      },
      makeTabbable: function makeTabbable() {
        _this.tabIndex = 0;
      },
      makeUntabbable: function makeUntabbable() {
        _this.tabIndex = -1;
      },
      getComputedStyleValue: function getComputedStyleValue(prop) {
        return window.getComputedStyle(_this.$refs.surface).getPropertyValue(prop);
      },
      setStyle: function setStyle(propertyName, value) {
        return _this.$set(_this.surfaceStyles, propertyName, value);
      },
      create2dRenderingContext: function create2dRenderingContext() {
        return document.createElement('canvas').getContext('2d');
      },
      setMenuElStyle: function setMenuElStyle(propertyName, value) {
        return _this.$refs.menu.$el.style[propertyName] = value;
      },
      setMenuElAttr: function setMenuElAttr(attr, value) {
        return _this.$refs.menu.$el.setAttribute(attr, value);
      },
      rmMenuElAttr: function rmMenuElAttr(attr) {
        return _this.$refs.menu.$el.removeAttribute(attr);
      },
      getMenuElOffsetHeight: function getMenuElOffsetHeight() {
        return _this.$refs.menu.$el.offsetHeight;
      },
      openMenu: function openMenu(focusIndex) {
        return _this.$refs.menu.show({ focusIndex: focusIndex });
      },
      isMenuOpen: function isMenuOpen() {
        return _this.$refs.menu.isOpen();
      },
      setSelectedTextContent: function setSelectedTextContent(selectedTextContent) {
        _this.selectedTextContent = selectedTextContent;
      },
      getNumberOfOptions: function getNumberOfOptions() {
        return _this.$refs.menu.items.length;
      },
      getTextForOptionAtIndex: function getTextForOptionAtIndex(index) {
        return _this.$refs.menu.items[index].textContent.trim();
      },
      getValueForOptionAtIndex: function getValueForOptionAtIndex(index) {
        return _this.$refs.menu.items[index].getAttribute('data-value') || _this.$refs.menu.items[index].textContent.trim();
      },
      setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
        return _this.$refs.menu.items[index].setAttribute(attr, value);
      },
      rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
        return _this.$refs.menu.items[index].removeAttribute(attr);
      },
      getOffsetTopForOptionAtIndex: function getOffsetTopForOptionAtIndex(index) {
        return _this.$refs.menu.items[index].offsetTop;
      },
      registerMenuInteractionHandler: function registerMenuInteractionHandler(type, handler) {
        return _this.$refs.menu.$el.addEventListener(type, handler);
      },
      deregisterMenuInteractionHandler: function deregisterMenuInteractionHandler(type, handler) {
        return _this.$refs.menu.$el.removeEventListener(type, handler);
      },
      notifyChange: function notifyChange() {
        _this.$emit('change', _this.foundation.getValue());
      },
      getWindowInnerHeight: function getWindowInnerHeight() {
        return window.innerHeight;
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      }
    });

    //TODO: MDCFIX
    var foundation = this.foundation;
    foundation.resize = function () {

      var font = foundation.adapter_.getComputedStyleValue('font');
      var letterSpacing = parseFloat(foundation.adapter_.getComputedStyleValue('letter-spacing'));

      if (font) {
        foundation.ctx_.font = font;
      } else {
        var primaryFontFamily = foundation.adapter_.getComputedStyleValue('font-family').split(',')[0];
        var fontSize = foundation.adapter_.getComputedStyleValue('font-size');
        foundation.ctx_.font = fontSize + ' ' + primaryFontFamily;
      }

      var maxTextLength = 0;

      var surfacePaddingRight = parseInt(foundation.adapter_.getComputedStyleValue('padding-right'), 10);
      var surfacePaddingLeft = parseInt(foundation.adapter_.getComputedStyleValue('padding-left'), 10);
      var selectBoxAddedPadding = surfacePaddingRight + surfacePaddingLeft;

      for (var i = 0, l = foundation.adapter_.getNumberOfOptions(); i < l; i++) {
        var txt = foundation.adapter_.getTextForOptionAtIndex(i).trim();

        var _foundation$ctx_$meas = foundation.ctx_.measureText(txt),
            _width = _foundation$ctx_$meas.width;

        var _addedSpace = letterSpacing * txt.length;

        maxTextLength = Math.max(maxTextLength, Math.ceil(_width + _addedSpace + selectBoxAddedPadding));
      }

      var labelTxt = _this.label;

      var _foundation$ctx_$meas2 = foundation.ctx_.measureText(labelTxt),
          width = _foundation$ctx_$meas2.width;

      var addedSpace = letterSpacing * labelTxt.length;

      maxTextLength = Math.max(maxTextLength, Math.ceil(width + addedSpace + selectBoxAddedPadding));

      foundation.adapter_.setStyle('width', maxTextLength + 'px');
    };
    /// 
    this.labelFoundation.init();
    this.foundation.init();
    this.foundation.setDisabled(this.disabled);
    this.refreshIndex();
    if (this.value !== this.foundation.getValue()) {
      this.$emit('change', this.foundation.getValue());
    }
  },
  beforeDestroy: function beforeDestroy() {
    var foundation = this.foundation;
    this.foundation = null;
    foundation.destroy();

    var foundationLabel = this.foundationLabel;
    this.foundationLabel = null;
    foundationLabel.destroy();
  }
};

var MDCMultiSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('select', { directives: [{ name: "model", rawName: "v-model", value: _vm.selected, expression: "selected" }], ref: "root", staticClass: "mdc-select mdc-multi-select mdc-list", style: _vm.styles, attrs: { "multiple": _vm.multiple, "disabled": _vm.disabled }, on: { "change": [function ($event) {
          var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
            return o.selected;
          }).map(function (o) {
            var val = "_value" in o ? o._value : o.value;return val;
          });_vm.selected = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
        }, _vm.onChange] } }, [_vm.label ? _c('optgroup', { ref: "optgroup", staticClass: "mdc-list-group", attrs: { "label": _vm.label } }, [_vm._t("default")], 2) : _vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-multi-select',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    multiple: Boolean,
    value: [String, Array],
    disabled: Boolean,
    label: String,
    maxSize: {
      type: [String, Number],
      default: 4
    }
  },
  data: function data() {
    return {
      selected: this.value,
      size: undefined,
      count: undefined
    };
  },

  computed: {
    styles: function styles() {
      var scroll = this.count > this.size;
      var size = 48 * this.size + (scroll ? 0 : 16);

      var styles = {
        'height': size + 'px',
        'overflow-y': scroll ? 'scroll' : 'hidden'
      };
      if (!scroll) {
        styles['background-image'] = 'unset';
      }
      return styles;
    }
  },
  methods: {
    onChange: function onChange() {
      this.$emit('change', this.selected);
    }
  },
  mounted: function mounted() {
    var _this = this;

    var refreshSize = function refreshSize() {
      var count = _this.$refs.root.querySelectorAll('option, optgroup').length;
      _this.count = count;
      var max = Number(_this.maxSize);
      if (_this.label) {
        max += 1;
      }
      _this.size = Math.min(count, max);
    };

    this.slotObserver = new MutationObserver(function () {
      return refreshSize();
    });
    this.slotObserver.observe(this.$el, { childList: true, subtree: true });

    refreshSize();
  },
  beforeDestroy: function beforeDestroy() {
    this.slotObserver.disconnect();
  }
};

var media$1 = new (function () {
  function _class() {
    classCallCheck(this, _class);
  }

  createClass(_class, [{
    key: 'mobile',
    get: function get$$1() {
      return this._mobile || (this._mobile = window.matchMedia('(max-width: 600px) and (pointer: coarse)'));
    }
  }]);
  return _class;
}())();

var mdcSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, _vm._b({ tag: "component", attrs: { "multiple": _vm.multiple, "label": _vm.label, "value": _vm.value }, on: { "change": _vm.onChange } }, 'component', _vm.$attrs, false), [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-select',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    multiple: Boolean,
    value: [String, Array],
    label: String,
    native: Boolean
  },
  provide: function provide() {
    return { mdcSelect: this };
  },

  components: {
    'mdc-native-select': MDCNativeSelect,
    'mdc-menu-select': MDCMenuSelect,
    'mdc-multi-select': MDCMultiSelect
  },
  data: function data() {
    return {
      mobile: window ? media$1.mobile.matches : true
    };
  },

  computed: {
    type: function type() {
      return this.multiple ? 'mdc-multi-select' : this.menu ? 'mdc-menu-select' : this.isNative ? 'mdc-native-select' : 'mdc-menu-select';
    },
    isNative: function isNative() {
      return this.native || this.multiple || this.mobile;
    }
  },
  methods: {
    onChange: function onChange(value) {
      this.$emit('change', value);
    },
    refreshMedia: function refreshMedia() {
      this.mobile = media$1.mobile.matches;
    }
  },
  beforeMount: function beforeMount() {
    media$1.mobile.addListener(this.refreshMedia);
    this.refreshMedia();
  },
  beforeDestroy: function beforeDestroy() {
    media$1.mobile.removeListener(this.refreshMedia);
  }
};

var MDCNativeOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.hasValue ? _c('option', { staticClass: "mdc-option mdc-native-option", attrs: { "disabled": _vm.disabled }, domProps: { "value": _vm.value } }, [_vm._t("default")], 2) : _c('option', { staticClass: "mdc-option mdc-native-option", attrs: { "disabled": _vm.disabled } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-native-option',
  props: {
    value: String,
    disabled: Boolean
  },
  computed: {
    hasValue: function hasValue() {
      return !(typeof this.value === 'undefined');
    }
  }
};

var MDCMenuOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-option mdc-menu-option mdc-list-item", attrs: { "role": "option", "tabindex": _vm.disabled ? -1 : 0, "aria-disabled": _vm.disabled, "data-value": _vm.value } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-menu-option',
  props: {
    value: String,
    disabled: Boolean
  }
};

var MDCMultiOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.hasValue ? _c('option', { staticClass: "mdc-option mdc-multi-option mdc-list-item", attrs: { "disabled": _vm.disabled }, domProps: { "value": _vm.value } }, [_vm._t("default")], 2) : _c('option', { staticClass: "mdc-option mdc-multi-option mdc-list-item", attrs: { "disabled": _vm.disabled } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-multi-option',
  props: {
    value: String,
    disabled: Boolean
  },
  computed: {
    hasValue: function hasValue() {
      return !(typeof this.value === 'undefined');
    }
  }
};

var mdcOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { tag: "component", attrs: { "disabled": _vm.disabled, "value": _vm.value } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-option',
  props: {
    value: String,
    disabled: Boolean
  },
  inject: ['mdcSelect'],
  components: {
    'mdc-native-option': MDCNativeOption,
    'mdc-multi-option': MDCMultiOption,
    'mdc-menu-option': MDCMenuOption
  },
  computed: {
    isNative: function isNative() {
      return this.mdcSelect.isNative;
    },
    multiple: function multiple() {
      return this.mdcSelect.multiple;
    },
    type: function type() {
      return this.multiple ? 'mdc-multi-option' : this.isNative ? 'mdc-native-option' : 'mdc-menu-option';
    }
  }
};

var VueMDCSelect = BasePlugin({
  mdcSelect: mdcSelect,
  mdcOption: mdcOption
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$12 = {
  ACTIVE: 'mdc-slider--active',
  DISABLED: 'mdc-slider--disabled',
  DISCRETE: 'mdc-slider--discrete',
  FOCUS: 'mdc-slider--focus',
  IN_TRANSIT: 'mdc-slider--in-transit',
  IS_DISCRETE: 'mdc-slider--discrete',
  HAS_TRACK_MARKER: 'mdc-slider--display-markers'
};

/** @enum {string} */
var strings$14 = {
  TRACK_SELECTOR: '.mdc-slider__track',
  TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
  LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
  THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
  PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
  ARIA_VALUEMIN: 'aria-valuemin',
  ARIA_VALUEMAX: 'aria-valuemax',
  ARIA_VALUENOW: 'aria-valuenow',
  ARIA_DISABLED: 'aria-disabled',
  STEP_DATA_ATTR: 'data-step',
  CHANGE_EVENT: 'MDCSlider:change',
  INPUT_EVENT: 'MDCSlider:input'
};

/** @enum {number} */
var numbers$3 = {
  PAGE_FACTOR: 4
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */

/**
 * Adapter for MDC Slider.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Slider into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCSliderAdapter = function () {
  function MDCSliderAdapter() {
    classCallCheck(this, MDCSliderAdapter);
  }

  createClass(MDCSliderAdapter, [{
    key: "hasClass",

    /**
     * Returns true if className exists for the slider Element
     * @param {string} className
     * @return {boolean}
     */
    value: function hasClass(className) {}

    /**
     * Adds a class to the slider Element
     * @param {string} className
     */

  }, {
    key: "addClass",
    value: function addClass(className) {}

    /**
     * Removes a class from the slider Element
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns a string if attribute name exists on the slider Element,
     * otherwise returns null
     * @param {string} name
     * @return {?string}
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(name) {}

    /**
     * Sets attribute name on slider Element to value
     * @param {string} name
     * @param {string} value
     */

  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {}

    /**
     * Removes attribute name from slider Element
     * @param {string} name
     */

  }, {
    key: "removeAttribute",
    value: function removeAttribute(name) {}

    /**
     * Returns the bounding client rect for the slider Element
     * @return {?ClientRect}
     */

  }, {
    key: "computeBoundingRect",
    value: function computeBoundingRect() {}

    /**
     * Returns the tab index of the slider Element
     * @return {number}
     */

  }, {
    key: "getTabIndex",
    value: function getTabIndex() {}

    /**
     * Registers an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}

    /**
     * Registers an event handler on the thumb container element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerThumbContainerInteractionHandler",
    value: function registerThumbContainerInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the thumb container element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterThumbContainerInteractionHandler",
    value: function deregisterThumbContainerInteractionHandler(type, handler) {}

    /**
     * Registers an event handler on the body for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerBodyInteractionHandler",
    value: function registerBodyInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the body for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterBodyInteractionHandler",
    value: function deregisterBodyInteractionHandler(type, handler) {}

    /**
     * Registers an event handler for the window resize event
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerResizeHandler",
    value: function registerResizeHandler(handler) {}

    /**
     * Deregisters an event handler for the window resize event
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterResizeHandler",
    value: function deregisterResizeHandler(handler) {}

    /**
     * Emits a custom event MDCSlider:input from the root
     */

  }, {
    key: "notifyInput",
    value: function notifyInput() {}

    /**
     * Emits a custom event MDCSlider:change from the root
     */

  }, {
    key: "notifyChange",
    value: function notifyChange() {}

    /**
     * Sets a style property of the thumb container element to the passed value
     * @param {string} propertyName
     * @param {string} value
     */

  }, {
    key: "setThumbContainerStyleProperty",
    value: function setThumbContainerStyleProperty(propertyName, value) {}

    /**
     * Sets a style property of the track element to the passed value
     * @param {string} propertyName
     * @param {string} value
     */

  }, {
    key: "setTrackStyleProperty",
    value: function setTrackStyleProperty(propertyName, value) {}

    /**
     * Sets the inner text of the pin marker to the passed value
     * @param {number} value
     */

  }, {
    key: "setMarkerValue",
    value: function setMarkerValue(value) {}

    /**
     * Appends the passed number of track markers to the track mark container element
     * @param {number} numMarkers
     */

  }, {
    key: "appendTrackMarkers",
    value: function appendTrackMarkers(numMarkers) {}

    /**
     * Removes all track markers fromt he track mark container element
     */

  }, {
    key: "removeTrackMarkers",
    value: function removeTrackMarkers() {}

    /**
     * Sets a style property of the last track marker to the passed value
     * @param {string} propertyName
     * @param {string} value
     */

  }, {
    key: "setLastTrackMarkersStyleProperty",
    value: function setLastTrackMarkersStyleProperty(propertyName, value) {}

    /**
     * Returns true if the root element is RTL, otherwise false
     * @return {boolean}
     */

  }, {
    key: "isRTL",
    value: function isRTL() {}
  }]);
  return MDCSliderAdapter;
}();

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var KEY_IDS = {
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  HOME: 'Home',
  END: 'End',
  PAGE_UP: 'PageUp',
  PAGE_DOWN: 'PageDown'
};

/** @enum {string} */
var MOVE_EVENT_MAP = {
  'mousedown': 'mousemove',
  'touchstart': 'touchmove',
  'pointerdown': 'pointermove'
};

var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];

/**
 * @extends {MDCFoundation<!MDCSliderAdapter>}
 */

var MDCSliderFoundation = function (_MDCFoundation) {
  inherits(MDCSliderFoundation, _MDCFoundation);
  createClass(MDCSliderFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$12;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$14;
    }

    /** @return enum {numbers} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$3;
    }

    /** @return {!MDCSliderAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCSliderAdapter} */{
          hasClass: function hasClass() {
            return (/* className: string */ /* boolean */false
            );
          },
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          getAttribute: function getAttribute() {
            return (/* name: string */ /* string|null */null
            );
          },
          setAttribute: function setAttribute() /* name: string, value: string */{},
          removeAttribute: function removeAttribute() /* name: string */{},
          computeBoundingRect: function computeBoundingRect() {
            return (/* ClientRect */{
                top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0
              }
            );
          },
          getTabIndex: function getTabIndex() {
            return (/* number */0
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
          registerBodyInteractionHandler: function registerBodyInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() /* type: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          notifyInput: function notifyInput() {},
          notifyChange: function notifyChange() {},
          setThumbContainerStyleProperty: function setThumbContainerStyleProperty() /* propertyName: string, value: string */{},
          setTrackStyleProperty: function setTrackStyleProperty() /* propertyName: string, value: string */{},
          setMarkerValue: function setMarkerValue() /* value: number */{},
          appendTrackMarkers: function appendTrackMarkers() /* numMarkers: number */{},
          removeTrackMarkers: function removeTrackMarkers() {},
          setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty() /* propertyName: string, value: string */{},
          isRTL: function isRTL() {
            return (/* boolean */false
            );
          }
        }
      );
    }

    /**
     * Creates a new instance of MDCSliderFoundation
     * @param {?MDCSliderAdapter} adapter
     */

  }]);

  function MDCSliderFoundation(adapter) {
    classCallCheck(this, MDCSliderFoundation);

    /** @private {?ClientRect} */
    var _this = possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));

    _this.rect_ = null;
    // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
    // because those could be valid tabindices set by the client code.
    _this.savedTabIndex_ = NaN;
    _this.active_ = false;
    _this.inTransit_ = false;
    _this.isDiscrete_ = false;
    _this.hasTrackMarker_ = false;
    _this.handlingThumbTargetEvt_ = false;
    _this.min_ = 0;
    _this.max_ = 100;
    _this.step_ = 0;
    _this.value_ = 0;
    _this.disabled_ = false;
    _this.preventFocusState_ = false;
    _this.updateUIFrame_ = 0;
    _this.thumbContainerPointerHandler_ = function () {
      _this.handlingThumbTargetEvt_ = true;
    };
    _this.interactionStartHandler_ = function (evt) {
      return _this.handleDown_(evt);
    };
    _this.keydownHandler_ = function (evt) {
      return _this.handleKeydown_(evt);
    };
    _this.focusHandler_ = function () {
      return _this.handleFocus_();
    };
    _this.blurHandler_ = function () {
      return _this.handleBlur_();
    };
    _this.resizeHandler_ = function () {
      return _this.layout();
    };
    return _this;
  }

  createClass(MDCSliderFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this.isDiscrete_ = this.adapter_.hasClass(cssClasses$12.IS_DISCRETE);
      this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$12.HAS_TRACK_MARKER);
      DOWN_EVENTS.forEach(function (evtName) {
        return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
      });
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
      this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      DOWN_EVENTS.forEach(function (evtName) {
        _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
      });
      this.adapter_.registerResizeHandler(this.resizeHandler_);
      this.layout();
      // At last step, provide a reasonable default value to discrete slider
      if (this.isDiscrete_ && this.getStep() == 0) {
        this.step_ = 1;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      DOWN_EVENTS.forEach(function (evtName) {
        _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
      });
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
      this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
      DOWN_EVENTS.forEach(function (evtName) {
        _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
      });
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'setupTrackMarker',
    value: function setupTrackMarker() {
      if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
        var min = this.getMin();
        var max = this.getMax();
        var step = this.getStep();
        var numMarkers = (max - min) / step;

        // In case distance between max & min is indivisible to step,
        // we place the secondary to last marker proportionally at where thumb
        // could reach and place the last marker at max value
        var indivisible = Math.ceil(numMarkers) !== numMarkers;
        if (indivisible) {
          numMarkers = Math.ceil(numMarkers);
        }

        this.adapter_.removeTrackMarkers();
        this.adapter_.appendTrackMarkers(numMarkers);

        if (indivisible) {
          var lastStepRatio = (max - numMarkers * step) / step + 1;
          var flex = getCorrectPropertyName(window, 'flex');
          this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
        }
      }
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.rect_ = this.adapter_.computeBoundingRect();
      this.updateUIForCurrentValue_();
    }

    /** @return {number} */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.value_;
    }

    /** @param {number} value */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.setValue_(value, false);
    }

    /** @return {number} */

  }, {
    key: 'getMax',
    value: function getMax() {
      return this.max_;
    }

    /** @param {number} max */

  }, {
    key: 'setMax',
    value: function setMax(max) {
      if (max < this.min_) {
        throw new Error('Cannot set max to be less than the slider\'s minimum value');
      }
      this.max_ = max;
      this.setValue_(this.value_, false, true);
      this.adapter_.setAttribute(strings$14.ARIA_VALUEMAX, String(this.max_));
      this.setupTrackMarker();
    }

    /** @return {number} */

  }, {
    key: 'getMin',
    value: function getMin() {
      return this.min_;
    }

    /** @param {number} min */

  }, {
    key: 'setMin',
    value: function setMin(min) {
      if (min > this.max_) {
        throw new Error('Cannot set min to be greater than the slider\'s maximum value');
      }
      this.min_ = min;
      this.setValue_(this.value_, false, true);
      this.adapter_.setAttribute(strings$14.ARIA_VALUEMIN, String(this.min_));
      this.setupTrackMarker();
    }

    /** @return {number} */

  }, {
    key: 'getStep',
    value: function getStep() {
      return this.step_;
    }

    /** @param {number} step */

  }, {
    key: 'setStep',
    value: function setStep(step) {
      if (step < 0) {
        throw new Error('Step cannot be set to a negative number');
      }
      if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
        step = 1;
      }
      this.step_ = step;
      this.setValue_(this.value_, false, true);
      this.setupTrackMarker();
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.disabled_;
    }

    /** @param {boolean} disabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      this.disabled_ = disabled;
      this.toggleClass_(cssClasses$12.DISABLED, this.disabled_);
      if (this.disabled_) {
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.setAttribute(strings$14.ARIA_DISABLED, 'true');
        this.adapter_.removeAttribute('tabindex');
      } else {
        this.adapter_.removeAttribute(strings$14.ARIA_DISABLED);
        if (!isNaN(this.savedTabIndex_)) {
          this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
        }
      }
    }

    /**
     * Called when the user starts interacting with the slider
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handleDown_',
    value: function handleDown_(evt) {
      var _this4 = this;

      if (this.disabled_) {
        return;
      }

      this.preventFocusState_ = true;
      this.setInTransit_(!this.handlingThumbTargetEvt_);
      this.handlingThumbTargetEvt_ = false;
      this.setActive_(true);

      var moveHandler = function moveHandler(evt) {
        _this4.handleMove_(evt);
      };

      // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
      // do not always fire these consistently in pairs.
      // (See https://github.com/material-components/material-components-web/issues/1192)
      var upHandler = function upHandler() {
        _this4.handleUp_();
        _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
        });
      };

      this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
      UP_EVENTS.forEach(function (evtName) {
        return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
      });
      this.setValueFromEvt_(evt);
    }

    /**
     * Called when the user moves the slider
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handleMove_',
    value: function handleMove_(evt) {
      evt.preventDefault();
      this.setValueFromEvt_(evt);
    }

    /**
     * Called when the user's interaction with the slider ends
     * @private
     */

  }, {
    key: 'handleUp_',
    value: function handleUp_() {
      this.setActive_(false);
      this.adapter_.notifyChange();
    }

    /**
     * Returns the pageX of the event
     * @param {!Event} evt
     * @return {number}
     * @private
     */

  }, {
    key: 'getPageX_',
    value: function getPageX_(evt) {
      if (evt.targetTouches && evt.targetTouches.length > 0) {
        return evt.targetTouches[0].pageX;
      }
      return evt.pageX;
    }

    /**
     * Sets the slider value from an event
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'setValueFromEvt_',
    value: function setValueFromEvt_(evt) {
      var pageX = this.getPageX_(evt);
      var value = this.computeValueFromPageX_(pageX);
      this.setValue_(value, true);
    }

    /**
     * Computes the new value from the pageX position
     * @param {number} pageX
     * @return {number}
     */

  }, {
    key: 'computeValueFromPageX_',
    value: function computeValueFromPageX_(pageX) {
      var max = this.max_,
          min = this.min_;

      var xPos = pageX - this.rect_.left;
      var pctComplete = xPos / this.rect_.width;
      if (this.adapter_.isRTL()) {
        pctComplete = 1 - pctComplete;
      }
      // Fit the percentage complete between the range [min,max]
      // by remapping from [0, 1] to [min, min+(max-min)].
      return min + pctComplete * (max - min);
    }

    /**
     * Handles keydown events
     * @param {!Event} evt
     */

  }, {
    key: 'handleKeydown_',
    value: function handleKeydown_(evt) {
      var keyId = this.getKeyId_(evt);
      var value = this.getValueForKeyId_(keyId);
      if (isNaN(value)) {
        return;
      }

      // Prevent page from scrolling due to key presses that would normally scroll the page
      evt.preventDefault();
      this.adapter_.addClass(cssClasses$12.FOCUS);
      this.setValue_(value, true);
      this.adapter_.notifyChange();
    }

    /**
     * Returns the computed name of the event
     * @param {!Event} kbdEvt
     * @return {string}
     */

  }, {
    key: 'getKeyId_',
    value: function getKeyId_(kbdEvt) {
      if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
        return KEY_IDS.ARROW_LEFT;
      }
      if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
        return KEY_IDS.ARROW_RIGHT;
      }
      if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
        return KEY_IDS.ARROW_UP;
      }
      if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
        return KEY_IDS.ARROW_DOWN;
      }
      if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
        return KEY_IDS.HOME;
      }
      if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
        return KEY_IDS.END;
      }
      if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
        return KEY_IDS.PAGE_UP;
      }
      if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
        return KEY_IDS.PAGE_DOWN;
      }

      return '';
    }

    /**
     * Computes the value given a keyboard key ID
     * @param {string} keyId
     * @return {number}
     */

  }, {
    key: 'getValueForKeyId_',
    value: function getValueForKeyId_(keyId) {
      var max = this.max_,
          min = this.min_,
          step = this.step_;

      var delta = step || (max - min) / 100;
      var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
      if (valueNeedsToBeFlipped) {
        delta = -delta;
      }

      switch (keyId) {
        case KEY_IDS.ARROW_LEFT:
        case KEY_IDS.ARROW_DOWN:
          return this.value_ - delta;
        case KEY_IDS.ARROW_RIGHT:
        case KEY_IDS.ARROW_UP:
          return this.value_ + delta;
        case KEY_IDS.HOME:
          return this.min_;
        case KEY_IDS.END:
          return this.max_;
        case KEY_IDS.PAGE_UP:
          return this.value_ + delta * numbers$3.PAGE_FACTOR;
        case KEY_IDS.PAGE_DOWN:
          return this.value_ - delta * numbers$3.PAGE_FACTOR;
        default:
          return NaN;
      }
    }
  }, {
    key: 'handleFocus_',
    value: function handleFocus_() {
      if (this.preventFocusState_) {
        return;
      }
      this.adapter_.addClass(cssClasses$12.FOCUS);
    }
  }, {
    key: 'handleBlur_',
    value: function handleBlur_() {
      this.preventFocusState_ = false;
      this.adapter_.removeClass(cssClasses$12.FOCUS);
    }

    /**
     * Sets the value of the slider
     * @param {number} value
     * @param {boolean} shouldFireInput
     * @param {boolean=} force
     */

  }, {
    key: 'setValue_',
    value: function setValue_(value, shouldFireInput) {
      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (value === this.value_ && !force) {
        return;
      }

      var min = this.min_,
          max = this.max_;

      var valueSetToBoundary = value === min || value === max;
      if (this.step_ && !valueSetToBoundary) {
        value = this.quantize_(value);
      }
      if (value < min) {
        value = min;
      } else if (value > max) {
        value = max;
      }
      this.value_ = value;
      this.adapter_.setAttribute(strings$14.ARIA_VALUENOW, String(this.value_));
      this.updateUIForCurrentValue_();

      if (shouldFireInput) {
        this.adapter_.notifyInput();
        if (this.isDiscrete_) {
          this.adapter_.setMarkerValue(value);
        }
      }
    }

    /**
     * Calculates the quantized value
     * @param {number} value
     * @return {number}
     */

  }, {
    key: 'quantize_',
    value: function quantize_(value) {
      var numSteps = Math.round(value / this.step_);
      var quantizedVal = numSteps * this.step_;
      return quantizedVal;
    }
  }, {
    key: 'updateUIForCurrentValue_',
    value: function updateUIForCurrentValue_() {
      var _this5 = this;

      var max = this.max_,
          min = this.min_,
          value = this.value_;

      var pctComplete = (value - min) / (max - min);
      var translatePx = pctComplete * this.rect_.width;
      if (this.adapter_.isRTL()) {
        translatePx = this.rect_.width - translatePx;
      }

      var transformProp = getCorrectPropertyName(window, 'transform');
      var transitionendEvtName = getCorrectEventName(window, 'transitionend');

      if (this.inTransit_) {
        var onTransitionEnd = function onTransitionEnd() {
          _this5.setInTransit_(false);
          _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        };
        this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
      }

      this.updateUIFrame_ = requestAnimationFrame(function () {
        // NOTE(traviskaufman): It would be nice to use calc() here,
        // but IE cannot handle calcs in transforms correctly.
        // See: https://goo.gl/NC2itk
        // Also note that the -50% offset is used to center the slider thumb.
        _this5.adapter_.setThumbContainerStyleProperty(transformProp, 'translateX(' + translatePx + 'px) translateX(-50%)');
        _this5.adapter_.setTrackStyleProperty(transformProp, 'scaleX(' + pctComplete + ')');
      });
    }

    /**
     * Toggles the active state of the slider
     * @param {boolean} active
     */

  }, {
    key: 'setActive_',
    value: function setActive_(active) {
      this.active_ = active;
      this.toggleClass_(cssClasses$12.ACTIVE, this.active_);
    }

    /**
     * Toggles the inTransit state of the slider
     * @param {boolean} inTransit
     */

  }, {
    key: 'setInTransit_',
    value: function setInTransit_(inTransit) {
      this.inTransit_ = inTransit;
      this.toggleClass_(cssClasses$12.IN_TRANSIT, this.inTransit_);
    }

    /**
     * Conditionally adds or removes a class based on shouldBePresent
     * @param {string} className
     * @param {boolean} shouldBePresent
     */

  }, {
    key: 'toggleClass_',
    value: function toggleClass_(className, shouldBePresent) {
      if (shouldBePresent) {
        this.adapter_.addClass(className);
      } else {
        this.adapter_.removeClass(className);
      }
    }
  }]);
  return MDCSliderFoundation;
}(MDCFoundation);

var mdcSlider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-slider", class: _vm.classes, attrs: { "tabindex": "0", "role": "slider" } }, [_c('div', { staticClass: "mdc-slider__track-container" }, [_c('div', { staticClass: "mdc-slider__track", style: _vm.trackStyles }), _vm._v(" "), _vm.hasMarkers ? _c('div', { staticClass: "mdc-slider__track-marker-container" }, _vm._l(_vm.numMarkers, function (markerNum) {
      return _c('div', { key: markerNum, staticClass: "mdc-slider__track-marker", style: markerNum == _vm.numMarkers ? _vm.lastTrackMarkersStyles : {} });
    })) : _vm._e()]), _vm._v(" "), _c('div', { ref: "thumbContainer", staticClass: "mdc-slider__thumb-container", style: _vm.thumbStyles }, [_vm.isDiscrete ? _c('div', { staticClass: "mdc-slider__pin" }, [_c('span', { staticClass: "mdc-slider__pin-value-marker" }, [_vm._v(_vm._s(_vm.markerValue))])]) : _vm._e(), _vm._v(" "), _c('svg', { staticClass: "mdc-slider__thumb", attrs: { "width": "21", "height": "21" } }, [_c('circle', { attrs: { "cx": "10.5", "cy": "10.5", "r": "7.875" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-slider__focus-ring" })])]);
  }, staticRenderFns: [],
  name: 'mdc-slider',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: [Number, String],
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String], default: 0 },
    displayMarkers: Boolean,
    disabled: Boolean,
    layoutOn: String,
    layoutOnSource: { type: Object, required: false }
  },
  data: function data() {
    return {
      classes: {
        'mdc-slider--discrete': !!this.step,
        'mdc-slider--display-markers': this.displayMarkers
      },
      trackStyles: {},
      lastTrackMarkersStyles: {},
      thumbStyles: {},
      markerValue: '',
      numMarkers: 0
    };
  },

  computed: {
    isDiscrete: function isDiscrete() {
      return !!this.step;
    },
    hasMarkers: function hasMarkers() {
      return !!this.step && this.displayMarkers && this.numMarkers;
    }
  },
  watch: {
    value: function value() {
      if (this.foundation.getValue() !== Number(this.value)) {
        this.foundation.setValue(this.value);
      }
    },
    min: function min() {
      this.foundation.setMin(Number(this.min));
    },
    max: function max() {
      this.foundation.setMax(Number(this.max));
    },
    step: function step() {
      this.foundation.setStep(Number(this.step));
    },
    disabled: function disabled() {
      this.foundation.setDisabled(this.disabled);
    }
  },
  methods: {
    layout: function layout() {
      var _this = this;

      this.$nextTick(function () {
        _this.foundation && _this.foundation.layout();
      });
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.foundation = new MDCSliderFoundation({
      hasClass: function hasClass(className) {
        return _this2.$el.classList.contains(className);
      },
      addClass: function addClass(className) {
        _this2.$set(_this2.classes, className, true);
      },
      removeClass: function removeClass(className) {
        _this2.$delete(_this2.classes, className, true);
      },
      getAttribute: function getAttribute(name) {
        return _this2.$el.getAttribute(name);
      },
      setAttribute: function setAttribute(name, value) {
        return _this2.$el.setAttribute(name, value);
      },
      removeAttribute: function removeAttribute(name) {
        return _this2.$el.removeAttribute(name);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this2.$el.getBoundingClientRect();
      },
      getTabIndex: function getTabIndex() {
        return _this2.$el.tabIndex;
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        _this2.$el.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        _this2.$el.removeEventListener(type, handler);
      },
      registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
        _this2.$refs.thumbContainer.addEventListener(type, handler);
      },
      deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
        _this2.$refs.thumbContainer.removeEventListener(type, handler);
      },
      registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
        document.body.addEventListener(type, handler);
      },
      deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
        document.body.removeEventListener(type, handler);
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        window.removeEventListener('resize', handler);
      },
      notifyInput: function notifyInput() {
        _this2.$emit('input', _this2.foundation.getValue());
      },
      notifyChange: function notifyChange() {
        _this2.$emit('change', _this2.foundation.getValue());
      },
      setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
        _this2.$set(_this2.thumbStyles, propertyName, value);
      },
      setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
        _this2.$set(_this2.trackStyles, propertyName, value);
      },
      setMarkerValue: function setMarkerValue(value) {
        _this2.markerValue = value;
      },
      appendTrackMarkers: function appendTrackMarkers(numMarkers) {
        _this2.numMarkers = numMarkers;
      },
      removeTrackMarkers: function removeTrackMarkers() {
        _this2.numMarkers = 0;
      },
      setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
        _this2.$set(_this2.lastTrackMarkersStyles, propertyName, value);
      },
      isRTL: function isRTL() {
        return false;
      }
    });

    this.foundation.init();
    this.foundation.setDisabled(this.disabled);
    this.foundation.setMin(Number(this.min));
    this.foundation.setMax(Number(this.max));
    this.foundation.setStep(Number(this.step));
    this.foundation.setValue(Number(this.value));
    if (this.hasMarkers) {
      this.foundation.setupTrackMarker();
    }

    this.$root.$on('mdc:layout', this.layout);

    if (this.layoutOn) {
      var source = this.layoutOnSource || this.$root;
      source.$on(this.layoutOn, this.layout);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCSlider = BasePlugin({
  mdcSlider: mdcSlider
});

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var cssClasses$13 = {
  ROOT: 'mdc-snackbar',
  TEXT: 'mdc-snackbar__text',
  ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
  ACTION_BUTTON: 'mdc-snackbar__action-button',
  ACTIVE: 'mdc-snackbar--active',
  MULTILINE: 'mdc-snackbar--multiline',
  ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
};

var strings$15 = {
  TEXT_SELECTOR: '.mdc-snackbar__text',
  ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
  ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
  SHOW_EVENT: 'MDCSnackbar:show',
  HIDE_EVENT: 'MDCSnackbar:hide'
};

var numbers$4 = {
  MESSAGE_TIMEOUT: 2750
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCSnackbarFoundation = function (_MDCFoundation) {
  inherits(MDCSnackbarFoundation, _MDCFoundation);
  createClass(MDCSnackbarFoundation, [{
    key: 'active',
    get: function get$$1() {
      return this.active_;
    }
  }], [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$13;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$15;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        setAriaHidden: function setAriaHidden() {},
        unsetAriaHidden: function unsetAriaHidden() {},
        setActionAriaHidden: function setActionAriaHidden() {},
        unsetActionAriaHidden: function unsetActionAriaHidden() {},
        setActionText: function setActionText() /* actionText: string */{},
        setMessageText: function setMessageText() /* message: string */{},
        setFocus: function setFocus() {},
        visibilityIsHidden: function visibilityIsHidden() {
          return (/* boolean */false
          );
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler() /* handler: EventListener */{},
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler() /* handler: EventListener */{},
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler() /* handler: EventListener */{},
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler() /* handler: EventListener */{},
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerActionClickHandler: function registerActionClickHandler() /* handler: EventListener */{},
        deregisterActionClickHandler: function deregisterActionClickHandler() /* handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        notifyShow: function notifyShow() {},
        notifyHide: function notifyHide() {}
      };
    }
  }]);

  function MDCSnackbarFoundation(adapter) {
    classCallCheck(this, MDCSnackbarFoundation);

    var _this = possibleConstructorReturn(this, (MDCSnackbarFoundation.__proto__ || Object.getPrototypeOf(MDCSnackbarFoundation)).call(this, _extends(MDCSnackbarFoundation.defaultAdapter, adapter)));

    _this.active_ = false;
    _this.actionWasClicked_ = false;
    _this.dismissOnAction_ = true;
    _this.firstFocus_ = true;
    _this.pointerDownRecognized_ = false;
    _this.snackbarHasFocus_ = false;
    _this.snackbarData_ = null;
    _this.queue_ = [];
    _this.actionClickHandler_ = function () {
      _this.actionWasClicked_ = true;
      _this.invokeAction_();
    };
    _this.visibilitychangeHandler_ = function () {
      clearTimeout(_this.timeoutId_);
      _this.snackbarHasFocus_ = true;

      if (!_this.adapter_.visibilityIsHidden()) {
        setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
      }
    };
    _this.interactionHandler_ = function (evt) {
      if (evt.type == 'touchstart' || evt.type == 'mousedown') {
        _this.pointerDownRecognized_ = true;
      }
      _this.handlePossibleTabKeyboardFocus_(evt);

      if (evt.type == 'focus') {
        _this.pointerDownRecognized_ = false;
      }
    };
    _this.blurHandler_ = function () {
      clearTimeout(_this.timeoutId_);
      _this.snackbarHasFocus_ = false;
      _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
    };
    return _this;
  }

  createClass(MDCSnackbarFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerActionClickHandler(this.actionClickHandler_);
      this.adapter_.setAriaHidden();
      this.adapter_.setActionAriaHidden();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
      this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
      this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
      ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
        _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
      });
    }
  }, {
    key: 'dismissesOnAction',
    value: function dismissesOnAction() {
      return this.dismissOnAction_;
    }
  }, {
    key: 'setDismissOnAction',
    value: function setDismissOnAction(dismissOnAction) {
      this.dismissOnAction_ = !!dismissOnAction;
    }
  }, {
    key: 'show',
    value: function show(data) {
      var _this3 = this;

      if (!data) {
        throw new Error('Please provide a data object with at least a message to display.');
      }
      if (!data.message) {
        throw new Error('Please provide a message to be displayed.');
      }
      if (data.actionHandler && !data.actionText) {
        throw new Error('Please provide action text with the handler.');
      }
      if (this.active) {
        this.queue_.push(data);
        return;
      }
      clearTimeout(this.timeoutId_);
      this.snackbarData_ = data;
      this.firstFocus_ = true;
      this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
      this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
      ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
        _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
      });

      var ACTIVE = cssClasses$13.ACTIVE,
          MULTILINE = cssClasses$13.MULTILINE,
          ACTION_ON_BOTTOM = cssClasses$13.ACTION_ON_BOTTOM;


      this.adapter_.setMessageText(this.snackbarData_.message);

      if (this.snackbarData_.multiline) {
        this.adapter_.addClass(MULTILINE);
        if (this.snackbarData_.actionOnBottom) {
          this.adapter_.addClass(ACTION_ON_BOTTOM);
        }
      }

      if (this.snackbarData_.actionHandler) {
        this.adapter_.setActionText(this.snackbarData_.actionText);
        this.actionHandler_ = this.snackbarData_.actionHandler;
        this.setActionHidden_(false);
      } else {
        this.setActionHidden_(true);
        this.actionHandler_ = null;
        this.adapter_.setActionText(null);
      }

      this.active_ = true;
      this.adapter_.addClass(ACTIVE);
      this.adapter_.unsetAriaHidden();
      this.adapter_.notifyShow();

      this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
    }
  }, {
    key: 'handlePossibleTabKeyboardFocus_',
    value: function handlePossibleTabKeyboardFocus_() {
      var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

      if (hijackFocus) {
        this.setFocusOnAction_();
      }

      this.firstFocus_ = false;
    }
  }, {
    key: 'setFocusOnAction_',
    value: function setFocusOnAction_() {
      this.adapter_.setFocus();
      this.snackbarHasFocus_ = true;
      this.firstFocus_ = false;
    }
  }, {
    key: 'invokeAction_',
    value: function invokeAction_() {
      try {
        if (!this.actionHandler_) {
          return;
        }

        this.actionHandler_();
      } finally {
        if (this.dismissOnAction_) {
          this.cleanup_();
        }
      }
    }
  }, {
    key: 'cleanup_',
    value: function cleanup_() {
      var _this4 = this;

      var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

      if (allowDismissal) {
        var ACTIVE = cssClasses$13.ACTIVE,
            MULTILINE = cssClasses$13.MULTILINE,
            ACTION_ON_BOTTOM = cssClasses$13.ACTION_ON_BOTTOM;


        this.adapter_.removeClass(ACTIVE);

        var handler = function handler() {
          clearTimeout(_this4.timeoutId_);
          _this4.adapter_.deregisterTransitionEndHandler(handler);
          _this4.adapter_.removeClass(MULTILINE);
          _this4.adapter_.removeClass(ACTION_ON_BOTTOM);
          _this4.setActionHidden_(true);
          _this4.adapter_.setAriaHidden();
          _this4.active_ = false;
          _this4.snackbarHasFocus_ = false;
          _this4.adapter_.notifyHide();
          _this4.showNext_();
        };

        this.adapter_.registerTransitionEndHandler(handler);
      }
    }
  }, {
    key: 'showNext_',
    value: function showNext_() {
      if (!this.queue_.length) {
        return;
      }
      this.show(this.queue_.shift());
    }
  }, {
    key: 'setActionHidden_',
    value: function setActionHidden_(isHidden) {
      if (isHidden) {
        this.adapter_.setActionAriaHidden();
      } else {
        this.adapter_.unsetActionAriaHidden();
      }
    }
  }]);
  return MDCSnackbarFoundation;
}(MDCFoundation);

var mdcSnackbar = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-snackbar", class: _vm.classes, attrs: { "aria-live": "assertive", "aria-atomic": "true", "aria-hidden": _vm.hidden } }, [_c('div', { staticClass: "mdc-snackbar__text" }, [_vm._v(_vm._s(_vm.message))]), _vm._v(" "), _c('div', { staticClass: "mdc-snackbar__action-wrapper" }, [_c('button', { ref: "button", staticClass: "mdc-snackbar__action-button", attrs: { "type": "button", "aria-hidden": _vm.actionHidden } }, [_vm._v(_vm._s(_vm.actionText))])])]);
  }, staticRenderFns: [],
  name: 'mdc-snackbar',
  props: {
    'align-start': Boolean,
    'event': {
      type: String,
      required: false,
      default: function _default() {
        return 'show-snackbar';
      }
    },
    'event-source': {
      type: Object,
      required: false,
      default: function _default() {
        return this.$root;
      }
    },
    'dismisses-on-action': { type: Boolean, default: true }
  },
  data: function data() {
    return {
      classes: {
        'mdc-snackbar--align-start': this.alignStart
      },
      message: '',
      actionText: '',
      hidden: false,
      actionHidden: false
    };
  },

  methods: {
    show: function show(data) {
      this.foundation.show(data);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCSnackbarFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      setAriaHidden: function setAriaHidden() {
        return _this.hidden = true;
      },
      unsetAriaHidden: function unsetAriaHidden() {
        return _this.hidden = false;
      },
      setActionAriaHidden: function setActionAriaHidden() {
        return _this.actionHidden = true;
      },
      unsetActionAriaHidden: function unsetActionAriaHidden() {
        return _this.actionHidden = false;
      },
      setActionText: function setActionText(text) {
        _this.actionText = text;
      },
      setMessageText: function setMessageText(text) {
        _this.message = text;
      },
      setFocus: function setFocus() {
        return _this.$refs.button.focus();
      },
      visibilityIsHidden: function visibilityIsHidden() {
        return document.hidden;
      },
      registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
        return _this.$refs.button.addEventListener('blur', handler, true);
      },
      deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
        return _this.$refs.button.removeEventListener('blur', handler, true);
      },
      registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
        return document.addEventListener('visibilitychange', handler);
      },
      deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
        return document.removeEventListener('visibilitychange', handler);
      },
      registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
        return document.body.addEventListener(evt, handler, true);
      },
      deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
        return document.body.removeEventListener(evt, handler, true);
      },
      registerActionClickHandler: function registerActionClickHandler(handler) {
        return _this.$refs.button.addEventListener('click', handler);
      },
      deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
        return _this.$refs.button.removeEventListener('click', handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        _this.$refs.root.addEventListener(getCorrectEventName(window, 'transitionend'), handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        _this.$refs.root.removeEventListener(getCorrectEventName(window, 'transitionend'), handler);
      },
      notifyShow: function notifyShow() {
        return _this.$emit('show');
      },
      notifyHide: function notifyHide() {
        return _this.$emit('hide');
      }
    });
    this.foundation.init();
    if (this.event) {
      this.eventSource.$on(this.event, function (data) {
        _this.foundation.show(data);
      });
    }
    this.foundation.setDismissOnAction(this.dismissesOnAction);
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCSnackbar = BasePlugin({
  mdcSnackbar: mdcSnackbar
});

var mdcSwitch = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch-wrapper", class: { 'mdc-form-field': this.hasLabel, 'mdc-form-field--align-end': this.hasLabel && this.alignEnd } }, [_c('div', { staticClass: "mdc-switch", class: { 'mdc-switch--disabled': _vm.disabled } }, [_c('input', { ref: "control", staticClass: "mdc-switch__native-control", attrs: { "type": "checkbox", "name": _vm.name, "id": _vm._uid, "disabled": _vm.disabled }, domProps: { "checked": _vm.checked }, on: { "change": _vm.onChanged } }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _vm.hasLabel ? _c('label', { staticClass: "mdc-switch-label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
  }, staticRenderFns: [function () {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch__background" }, [_c('div', { staticClass: "mdc-switch__knob" })]);
  }],
  name: 'mdc-switch',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    'checked': Boolean,
    'label': String,
    'alignEnd': Boolean,
    'disabled': Boolean,
    'value': { type: String, default: function _default() {
        return 'on';
      }
    },
    'name': String
  },
  computed: {
    hasLabel: function hasLabel() {
      return this.label || this.$slots.default;
    }
  },
  methods: {
    onChanged: function onChanged(event) {
      this.$emit('change', event.target.checked);
    }
  }
};

var VueMDCSwitch = BasePlugin({
  mdcSwitch: mdcSwitch
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$14 = {
  ACTIVE: 'mdc-tab--active'
};

var strings$16 = {
  SELECTED_EVENT: 'MDCTab:selected'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCTabFoundation = function (_MDCFoundation) {
  inherits(MDCTabFoundation, _MDCFoundation);
  createClass(MDCTabFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$14;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$16;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        getOffsetWidth: function getOffsetWidth() {
          return (/* number */0
          );
        },
        getOffsetLeft: function getOffsetLeft() {
          return (/* number */0
          );
        },
        notifySelected: function notifySelected() {}
      };
    }
  }]);

  function MDCTabFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, MDCTabFoundation);

    var _this = possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, _extends(MDCTabFoundation.defaultAdapter, adapter)));

    _this.computedWidth_ = 0;
    _this.computedLeft_ = 0;
    _this.isActive_ = false;
    _this.preventDefaultOnClick_ = false;

    _this.clickHandler_ = function (evt) {
      if (_this.preventDefaultOnClick_) {
        evt.preventDefault();
      }
      _this.adapter_.notifySelected();
    };

    _this.keydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
        _this.adapter_.notifySelected();
      }
    };
    return _this;
  }

  createClass(MDCTabFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
    }
  }, {
    key: 'getComputedWidth',
    value: function getComputedWidth() {
      return this.computedWidth_;
    }
  }, {
    key: 'getComputedLeft',
    value: function getComputedLeft() {
      return this.computedLeft_;
    }
  }, {
    key: 'isActive',
    value: function isActive() {
      return this.isActive_;
    }
  }, {
    key: 'setActive',
    value: function setActive(isActive) {
      this.isActive_ = isActive;
      if (this.isActive_) {
        this.adapter_.addClass(cssClasses$14.ACTIVE);
      } else {
        this.adapter_.removeClass(cssClasses$14.ACTIVE);
      }
    }
  }, {
    key: 'preventsDefaultOnClick',
    value: function preventsDefaultOnClick() {
      return this.preventDefaultOnClick_;
    }
  }, {
    key: 'setPreventDefaultOnClick',
    value: function setPreventDefaultOnClick(preventDefaultOnClick) {
      this.preventDefaultOnClick_ = preventDefaultOnClick;
    }
  }, {
    key: 'measureSelf',
    value: function measureSelf() {
      this.computedWidth_ = this.adapter_.getOffsetWidth();
      this.computedLeft_ = this.adapter_.getOffsetLeft();
    }
  }]);
  return MDCTabFoundation;
}(MDCFoundation);

var mdcTab = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-tab", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [!!_vm.hasIcon ? _c('i', { ref: "icon", staticClass: "mdc-tab__icon", class: _vm.hasIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("icon", [_vm._v(_vm._s(_vm.hasIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasText ? _c('span', { class: { 'mdc-tab__icon-text': !!_vm.hasIcon } }, [_vm._t("default")], 2) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-tab',
  mixins: [CustomLinkMixin, DispatchEventMixin],
  props: {
    active: Boolean,
    icon: [String, Array, Object]
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    hasIcon: function hasIcon() {
      if (this.icon || this.$slots.icon) {
        this.icon ? extractIconProp(this.icon) : {};
      }
      return false;
    },
    hasText: function hasText() {
      return !!this.$slots.default;
    }
  },
  methods: {
    getComputedWidth: function getComputedWidth() {
      return this.foundation.getComputedWidth();
    },
    getComputedLeft: function getComputedLeft() {
      return this.foundation.getComputedLeft();
    },
    isActive: function isActive() {
      return this.foundation.isActive();
    },
    setActive: function setActive(isActive) {
      this.foundation.setActive(isActive);
    },
    isDefaultPreventedOnClick: function isDefaultPreventedOnClick() {
      return this.foundation.preventsDefaultOnClick();
    },
    setPreventDefaultOnClick: function setPreventDefaultOnClick(preventDefaultOnClick) {
      this.foundation.setPreventDefaultOnClick(preventDefaultOnClick);
    },
    measureSelf: function measureSelf() {
      this.foundation.measureSelf();
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCTabFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$el.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$el.removeEventListener(type, handler);
      },
      getOffsetWidth: function getOffsetWidth() {
        return _this.$el.offsetWidth;
      },
      getOffsetLeft: function getOffsetLeft() {
        return _this.$el.offsetLeft;
      },
      notifySelected: function notifySelected() {
        emitCustomEvent(_this.$el, MDCTabFoundation.strings.SELECTED_EVENT, { tab: _this }, true);
      }
    });
    this.foundation.init();
    this.setActive(this.active);
    this.ripple = new RippleBase(this);
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
    this.ripple.destroy();
  }
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$15 = {
  UPGRADED: 'mdc-tab-bar-upgraded'
};

var strings$17 = {
  TAB_SELECTOR: '.mdc-tab',
  INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
  CHANGE_EVENT: 'MDCTabBar:change'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCTabBarFoundation = function (_MDCFoundation) {
  inherits(MDCTabBarFoundation, _MDCFoundation);
  createClass(MDCTabBarFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$15;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$17;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
        unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        getOffsetWidth: function getOffsetWidth() {
          return (/* number */0
          );
        },
        setStyleForIndicator: function setStyleForIndicator() /* propertyName: string, value: string */{},
        getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
          return (/* number */0
          );
        },
        notifyChange: function notifyChange() /* evtData: {activeTabIndex: number} */{},
        getNumberOfTabs: function getNumberOfTabs() {
          return (/* number */0
          );
        },
        isTabActiveAtIndex: function isTabActiveAtIndex() {
          return (/* index: number */ /* boolean */false
          );
        },
        setTabActiveAtIndex: function setTabActiveAtIndex() /* index: number, isActive: true */{},
        isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
          return (/* index: number */ /* boolean */false
          );
        },
        setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex() /* index: number, preventDefaultOnClick: boolean */{},
        measureTabAtIndex: function measureTabAtIndex() /* index: number */{},
        getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
          return (/* index: number */ /* number */0
          );
        },
        getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
          return (/* index: number */ /* number */0
          );
        }
      };
    }
  }]);

  function MDCTabBarFoundation(adapter) {
    classCallCheck(this, MDCTabBarFoundation);

    var _this = possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, _extends(MDCTabBarFoundation.defaultAdapter, adapter)));

    _this.isIndicatorShown_ = false;
    _this.computedWidth_ = 0;
    _this.computedLeft_ = 0;
    _this.activeTabIndex_ = 0;
    _this.layoutFrame_ = 0;
    _this.resizeHandler_ = function () {
      return _this.layout();
    };
    return _this;
  }

  createClass(MDCTabBarFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.addClass(cssClasses$15.UPGRADED);
      this.adapter_.bindOnMDCTabSelectedEvent();
      this.adapter_.registerResizeHandler(this.resizeHandler_);
      var activeTabIndex = this.findActiveTabIndex_();
      if (activeTabIndex >= 0) {
        this.activeTabIndex_ = activeTabIndex;
      }
      this.layout();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.removeClass(cssClasses$15.UPGRADED);
      this.adapter_.unbindOnMDCTabSelectedEvent();
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'layoutInternal_',
    value: function layoutInternal_() {
      var _this2 = this;

      this.forEachTabIndex_(function (index) {
        return _this2.adapter_.measureTabAtIndex(index);
      });
      this.computedWidth_ = this.adapter_.getOffsetWidth();
      this.layoutIndicator_();
    }
  }, {
    key: 'layoutIndicator_',
    value: function layoutIndicator_() {
      var isIndicatorFirstRender = !this.isIndicatorShown_;

      // Ensure that indicator appears in the right position immediately for correct first render.
      if (isIndicatorFirstRender) {
        this.adapter_.setStyleForIndicator('transition', 'none');
      }

      var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
      var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();

      var transformValue = 'translateX(' + translateAmtForActiveTabLeft + 'px) scale(' + scaleAmtForActiveTabWidth + ', 1)';
      this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

      if (isIndicatorFirstRender) {
        // Force layout so that transform styles to take effect.
        this.adapter_.getOffsetWidthForIndicator();
        this.adapter_.setStyleForIndicator('transition', '');
        this.adapter_.setStyleForIndicator('visibility', 'visible');
        this.isIndicatorShown_ = true;
      }
    }
  }, {
    key: 'findActiveTabIndex_',
    value: function findActiveTabIndex_() {
      var _this3 = this;

      var activeTabIndex = -1;
      this.forEachTabIndex_(function (index) {
        if (_this3.adapter_.isTabActiveAtIndex(index)) {
          activeTabIndex = index;
          return true;
        }
      });
      return activeTabIndex;
    }
  }, {
    key: 'forEachTabIndex_',
    value: function forEachTabIndex_(iterator) {
      var numTabs = this.adapter_.getNumberOfTabs();
      for (var index = 0; index < numTabs; index++) {
        var shouldBreak = iterator(index);
        if (shouldBreak) {
          break;
        }
      }
    }
  }, {
    key: 'layout',
    value: function layout() {
      var _this4 = this;

      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }

      this.layoutFrame_ = requestAnimationFrame(function () {
        _this4.layoutInternal_();
        _this4.layoutFrame_ = 0;
      });
    }
  }, {
    key: 'switchToTabAtIndex',
    value: function switchToTabAtIndex(index, shouldNotify) {
      var _this5 = this;

      if (index === this.activeTabIndex_) {
        return;
      }

      if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
        throw new Error('Out of bounds index specified for tab: ' + index);
      }

      var prevActiveTabIndex = this.activeTabIndex_;
      this.activeTabIndex_ = index;
      requestAnimationFrame(function () {
        if (prevActiveTabIndex >= 0) {
          _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
        }
        _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);
        _this5.layoutIndicator_();
        if (shouldNotify) {
          _this5.adapter_.notifyChange({ activeTabIndex: _this5.activeTabIndex_ });
        }
      });
    }
  }, {
    key: 'getActiveTabIndex',
    value: function getActiveTabIndex() {
      return this.findActiveTabIndex_();
    }
  }]);
  return MDCTabBarFoundation;
}(MDCFoundation);

var mdcTabBar = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-tab-bar", class: _vm.classes }, [_vm._t("default"), _vm._v(" "), _c('span', { ref: "indicator", staticClass: "mdc-tab-bar__indicator", style: _vm.indicatorStyles })], 2);
  }, staticRenderFns: [],
  name: 'mdc-tab-bar',
  props: {
    'indicator-primary': Boolean,
    'indicator-accent': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-tab-bar--indicator-primary': this.indicatorPrimary,
        'mdc-tab-bar--indicator-accent': this.indicatorAccent
      },
      indicatorStyles: {},
      tabs: []
    };
  },

  methods: {
    onSelect: function onSelect(_ref) {
      var detail = _ref.detail;
      var tab = detail.tab;

      var index = this.tabs.indexOf(tab);
      if (index < 0) {
        throw new Error('mdc-tab-bar internal error: index not found');
      }
      this.foundation.switchToTabAtIndex(index, true);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCTabBarFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
        _this.$el.addEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
      },
      unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
        return _this.$el.removeEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        return window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        return window.removeEventListener('resize', handler);
      },
      getOffsetWidth: function getOffsetWidth() {
        return _this.$el.offsetWidth;
      },
      setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
        return _this.$set(_this.indicatorStyles, propertyName, value);
      },
      getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
        return _this.$refs.indicator.offsetWidth;
      },
      notifyChange: function notifyChange(evtData) {
        _this.$emit('change', evtData.activeTabIndex);
      },
      getNumberOfTabs: function getNumberOfTabs() {
        return _this.tabs.length;
      },
      isTabActiveAtIndex: function isTabActiveAtIndex(index) {
        return _this.tabs[index].isActive();
      },
      setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
        _this.tabs[index].setActive(isActive);
      },
      isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
        return _this.tabs[index].isDefaultPreventedOnClick();
      },
      setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
        _this.tabs[index].setPreventDefaultOnClick(preventDefaultOnClick);
      },
      measureTabAtIndex: function measureTabAtIndex(index) {
        return _this.tabs[index].measureSelf();
      },
      getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
        return _this.tabs[index].getComputedWidth();
      },
      getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
        return _this.tabs[index].getComputedLeft();
      }
    });

    var resetTabs = function resetTabs() {
      var tabElements = [].slice.call(_this.$el.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
      _this.tabs = tabElements.map(function (el) {
        return el.__vue__;
      });

      var hasText = void 0,
          hasIcon = void 0;
      var tabs = _this.tabs;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tab = _step.value;

          if (tab.hasText) {
            hasText = true;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = tabs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _tab = _step2.value;

          if (_tab.hasIcon) {
            hasIcon = true;
            break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (hasText && hasIcon) {
        _this.$set(_this.classes, 'mdc-tab-bar--icons-with-text', true);
      } else if (hasIcon) {
        _this.$set(_this.classes, 'mdc-tab-bar--icon-tab-bar', true);
      }

      if (_this.foundation) {
        var activeTabIndex = _this.foundation.getActiveTabIndex();
        if (activeTabIndex >= 0) {
          _this.foundation.switchToTabAtIndex(activeTabIndex, true);
        } else {
          _this.foundation.switchToTabAtIndex(0, true);
        }
        _this.foundation.layout();
      }
    };

    resetTabs();

    this.slotObserver = new MutationObserver(function () {
      return resetTabs();
    });
    this.slotObserver.observe(this.$el, { childList: true, subtree: true });

    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.slotObserver.disconnect();
    this.foundation.destroy();
  }
};

var VueMDCTabs = BasePlugin({
  mdcTab: mdcTab,
  mdcTabBar: mdcTabBar
});

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC TextField Line Ripple.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the line ripple into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCLineRippleAdapter = function () {
  function MDCLineRippleAdapter() {
    classCallCheck(this, MDCLineRippleAdapter);
  }

  createClass(MDCLineRippleAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the line ripple element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the line ripple element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /**
     * Sets an attribute with a given value on the line ripple element.
     * @param {string} attr
     * @param {string} value
     */

  }, {
    key: "setAttr",
    value: function setAttr(attr, value) {}

    /**
     * Registers an event listener on the line ripple element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerEventHandler",
    value: function registerEventHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the line ripple element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterEventHandler",
    value: function deregisterEventHandler(evtType, handler) {}
  }]);
  return MDCLineRippleAdapter;
}();

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$16 = {
  LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
  LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCLineRippleAdapter>}
 * @final
 */

var MDCLineRippleFoundation = function (_MDCFoundation) {
  inherits(MDCLineRippleFoundation, _MDCFoundation);
  createClass(MDCLineRippleFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$16;
    }

    /**
     * {@see MDCLineRippleAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCLineRippleAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCLineRippleAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          setAttr: function setAttr() {},
          registerEventHandler: function registerEventHandler() {},
          deregisterEventHandler: function deregisterEventHandler() {}
        }
      );
    }

    /**
     * @param {!MDCLineRippleAdapter=} adapter
     */

  }]);

  function MDCLineRippleFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /** @type {!MDCLineRippleAdapter} */{};
    classCallCheck(this, MDCLineRippleFoundation);

    /** @private {function(!Event): undefined} */
    var _this = possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));

    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd(evt);
    };
    return _this;
  }

  createClass(MDCLineRippleFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
    }

    /**
     * Activates the line ripple
     */

  }, {
    key: 'activate',
    value: function activate() {
      this.adapter_.removeClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);
      this.adapter_.addClass(cssClasses$16.LINE_RIPPLE_ACTIVE);
    }

    /**
     * Sets the center of the ripple animation to the given X coordinate.
     * @param {!number} xCoordinate
     */

  }, {
    key: 'setRippleCenter',
    value: function setRippleCenter(xCoordinate) {
      var attributeString = 'transform-origin: ' + xCoordinate + 'px center';

      this.adapter_.setAttr('style', attributeString);
    }

    /**
     * Deactivates the line ripple
     */

  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.adapter_.addClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);
    }

    /**
     * Handles a transition end event
     * @param {!Event} evt
     */

  }, {
    key: 'handleTransitionEnd',
    value: function handleTransitionEnd(evt) {
      // Wait for the line ripple to be either transparent or opaque
      // before emitting the animation end event
      var isDeactivating = this.adapter_.hasClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);

      if (evt.propertyName === 'opacity') {
        if (isDeactivating) {
          this.adapter_.removeClass(cssClasses$16.LINE_RIPPLE_ACTIVE);
          this.adapter_.removeClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);
        }
      }
    }
  }]);
  return MDCLineRippleFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Helper Text.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the TextField helper text into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldHelperTextAdapter = function () {
  function MDCTextFieldHelperTextAdapter() {
    classCallCheck(this, MDCTextFieldHelperTextAdapter);
  }

  createClass(MDCTextFieldHelperTextAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the helper text element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the helper text element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns whether or not the helper text element contains the given class.
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /**
     * Sets an attribute with a given value on the helper text element.
     * @param {string} attr
     * @param {string} value
     */

  }, {
    key: "setAttr",
    value: function setAttr(attr, value) {}

    /**
     * Removes an attribute from the helper text element.
     * @param {string} attr
     */

  }, {
    key: "removeAttr",
    value: function removeAttr(attr) {}

    /**
     * Sets the text content for the helper text element.
     * @param {string} content
     */

  }, {
    key: "setContent",
    value: function setContent(content) {}
  }]);
  return MDCTextFieldHelperTextAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$18 = {
  ARIA_HIDDEN: 'aria-hidden',
  ROLE: 'role'
};

/** @enum {string} */
var cssClasses$17 = {
  HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
  HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
 * @final
 */

var MDCTextFieldHelperTextFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);
  createClass(MDCTextFieldHelperTextFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$17;
    }

    /** @return enum {string} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$18;
    }

    /**
     * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldHelperTextAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldHelperTextAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          setAttr: function setAttr() {},
          removeAttr: function removeAttr() {},
          setContent: function setContent() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldHelperTextAdapter} adapter
     */

  }]);

  function MDCTextFieldHelperTextFoundation(adapter) {
    classCallCheck(this, MDCTextFieldHelperTextFoundation);
    return possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
  }

  /**
   * Sets the content of the helper text field.
   * @param {string} content
   */


  createClass(MDCTextFieldHelperTextFoundation, [{
    key: 'setContent',
    value: function setContent(content) {
      this.adapter_.setContent(content);
    }

    /** @param {boolean} isPersistent Sets the persistency of the helper text. */

  }, {
    key: 'setPersistent',
    value: function setPersistent(isPersistent) {
      if (isPersistent) {
        this.adapter_.addClass(cssClasses$17.HELPER_TEXT_PERSISTENT);
      } else {
        this.adapter_.removeClass(cssClasses$17.HELPER_TEXT_PERSISTENT);
      }
    }

    /**
     * @param {boolean} isValidation True to make the helper text act as an
     *   error validation message.
     */

  }, {
    key: 'setValidation',
    value: function setValidation(isValidation) {
      if (isValidation) {
        this.adapter_.addClass(cssClasses$17.HELPER_TEXT_VALIDATION_MSG);
      } else {
        this.adapter_.removeClass(cssClasses$17.HELPER_TEXT_VALIDATION_MSG);
      }
    }

    /** Makes the helper text visible to the screen reader. */

  }, {
    key: 'showToScreenReader',
    value: function showToScreenReader() {
      this.adapter_.removeAttr(strings$18.ARIA_HIDDEN);
    }

    /**
     * Sets the validity of the helper text based on the input validity.
     * @param {boolean} inputIsValid
     */

  }, {
    key: 'setValidity',
    value: function setValidity(inputIsValid) {
      var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$17.HELPER_TEXT_PERSISTENT);
      var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$17.HELPER_TEXT_VALIDATION_MSG);
      var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

      if (validationMsgNeedsDisplay) {
        this.adapter_.setAttr(strings$18.ROLE, 'alert');
      } else {
        this.adapter_.removeAttr(strings$18.ROLE);
      }

      if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
        this.hide_();
      }
    }

    /**
     * Hides the help text from screen readers.
     * @private
     */

  }, {
    key: 'hide_',
    value: function hide_() {
      this.adapter_.setAttr(strings$18.ARIA_HIDDEN, 'true');
    }
  }]);
  return MDCTextFieldHelperTextFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Icon.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the text field icon into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldIconAdapter = function () {
  function MDCTextFieldIconAdapter() {
    classCallCheck(this, MDCTextFieldIconAdapter);
  }

  createClass(MDCTextFieldIconAdapter, [{
    key: "setAttr",

    /**
     * Sets an attribute on the icon element.
     * @param {string} attr
     * @param {string} value
     */
    value: function setAttr(attr, value) {}

    /**
     * Registers an event listener on the icon element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the icon element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}

    /**
     * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
     */

  }, {
    key: "notifyIconAction",
    value: function notifyIconAction() {}
  }]);
  return MDCTextFieldIconAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$19 = {
  ICON_EVENT: 'MDCTextField:icon'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
 * @final
 */

var MDCTextFieldIconFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldIconFoundation, _MDCFoundation);
  createClass(MDCTextFieldIconFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$19;
    }

    /**
     * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldIconAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldIconAdapter} */{
          setAttr: function setAttr() {},
          registerInteractionHandler: function registerInteractionHandler() {},
          deregisterInteractionHandler: function deregisterInteractionHandler() {},
          notifyIconAction: function notifyIconAction() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldIconAdapter} adapter
     */

  }]);

  function MDCTextFieldIconFoundation(adapter) {
    classCallCheck(this, MDCTextFieldIconFoundation);

    /** @private {function(!Event): undefined} */
    var _this = possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));

    _this.interactionHandler_ = function (evt) {
      return _this.handleInteraction(evt);
    };
    return _this;
  }

  createClass(MDCTextFieldIconFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
      });
    }

    /**
     * Sets the content of the helper text field.
     * @param {boolean} disabled
     */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      if (disabled) {
        this.adapter_.setAttr('tabindex', '-1');
      } else {
        this.adapter_.setAttr('tabindex', '0');
      }
    }

    /**
     * Handles an interaction event
     * @param {!Event} evt
     */

  }, {
    key: 'handleInteraction',
    value: function handleInteraction(evt) {
      if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
        this.adapter_.notifyIconAction();
      }
    }
  }]);
  return MDCTextFieldIconFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Label.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Text Field label into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldLabelAdapter = function () {
  function MDCTextFieldLabelAdapter() {
    classCallCheck(this, MDCTextFieldLabelAdapter);
  }

  createClass(MDCTextFieldLabelAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the label element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the label element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns the width of the label element.
     * @return {number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {}
  }]);
  return MDCTextFieldLabelAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$18 = {
  LABEL_FLOAT_ABOVE: 'mdc-text-field__label--float-above',
  LABEL_SHAKE: 'mdc-text-field__label--shake'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldLabelAdapter>}
 * @final
 */

var MDCTextFieldLabelFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldLabelFoundation, _MDCFoundation);
  createClass(MDCTextFieldLabelFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$18;
    }

    /**
     * {@see MDCTextFieldLabelAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldLabelAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldLabelAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          getWidth: function getWidth() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldLabelAdapter} adapter
     */

  }]);

  function MDCTextFieldLabelFoundation(adapter) {
    classCallCheck(this, MDCTextFieldLabelFoundation);
    return possibleConstructorReturn(this, (MDCTextFieldLabelFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldLabelFoundation)).call(this, _extends(MDCTextFieldLabelFoundation.defaultAdapter, adapter)));
  }

  /**
   * Returns the width of the label element.
   * @return {number}
   */


  createClass(MDCTextFieldLabelFoundation, [{
    key: 'getWidth',
    value: function getWidth() {
      return this.adapter_.getWidth();
    }

    /**
     * Styles the label to produce the label shake for errors.
     * @param {boolean} isValid Whether the input's value is valid (passes all
     *     validity checks).
     * @param {boolean} isFocused Whether the input is focused.
     */

  }, {
    key: 'styleShake',
    value: function styleShake(isValid, isFocused) {
      var LABEL_SHAKE = MDCTextFieldLabelFoundation.cssClasses.LABEL_SHAKE;

      if (isValid || isFocused) {
        this.adapter_.removeClass(LABEL_SHAKE);
      } else {
        this.adapter_.addClass(LABEL_SHAKE);
      }
    }

    /**
     * Styles the label to float or defloat as necessary.
     * @param {string} value The value of the input.
     * @param {boolean} isFocused Whether the input is focused.
     * @param {boolean} isBadInput The input's `validity.badInput` value.
     */

  }, {
    key: 'styleFloat',
    value: function styleFloat(value, isFocused, isBadInput) {
      var _MDCTextFieldLabelFou = MDCTextFieldLabelFoundation.cssClasses,
          LABEL_FLOAT_ABOVE = _MDCTextFieldLabelFou.LABEL_FLOAT_ABOVE,
          LABEL_SHAKE = _MDCTextFieldLabelFou.LABEL_SHAKE;

      if (!!value || isFocused) {
        this.adapter_.addClass(LABEL_FLOAT_ABOVE);
      } else if (!isBadInput) {
        this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }
  }]);
  return MDCTextFieldLabelFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Outline.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Text Field outline into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldOutlineAdapter = function () {
  function MDCTextFieldOutlineAdapter() {
    classCallCheck(this, MDCTextFieldOutlineAdapter);
  }

  createClass(MDCTextFieldOutlineAdapter, [{
    key: "getWidth",

    /**
     * Returns the width of the root element.
     * @return {number}
     */
    value: function getWidth() {}

    /**
     * Returns the height of the root element.
     * @return {number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {}

    /**
     * Sets the "d" attribute of the outline element's SVG path.
     * @param {string} value
     */

  }, {
    key: "setOutlinePathAttr",
    value: function setOutlinePathAttr(value) {}

    /**
     * Returns the idle outline element's computed style value of the given css property `propertyName`.
     * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
     * @param {string} propertyName
     * @return {string}
     */

  }, {
    key: "getIdleOutlineStyleValue",
    value: function getIdleOutlineStyleValue(propertyName) {}
  }]);
  return MDCTextFieldOutlineAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$20 = {
  PATH_SELECTOR: '.mdc-text-field__outline-path',
  IDLE_OUTLINE_SELECTOR: '.mdc-text-field__idle-outline'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldOutlineAdapter>}
 * @final
 */

var MDCTextFieldOutlineFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldOutlineFoundation, _MDCFoundation);
  createClass(MDCTextFieldOutlineFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$20;
    }

    /**
     * {@see MDCTextFieldOutlineAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldOutlineAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldOutlineAdapter} */{
          getWidth: function getWidth() {},
          getHeight: function getHeight() {},
          setOutlinePathAttr: function setOutlinePathAttr() {},
          getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldOutlineAdapter} adapter
     */

  }]);

  function MDCTextFieldOutlineFoundation(adapter) {
    classCallCheck(this, MDCTextFieldOutlineFoundation);
    return possibleConstructorReturn(this, (MDCTextFieldOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldOutlineFoundation)).call(this, _extends(MDCTextFieldOutlineFoundation.defaultAdapter, adapter)));
  }

  /**
   * Updates the SVG path of the focus outline element based on the given width of the
   * label element and the RTL context.
   * @param {number} labelWidth
   * @param {boolean=} isRtl
   */


  createClass(MDCTextFieldOutlineFoundation, [{
    key: 'updateSvgPath',
    value: function updateSvgPath(labelWidth) {
      var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
      var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
      var radius = parseFloat(radiusStyleValue);
      var width = this.adapter_.getWidth();
      var height = this.adapter_.getHeight();
      var cornerWidth = radius + 1.2;
      var leadingStrokeLength = Math.abs(11 - cornerWidth);
      var paddedLabelWidth = labelWidth + 8;

      // The right, bottom, and left sides of the outline follow the same SVG path.
      var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;

      var path = void 0;
      if (!isRtl) {
        path = 'M' + (cornerWidth + leadingStrokeLength + paddedLabelWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedLabelWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
      } else {
        path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedLabelWidth - leadingStrokeLength);
      }

      this.adapter_.setOutlinePathAttr(path);
    }
  }]);
  return MDCTextFieldOutlineFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/**
 * Adapter for MDC Text Field.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Text Field into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */

var MDCTextFieldAdapter = function () {
  function MDCTextFieldAdapter() {
    classCallCheck(this, MDCTextFieldAdapter);
  }

  createClass(MDCTextFieldAdapter, [{
    key: 'addClass',

    /**
     * Adds a class to the root Element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the root Element.
     * @param {string} className
     */

  }, {
    key: 'removeClass',
    value: function removeClass(className) {}

    /**
     * Returns true if the root element contains the given class name.
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: 'hasClass',
    value: function hasClass(className) {}

    /**
     * Registers an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'registerTextFieldInteractionHandler',
    value: function registerTextFieldInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'deregisterTextFieldInteractionHandler',
    value: function deregisterTextFieldInteractionHandler(type, handler) {}

    /**
     * Registers an event listener on the native input element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'registerInputInteractionHandler',
    value: function registerInputInteractionHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the native input element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'deregisterInputInteractionHandler',
    value: function deregisterInputInteractionHandler(evtType, handler) {}

    /**
     * Returns an object representing the native text input element, with a
     * similar API shape. The object returned should include the value, disabled
     * and badInput properties, as well as the checkValidity() function. We never
     * alter the value within our code, however we do update the disabled
     * property, so if you choose to duck-type the return value for this method
     * in your implementation it's important to keep this in mind. Also note that
     * this method can return null, which the foundation will handle gracefully.
     * @return {?Element|?NativeInputType}
     */

  }, {
    key: 'getNativeInput',
    value: function getNativeInput() {}

    /**
     * Returns true if the textfield is focused.
     * We achieve this via `document.activeElement === this.root_`.
     * @return {boolean}
     */

  }, {
    key: 'isFocused',
    value: function isFocused() {}

    /**
     * Returns true if the direction of the root element is set to RTL.
     * @return {boolean}
     */

  }, {
    key: 'isRtl',
    value: function isRtl() {}

    /**
     * Activates the line ripple.
     */

  }, {
    key: 'activateLineRipple',
    value: function activateLineRipple() {}

    /**
     * Deactivates the line ripple.
     */

  }, {
    key: 'deactivateLineRipple',
    value: function deactivateLineRipple() {}

    /**
     * Sets the transform origin of the line ripple.
     * @param {number} normalizedX
     */

  }, {
    key: 'setLineRippleTransformOrigin',
    value: function setLineRippleTransformOrigin(normalizedX) {}
  }]);
  return MDCTextFieldAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$21 = {
  ARIA_CONTROLS: 'aria-controls',
  INPUT_SELECTOR: '.mdc-text-field__input',
  LABEL_SELECTOR: '.mdc-text-field__label',
  ICON_SELECTOR: '.mdc-text-field__icon',
  OUTLINE_SELECTOR: '.mdc-text-field__outline',
  BOTTOM_LINE_SELECTOR: '.mdc-line-ripple'
};

/** @enum {string} */
var cssClasses$19 = {
  ROOT: 'mdc-text-field',
  UPGRADED: 'mdc-text-field--upgraded',
  DISABLED: 'mdc-text-field--disabled',
  DENSE: 'mdc-text-field--dense',
  FOCUSED: 'mdc-text-field--focused',
  INVALID: 'mdc-text-field--invalid',
  BOX: 'mdc-text-field--box',
  OUTLINED: 'mdc-text-field--outlined'
};

/** @enum {number} */
var numbers$5 = {
  LABEL_SCALE: 0.75,
  DENSE_LABEL_SCALE: 0.923
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint-enable no-unused-vars */
/**
 * @extends {MDCFoundation<!MDCTextFieldAdapter>}
 * @final
 */

var MDCTextFieldFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldFoundation, _MDCFoundation);
  createClass(MDCTextFieldFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$19;
    }

    /** @return enum {string} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$21;
    }

    /** @return enum {string} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$5;
    }

    /**
     * {@see MDCTextFieldAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
          deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
          registerInputInteractionHandler: function registerInputInteractionHandler() {},
          deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
          getNativeInput: function getNativeInput() {},
          isFocused: function isFocused() {},
          isRtl: function isRtl() {},
          activateLineRipple: function activateLineRipple() {},
          deactivateLineRipple: function deactivateLineRipple() {},
          setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldAdapter} adapter
     * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
     */

  }]);

  function MDCTextFieldFoundation(adapter) {
    var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {!FoundationMapType} */{};
    classCallCheck(this, MDCTextFieldFoundation);

    /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
    var _this = possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));

    _this.helperText_ = foundationMap.helperText;
    /** @type {!MDCTextFieldIconFoundation|undefined} */
    _this.icon_ = foundationMap.icon;
    /** @type {!MDCTextFieldLabelFoundation|undefined} */
    _this.label_ = foundationMap.label;
    /** @type {!MDCTextFieldOutlineFoundation|undefined} */
    _this.outline_ = foundationMap.outline;

    /** @private {boolean} */
    _this.isFocused_ = false;
    /** @private {boolean} */
    _this.receivedUserInput_ = false;
    /** @private {boolean} */
    _this.useCustomValidityChecking_ = false;
    /** @private {boolean} */
    _this.isValid_ = true;
    /** @private {function(): undefined} */
    _this.inputFocusHandler_ = function () {
      return _this.activateFocus();
    };
    /** @private {function(): undefined} */
    _this.inputBlurHandler_ = function () {
      return _this.deactivateFocus();
    };
    /** @private {function(): undefined} */
    _this.inputInputHandler_ = function () {
      return _this.autoCompleteFocus();
    };
    /** @private {function(!Event): undefined} */
    _this.setPointerXOffset_ = function (evt) {
      return _this.setTransformOrigin(evt);
    };
    /** @private {function(!Event): undefined} */
    _this.textFieldInteractionHandler_ = function () {
      return _this.handleTextFieldInteraction();
    };
    return _this;
  }

  createClass(MDCTextFieldFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
      // Ensure label does not collide with any pre-filled value.
      if (this.label_ && this.getValue()) {
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }

      if (this.adapter_.isFocused()) {
        this.inputFocusHandler_();
      }

      this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
      this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
      this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
      ['mousedown', 'touchstart'].forEach(function (evtType) {
        _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
      });
      ['click', 'keydown'].forEach(function (evtType) {
        _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
      this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
      this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
      this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
      ['mousedown', 'touchstart'].forEach(function (evtType) {
        _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
      });
      ['click', 'keydown'].forEach(function (evtType) {
        _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
      });
    }

    /**
     * Handles user interactions with the Text Field.
     */

  }, {
    key: 'handleTextFieldInteraction',
    value: function handleTextFieldInteraction() {
      if (this.adapter_.getNativeInput().disabled) {
        return;
      }
      this.receivedUserInput_ = true;
    }

    /**
     * Updates the focus outline for outlined text fields.
     */

  }, {
    key: 'updateOutline',
    value: function updateOutline() {
      if (!this.outline_ || !this.label_) {
        return;
      }

      var isDense = this.adapter_.hasClass(cssClasses$19.DENSE);
      var labelScale = isDense ? numbers$5.DENSE_LABEL_SCALE : numbers$5.LABEL_SCALE;
      var labelWidth = this.label_.getWidth() * labelScale;
      var isRtl = this.adapter_.isRtl();
      this.outline_.updateSvgPath(labelWidth, isRtl);
    }

    /**
     * Activates the text field focus state.
     */

  }, {
    key: 'activateFocus',
    value: function activateFocus() {
      this.isFocused_ = true;
      this.styleFocused_(this.isFocused_);
      this.adapter_.activateLineRipple();
      if (this.outline_) {
        this.updateOutline();
      }
      if (this.label_) {
        this.label_.styleShake(this.isValid(), this.isFocused_);
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }
      if (this.helperText_) {
        this.helperText_.showToScreenReader();
      }
    }

    /**
     * Sets the line ripple's transform origin, so that the line ripple activate
     * animation will animate out from the user's click location.
     * @param {!Event} evt
     */

  }, {
    key: 'setTransformOrigin',
    value: function setTransformOrigin(evt) {
      var targetClientRect = evt.target.getBoundingClientRect();
      var evtCoords = { x: evt.clientX, y: evt.clientY };
      var normalizedX = evtCoords.x - targetClientRect.left;
      this.adapter_.setLineRippleTransformOrigin(normalizedX);
    }

    /**
     * Activates the Text Field's focus state in cases when the input value
     * changes without user input (e.g. programatically).
     */

  }, {
    key: 'autoCompleteFocus',
    value: function autoCompleteFocus() {
      if (!this.receivedUserInput_) {
        this.activateFocus();
      }
    }

    /**
     * Deactivates the Text Field's focus state.
     */

  }, {
    key: 'deactivateFocus',
    value: function deactivateFocus() {
      this.isFocused_ = false;
      this.adapter_.deactivateLineRipple();
      var input = this.getNativeInput_();
      var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
      var isValid = this.isValid();
      this.styleValidity_(isValid);
      this.styleFocused_(this.isFocused_);
      if (this.label_) {
        this.label_.styleShake(this.isValid(), this.isFocused_);
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }
      if (shouldRemoveLabelFloat) {
        this.receivedUserInput_ = false;
      }
    }

    /**
     * @return {string} The value of the input Element.
     */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.getNativeInput_().value;
    }

    /**
     * @param {string} value The value to set on the input Element.
     */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.getNativeInput_().value = value;
      var isValid = this.isValid();
      this.styleValidity_(isValid);
      if (this.label_) {
        this.label_.styleShake(isValid, this.isFocused_);
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }
    }

    /**
     * @return {boolean} If a custom validity is set, returns that value.
     *     Otherwise, returns the result of native validity checks.
     */

  }, {
    key: 'isValid',
    value: function isValid() {
      return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
    }

    /**
     * @param {boolean} isValid Sets the validity state of the Text Field.
     */

  }, {
    key: 'setValid',
    value: function setValid(isValid) {
      this.useCustomValidityChecking_ = true;
      this.isValid_ = isValid;
      // Retrieve from the getter to ensure correct logic is applied.
      isValid = this.isValid();
      this.styleValidity_(isValid);
      if (this.label_) {
        this.label_.styleShake(isValid, this.isFocused_);
      }
    }

    /**
     * @return {boolean} True if the Text Field is disabled.
     */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.getNativeInput_().disabled;
    }

    /**
     * @param {boolean} disabled Sets the text-field disabled or enabled.
     */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      this.getNativeInput_().disabled = disabled;
      this.styleDisabled_(disabled);
    }

    /**
     * @return {boolean} True if the Text Field is required.
     */

  }, {
    key: 'isRequired',
    value: function isRequired() {
      return this.getNativeInput_().required;
    }

    /**
     * @param {boolean} isRequired Sets the text-field required or not.
     */

  }, {
    key: 'setRequired',
    value: function setRequired(isRequired) {
      this.getNativeInput_().required = isRequired;
      // Addition of the asterisk is automatic based on CSS, but validity checking
      // needs to be manually run.
      this.styleValidity_(this.isValid());
    }

    /**
     * @param {string} content Sets the content of the helper text.
     */

  }, {
    key: 'setHelperTextContent',
    value: function setHelperTextContent(content) {
      if (this.helperText_) {
        this.helperText_.setContent(content);
      }
    }

    /**
     * @return {boolean} True if the Text Field input fails in converting the
     *     user-supplied value.
     * @private
     */

  }, {
    key: 'isBadInput_',
    value: function isBadInput_() {
      return this.getNativeInput_().validity.badInput;
    }

    /**
     * @return {boolean} The result of native validity checking
     *     (ValidityState.valid).
     */

  }, {
    key: 'isNativeInputValid_',
    value: function isNativeInputValid_() {
      return this.getNativeInput_().validity.valid;
    }

    /**
     * Styles the component based on the validity state.
     * @param {boolean} isValid
     * @private
     */

  }, {
    key: 'styleValidity_',
    value: function styleValidity_(isValid) {
      var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

      if (isValid) {
        this.adapter_.removeClass(INVALID);
      } else {
        this.adapter_.addClass(INVALID);
      }
      if (this.helperText_) {
        this.helperText_.setValidity(isValid);
      }
    }

    /**
     * Styles the component based on the focused state.
     * @param {boolean} isFocused
     * @private
     */

  }, {
    key: 'styleFocused_',
    value: function styleFocused_(isFocused) {
      var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

      if (isFocused) {
        this.adapter_.addClass(FOCUSED);
      } else {
        this.adapter_.removeClass(FOCUSED);
      }
    }

    /**
     * Styles the component based on the disabled state.
     * @param {boolean} isDisabled
     * @private
     */

  }, {
    key: 'styleDisabled_',
    value: function styleDisabled_(isDisabled) {
      var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
          DISABLED = _MDCTextFieldFoundati.DISABLED,
          INVALID = _MDCTextFieldFoundati.INVALID;

      if (isDisabled) {
        this.adapter_.addClass(DISABLED);
        this.adapter_.removeClass(INVALID);
      } else {
        this.adapter_.removeClass(DISABLED);
      }
      if (this.icon_) {
        this.icon_.setDisabled(isDisabled);
      }
    }

    /**
     * @return {!Element|!NativeInputType} The native text input from the
     * host environment, or a dummy if none exists.
     * @private
     */

  }, {
    key: 'getNativeInput_',
    value: function getNativeInput_() {
      return this.adapter_.getNativeInput() ||
      /** @type {!NativeInputType} */{
        value: '',
        disabled: false,
        validity: {
          badInput: false,
          valid: true
        }
      };
    }
  }]);
  return MDCTextFieldFoundation;
}(MDCFoundation);

var mdcTextField = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-textfield-wrapper", style: { width: _vm.fullwidth ? '100%' : undefined } }, [_c('div', { ref: "root", class: _vm.rootClasses }, [!!_vm.hasLeadingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasLeadingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("leading-icon", [_vm._v(_vm._s(_vm.hasLeadingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.multiline ? _c('textarea', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls, "rows": _vm.rows, "cols": _vm.cols }, on: { "input": function input($event) {
          _vm.updateValue($event.target.value);
        } } }, 'textarea', _vm.inputAttrs, false), _vm.$listeners)) : _c('input', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "type": _vm.type, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls }, on: { "input": function input($event) {
          _vm.updateValue($event.target.value);
        } } }, 'input', _vm.inputAttrs, false), _vm.$listeners)), _vm._v(" "), _vm.hasLabel ? _c('label', { ref: "label", class: _vm.labelClassesUpgraded, attrs: { "for": _vm._uid } }, [_vm._v(" " + _vm._s(_vm.label) + " ")]) : _vm._e(), _vm._v(" "), !!_vm.hasTrailingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasTrailingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("trailing-icon", [_vm._v(_vm._s(_vm.hasTrailingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outline", staticClass: "mdc-text-field__outline" }, [_c('svg', [_c('path', { staticClass: "mdc-text-field__outline-path", attrs: { "d": _vm.outlinePathAttr } })])]) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outlineIdle", staticClass: "mdc-text-field__idle-outline" }) : _vm._e(), _vm._v(" "), _vm.hasBottomLine ? _c('div', { ref: "bottom", class: _vm.bottomClasses }) : _vm._e()]), _vm._v(" "), _vm.helptext ? _c('p', { ref: "help", class: _vm.helpClasses, attrs: { "id": 'help-' + _vm._uid, "aria-hidden": "true" } }, [_vm._v(" " + _vm._s(_vm.helptext) + " ")]) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-textfield',
  mixins: [CustomElementMixin, DispatchFocusMixin],
  model: {
    prop: 'value',
    event: 'model'
  },
  props: {
    value: String,
    type: {
      type: String,
      default: 'text',
      validator: function validator(value) {
        return ['text', 'email', 'search', 'password', 'tel', 'url'].indexOf(value) !== -1;
      }
    },
    dense: Boolean,
    label: String,
    helptext: String,
    helptextPersistent: Boolean,
    helptextValidation: Boolean,
    box: Boolean,
    outline: Boolean,
    disabled: Boolean,
    required: Boolean,
    valid: { type: Boolean, default: undefined },
    fullwidth: Boolean,
    multiline: Boolean,
    leadingIcon: [String, Array, Object],
    trailingIcon: [String, Array, Object],
    size: { type: [Number, String], default: 20 },
    minlength: { type: [Number, String], default: undefined },
    maxlength: { type: [Number, String], default: undefined },
    rows: { type: [Number, String], default: 8 },
    cols: { type: [Number, String], default: 40 },

    // other input props  
    name: String,
    readonly: Boolean,
    autocomplete: Boolean,
    autofocus: Boolean
  },
  data: function data() {
    return {
      text: this.value,
      rootClasses: {
        'mdc-textfield': true,
        'mdc-text-field': true,
        'mdc-text-field--upgraded': true,
        'mdc-text-field--disabled': this.disabled,
        'mdc-text-field--dense': this.dense,
        'mdc-text-field--fullwidth': this.fullwidth,
        'mdc-text-field--textarea': this.multiline,
        'mdc-text-field--box': !this.fullwidth && this.box,
        'mdc-text-field--outlined': !this.fullwidth && this.outline
      },
      inputClasses: {
        'mdc-text-field__input': true
      },
      labelClasses: {
        'mdc-text-field__label': true
      },
      bottomClasses: {
        'mdc-line-ripple': true
      },
      helpClasses: {
        'mdc-text-field-helper-text': true,
        'mdc-text-field-helper-text--persistent': this.helptextPersistent,
        'mdc-text-field-helper-text--validation-msg': this.helptextValidation
      },
      outlinePathAttr: undefined
    };
  },
  watch: {
    disabled: function disabled() {
      this.foundation && this.foundation.setDisabled(this.disabled);
    },
    required: function required() {
      this.foundation && this.foundation.setRequired(this.disabled);
    },
    valid: function valid() {
      if (typeof this.valid !== "undefined") {
        this.foundation && this.foundation.setValid(this.valid);
      }
    },
    dense: function dense() {
      this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
    },
    helptextPersistent: function helptextPersistent() {
      this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
    },
    helptextValidation: function helptextValidation() {
      this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
    },
    value: function value(_value) {
      if (this.foundation) {
        if (_value !== this.foundation.getValue()) {
          this.foundation.setValue(_value);
        }
      }
    }
  },
  methods: {
    updateValue: function updateValue(value) {
      this.$emit('model', value);
    },
    focus: function focus() {
      this.$refs.input && this.$refs.input.focus();
    },
    blur: function blur() {
      this.$refs.input && this.$refs.input.blur();
    }
  },
  computed: {
    inputAttrs: function inputAttrs() {
      var name = this.name,
          readonly = this.readonly,
          autocomplete = this.autocomplete,
          autofocus = this.autofocus;

      return { name: name, readonly: readonly, autocomplete: autocomplete, autofocus: autofocus };
    },
    inputPlaceHolder: function inputPlaceHolder() {
      return this.fullwidth ? this.label : undefined;
    },
    inputAriaControls: function inputAriaControls() {
      return this.help ? 'help-' + this._uid : undefined;
    },
    hasLabel: function hasLabel() {
      return !this.fullwidth && this.label;
    },
    hasOutline: function hasOutline() {
      return !this.fullwidth && this.outline;
    },
    hasBottomLine: function hasBottomLine() {
      return !this.hasOutline && !this.multiline;
    },
    hasLeadingIcon: function hasLeadingIcon() {
      if ((this.leadingIcon || this.$slots['leading-icon']) && !(this.trailingIcon || this.$slots['trailing-icon'])) {
        return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
      }
      return false;
    },
    hasTrailingIcon: function hasTrailingIcon() {
      if (this.trailingIcon || this.$slots['trailing-icon']) {
        return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
      }
      return false;
    },
    labelClassesUpgraded: function labelClassesUpgraded() {
      return _extends(this.labelClasses, {
        'mdc-text-field__label--float-above': this.value
      });
    }
  },
  mounted: function mounted() {
    var _this = this;

    if (this.$refs.bottom) {
      this.bottomLineFoundation = new MDCLineRippleFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.bottomClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.bottomClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.bottomClasses.classList.contains(className);
        },
        setAttr: function setAttr(name, value) {
          _this.$refs.bottom.setAttribute(name, value);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          _this.$refs.bottom.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          _this.$refs.bottom.removeEventListener(evtType, handler);
        }
      });
      this.bottomLineFoundation.init();
    }

    if (this.$refs.help) {
      this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.helpClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.helpClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.help.classList.contains(className);
        },
        setAttr: function setAttr(name, value) {
          _this.$refs.help.setAttribute(name, value);
        },
        removeAttr: function removeAttr(name) {
          _this.$refs.help.removeAttribute(name);
        },
        setContent: function setContent() /*content*/{
          // help text get's updated from {{helptext}}
          // this.$refs.help.textContent = content;
        }
      });
      this.helperTextFoundation.init();
    }

    if (this.$refs.icon) {
      if (this.hasLeadingIcon) {
        this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
      } else if (this.hasTrailingIcon) {
        this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
      }

      this.iconFoundation = new MDCTextFieldIconFoundation({
        setAttr: function setAttr(attr, value) {
          return _this.$refs.icon.setAttribute(attr, value);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$refs.icon.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$refs.icon.removeEventListener(evtType, handler);
        },
        notifyIconAction: function notifyIconAction() {
          return _this.$emit('icon-action');
        }
      });
      this.iconFoundation.init();
    }

    if (this.$refs.label) {
      this.labelFoundation = new MDCTextFieldLabelFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.labelClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.labelClasses, className);
        },
        getWidth: function getWidth() {
          return _this.$refs.label.offsetWidth;
        }
      });
      this.labelFoundation.init();
    }

    if (this.$refs.outline) {
      this.outlineFoundation = new MDCTextFieldOutlineFoundation({
        getWidth: function getWidth() {
          return _this.$refs.outline.offsetWidth;
        },
        getHeight: function getHeight() {
          return _this.$refs.outline.offsetHeight;
        },
        setOutlinePathAttr: function setOutlinePathAttr(value) {
          _this.outlinePathAttr = value;
        },
        getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
          var idleOutlineElement = _this.$refs.outlineIdle;
          if (idleOutlineElement) {
            return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
          }
        }
      });
      this.outlineFoundation.init();
    }

    this.foundation = new MDCTextFieldFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.rootClasses, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.rootClasses, className);
      },
      hasClass: function hasClass(className) {
        _this.$refs.root.classList.contains(className);
      },
      registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
        _this.$refs.root.addEventListener(evtType, handler);
      },
      deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
        _this.$refs.root.removeEventListener(evtType, handler);
      },
      isFocused: function isFocused() {
        return document.activeElement === _this.$refs.input;
      },
      isRtl: function isRtl() {
        return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
      },
      deactivateLineRipple: function deactivateLineRipple() {
        if (_this.bottom) {
          _this.bottom.deactivate();
        }
      },
      activateLineRipple: function activateLineRipple() {
        if (_this.bottom) {
          _this.bottom.activate();
        }
      },
      setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
        if (_this.bottom) {
          _this.bottom.setRippleCenter(normalizedX);
        }
      },
      registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
        _this.$refs.input.addEventListener(evtType, handler);
      },
      deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
        _this.$refs.input.removeEventListener(evtType, handler);
      },
      getNativeInput: function getNativeInput() {
        return _this.$refs.input;
      }

    }, {
      bottomLine: this.bottomLineFoundation,
      helperText: this.helperTextFoundation,
      icon: this.iconFoundation,
      label: this.labelFoundation,
      outline: this.outlineFoundation
    });

    this.foundation.init();
    this.foundation.setValue(this.value);
    this.foundation.setDisabled(this.disabled);
    this.foundation.setRequired(this.required);
    if (typeof this.valid !== "undefined") {
      this.foundation.setValid(this.valid);
    }

    if (this.textbox) {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation && this.foundation.destroy();
    this.bottomLineFoundation && this.bottomLineFoundation.destroy();
    this.helperTextFoundation && this.helperTextFoundation.destroy();
    this.iconFoundation && this.iconFoundation.destroy();
    this.labelFoundation && this.labelFoundation.destroy();
    this.outlineFoundation && this.outlineFoundation.destroy();
    this.ripple && this.ripple.destroy();
  }
};

var VueMDCTextfield = BasePlugin({
  mdcTextField: mdcTextField
});

var THEME_COLORS = ['primary', 'secondary', 'background', 'primary-light', 'secondary-light', 'secondary-dark', 'primary-dark'];

var THEME_STYLES = ['text-primary', 'text-secondary', 'text-hint', 'text-icon', 'text-disabled'];

var mdcTheme = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-theme", class: _vm.classes, attrs: { "tag": _vm.tag } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-theme',
  components: {
    CustomElement: CustomElement
  },
  props: {
    tag: { type: String, default: 'div' },
    color: String,
    background: String
  },
  computed: {
    classes: function classes() {
      var classes = {};

      if (this.color && THEME_COLORS.indexOf(this.color) !== -1) {
        classes['mdc-theme--' + this.color] = true;
      }

      if (this.background && THEME_COLORS.indexOf(this.background) !== -1) {
        classes['mdc-theme--' + this.background + '-bg'] = true;

        if (this.color && THEME_STYLES.indexOf(this.color) !== -1) {
          classes['mdc-theme--' + this.color + '-on-' + this.background] = true;
        }
      }
      return classes;
    }
  }
};

var VueMDCTheme = BasePlugin({
  mdcTheme: mdcTheme
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$20 = {
  FIXED: 'mdc-toolbar--fixed',
  FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
  FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
  TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
  FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
  FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
  FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
};

var strings$22 = {
  TITLE_SELECTOR: '.mdc-toolbar__title',
  FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
  CHANGE_EVENT: 'MDCToolbar:change'
};

var numbers$6 = {
  MAX_TITLE_SIZE: 2.125,
  MIN_TITLE_SIZE: 1.25,
  TOOLBAR_ROW_HEIGHT: 64,
  TOOLBAR_ROW_MOBILE_HEIGHT: 56,
  TOOLBAR_MOBILE_BREAKPOINT: 600
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MDCToolbarFoundation = function (_MDCFoundation) {
  inherits(MDCToolbarFoundation, _MDCFoundation);
  createClass(MDCToolbarFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$20;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$22;
    }
  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$6;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        hasClass: function hasClass() {
          return (/* className: string */ /* boolean */false
          );
        },
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
        deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        getViewportWidth: function getViewportWidth() {
          return (/* number */0
          );
        },
        getViewportScrollY: function getViewportScrollY() {
          return (/* number */0
          );
        },
        getOffsetHeight: function getOffsetHeight() {
          return (/* number */0
          );
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          return (/* number */0
          );
        },
        notifyChange: function notifyChange() /* evtData: {flexibleExpansionRatio: number} */{},
        setStyle: function setStyle() /* property: string, value: string */{},
        setStyleForTitleElement: function setStyleForTitleElement() /* property: string, value: string */{},
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement() /* property: string, value: string */{},
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement() /* property: string, value: string */{}
      };
    }
  }]);

  function MDCToolbarFoundation(adapter) {
    classCallCheck(this, MDCToolbarFoundation);

    var _this = possibleConstructorReturn(this, (MDCToolbarFoundation.__proto__ || Object.getPrototypeOf(MDCToolbarFoundation)).call(this, _extends(MDCToolbarFoundation.defaultAdapter, adapter)));

    _this.resizeHandler_ = function () {
      return _this.checkRowHeight_();
    };
    _this.scrollHandler_ = function () {
      return _this.updateToolbarStyles_();
    };
    _this.checkRowHeightFrame_ = 0;
    _this.scrollFrame_ = 0;
    _this.executedLastChange_ = false;

    _this.calculations_ = {
      toolbarRowHeight: 0,
      // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
      toolbarRatio: 0, // The ratio of toolbar height to row height
      flexibleExpansionRatio: 0, // The ratio of flexible space height to row height
      maxTranslateYRatio: 0, // The ratio of max toolbar move up distance to row height
      scrollThresholdRatio: 0, // The ratio of max scrollTop that we should listen to to row height
      // Derived Heights based on the above key ratios.
      toolbarHeight: 0,
      flexibleExpansionHeight: 0, // Flexible row minus toolbar height (derived)
      maxTranslateYDistance: 0, // When toolbar only fix last row (derived)
      scrollThreshold: 0
    };
    // Toolbar fixed behavior
    // If toolbar is fixed
    _this.fixed_ = false;
    // If fixed is targeted only at the last row
    _this.fixedLastrow_ = false;
    // Toolbar flexible behavior
    // If the first row is flexible
    _this.hasFlexibleRow_ = false;
    // If use the default behavior
    _this.useFlexDefaultBehavior_ = false;
    return _this;
  }

  createClass(MDCToolbarFoundation, [{
    key: 'init',
    value: function init() {
      this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
      this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
      this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);
      if (this.hasFlexibleRow_) {
        this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
      }
      this.initKeyRatio_();
      this.setKeyHeights_();
      this.adapter_.registerResizeHandler(this.resizeHandler_);
      this.adapter_.registerScrollHandler(this.scrollHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      this.adapter_.deregisterScrollHandler(this.scrollHandler_);
    }
  }, {
    key: 'updateAdjustElementStyles',
    value: function updateAdjustElementStyles() {
      if (this.fixed_) {
        this.adapter_.setStyleForFixedAdjustElement('margin-top', this.calculations_.toolbarHeight + 'px');
      }
    }
  }, {
    key: 'getFlexibleExpansionRatio_',
    value: function getFlexibleExpansionRatio_(scrollTop) {
      // To prevent division by zero when there is no flexibleExpansionHeight
      var delta = 0.0001;
      return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
    }
  }, {
    key: 'checkRowHeight_',
    value: function checkRowHeight_() {
      var _this2 = this;

      cancelAnimationFrame(this.checkRowHeightFrame_);
      this.checkRowHeightFrame_ = requestAnimationFrame(function () {
        return _this2.setKeyHeights_();
      });
    }
  }, {
    key: 'setKeyHeights_',
    value: function setKeyHeights_() {
      var newToolbarRowHeight = this.getRowHeight_();
      if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
        this.calculations_.toolbarRowHeight = newToolbarRowHeight;
        this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
        this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
        this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
        this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
        this.updateAdjustElementStyles();
        this.updateToolbarStyles_();
      }
    }
  }, {
    key: 'updateToolbarStyles_',
    value: function updateToolbarStyles_() {
      var _this3 = this;

      cancelAnimationFrame(this.scrollFrame_);
      this.scrollFrame_ = requestAnimationFrame(function () {
        var scrollTop = _this3.adapter_.getViewportScrollY();
        var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

        if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
          return;
        }

        var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

        _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);
        if (_this3.fixedLastrow_) {
          _this3.updateToolbarFixedState_(scrollTop);
        }
        if (_this3.hasFlexibleRow_) {
          _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
        }
        _this3.executedLastChange_ = hasScrolledOutOfThreshold;
        _this3.adapter_.notifyChange({ flexibleExpansionRatio: flexibleExpansionRatio });
      });
    }
  }, {
    key: 'scrolledOutOfThreshold_',
    value: function scrolledOutOfThreshold_(scrollTop) {
      return scrollTop > this.calculations_.scrollThreshold;
    }
  }, {
    key: 'initKeyRatio_',
    value: function initKeyRatio_() {
      var toolbarRowHeight = this.getRowHeight_();
      var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
      this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
      this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
      this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
      this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
    }
  }, {
    key: 'getRowHeight_',
    value: function getRowHeight_() {
      var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
      return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
    }
  }, {
    key: 'updateToolbarFlexibleState_',
    value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
      this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
      this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
      if (flexibleExpansionRatio === 1) {
        this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
      } else if (flexibleExpansionRatio === 0) {
        this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
      }
    }
  }, {
    key: 'updateToolbarFixedState_',
    value: function updateToolbarFixedState_(scrollTop) {
      var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
      this.adapter_.setStyle('transform', 'translateY(' + -translateDistance + 'px)');

      if (translateDistance === this.calculations_.maxTranslateYDistance) {
        this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
      } else {
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
      }
    }
  }, {
    key: 'updateFlexibleRowElementStyles_',
    value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
      if (this.fixed_) {
        var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
        this.adapter_.setStyleForFlexibleRowElement('height', height + this.calculations_.toolbarRowHeight + 'px');
      }
      if (this.useFlexDefaultBehavior_) {
        this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
      }
    }
  }, {
    key: 'updateElementStylesDefaultBehavior_',
    value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
      var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
      var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
      var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;

      this.adapter_.setStyleForTitleElement('font-size', currentTitleSize + 'rem');
    }
  }]);
  return MDCToolbarFoundation;
}(MDCFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var supportsPassive_$2 = void 0;

// Determine whether the current browser supports passive event listeners, and if so, use them.
function applyPassive$2() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_$2 === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_$2 = isSupported;
  }

  return supportsPassive_$2 ? { passive: true } : false;
}

var mdcToolbar = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', { staticClass: "mdc-toolbar-wrapper" }, [_c('div', { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, [_vm._t("default")], 2), _vm._v(" "), _vm.fixed || _vm.waterfall || _vm.fixedLastrow ? _c('div', { ref: "fixed-adjust", staticClass: "mdc-toolbar-fixed-adjust", style: _vm.adjustStyles }) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-toolbar',
  props: {
    'fixed': Boolean,
    'waterfall': Boolean,
    'fixed-lastrow': Boolean,
    'flexible': Boolean,
    'flexible-default': { type: Boolean, default: true }
  },
  data: function data() {
    return {
      rootClasses: {
        'mdc-toolbar': true,
        'mdc-toolbar--fixed': this.fixed || this.waterfall || this.fixedLastrow,
        'mdc-toolbar--waterfall': this.waterfall,
        'mdc-toolbar--fixed-lastrow-only': this.fixedLastrow,
        'mdc-toolbar--flexible': this.flexible,
        'mdc-toolbar--flexible-default-behavior': this.flexible && this.flexibleDefault
      },
      rootStyles: {},
      adjustStyles: {
        // to avoid top margin collapse with :after el
        // 0.1 px should be rounded to 0px
        // TODO: find a better trick
        // height: '0.1px'
      },
      foundation: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCToolbarFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.rootClasses, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.rootClasses, className);
      },
      hasClass: function hasClass(className) {
        return _this.$refs.root.classList.contains(className);
      },
      registerScrollHandler: function registerScrollHandler(handler) {
        window.addEventListener('scroll', handler, applyPassive$2());
      },
      deregisterScrollHandler: function deregisterScrollHandler(handler) {
        window.removeEventListener('scroll', handler, applyPassive$2());
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        window.removeEventListener('resize', handler);
      },
      getViewportWidth: function getViewportWidth() {
        return window.innerWidth;
      },
      getViewportScrollY: function getViewportScrollY() {
        return window.pageYOffset;
      },
      getOffsetHeight: function getOffsetHeight() {
        return _this.$refs.root.offsetHeight;
      },
      getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
        var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
        return el ? el.offsetHeight : undefined;
      },
      notifyChange: function notifyChange(evtData) {
        _this.$emit('change', evtData);
      },
      setStyle: function setStyle(property, value) {
        _this.$set(_this.rootStyles, property, value);
      },
      setStyleForTitleElement: function setStyleForTitleElement(property, value) {
        var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);
        if (el) el.style.setProperty(property, value);
      },
      setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
        var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
        if (el) el.style.setProperty(property, value);
      },
      setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
        _this.$set(_this.adjustStyles, property, value);
      }
    });
    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var mdcToolbarRow = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-toolbar-row mdc-toolbar__row" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-row'
};

var mdcToolbarSection = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-toolbar-section mdc-toolbar__section", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-section',
  props: {
    'align-start': Boolean,
    'align-end': Boolean,
    'shrink-to-fit': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-toolbar__section--align-start': this.alignStart,
        'mdc-toolbar__section--align-end': this.alignEnd,
        'mdc-toolbar__section--shrink-to-fit': this.shrinkToFit
      }
    };
  }
};

var mdcToolbarMenuIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-menu-icon mdc-toolbar__menu-icon", class: { 'material-icons': !!_vm.icon }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-menu-icon',
  mixins: [DispatchEventMixin],
  props: {
    icon: { type: String, 'default': "menu" }
  }
};

var mdcToolbarTitle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-title mdc-toolbar__title", on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-title',
  mixins: [DispatchEventMixin]
};

var mdcToolbarIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-icon mdc-toolbar__icon", class: { 'material-icons': !!_vm.icon }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-icon',
  mixins: [DispatchEventMixin],
  props: {
    icon: String
  }
};

var VueMDCToolbar = BasePlugin({
  mdcToolbar: mdcToolbar,
  mdcToolbarRow: mdcToolbarRow,
  mdcToolbarSection: mdcToolbarSection,
  mdcToolbarMenuIcon: mdcToolbarMenuIcon,
  mdcToolbarTitle: mdcToolbarTitle,
  mdcToolbarIcon: mdcToolbarIcon
});

var typos = ['display4', 'display3', 'display2', 'display1', 'headline', 'title', 'subheading1', 'subheading2', 'body1', 'body2', 'caption', 'button'];

var mdcTypoMixin = function mdcTypoMixin(name) {
  return {
    render: function render(createElement) {
      var _class;

      return createElement(this.tag, {
        'class': (_class = {
          'mdc-typo': true
        }, defineProperty(_class, name, true), defineProperty(_class, 'mdc-typography--' + this.typo, true), defineProperty(_class, 'mdc-typography--adjust-margin', this.adjustMargin), _class),
        'attrs': this.$attrs,
        'on': this.$listeners
      }, this.$slots.default);
    }
  };
};

function mdcTypoPropMixin(defaultTag, defaultTypo, validTypos) {
  return {
    props: {
      'tag': {
        type: String,
        default: defaultTag
      },
      'typo': {
        type: String,
        default: defaultTypo,
        validator: function validator(value) {
          return validTypos.indexOf(value) !== -1;
        }
      },
      'adjust-margin': {
        type: Boolean,
        default: false
      }
    }
  };
}

var mdcTextSection = {
  name: 'mdc-text-section',
  props: {
    'tag': {
      type: String,
      default: 'section'
    }
  },
  render: function render(createElement) {
    return createElement(this.tag, {
      'class': {
        'mdc-typography': true,
        'mdc-text-section': true
      },
      'attrs': this.$attrs,
      'on': this.$listeners
    }, this.$slots.default);
  }
};

var mdcText = {
  name: 'mdc-text',
  mixins: [mdcTypoMixin('mdc-text'), mdcTypoPropMixin('p', 'body1', typos)]
};

var mdcDisplay = {
  name: 'mdc-display',
  mixins: [mdcTypoMixin('mdc-display'), mdcTypoPropMixin('h1', 'display1', ['display4', 'display3', 'display2', 'display1'])]
};

var mdcHeadline = {
  name: 'mdc-headline',
  mixins: [mdcTypoMixin('mdc-headline'), mdcTypoPropMixin('h2', 'headline', ['headline'])]
};

var mdcTitle = {
  name: 'mdc-title',
  mixins: [mdcTypoMixin('mdc-title'), mdcTypoPropMixin('h3', 'title', ['title'])]
};

var mdcSubHeading = {
  name: 'mdc-subheading',
  mixins: [mdcTypoMixin('mdc-subheading'), mdcTypoPropMixin('h4', 'subheading2', ['subheading1', 'subheading2'])]
};

var mdcBody = {
  name: 'mdc-body',
  mixins: [mdcTypoMixin('mdc-body'), mdcTypoPropMixin('p', 'body1', ['body1', 'body2'])]
};

var mdcCaption = {
  name: 'mdc-caption',
  mixins: [mdcTypoMixin('mdc-caption'), mdcTypoPropMixin('span', 'caption', ['caption'])]
};

var VueMDCTypography = BasePlugin({
  mdcTextSection: mdcTextSection,
  mdcText: mdcText,
  mdcBody: mdcBody,
  mdcCaption: mdcCaption,
  mdcDisplay: mdcDisplay,
  mdcHeadline: mdcHeadline,
  mdcSubHeading: mdcSubHeading,
  mdcTitle: mdcTitle
});

//
// vue PlugIn
//
var plugin = {
  version: '0.11.2',
  install: function install(vm) {
    vm.use(VueMDCButton);
    vm.use(VueMDCCard);
    vm.use(VueMDCCheckbox);
    vm.use(VueMDCChipSet);
    vm.use(VueMDCDialog);
    vm.use(VueMDCDrawer);
    vm.use(VueMDCElevation);
    vm.use(VueMDCFab);
    vm.use(VueMDCGridList);
    vm.use(VueMDCIcon);
    vm.use(VueMDCIconToggle);
    vm.use(VueMDCLayoutApp);
    vm.use(VueMDCLayoutGrid);
    vm.use(VueMDCLinearProgress);
    vm.use(VueMDCList);
    vm.use(VueMDCMenu);
    vm.use(VueMDCRadio);
    vm.use(VueMDCRipple);
    vm.use(VueMDCSelect);
    vm.use(VueMDCSlider);
    vm.use(VueMDCSnackbar);
    vm.use(VueMDCSwitch);
    vm.use(VueMDCTabs);
    vm.use(VueMDCTextfield);
    vm.use(VueMDCTheme);
    vm.use(VueMDCToolbar);
    vm.use(VueMDCTypography);
  }
};

autoInit(plugin);

return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1kYy1hZGFwdGVyLmpzIiwic291cmNlcyI6WyIuLi9jb21wb25lbnRzL2Jhc2UvYXV0by1pbml0LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Jhc2UtcGx1Z2luLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1lbGVtZW50LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1saW5rLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1ldmVudC5qcyIsIi4uL2NvbXBvbmVudHMvYmFzZS9jdXN0b20tYnV0dG9uLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1pY29uLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Rpc3BhdGNoLWV2ZW50LW1peGluLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Rpc3BhdGNoLWZvY3VzLW1peGluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLWJhc2UuanMiLCIuLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9idXR0b24vbWRjLWJ1dHRvbi1iYXNlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvYnV0dG9uL21kYy1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9idXR0b24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1tZWRpYS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtaGVhZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC10aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtc3VidGl0bGUudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXRleHQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24taWNvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L21kYy1jaGVja2JveC52dWUiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2NoaXBzL21kYy1jaGlwLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9jaGlwcy9tZGMtY2hpcC1zZXQudnVlIiwiLi4vY29tcG9uZW50cy9jaGlwcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL3V0aWwuanMiLCIuLi9jb21wb25lbnRzL2RpYWxvZy9tZGMtZGlhbG9nLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZGlhbG9nL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcm1hbmVudC1kcmF3ZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcnNpc3RlbnQtZHJhd2VyLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy10ZW1wb3JhcnktZHJhd2VyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1sYXlvdXQudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2VsZXZhdGlvbi9tZGMtZWxldmF0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZWxldmF0aW9uL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9mYWIvbWRjLWZhYi52dWUiLCIuLi9jb21wb25lbnRzL2ZhYi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2dyaWQtbGlzdC9tZGMtZ3JpZC1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZ3JpZC1saXN0L21kYy1ncmlkLXRpbGUudnVlIiwiLi4vY29tcG9uZW50cy9ncmlkLWxpc3QvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2ljb24vbWRjLWljb24udnVlIiwiLi4vY29tcG9uZW50cy9pY29uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL21kYy1pY29uLXRvZ2dsZS52dWUiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtYXBwL21kYy1sYXlvdXQtYXBwLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWFwcC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1jZWxsLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1pbm5lci1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9saW5lYXItcHJvZ3Jlc3MvbWRjLWxpbmVhci1wcm9ncmVzcy52dWUiLCIuLi9jb21wb25lbnRzL2xpbmVhci1wcm9ncmVzcy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWdyb3VwLWhlYWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1hbmNob3IudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3JhZGlvL21kYy1yYWRpby52dWUiLCIuLi9jb21wb25lbnRzL3JhZGlvL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW5hdGl2ZS1zZWxlY3QudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2xhYmVsL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9sYWJlbC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9sYWJlbC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW1lbnUtc2VsZWN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1tdWx0aS1zZWxlY3QudnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLXNlbGVjdC52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtbmF0aXZlLW9wdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtbWVudS1vcHRpb24udnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW11bHRpLW9wdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtb3B0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NsaWRlci9tZGMtc2xpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2xpZGVyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbmFja2Jhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NuYWNrYmFyL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NuYWNrYmFyL21kYy1zbmFja2Jhci52dWUiLCIuLi9jb21wb25lbnRzL3NuYWNrYmFyL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9zd2l0Y2gvbWRjLXN3aXRjaC52dWUiLCIuLi9jb21wb25lbnRzL3N3aXRjaC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFicy90YWIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90YWJzL21kYy10YWIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi1iYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi1iYXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdGFicy9tZGMtdGFiLWJhci52dWUiLCIuLi9jb21wb25lbnRzL3RhYnMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9sYWJlbC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvbGFiZWwvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvbGFiZWwvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL291dGxpbmUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL291dGxpbmUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvb3V0bGluZS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RleHRmaWVsZC9tZGMtdGV4dGZpZWxkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGV4dGZpZWxkL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy90aGVtZS9tZGMtdGhlbWUudnVlIiwiLi4vY29tcG9uZW50cy90aGVtZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9vbGJhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9vbGJhci91dGlsLmpzIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci1yb3cudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLXNlY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLW1lbnUtaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItdGl0bGUudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLWljb24udnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L21kYy10eXBvZ3JhcGh5LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGF1dG9Jbml0IChwbHVnaW4pIHtcbiAgLy8gQXV0by1pbnN0YWxsXG4gIGxldCBfVnVlID0gbnVsbFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfVnVlID0gd2luZG93LlZ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLypnbG9iYWwgZ2xvYmFsKi9cbiAgICBfVnVlID0gZ2xvYmFsLlZ1ZVxuICB9XG4gIGlmIChfVnVlKSB7XG4gICAgX1Z1ZS51c2UocGx1Z2luKVxuICB9XG59XG4gICIsImV4cG9ydCBmdW5jdGlvbiBCYXNlUGx1Z2luIChjb21wb25lbnRzKSB7IFxuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdfX1ZFUlNJT05fXycsXG4gICAgaW5zdGFsbDogKHZtKSA9PiB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1trZXldXG4gICAgICAgICAgdm0uY29tcG9uZW50KGNvbXBvbmVudC5uYW1lLGNvbXBvbmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHNcbiAgfSBcbn1cblxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlciAoY3JlYXRlRWxlbWVudCwgY29udGV4dCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgY29udGV4dC5wcm9wcy5pcyB8fCBjb250ZXh0LnByb3BzLnRhZyB8fCAnZGl2JywgXG4gICAgICBjb250ZXh0LmRhdGEsXG4gICAgICBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21FbGVtZW50TWl4aW4gPSB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21FbGVtZW50XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBDdXN0b21MaW5rID0ge1xuICBuYW1lOiAnY3VzdG9tLWxpbmsnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHRhZzogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdhJyB9LFxuICAgIGxpbmsgOiBPYmplY3QsXG4gIH0sXG4gIHJlbmRlciAoaCwgY29udGV4dCkge1xuICAgIGxldCBlbGVtZW50IFxuICAgIGxldCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5kYXRhKVxuXG4gICAgaWYgKGNvbnRleHQucHJvcHMubGluayAmJiBjb250ZXh0LnBhcmVudC4kcm91dGVyKSB7XG4gICAgICAvLyByb3V0ZXItbGluayBjYXNlXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wYXJlbnQuJHJvb3QuJG9wdGlvbnMuY29tcG9uZW50c1sncm91dGVyLWxpbmsnXSBcbiAgICAgIGRhdGEucHJvcHMgPSBPYmplY3QuYXNzaWduKHt0YWc6IGNvbnRleHQucHJvcHMudGFnfSwgY29udGV4dC5wcm9wcy5saW5rKVxuICAgICAgaWYgKGRhdGEub24uY2xpY2spIHtcbiAgICAgICAgZGF0YS5uYXRpdmVPbiA9IHtjbGljazogZGF0YS5vbi5jbGljayB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVsZW1lbnQgZmFsbGJhY2tcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnByb3BzLnRhZyBcbiAgICB9IFxuXG4gICAgcmV0dXJuIGgoZWxlbWVudCwgZGF0YSwgY29udGV4dC5jaGlsZHJlbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tTGlua01peGluID0ge1xuICBwcm9wczoge1xuICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGxpbmsgKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG8gJiYge1xuICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgIGFwcGVuZDogdGhpcy5hcHBlbmQsXG4gICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcbiAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgIGV4YWN0QWN0aXZlQ2xhc3M6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcyxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHMgOiB7IFxuICAgIEN1c3RvbUxpbmsgXG4gIH1cbn0iLCIvKiBnbG9iYWwgQ3VzdG9tRXZlbnQgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRDdXN0b21FdmVudCAoZWwsIGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gIGxldCBldnRcbiAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICBidWJibGVzOiBzaG91bGRCdWJibGVcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKVxuICB9XG4gIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KVxufVxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUJ1dHRvbiA9IHtcbiAgbmFtZTogJ2N1c3RvbS1idXR0b24nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGxpbmsgOiBPYmplY3QsXG4gIH0sXG4gIHJlbmRlciAoaCwgY29udGV4dCkge1xuICAgIGxldCBlbGVtZW50IFxuICAgIGxldCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5kYXRhKVxuXG4gICAgaWYgKGNvbnRleHQucHJvcHMubGluayAmJiBjb250ZXh0LnBhcmVudC4kcm91dGVyKSB7XG4gICAgICAvLyByb3V0ZXItbGluayBjYXNlXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wYXJlbnQuJHJvb3QuJG9wdGlvbnMuY29tcG9uZW50c1sncm91dGVyLWxpbmsnXSBcbiAgICAgIGRhdGEucHJvcHMgPSBPYmplY3QuYXNzaWduKHt0YWc6IGNvbnRleHQucHJvcHMudGFnfSwgY29udGV4dC5wcm9wcy5saW5rKVxuICAgICAgZGF0YS5hdHRycy5yb2xlID0gJ2J1dHRvbidcbiAgICAgIGlmIChkYXRhLm9uLmNsaWNrKSB7XG4gICAgICAgIGRhdGEubmF0aXZlT24gPSB7Y2xpY2s6IGRhdGEub24uY2xpY2sgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLmhyZWYpIHtcbiAgICAgIC8vIGhyZWYgY2FzZVxuICAgICAgZWxlbWVudCA9ICdhJyBcbiAgICAgIGRhdGEuYXR0cnMucm9sZSA9ICdidXR0b24nXG4gICAgfSAgZWxzZSB7XG4gICAgICAvLyBidXR0b24gZmFsbGJhY2tcbiAgICAgIGVsZW1lbnQgPSAnYnV0dG9uJ1xuICAgIH0gXG5cbiAgICByZXR1cm4gaChlbGVtZW50LCBkYXRhLCBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21CdXR0b25NaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgdG86IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGluayAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50byAmJiB7XG4gICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICBleGFjdDogdGhpcy5leGFjdCxcbiAgICAgICAgYXBwZW5kOiB0aGlzLmFwcGVuZCxcbiAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgICBhY3RpdmVDbGFzczogdGhpcy5hY3RpdmVDbGFzcyxcbiAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzLFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50cyA6IHsgXG4gICAgQ3VzdG9tQnV0dG9uIFxuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdEljb25Qcm9wIChpY29uUHJvcCkge1xuICAgIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc2VzOiB7ICdtYXRlcmlhbC1pY29ucycgOiB0cnVlfSxcbiAgICAgICAgY29udGVudDogaWNvblByb3AgXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGljb25Qcm9wIGluc3RhbmNlb2YgQXJyYXkpe1xuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIGNsYXNzZXM6IGljb25Qcm9wLnJlZHVjZShcbiAgICAgICAgICAocmVzdWx0LCB2YWx1ZSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQse1t2YWx1ZV06dHJ1ZX0pLFxuICAgICAgICAgIHt9KSxcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdvYmplY3QnKXtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBjbGFzc2VzOiBpY29uUHJvcC5jbGFzc05hbWUuc3BsaXQoJyAnKS5yZWR1Y2UoXG4gICAgICAgICAgKHJlc3VsdCwgdmFsdWUpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LHtbdmFsdWVdOnRydWV9KSxcbiAgICAgICAgICB7fSksXG4gICAgICAgIGNvbnRlbnQ6IGljb25Qcm9wLnRleHRDb250ZW50IFxuICAgICAgfVxuICAgIH1cbiAgfVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRXZlbnRNaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICAnZXZlbnQnOiBTdHJpbmcsXG4gICAgJ2V2ZW50LXRhcmdldCc6IE9iamVjdCxcbiAgICAnZXZlbnQtYXJncyc6IEFycmF5LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZGlzcGF0Y2hFdmVudCAoZXZ0KSB7XG4gICAgICB0aGlzLiRlbWl0KGV2dC50eXBlKVxuICAgICAgaWYgKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZXZlbnRUYXJnZXQgfHwgdGhpcy4kcm9vdFxuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZXZlbnRBcmdzIHx8IFtdXG4gICAgICAgIHRhcmdldC4kZW1pdCh0aGlzLmV2ZW50LCAuLi5hcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRm9jdXNNaXhpbiA9IHtcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuICB7aGFzRm9jdXM6IGZhbHNlfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlXG4gICAgfSxcbiAgICBvbk1vdXNlVXAgKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2VcbiAgICB9LFxuICAgIG9uRm9jdXNFdmVudCAoKSB7XG4gICAgICAvLyBkaXNwYXRjaCBhc3luYyB0byBsZXQgdGltZSB0byBvdGhlciBmb2N1cyBldmVudCB0byBwcm9wYWdhdGVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwwKVxuICAgIH0sXG4gICAgb25CbHVyRXZlbnQgKCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICAvLyBhbHNvIGZpbHR1ciBibHVyIGlmIG1vdXNlZG93blxuICAgICAgdGhpcy5fYWN0aXZlIHx8IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwwKVxuICAgIH0sXG4gICAgZGlzcGF0Y2hGb2N1c0V2ZW50KCkge1xuICAgICAgbGV0IGhhc0ZvY3VzID0gdGhpcy4kZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgdGhpcy4kZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICBpZiAoaGFzRm9jdXMgIT0gdGhpcy5oYXNGb2N1cykge1xuICAgICAgICB0aGlzLiRlbWl0KGhhc0ZvY3VzID8gJ2ZvY3VzJyA6ICdibHVyJylcbiAgICAgICAgdGhpcy5oYXNGb2N1cyA9IGhhc0ZvY3VzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBSaXBwbGUuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gQ1NTIHZhcmlhYmxlc1xuICogLSBwb3NpdGlvblxuICogLSBkaW1lbnNpb25zXG4gKiAtIHNjcm9sbCBwb3NpdGlvblxuICogLSBldmVudCBoYW5kbGVyc1xuICogLSB1bmJvdW5kZWQsIGFjdGl2ZSBhbmQgZGlzYWJsZWQgc3RhdGVzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENSaXBwbGVBZGFwdGVyIHtcbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1VuYm91bmRlZCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzU3VyZmFjZUFjdGl2ZSgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzU3VyZmFjZURpc2FibGVkKCkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudFRhcmdldH0gdGFyZ2V0ICovXG4gIGNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFyTmFtZVxuICAgKiBAcGFyYW0gez9udW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgdXBkYXRlQ3NzVmFyaWFibGUodmFyTmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqIEByZXR1cm4geyFDbGllbnRSZWN0fSAqL1xuICBjb21wdXRlQm91bmRpbmdSZWN0KCkge31cblxuICAvKiogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gKi9cbiAgZ2V0V2luZG93UGFnZU9mZnNldCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgLy8gUmlwcGxlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHRoZSBcInJvb3RcIiBjb21wb25lbnQgaXMgcmVhbGx5IGEgXCJtaXhpblwiIG9mIHNvcnRzLFxuICAvLyBnaXZlbiB0aGF0IGl0J3MgYW4gJ3VwZ3JhZGUnIHRvIGFuIGV4aXN0aW5nIGNvbXBvbmVudC4gVGhhdCBiZWluZyBzYWlkIGl0IGlzIHRoZSByb290XG4gIC8vIENTUyBjbGFzcyB0aGF0IGFsbCBvdGhlciBDU1MgY2xhc3NlcyBkZXJpdmUgZnJvbS5cbiAgUk9PVDogJ21kYy1yaXBwbGUtdXBncmFkZWQnLFxuICBVTkJPVU5ERUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS11bmJvdW5kZWQnLFxuICBCR19GT0NVU0VEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tYmFja2dyb3VuZC1mb2N1c2VkJyxcbiAgRkdfQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtYWN0aXZhdGlvbicsXG4gIEZHX0RFQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtZGVhY3RpdmF0aW9uJyxcbn07XG5cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFZBUl9MRUZUOiAnLS1tZGMtcmlwcGxlLWxlZnQnLFxuICBWQVJfVE9QOiAnLS1tZGMtcmlwcGxlLXRvcCcsXG4gIFZBUl9GR19TSVpFOiAnLS1tZGMtcmlwcGxlLWZnLXNpemUnLFxuICBWQVJfRkdfU0NBTEU6ICctLW1kYy1yaXBwbGUtZmctc2NhbGUnLFxuICBWQVJfRkdfVFJBTlNMQVRFX1NUQVJUOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCcsXG4gIFZBUl9GR19UUkFOU0xBVEVfRU5EOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1lbmQnLFxufTtcblxuY29uc3QgbnVtYmVycyA9IHtcbiAgUEFERElORzogMTAsXG4gIElOSVRJQUxfT1JJR0lOX1NDQUxFOiAwLjYsXG4gIERFQUNUSVZBVElPTl9USU1FT1VUX01TOiAyMjUsIC8vIENvcnJlc3BvbmRzIHRvICRtZGMtcmlwcGxlLXRyYW5zbGF0ZS1kdXJhdGlvbiAoaS5lLiBhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgRkdfREVBQ1RJVkFUSU9OX01TOiAxNTAsIC8vIENvcnJlc3BvbmRzIHRvICRtZGMtcmlwcGxlLWZhZGUtb3V0LWR1cmF0aW9uIChpLmUuIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXG4gIFRBUF9ERUxBWV9NUzogMzAwLCAvLyBEZWxheSBiZXR3ZWVuIHRvdWNoIGFuZCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIG9uIHRvdWNoIGRldmljZXNcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBTdG9yZXMgcmVzdWx0IGZyb20gc3VwcG9ydHNDc3NWYXJpYWJsZXMgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IENTUyBjdXN0b20gdmFyaWFibGUgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcblxuLyoqXG4gKiBTdG9yZXMgcmVzdWx0IGZyb20gYXBwbHlQYXNzaXZlIHRvIGF2b2lkIHJlZHVuZGFudCBwcm9jZXNzaW5nIHRvIGRldGVjdCBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIHN1cHBvcnQuXG4gKiBAcHJpdmF0ZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmxldCBzdXBwb3J0c1Bhc3NpdmVfO1xuXG4vKipcbiAqIEBwYXJhbSB7IVdpbmRvd30gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBkZXRlY3RFZGdlUHNldWRvVmFyQnVnKHdpbmRvd09iaikge1xuICAvLyBEZXRlY3QgdmVyc2lvbnMgb2YgRWRnZSB3aXRoIGJ1Z2d5IHZhcigpIHN1cHBvcnRcbiAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMTQ5NTQ0OC9cbiAgY29uc3QgZG9jdW1lbnQgPSB3aW5kb3dPYmouZG9jdW1lbnQ7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbm9kZS5jbGFzc05hbWUgPSAnbWRjLXJpcHBsZS1zdXJmYWNlLS10ZXN0LWVkZ2UtdmFyLWJ1Zyc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7XG5cbiAgLy8gVGhlIGJ1ZyBleGlzdHMgaWYgOjpiZWZvcmUgc3R5bGUgZW5kcyB1cCBwcm9wYWdhdGluZyB0byB0aGUgcGFyZW50IGVsZW1lbnQuXG4gIC8vIEFkZGl0aW9uYWxseSwgZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIG51bGwgaW4gaWZyYW1lcyB3aXRoIGRpc3BsYXk6IFwibm9uZVwiIGluIEZpcmVmb3gsXG4gIC8vIGJ1dCBGaXJlZm94IGlzIGtub3duIHRvIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzIGNvcnJlY3RseS5cbiAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvd09iai5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICBjb25zdCBoYXNQc2V1ZG9WYXJCdWcgPSBjb21wdXRlZFN0eWxlICE9PSBudWxsICYmIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wU3R5bGUgPT09ICdzb2xpZCc7XG4gIG5vZGUucmVtb3ZlKCk7XG4gIHJldHVybiBoYXNQc2V1ZG9WYXJCdWc7XG59XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlUmVmcmVzaFxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93T2JqLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9PT0gJ2Jvb2xlYW4nICYmICFmb3JjZVJlZnJlc2gpIHtcbiAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXNfID0gIWRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xufVxuXG4vL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IEhUTUxFbGVtZW50UHJvdG90eXBlXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlKSB7XG4gIHJldHVybiBbXG4gICAgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdtYXRjaGVzJyxcbiAgXS5maWx0ZXIoKHApID0+IHAgaW4gSFRNTEVsZW1lbnRQcm90b3R5cGUpLnBvcCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUV2ZW50fSBldlxuICogQHBhcmFtIHshe3g6IG51bWJlciwgeTogbnVtYmVyfX0gcGFnZU9mZnNldFxuICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdFxuICogQHJldHVybiB7IXt4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gKi9cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyhldiwgcGFnZU9mZnNldCwgY2xpZW50UmVjdCkge1xuICBjb25zdCB7eCwgeX0gPSBwYWdlT2Zmc2V0O1xuICBjb25zdCBkb2N1bWVudFggPSB4ICsgY2xpZW50UmVjdC5sZWZ0O1xuICBjb25zdCBkb2N1bWVudFkgPSB5ICsgY2xpZW50UmVjdC50b3A7XG5cbiAgbGV0IG5vcm1hbGl6ZWRYO1xuICBsZXQgbm9ybWFsaXplZFk7XG4gIC8vIERldGVybWluZSB0b3VjaCBwb2ludCByZWxhdGl2ZSB0byB0aGUgcmlwcGxlIGNvbnRhaW5lci5cbiAgaWYgKGV2LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgIG5vcm1hbGl6ZWRYID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfSBlbHNlIHtcbiAgICBub3JtYWxpemVkWCA9IGV2LnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYucGFnZVkgLSBkb2N1bWVudFk7XG4gIH1cblxuICByZXR1cm4ge3g6IG5vcm1hbGl6ZWRYLCB5OiBub3JtYWxpemVkWX07XG59XG5cbmV4cG9ydCB7c3VwcG9ydHNDc3NWYXJpYWJsZXMsIGFwcGx5UGFzc2l2ZSwgZ2V0TWF0Y2hlc1Byb3BlcnR5LCBnZXROb3JtYWxpemVkRXZlbnRDb29yZHN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1JpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtnZXROb3JtYWxpemVkRXZlbnRDb29yZHN9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGlzQWN0aXZhdGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgYWN0aXZhdGlvbkV2ZW50OiBFdmVudCxcbiAqICAgaXNQcm9ncmFtbWF0aWM6IChib29sZWFufHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBBY3RpdmF0aW9uU3RhdGVUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICBhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBkZWFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGZvY3VzOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGJsdXI6IChzdHJpbmd8dW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVySW5mb1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGFjdGl2YXRlOiBmdW5jdGlvbighRXZlbnQpLFxuICogICBkZWFjdGl2YXRlOiBmdW5jdGlvbighRXZlbnQpLFxuICogICBmb2N1czogZnVuY3Rpb24oKSxcbiAqICAgYmx1cjogZnVuY3Rpb24oKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVyc1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIHg6IG51bWJlcixcbiAqICAgeTogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgUG9pbnRUeXBlO1xuXG4vLyBBY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIHRoZSByb290IGVsZW1lbnQgb2YgZWFjaCBpbnN0YW5jZSBmb3IgYWN0aXZhdGlvblxuY29uc3QgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93biddO1xuXG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbmNvbnN0IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gWyd0b3VjaGVuZCcsICdwb2ludGVydXAnLCAnbW91c2V1cCddO1xuXG4vLyBUcmFja3MgYWN0aXZhdGlvbnMgdGhhdCBoYXZlIG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGZyYW1lLCB0byBhdm9pZCBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG4vKiogQHR5cGUgeyFBcnJheTwhRXZlbnRUYXJnZXQ+fSAqL1xubGV0IGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmlwcGxlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gLyogYm9vbGVhbiAtIGNhY2hlZCAqLyB7fSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKC8qIHRhcmdldDogIUV2ZW50VGFyZ2V0ICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyB7fSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IC8qIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gKi8ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUNsaWVudFJlY3R9ICovXG4gICAgdGhpcy5mcmFtZV8gPSAvKiogQHR5cGUgeyFDbGllbnRSZWN0fSAqLyAoe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5hY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5kZWFjdGl2YXRlXyhlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgKCkgPT4gdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRClcbiAgICApO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQ9KX0gKi9cbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICgpID0+IHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpXG4gICAgKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshe2xlZnQ6IG51bWJlciwgdG9wOm51bWJlcn19ICovXG4gICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ1NjYWxlXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RXZlbnR9ICovXG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHdlIGFyZSBub3QgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudFxuICAgKiB1bnRpbCB0aGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0aGUgZm91bmRhdGlvbiByZXF1ZXN0cyBpdC4gVGhpcyBwcmV2ZW50cyBzY2VuYXJpb3Mgd2hlcmVcbiAgICogY2xpZW50LXNpZGUgZmVhdHVyZS1kZXRlY3Rpb24gbWF5IGhhcHBlbiB0b28gZWFybHksIHN1Y2ggYXMgd2hlbiBjb21wb25lbnRzIGFyZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG4gICAqIGFuZCB0aGVuIGluaXRpYWxpemVkIGF0IG1vdW50IHRpbWUgb24gdGhlIGNsaWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzU3VwcG9ydGVkXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9XG4gICAqL1xuICBkZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IGZhbHNlLFxuICAgICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiBmYWxzZSxcbiAgICAgIHdhc0VsZW1lbnRNYWRlQWN0aXZlOiBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb25FdmVudDogbnVsbCxcbiAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpc3RlclJvb3RIYW5kbGVyc18oKTtcblxuICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFJPT1QpO1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpO1xuICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuXG4gICAgY29uc3Qge1JPT1QsIFVOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoUk9PVCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgICB0aGlzLnJlbW92ZUNzc1ZhcnNfKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW1vdmVDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7c3RyaW5nc30gPSBNRENSaXBwbGVGb3VuZGF0aW9uO1xuICAgIE9iamVjdC5rZXlzKHN0cmluZ3MpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChrLmluZGV4T2YoJ1ZBUl8nKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKHN0cmluZ3Nba10sIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY3RpdmF0ZV8oZSkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZURpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIHJlYWN0aW5nIHRvIGZvbGxvdy1vbiBldmVudHMgZmlyZWQgYnkgdG91Y2ggZGV2aWNlIGFmdGVyIGFuIGFscmVhZHktcHJvY2Vzc2VkIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjb25zdCBwcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfO1xuICAgIGNvbnN0IGlzU2FtZUludGVyYWN0aW9uID0gcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgJiYgZSAmJiBwcmV2aW91c0FjdGl2YXRpb25FdmVudC50eXBlICE9PSBlLnR5cGU7XG4gICAgaWYgKGlzU2FtZUludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBlID09PSBudWxsO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5hY3RpdmF0aW9uRXZlbnQgPSBlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPyBmYWxzZSA6IChcbiAgICAgIGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAncG9pbnRlcmRvd24nXG4gICAgKTtcblxuICAgIGNvbnN0IGhhc0FjdGl2YXRlZENoaWxkID1cbiAgICAgIGUgJiYgYWN0aXZhdGVkVGFyZ2V0cy5sZW5ndGggPiAwICYmIGFjdGl2YXRlZFRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSk7XG4gICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5wdXNoKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZS50YXJnZXQpKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oZSk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgd3JhcHBlZCBpbiBhbiByQUYgY2FsbCBiL2Mgd2ViIGJyb3dzZXJzXG4gICAgICAvLyByZXBvcnQgYWN0aXZlIHN0YXRlcyBpbmNvbnNpc3RlbnRseSB3aGVuIHRoZXkncmUgY2FsbGVkIHdpdGhpblxuICAgICAgLy8gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgIC8vIC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjM1OTcxXG4gICAgICAvLyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTM3NDFcbiAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IChlICYmIGUudHlwZSA9PT0gJ2tleWRvd24nKSA/IHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlQWN0aXZlKCkgOiB0cnVlO1xuICAgICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSBpbW1lZGlhdGVseSBpZiBlbGVtZW50IHdhcyBub3QgbWFkZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgYXJyYXkgb24gbmV4dCBmcmFtZSBhZnRlciB0aGUgY3VycmVudCBldmVudCBoYXMgaGFkIGEgY2hhbmNlIHRvIGJ1YmJsZSB0byBwcmV2ZW50IGFuY2VzdG9yIHJpcHBsZXNcbiAgICAgIGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYW5pbWF0ZUFjdGl2YXRpb25fKCkge1xuICAgIGNvbnN0IHtWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0RFQUNUSVZBVElPTl9USU1FT1VUX01TfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycztcblxuICAgIGxldCB0cmFuc2xhdGVTdGFydCA9ICcnO1xuICAgIGxldCB0cmFuc2xhdGVFbmQgPSAnJztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICBjb25zdCB7c3RhcnRQb2ludCwgZW5kUG9pbnR9ID0gdGhpcy5nZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCk7XG4gICAgICB0cmFuc2xhdGVTdGFydCA9IGAke3N0YXJ0UG9pbnQueH1weCwgJHtzdGFydFBvaW50Lnl9cHhgO1xuICAgICAgdHJhbnNsYXRlRW5kID0gYCR7ZW5kUG9pbnQueH1weCwgJHtlbmRQb2ludC55fXB4YDtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19UUkFOU0xBVEVfU1RBUlQsIHRyYW5zbGF0ZVN0YXJ0KTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19UUkFOU0xBVEVfRU5ELCB0cmFuc2xhdGVFbmQpO1xuICAgIC8vIENhbmNlbCBhbnkgb25nb2luZyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBhbmltYXRpb25zXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfKTtcbiAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcblxuICAgIC8vIEZvcmNlIGxheW91dCBpbiBvcmRlciB0byByZS10cmlnZ2VyIHRoZSBhbmltYXRpb24uXG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfKCksIERFQUNUSVZBVElPTl9USU1FT1VUX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHt7c3RhcnRQb2ludDogUG9pbnRUeXBlLCBlbmRQb2ludDogUG9pbnRUeXBlfX1cbiAgICovXG4gIGdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKSB7XG4gICAgY29uc3Qge2FjdGl2YXRpb25FdmVudCwgd2FzQWN0aXZhdGVkQnlQb2ludGVyfSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcblxuICAgIGxldCBzdGFydFBvaW50O1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIpIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoXG4gICAgICAgIC8qKiBAdHlwZSB7IUV2ZW50fSAqLyAoYWN0aXZhdGlvbkV2ZW50KSxcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dQYWdlT2Zmc2V0KCksIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBvaW50ID0ge1xuICAgICAgICB4OiB0aGlzLmZyYW1lXy53aWR0aCAvIDIsXG4gICAgICAgIHk6IHRoaXMuZnJhbWVfLmhlaWdodCAvIDIsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBDZW50ZXIgdGhlIGVsZW1lbnQgYXJvdW5kIHRoZSBzdGFydCBwb2ludC5cbiAgICBzdGFydFBvaW50ID0ge1xuICAgICAgeDogc3RhcnRQb2ludC54IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgICB5OiBzdGFydFBvaW50LnkgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICB9O1xuXG4gICAgY29uc3QgZW5kUG9pbnQgPSB7XG4gICAgICB4OiAodGhpcy5mcmFtZV8ud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIHJldHVybiB7c3RhcnRQb2ludCwgZW5kUG9pbnR9O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYm90aCB3aGVuIGEgcG9pbnRpbmcgZGV2aWNlIGlzIHJlbGVhc2VkLCBhbmQgd2hlbiB0aGUgYWN0aXZhdGlvbiBhbmltYXRpb24gZW5kcy5cbiAgICAvLyBUaGUgZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBzaG91bGQgb25seSBydW4gYWZ0ZXIgYm90aCBvZiB0aG9zZSBvY2N1ci5cbiAgICBjb25zdCB7RkdfREVBQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBjb25zdCB7aGFzRGVhY3RpdmF0aW9uVVhSdW4sIGlzQWN0aXZhdGVkfSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBjb25zdCBhY3RpdmF0aW9uSGFzRW5kZWQgPSBoYXNEZWFjdGl2YXRpb25VWFJ1biB8fCAhaXNBY3RpdmF0ZWQ7XG5cbiAgICBpZiAoYWN0aXZhdGlvbkhhc0VuZGVkICYmIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXykge1xuICAgICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgIH0sIG51bWJlcnMuRkdfREVBQ1RJVkFUSU9OX01TKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCkge1xuICAgIGNvbnN0IHtGR19BQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICB9XG5cbiAgcmVzZXRBY3RpdmF0aW9uU3RhdGVfKCkge1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmFjdGl2YXRpb25FdmVudDtcbiAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgLy8gVG91Y2ggZGV2aWNlcyBtYXkgZmlyZSBhZGRpdGlvbmFsIGV2ZW50cyBmb3IgdGhlIHNhbWUgaW50ZXJhY3Rpb24gd2l0aGluIGEgc2hvcnQgdGltZS5cbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXMgZXZlbnQgdW50aWwgaXQncyBzYWZlIHRvIGFzc3VtZSB0aGF0IHN1YnNlcXVlbnQgZXZlbnRzIGFyZSBmb3IgbmV3IGludGVyYWN0aW9ucy5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbCwgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlRBUF9ERUxBWV9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlYWN0aXZhdGVfKGUpIHtcbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIHNjZW5hcmlvcyBzdWNoIGFzIHdoZW4geW91IGhhdmUgYSBrZXl1cCBldmVudCB0aGF0IGJsdXJzIHRoZSBlbGVtZW50LlxuICAgIGlmICghYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSAvKiogQHR5cGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqLyAoT2JqZWN0LmFzc2lnbih7fSwgYWN0aXZhdGlvblN0YXRlKSk7XG5cbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljKSB7XG4gICAgICBjb25zdCBldnRPYmplY3QgPSBudWxsO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oZXZ0T2JqZWN0LCBzdGF0ZSkpO1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8uaGFzRGVhY3RpdmF0aW9uVVhSdW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBkZWFjdGl2YXRlKGV2ZW50ID0gbnVsbCkge1xuICAgIHRoaXMuZGVhY3RpdmF0ZV8oZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYW5pbWF0ZURlYWN0aXZhdGlvbl8oZSwge3dhc0FjdGl2YXRlZEJ5UG9pbnRlciwgd2FzRWxlbWVudE1hZGVBY3RpdmV9KSB7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlciB8fCB3YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0RnJhbWVfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxheW91dEZyYW1lXyk7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgbGF5b3V0SW50ZXJuYWxfKCkge1xuICAgIHRoaXMuZnJhbWVfID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgodGhpcy5mcmFtZV8uaGVpZ2h0LCB0aGlzLmZyYW1lXy53aWR0aCk7XG5cbiAgICAvLyBTdXJmYWNlIGRpYW1ldGVyIGlzIHRyZWF0ZWQgZGlmZmVyZW50bHkgZm9yIHVuYm91bmRlZCB2cy4gYm91bmRlZCByaXBwbGVzLlxuICAgIC8vIFVuYm91bmRlZCByaXBwbGUgZGlhbWV0ZXIgaXMgY2FsY3VsYXRlZCBzbWFsbGVyIHNpbmNlIHRoZSBzdXJmYWNlIGlzIGV4cGVjdGVkIHRvIGFscmVhZHkgYmUgcGFkZGVkIGFwcHJvcHJpYXRlbHlcbiAgICAvLyB0byBleHRlbmQgdGhlIGhpdGJveCwgYW5kIHRoZSByaXBwbGUgaXMgZXhwZWN0ZWQgdG8gbWVldCB0aGUgZWRnZXMgb2YgdGhlIHBhZGRlZCBoaXRib3ggKHdoaWNoIGlzIHR5cGljYWxseVxuICAgIC8vIHNxdWFyZSkuIEJvdW5kZWQgcmlwcGxlcywgb24gdGhlIG90aGVyIGhhbmQsIGFyZSBmdWxseSBleHBlY3RlZCB0byBleHBhbmQgYmV5b25kIHRoZSBzdXJmYWNlJ3MgbG9uZ2VzdCBkaWFtZXRlclxuICAgIC8vIChjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkaWFnb25hbCBwbHVzIGEgY29uc3RhbnQgcGFkZGluZyksIGFuZCBhcmUgY2xpcHBlZCBhdCB0aGUgc3VyZmFjZSdzIGJvcmRlciB2aWFcbiAgICAvLyBgb3ZlcmZsb3c6IGhpZGRlbmAuXG4gICAgY29uc3QgZ2V0Qm91bmRlZFJhZGl1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGh5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5mcmFtZV8ud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5mcmFtZV8uaGVpZ2h0LCAyKSk7XG4gICAgICByZXR1cm4gaHlwb3RlbnVzZSArIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5QQURESU5HO1xuICAgIH07XG5cbiAgICB0aGlzLm1heFJhZGl1c18gPSB0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkgPyBtYXhEaW0gOiBnZXRCb3VuZGVkUmFkaXVzKCk7XG5cbiAgICAvLyBSaXBwbGUgaXMgc2l6ZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgbGFyZ2VzdCBkaW1lbnNpb24gb2YgdGhlIHN1cmZhY2UsIHRoZW4gc2NhbGVzIHVwIHVzaW5nIGEgQ1NTIHNjYWxlIHRyYW5zZm9ybVxuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gbWF4RGltICogTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLklOSVRJQUxfT1JJR0lOX1NDQUxFO1xuICAgIHRoaXMuZmdTY2FsZV8gPSB0aGlzLm1heFJhZGl1c18gLyB0aGlzLmluaXRpYWxTaXplXztcblxuICAgIHRoaXMudXBkYXRlTGF5b3V0Q3NzVmFyc18oKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1cGRhdGVMYXlvdXRDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7XG4gICAgICBWQVJfRkdfU0laRSwgVkFSX0xFRlQsIFZBUl9UT1AsIFZBUl9GR19TQ0FMRSxcbiAgICB9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0laRSwgYCR7dGhpcy5pbml0aWFsU2l6ZV99cHhgKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TQ0FMRSwgdGhpcy5mZ1NjYWxlXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLnVuYm91bmRlZENvb3Jkc18gPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICAgIHRvcDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9MRUZULCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18ubGVmdH1weGApO1xuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfVE9QLCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18udG9wfXB4YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdW5ib3VuZGVkICovXG4gIHNldFVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICBjb25zdCB7VU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAodW5ib3VuZGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlRm91bmRhdGlvbjtcbiIsImltcG9ydCBNRENSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvZm91bmRhdGlvbi5qcydcbmltcG9ydCB7c3VwcG9ydHNDc3NWYXJpYWJsZXMsIGdldE1hdGNoZXNQcm9wZXJ0eSwgYXBwbHlQYXNzaXZlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL3V0aWwnXG5cbmV4cG9ydCBjbGFzcyBSaXBwbGVCYXNlIGV4dGVuZHMgTURDUmlwcGxlRm91bmRhdGlvbiB7XG5cbiAgc3RhdGljIGdldCBNQVRDSEVTICgpIHtcbiAgICAvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbiAgICByZXR1cm4gUmlwcGxlQmFzZS5fbWF0Y2hlcyB8fFxuICAgICAgKCBSaXBwbGVCYXNlLl9tYXRjaGVzID0gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSkpXG4gIH1cblxuICBzdGF0aWMgaXNTdXJmYWNlQWN0aXZlIChyZWYpIHtcbiAgICByZXR1cm4gcmVmW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICB9XG5cbiAgY29uc3RydWN0b3IgKHZtLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7XG4gICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3cpXG4gICAgICB9LFxuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB2bS4kZWxbUmlwcGxlQmFzZS5NQVRDSEVTXSgnOmFjdGl2ZScpXG4gICAgICB9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZtLmRpc2FibGVkXG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3MgKGNsYXNzTmFtZSkge1xuICAgICAgICB2bS4kc2V0KHZtLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzcyAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHZtLiRkZWxldGUodm0uY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICh0YXJnZXQpID0+IHZtLiRlbC5jb250YWlucyh0YXJnZXQpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdm0uJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdm0uJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFyTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdm0uJHNldCh2bS5zdHlsZXMsIHZhck5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZtLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICh7eDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXR9KVxuICAgICAgfSxcbiAgICB9LCBvcHRpb25zKSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUmlwcGxlTWl4aW4gPSB7XG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn0gICIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IDp0YWc9XCJ0YWdcIiBjbGFzcz1cIm1kYy1yaXBwbGVcIlxuICAgIDpjbGFzc2VzPVwiY2xhc3Nlc1wiIDpzdHlsZXM9XCJzdHlsZXNcIj5cbiAgICA8c2xvdCAvPlxuICA8L2N1c3RvbS1lbGVtZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7Q3VzdG9tRWxlbWVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHtSaXBwbGVNaXhpbn0gZnJvbSAnLi9tZGMtcmlwcGxlLWJhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1yaXBwbGUnLFxuICBtaXhpbnM6W0N1c3RvbUVsZW1lbnRNaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIHRhZzogU3RyaW5nXG4gIH0sXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNSaXBwbGUgZnJvbSAnLi9tZGMtcmlwcGxlLnZ1ZSdcblxuZXhwb3J0ICogZnJvbSAnLi9tZGMtcmlwcGxlLWJhc2UuanMnXG5cbmV4cG9ydCB7XG4gIG1kY1JpcHBsZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjUmlwcGxlXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWJ1dHRvbiByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmhyZWY9XCJocmVmXCIgOmxpbms9XCJsaW5rXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiBcbiAgICBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7UmlwcGxlTWl4aW59IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWJ1dHRvbi1iYXNlJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24nLFxuICBleHRlbmRzOiBtZGNCdXR0b25CYXNlLFxuICBwcm9wczoge1xuICAgIHJhaXNlZDogQm9vbGVhbixcbiAgICB1bmVsZXZhdGVkOiBCb29sZWFuLFxuICAgIHN0cm9rZWQ6IEJvb2xlYW4sXG4gICAgZGVuc2U6IEJvb2xlYW4sXG4gICAgY29tcGFjdDogQm9vbGVhbiwgXG4gICAgYWNjZW50OiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcbiAgICAgICAgJ21kYy1idXR0b24tLXJhaXNlZCc6IHRoaXMucmFpc2VkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCc6IHRoaXMudW5lbGV2YXRlZCxcbiAgICAgICAgJ21kYy1idXR0b24tLXN0cm9rZWQnOiB0aGlzLnN0cm9rZWQsXG4gICAgICAgICdtZGMtYnV0dG9uLS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtYnV0dG9uLS1jb21wYWN0JzogdGhpcy5jb21wYWN0LFxuICAgICAgICAnbWRjLWJ1dHRvbi0tYWNjZW50JzogdGhpcy5hY2NlbnRcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgcmFpc2VkICgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1yYWlzZWQnLCB0aGlzLnJhaXNlZCApXG4gICAgfSxcbiAgICB1bmVsZXZhdGVkICgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJywgdGhpcy51bmVsZXZhdGVkIClcbiAgICB9LFxuICAgIHN0cm9rZWQgKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLXN0cm9rZWQnLCB0aGlzLnN0cm9rZWQgKVxuICAgIH0sXG4gICAgZGVuc2UgKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWRlbnNlJywgdGhpcy5kZW5zZSApXG4gICAgfSxcbiAgICBjb21wYWN0ICgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1jb21wYWN0JywgdGhpcy5jb21wYWN0IClcbiAgICB9LFxuICAgIGFjY2VudCAoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tYWNjZW50JywgdGhpcy5hY2NlbnQgKVxuICAgIH0sXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0J1dHRvbiBmcm9tICcuL21kYy1idXR0b24udnVlJ1xuaW1wb3J0IG1kY0J1dHRvbkJhc2UgZnJvbSAnLi9tZGMtYnV0dG9uLWJhc2UudnVlJ1xuXG5leHBvcnQge21kY0J1dHRvbkJhc2UsIG1kY0J1dHRvbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0J1dHRvblxufSlcbiIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRjLWNhcmRcIiA6Y2xhc3M9XCJ7J21kYy1jYXJkLS1zdHJva2VkJzogc3Ryb2tlZH1cIj5cclxuICAgIDxzbG90PlxyXG4gICAgPC9zbG90PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6IFwibWRjLWNhcmRcIixcclxuICBwcm9wczoge1xyXG4gICAgc3Ryb2tlZDogQm9vbGVhblxyXG4gIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y3VzdG9tLWxpbmsgXHJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXByaW1hcnktYWN0aW9uIG1kYy1jYXJkX19wcmltYXJ5LWFjdGlvblwiXHJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCIgXHJcbiAgICA6bGluaz1cImxpbmtcIiBcclxuICAgIEBjbGljaz1cImRpc3BhdGNoRXZlbnRcIj5cclxuICAgIDxzbG90IC8+XHJcbiAgPC9jdXN0b20tbGluaz5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW59IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCB7IFJpcHBsZU1peGluIH0gZnJvbSAnLi4vcmlwcGxlL2luZGV4JztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1wcmltYXJ5LWFjdGlvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4sIFJpcHBsZU1peGluXSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC1tZWRpYSBtZGMtY2FyZF9fbWVkaWFcIiBcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJtZGMtY2FyZF9fbWVkaWEtY29udGVudFwiIHYtaWY9XCIkc2xvdHMuZGVmYXVsdFwiPlxyXG4gICAgICA8c2xvdD5cclxuICAgICAgPC9zbG90PlxyXG4gICAgPC9kaXY+XHJcbiAgPC9zZWN0aW9uPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6IFwibWRjLWNhcmQtbWVkaWFcIixcclxuICBwcm9wczoge1xyXG4gICAgc3JjOiBTdHJpbmcsXHJcbiAgICAnc3F1YXJlJzogQm9vbGVhblxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIHN0eWxlcygpIHtcclxuICAgICAgdmFyIHN0eWxlcyA9IHtcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHt0aGlzLnNyY30pYFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHN0eWxlcztcclxuICAgIH0sIFxyXG4gICAgY2xhc3NlcygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3F1YXJlID8gJ21kYy1jYXJkX19tZWRpYS0tc3F1YXJlJzogJ21kYy1jYXJkX19tZWRpYS0tMTYtOSdcclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC1oZWFkZXIgbWRjLWNhcmRfX3ByaW1hcnlcIj5cbiAgICA8c2xvdD5cbiAgICAgIDxoMSBjbGFzcz1cIm1kYy1jYXJkX190aXRsZVwiXG4gICAgICAgIDpjbGFzcz1cInsnbWRjLWNhcmRfX3RpdGxlLS1sYXJnZSc6IGxhcmdlVGl0bGV9XCJcbiAgICAgICAgdi1pZj1cInRpdGxlXCJcbiAgICAgICAgPlxuICAgICAgICB7eyB0aXRsZSB9fVxuICAgICAgPC9oMT5cbiAgICAgIDxoMiBjbGFzcz1cIm1kYy1jYXJkX19zdWJ0aXRsZVwiXG4gICAgICAgIHYtaWY9XCJzdWJ0aXRsZVwiXG4gICAgICA+XG4gICAgICAge3sgc3VidGl0bGUgfX0gXG4gICAgICA8L2gyPlxuICAgIDwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLWhlYWRlcicsXG4gIHByb3BzOiB7XG4gICAgJ3RpdGxlJzogU3RyaW5nLFxuICAgICdzdWJ0aXRsZSc6IFN0cmluZyxcbiAgICAnbGFyZ2UtdGl0bGUnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGgxIGNsYXNzPVwibWRjLWNhcmQtdGl0bGUgbWRjLWNhcmRfX3RpdGxlXCJcbiAgICAgIDpjbGFzcz1cInsnbWRjLWNhcmRfX3RpdGxlLS1sYXJnZSc6IGxhcmdlfVwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9oMT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10aXRsZScsXG4gIHByb3BzOiB7XG4gICAgJ2xhcmdlJzogQm9vbGVhblxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGgyIGNsYXNzPVwibWRjLWNhcmQtc3VidGl0bGUgbWRjLWNhcmRfX3N1YnRpdGxlXCI+XG4gICAgPHNsb3Q+XG4gICAgPC9zbG90PlxuICA8L2gyPlxuPC90ZW1wbGF0ZT5cblxuXG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC1zdWJ0aXRsZSdcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLXRleHQgbWRjLWNhcmRfX3N1cHBvcnRpbmctdGV4dFwiPlxuICAgIDxzbG90PlxuICAgIDwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLXRleHQnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbnMgbWRjLWNhcmRfX2FjdGlvbnNcIiBcclxuICAgICAgICAgIDpjbGFzcz1cImNsYXNzZXNcIj5cclxuICAgIDxzbG90PlxyXG4gICAgPC9zbG90PlxyXG4gIDwvc2VjdGlvbj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbnMnLFxyXG4gIHByb3BzOiB7XHJcbiAgICBmdWxsQmxlZWQ6IEJvb2xlYW5cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBjbGFzc2VzICgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICdtZGMtY2FyZF9fYWN0aW9ucy0tZnVsbC1ibGVlZCc6IHRoaXMuZnVsbEJsZWVkLFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgY2xhc3M9XCJtZGMtY2FyZC1hY3Rpb24tYnV0dG9ucyBtZGMtY2FyZF9fYWN0aW9uLWJ1dHRvbnNcIj5cclxuICAgIDxzbG90PlxyXG4gICAgPC9zbG90PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6IFwibWRjLWNhcmQtYWN0aW9uLWJ1dHRvbnNcIlxyXG59O1xyXG48L3NjcmlwdD5cclxuIiwiPHNjcmlwdD5cclxuaW1wb3J0IHttZGNCdXR0b25CYXNlfSBmcm9tICcuLi9idXR0b24nXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nLFxyXG4gIGV4dGVuZHM6IG1kY0J1dHRvbkJhc2UsXHJcbiAgcHJvcHM6IHtcclxuICAgIGNvbXBhY3Q6IEJvb2xlYW4sXHJcbiAgICBhY2NlbnQ6IEJvb2xlYW5cclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtYnV0dG9uLS1jb21wYWN0JzogdGhpcy5jb21wYWN0LFxyXG4gICAgICAgICdtZGMtYnV0dG9uLS1hY2NlbnQnOiB0aGlzLmFjY2VudCxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgd2F0Y2g6IHtcclxuICAgIGNvbXBhY3QgKCkge1xyXG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tY29tcGFjdCcsIHRoaXMuY29tcGFjdCApXHJcbiAgICB9LFxyXG4gICAgYWNjZW50ICgpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWFjY2VudCcsIHRoaXMuYWNjZW50IClcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbi1pY29ucyBtZGMtY2FyZF9fYWN0aW9uLWljb25zXCI+XHJcbiAgICA8c2xvdD5cclxuICAgIDwvc2xvdD5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiBcIm1kYy1jYXJkLWFjdGlvbi1pY29uc1wiXHJcbn07XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNwYW4gOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiIFxyXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxyXG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cclxuICA8L3NwYW4+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQge0Rpc3BhdGNoRXZlbnRNaXhpbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbi1pY29uJyxcclxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBpY29uOiBTdHJpbmdcclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtY2FyZC1hY3Rpb24taWNvbic6IHRydWUsIFxyXG4gICAgICAgICdtYXRlcmlhbC1pY29ucyc6ISF0aGlzLmljb24sXHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtY2FyZF9fYWN0aW9uLS1pY29uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWljb24tdG9nZ2xlJzogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgaWNvbiAoKSB7XHJcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtYXRlcmlhbC1pY29ucycsICEhdGhpcy5pY29uKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCAoKSB7XHJcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMse1xyXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gdHJ1ZSxcclxuICAgIH0pXHJcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xyXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCBtZGNDYXJkIGZyb20gJy4vbWRjLWNhcmQudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFByaW1hcnlBY3Rpb24gZnJvbSAnLi9tZGMtY2FyZC1wcmltYXJ5LWFjdGlvbi52dWUnXHJcbmltcG9ydCBtZGNDYXJkTWVkaWEgZnJvbSAnLi9tZGMtY2FyZC1tZWRpYS52dWUnXHJcbmltcG9ydCBtZGNDYXJkSGVhZGVyIGZyb20gJy4vbWRjLWNhcmQtaGVhZGVyLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRUaXRsZSBmcm9tICcuL21kYy1jYXJkLXRpdGxlLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRTdWJ0aXRsZSBmcm9tICcuL21kYy1jYXJkLXN1YnRpdGxlLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRUZXh0IGZyb20gJy4vbWRjLWNhcmQtdGV4dC52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbnMudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMgZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24tYnV0dG9ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uQnV0dG9uIGZyb20gJy4vbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbi52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uSWNvbnMgZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24taWNvbnMudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZEFjdGlvbkljb24gZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24taWNvbi52dWUnXHJcblxyXG5leHBvcnQge1xyXG4gIG1kY0NhcmQsXHJcbiAgbWRjQ2FyZFByaW1hcnlBY3Rpb24sIFxyXG4gIG1kY0NhcmRNZWRpYSxcclxuICBtZGNDYXJkSGVhZGVyLFxyXG4gIG1kY0NhcmRUaXRsZSxcclxuICBtZGNDYXJkU3VidGl0bGUsXHJcbiAgbWRjQ2FyZFRleHQsXHJcbiAgbWRjQ2FyZEFjdGlvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbixcclxuICBtZGNDYXJkQWN0aW9uSWNvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkljb24gXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0NhcmQsIFxyXG4gIG1kY0NhcmRQcmltYXJ5QWN0aW9uLFxyXG4gIG1kY0NhcmRNZWRpYSxcclxuICBtZGNDYXJkSGVhZGVyLFxyXG4gIG1kY0NhcmRUaXRsZSxcclxuICBtZGNDYXJkU3VidGl0bGUsXHJcbiAgbWRjQ2FyZFRleHQsXHJcbiAgbWRjQ2FyZEFjdGlvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbixcclxuICBtZGNDYXJkQWN0aW9uSWNvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkljb25cclxufSlcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IE1EQ1JpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENSaXBwbGVGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQGV4dGVuZHMgTURDQ29tcG9uZW50PCFNRENSaXBwbGVGb3VuZGF0aW9uPlxuICovXG5jbGFzcyBNRENSaXBwbGUgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKiogQHBhcmFtIHsuLi4/fSBhcmdzICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51bmJvdW5kZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHt7aXNVbmJvdW5kZWQ6IChib29sZWFufHVuZGVmaW5lZCl9PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlfVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QsIHtpc1VuYm91bmRlZCA9IHVuZGVmaW5lZH0gPSB7fSkge1xuICAgIGNvbnN0IHJpcHBsZSA9IG5ldyBNRENSaXBwbGUocm9vdCk7XG4gICAgLy8gT25seSBvdmVycmlkZSB1bmJvdW5kZWQgYmVoYXZpb3IgaWYgb3B0aW9uIGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkXG4gICAgaWYgKGlzVW5ib3VuZGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJpcHBsZS51bmJvdW5kZWQgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpc1VuYm91bmRlZCk7XG4gICAgfVxuICAgIHJldHVybiByaXBwbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUmlwcGxlQ2FwYWJsZVN1cmZhY2V9IGluc3RhbmNlXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFkYXB0ZXIoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBNQVRDSEVTID0gdXRpbC5nZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB1dGlsLnN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvdyksXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gaW5zdGFuY2UudW5ib3VuZGVkLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBpbnN0YW5jZS5yb290X1tNQVRDSEVTXSgnOmFjdGl2ZScpLFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IGluc3RhbmNlLmRpc2FibGVkLFxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IGluc3RhbmNlLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiBpbnN0YW5jZS5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiBpbnN0YW5jZS5yb290Xy5jb250YWlucyh0YXJnZXQpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBpbnN0YW5jZS5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGluc3RhbmNlLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4gaW5zdGFuY2Uucm9vdF8uc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpLFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gaW5zdGFuY2Uucm9vdF8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAoe3g6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0fSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgdW5ib3VuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuYm91bmRlZF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0IHVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICB0aGlzLnVuYm91bmRlZF8gPSBCb29sZWFuKHVuYm91bmRlZCk7XG4gICAgdGhpcy5zZXRVbmJvdW5kZWRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc3VyZSBDb21waWxlciB0aHJvd3MgYW4gYWNjZXNzIGNvbnRyb2wgZXJyb3Igd2hlbiBkaXJlY3RseSBhY2Nlc3NpbmcgYVxuICAgKiBwcm90ZWN0ZWQgb3IgcHJpdmF0ZSBwcm9wZXJ0eSBpbnNpZGUgYSBnZXR0ZXIvc2V0dGVyLCBsaWtlIHVuYm91bmRlZCBhYm92ZS5cbiAgICogQnkgYWNjZXNzaW5nIHRoZSBwcm90ZWN0ZWQgcHJvcGVydHkgaW5zaWRlIGEgbWV0aG9kLCB3ZSBzb2x2ZSB0aGF0IHByb2JsZW0uXG4gICAqIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBleGlzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRVbmJvdW5kZWRfKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0VW5ib3VuZGVkKHRoaXMudW5ib3VuZGVkXyk7XG4gIH1cblxuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlKCk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ubGF5b3V0KCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1JpcHBsZUZvdW5kYXRpb259ICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihNRENSaXBwbGUuY3JlYXRlQWRhcHRlcih0aGlzKSk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgdGhpcy51bmJvdW5kZWQgPSAnbWRjUmlwcGxlSXNVbmJvdW5kZWQnIGluIHRoaXMucm9vdF8uZGF0YXNldDtcbiAgfVxufVxuXG4vKipcbiAqIFNlZSBNYXRlcmlhbCBEZXNpZ24gc3BlYyBmb3IgbW9yZSBkZXRhaWxzIG9uIHdoZW4gdG8gdXNlIHJpcHBsZXMuXG4gKiBodHRwczovL21hdGVyaWFsLmlvL2d1aWRlbGluZXMvbW90aW9uL2Nob3Jlb2dyYXBoeS5odG1sI2Nob3Jlb2dyYXBoeS1jcmVhdGlvblxuICogQHJlY29yZFxuICovXG5jbGFzcyBSaXBwbGVDYXBhYmxlU3VyZmFjZSB7fVxuXG4vKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUucm9vdF87XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBibGVlZHMgb3V0IG9mIHRoZSBib3VuZHMgb2YgdGhlIGVsZW1lbnQuXG4gKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS51bmJvdW5kZWQ7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBpcyBhdHRhY2hlZCB0byBhIGRpc2FibGVkIGNvbXBvbmVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLmRpc2FibGVkO1xuXG5leHBvcnQge01EQ1JpcHBsZSwgTURDUmlwcGxlRm91bmRhdGlvbiwgUmlwcGxlQ2FwYWJsZVN1cmZhY2UsIHV0aWx9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1JpcHBsZX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9pbmRleCc7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGNoZWNrZWQ6IGJvb2xlYW4sXG4gKiAgIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4sXG4gKiAgIGRpc2FibGVkOiBib29sZWFuLFxuICogICB2YWx1ZTogP3N0cmluZ1xuICogfX1cbiAqL1xubGV0IE1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZTtcblxuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdGlvbkNvbnRyb2wge1xuICAvKiogQHJldHVybiB7P01EQ1JpcHBsZX0gKi9cbiAgZ2V0IHJpcHBsZSgpIHt9XG59XG5cbmV4cG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlLCBNRENTZWxlY3Rpb25Db250cm9sfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBDaGVja2JveC4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBldmVudCBoYW5kbGVyc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDQ2hlY2tib3hBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICByZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEByZXR1cm4geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9ICovXG4gIGdldE5hdGl2ZUNvbnRyb2woKSB7fVxuXG4gIGZvcmNlTGF5b3V0KCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNBdHRhY2hlZFRvRE9NKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IFJPT1QgPSAnbWRjLWNoZWNrYm94JztcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBVUEdSQURFRDogJ21kYy1jaGVja2JveC0tdXBncmFkZWQnLFxuICBDSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1jaGVja2VkJyxcbiAgSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0taW5kZXRlcm1pbmF0ZScsXG4gIERJU0FCTEVEOiAnbWRjLWNoZWNrYm94LS1kaXNhYmxlZCcsXG4gIEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tdW5jaGVja2VkLWNoZWNrZWQnLFxuICBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1pbmRldGVybWluYXRlJyxcbiAgQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLXVuY2hlY2tlZCcsXG4gIEFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXG4gIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtY2hlY2tlZCcsXG4gIEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUjogYC4ke1JPT1R9X19uYXRpdmUtY29udHJvbGAsXG4gIFRSQU5TSVRJT05fU1RBVEVfSU5JVDogJ2luaXQnLFxuICBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQ6ICdjaGVja2VkJyxcbiAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ6ICd1bmNoZWNrZWQnLFxuICBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEU6ICdpbmRldGVybWluYXRlJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgQU5JTV9FTkRfTEFUQ0hfTVM6IDI1MCxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5pbXBvcnQgTURDQ2hlY2tib3hBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqIEBjb25zdCB7IUFycmF5PHN0cmluZz59ICovXG5jb25zdCBDQl9QUk9UT19QUk9QUyA9IFsnY2hlY2tlZCcsICdpbmRldGVybWluYXRlJ107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0NoZWNrYm94QWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0NoZWNrYm94QWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDQ2hlY2tib3hBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGdldE5hdGl2ZUNvbnRyb2w6ICgpID0+IC8qICFNRENTZWxlY3Rpb25Db250cm9sU3RhdGUgKi8ge30sXG4gICAgICBmb3JjZUxheW91dDogKCkgPT4ge30sXG4gICAgICBpc0F0dGFjaGVkVG9ET006ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENDaGVja2JveEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuY3VycmVudENoZWNrU3RhdGVfID0gc3RyaW5ncy5UUkFOU0lUSU9OX1NUQVRFX0lOSVQ7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18gPSAnJztcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYW5pbUVuZExhdGNoVGltZXJfID0gMDtcblxuICAgIHRoaXMuYW5pbUVuZEhhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy5oYW5kbGVBbmltYXRpb25FbmQoKSk7XG5cbiAgICB0aGlzLmNoYW5nZUhhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy5oYW5kbGVDaGFuZ2UoKSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuY3VycmVudENoZWNrU3RhdGVfID0gdGhpcy5kZXRlcm1pbmVDaGVja1N0YXRlXyh0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckNoYW5nZUhhbmRsZXIodGhpcy5jaGFuZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcih0aGlzLmNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLnVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNDaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWQgKi9cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzSW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmluZGV0ZXJtaW5hdGU7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpbmRldGVybWluYXRlICovXG4gIHNldEluZGV0ZXJtaW5hdGUoaW5kZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgYW5pbWF0aW9uZW5kIGV2ZW50IGZvciB0aGUgY2hlY2tib3hcbiAgICovXG4gIGhhbmRsZUFuaW1hdGlvbkVuZCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8pO1xuICAgIHRoaXMuYW5pbUVuZExhdGNoVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKHRoaXMuYW5pbUVuZEhhbmRsZXJfKTtcbiAgICB9LCBudW1iZXJzLkFOSU1fRU5EX0xBVENIX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHRoZSBjaGVja2JveFxuICAgKi9cbiAgaGFuZGxlQ2hhbmdlKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbkNoZWNrU3RhdGVfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5nZXROYXRpdmVDb250cm9sXygpO1xuICAgIGNvbnN0IGNiUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmF0aXZlQ2IpO1xuXG4gICAgQ0JfUFJPVE9fUFJPUFMuZm9yRWFjaCgoY29udHJvbFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjYlByb3RvLCBjb250cm9sU3RhdGUpO1xuICAgICAgLy8gV2UgaGF2ZSB0byBjaGVjayBmb3IgdGhpcyBkZXNjcmlwdG9yLCBzaW5jZSBzb21lIGJyb3dzZXJzIChTYWZhcmkpIGRvbid0IHN1cHBvcnQgaXRzIHJldHVybi5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQ5NzM5XG4gICAgICBpZiAodmFsaWREZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUNiRGVzYyA9IC8qKiBAdHlwZSB7IU9iamVjdFByb3BlcnR5RGVzY3JpcHRvcn0gKi8gKHtcbiAgICAgICAgICBnZXQ6IGRlc2MuZ2V0LFxuICAgICAgICAgIHNldDogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKG5hdGl2ZUNiLCBzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25DaGVja1N0YXRlXygpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2IsIGNvbnRyb2xTdGF0ZSwgbmF0aXZlQ2JEZXNjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1bmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpIHtcbiAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKTtcbiAgICBjb25zdCBjYlByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5hdGl2ZUNiKTtcblxuICAgIENCX1BST1RPX1BST1BTLmZvckVhY2goKGNvbnRyb2xTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZGVzYyA9IC8qKiBAdHlwZSB7IU9iamVjdFByb3BlcnR5RGVzY3JpcHRvcn0gKi8gKFxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNiUHJvdG8sIGNvbnRyb2xTdGF0ZSkpO1xuICAgICAgaWYgKHZhbGlkRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2IsIGNvbnRyb2xTdGF0ZSwgZGVzYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdHJhbnNpdGlvbkNoZWNrU3RhdGVfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVDb250cm9sKCk7XG4gICAgaWYgKCFuYXRpdmVDYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudENoZWNrU3RhdGVfO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5kZXRlcm1pbmVDaGVja1N0YXRlXyhuYXRpdmVDYik7XG4gICAgaWYgKG9sZFN0YXRlID09PSBuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGlzbid0IGEgcHJldmlvdXNseSBleGlzdGluZyBhbmltYXRpb24gY2xhc3MsIGluIGNhc2UgZm9yIGV4YW1wbGVcbiAgICAvLyB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIGNoZWNrYm94IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHdhcyBmaW5pc2hlZC5cbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfLmxlbmd0aCA+IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvcmNlTGF5b3V0KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfID0gdGhpcy5nZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSBuZXdTdGF0ZTtcblxuICAgIC8vIENoZWNrIGZvciBwYXJlbnROb2RlIHNvIHRoYXQgYW5pbWF0aW9ucyBhcmUgb25seSBydW4gd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZFxuICAgIC8vIHRvIHRoZSBET00uXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNBdHRhY2hlZFRvRE9NKCkgJiYgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKHRoaXMuYW5pbUVuZEhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBuYXRpdmVDYlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRlcm1pbmVDaGVja1N0YXRlXyhuYXRpdmVDYikge1xuICAgIGNvbnN0IHtcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURSxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VELFxuICAgIH0gPSBzdHJpbmdzO1xuXG4gICAgaWYgKG5hdGl2ZUNiLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEU7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVDYi5jaGVja2VkID8gVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEIDogVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdGF0ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfSU5JVCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VELFxuICAgIH0gPSBzdHJpbmdzO1xuXG4gICAgY29uc3Qge1xuICAgICAgQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRCxcbiAgICAgIEFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEUsXG4gICAgICBBTklNX0NIRUNLRURfVU5DSEVDS0VELFxuICAgICAgQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEUsXG4gICAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCxcbiAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQsXG4gICAgfSA9IE1EQ0NoZWNrYm94Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuXG4gICAgc3dpdGNoIChvbGRTdGF0ZSkge1xuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9JTklUOlxuICAgICAgaWYgKG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEOlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgPyBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIDogQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTtcbiAgICBjYXNlIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRDpcbiAgICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQgPyBBTklNX0NIRUNLRURfVU5DSEVDS0VEIDogQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEU7XG4gICAgLy8gVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEID9cbiAgICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQgOiBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlQ29udHJvbF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpIHx8IHtcbiAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J8dW5kZWZpbmVkfSBpbnB1dFByb3BEZXNjXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZERlc2NyaXB0b3IoaW5wdXRQcm9wRGVzYykge1xuICByZXR1cm4gISFpbnB1dFByb3BEZXNjICYmIHR5cGVvZiBpbnB1dFByb3BEZXNjLnNldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGb3JtIEZpZWxkLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHJpcHBsZSBhY3RpdmF0aW9uXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENGb3JtRmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICBhY3RpdmF0ZUlucHV0UmlwcGxlKCkge31cblxuICBkZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3JtRmllbGRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZvcm0tZmllbGQgPiBsYWJlbCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENGb3JtRmllbGRBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0Zvcm1GaWVsZEFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENGb3JtRmllbGRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IC8qKiBAdHlwZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQ2xpY2tfKCkpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGhhbmRsZUNsaWNrXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlSW5wdXRSaXBwbGUoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm9ybUZpZWxkRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIG5vUHJlZml4OiBzdHJpbmcsXG4gKiAgIHdlYmtpdFByZWZpeDogc3RyaW5nLFxuICogICBzdHlsZVByb3BlcnR5OiBzdHJpbmdcbiAqIH19XG4gKi9cbmxldCBWZW5kb3JQcm9wZXJ0eU1hcFR5cGU7XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgZXZlbnRUeXBlTWFwID0ge1xuICAnYW5pbWF0aW9uc3RhcnQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25zdGFydCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0QW5pbWF0aW9uU3RhcnQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uZW5kJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uaXRlcmF0aW9uJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25JdGVyYXRpb24nLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNpdGlvbmVuZCc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICd0cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgY3NzUHJvcGVydHlNYXAgPSB7XG4gICdhbmltYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtYW5pbWF0aW9uJyxcbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zZm9ybScsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICB9LFxuICAndHJhbnNpdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtdHJhbnNpdGlvbicsXG4gIH0sXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHtcbiAgcmV0dXJuICh3aW5kb3dPYmpbJ2RvY3VtZW50J10gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGV2ZW50Rm91bmRJbk1hcHMoZXZlbnRUeXBlKSB7XG4gIHJldHVybiAoZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCB8fCBldmVudFR5cGUgaW4gY3NzUHJvcGVydHlNYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSBtYXBcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEphdmFTY3JpcHRFdmVudE5hbWUoZXZlbnRUeXBlLCBtYXAsIGVsKSB7XG4gIHJldHVybiBtYXBbZXZlbnRUeXBlXS5zdHlsZVByb3BlcnR5IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBicm93c2VyIHByZWZpeCBmb3IgQ1NTMyBhbmltYXRpb24gZXZlbnRzXG4gKiBhbmQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcGFyYW0geyFPYmplY3R9IHdpbmRvd09ialxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb25OYW1lKHdpbmRvd09iaiwgZXZlbnRUeXBlKSB7XG4gIGlmICghaGFzUHJvcGVyU2hhcGUod2luZG93T2JqKSB8fCAhZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqLyAoXG4gICAgZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCA/IGV2ZW50VHlwZU1hcCA6IGNzc1Byb3BlcnR5TWFwXG4gICk7XG4gIGNvbnN0IGVsID0gd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10oJ2RpdicpO1xuICBsZXQgZXZlbnROYW1lID0gJyc7XG5cbiAgaWYgKG1hcCA9PT0gZXZlbnRUeXBlTWFwKSB7XG4gICAgZXZlbnROYW1lID0gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50TmFtZSA9IG1hcFtldmVudFR5cGVdLm5vUHJlZml4IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBQdWJsaWMgZnVuY3Rpb25zIHRvIGFjY2VzcyBnZXRBbmltYXRpb25OYW1lKCkgZm9yIEphdmFTY3JpcHQgZXZlbnRzIG9yIENTU1xuLy8gcHJvcGVydHkgbmFtZXMuXG5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyA9IFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNU1RyYW5zZm9ybSddO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG5leHBvcnQge3RyYW5zZm9ybVN0eWxlUHJvcGVydGllcywgZ2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgOmNsYXNzPWZvcm1GaWVsZENsYXNzZXMgY2xhc3M9XCJtZGMtY2hlY2tib3gtd3JhcHBlclwiPlxuICAgIDxkaXYgcmVmPVwicm9vdFwiIGNsYXNzPVwibWRjLWNoZWNrYm94XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCI+XG4gICAgICA8aW5wdXQgcmVmPVwiY29udHJvbFwiIDppZD1cIl91aWRcIiB0eXBlPVwiY2hlY2tib3hcIiA6bmFtZT1cIm5hbWVcIlxuICAgICAgICBjbGFzcz1cIm1kYy1jaGVja2JveF9fbmF0aXZlLWNvbnRyb2xcIiA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtY2hlY2tib3hfX2JhY2tncm91bmRcIj5cbiAgICAgICAgPHN2ZyBjbGFzcz1cIm1kYy1jaGVja2JveF9fY2hlY2ttYXJrXCJcbiAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBjbGFzcz1cImNoZWNrYm94X19jaGVja21hcmstcGF0aFwiXG4gICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbiAgICAgICAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIi8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLWNoZWNrYm94X19taXhlZG1hcmtcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxsYWJlbCByZWY9XCJsYWJlbFwiICA6Zm9yPVwiX3VpZFwiXG4gICAgPjxzbG90Pnt7bGFiZWx9fTwvc2xvdD48L2xhYmVsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuaW1wb3J0IE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbidcbmltcG9ydCBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQge2dldENvcnJlY3RFdmVudE5hbWV9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24nXG5pbXBvcnQge0Rpc3BhdGNoRm9jdXNNaXhpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7UmlwcGxlQmFzZX0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hlY2tib3gnLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdjaGVja2VkJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAnY2hlY2tlZCc6IEJvb2xlYW4sXG4gICAgJ2luZGV0ZXJtaW5hdGUnOiBCb29sZWFuLFxuICAgICdkaXNhYmxlZCc6IEJvb2xlYW4sXG4gICAgJ2xhYmVsJzogU3RyaW5nLFxuICAgICdhbGlnbi1lbmQnOiBCb29sZWFuLFxuICAgICd2YWx1ZSc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0ICgpIHsgcmV0dXJuICdvbicgfSB9LFxuICAgICduYW1lJzogU3RyaW5nXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgY2xhc3Nlczoge31cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWwgfHwgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIH0sXG4gICAgZm9ybUZpZWxkQ2xhc3NlcyAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWZvcm0tZmllbGQnOiB0aGlzLmhhc0xhYmVsLFxuICAgICAgICAnbWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZCc6IHRoaXMuaGFzTGFiZWwgJiYgdGhpcy5hbGlnbkVuZFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnY2hlY2tlZCcgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZCh2YWx1ZSlcbiAgICB9LFxuICAgICdkaXNhYmxlZCcgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodmFsdWUpXG4gICAgfSxcbiAgICAnaW5kZXRlcm1pbmF0ZScgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0SW5kZXRlcm1pbmF0ZSh2YWx1ZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENDaGVja2JveEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAnYW5pbWF0aW9uZW5kJyksIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogKGhhbmRsZXIpID0+IHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gdGhpcy4kcmVmcy5jb250cm9sLFxuICAgICAgZm9yY2VMYXlvdXQ6ICgpID0+IHRoaXMuJHJlZnMucm9vdC5vZmZzZXRXaWR0aCxcbiAgICAgIGlzQXR0YWNoZWRUb0RPTTogKCkgPT4gQm9vbGVhbih0aGlzLiRlbC5wYXJlbnROb2RlKVxuICAgIH0pXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBSaXBwbGVCYXNlLmlzU3VyZmFjZUFjdGl2ZSh0aGlzLiRyZWZzLmNvbnRyb2wpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcdFx0XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcdFx0XG4gICAgICB9LFx0XHRcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcdFx0XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcdFx0XG4gICAgICB9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm9ybUZpZWxkID0gbmV3IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24oe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuYWN0aXZhdGUoKVxuICAgICAgfSxcbiAgICAgIGRlYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZWFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgdGhpcy5mb3JtRmllbGQuaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQodGhpcy5jaGVja2VkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRJbmRldGVybWluYXRlKHRoaXMuaW5kZXRlcm1pbmF0ZSlcblxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvcm1GaWVsZC5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZSAoKSB7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6aW5kZXRlcm1pbmF0ZScsIHRoaXMuZm91bmRhdGlvbi5pc0luZGV0ZXJtaW5hdGUoKSlcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuZm91bmRhdGlvbi5pc0NoZWNrZWQoKSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0NoZWNrYm94IGZyb20gJy4vbWRjLWNoZWNrYm94LnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjQ2hlY2tib3hcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0NoZWNrYm94XG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBDaGlwLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIENoaXAgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gXCJNRENDaGlwOmludGVyYWN0aW9uXCIgZXZlbnQgZGVub3RpbmcgdGhlIGNoaXAgaGFzIGJlZW5cbiAgICogaW50ZXJhY3RlZCB3aXRoICh0eXBpY2FsbHkgb24gY2xpY2sgb3Iga2V5ZG93bikuXG4gICAqL1xuICBub3RpZnlJbnRlcmFjdGlvbigpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoaXBBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgSU5URVJBQ1RJT05fRVZFTlQ6ICdNRENDaGlwOmludGVyYWN0aW9uJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDQ2hpcEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0NoaXBBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENDaGlwRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENDaGlwQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENDaGlwQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoaXBBZGFwdGVyfSAqLyAoe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJbnRlcmFjdGlvbjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyhldnQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnQgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb25fKGV2dCkge1xuICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJyB8fCBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlJbnRlcmFjdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbjxkaXYgY2xhc3M9XCJtZGMtY2hpcFwiIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIiB0YWJpbmRleD1cIjBcIiA+XG4gIDxpIGNsYXNzPVwibWRjLWNoaXBfX2ljb24gbWRjLWNoaXBfX2ljb24tLWxlYWRpbmdcIiBcbiAgICA6Y2xhc3M9XCJsZWFkaW5nQ2xhc3Nlc1wiIHYtaWY9XCJoYXZlbGVhZGluZ0ljb25cIlxuICA+e3tsZWFkaW5nSWNvbn19PC9pPlxuICA8ZGl2IGNsYXNzZXM9XCJtZGMtY2hpcF9fdGV4dFwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9kaXY+XG4gIDxpIGNsYXNzPVwibWRjLWNoaXBfX2ljb24gbWRjLWNoaXBfX2ljb24tLXRyYWlsaW5nXCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiIFxuICAgIDpjbGFzcz1cInRyYWlsaW5nQ2xhc3Nlc1wiIHYtaWY9XCJoYXZldHJhaWxpbmdJY29uXCJcbiAgPnt7dHJhaWxpbmdJY29ufX08L2k+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDQ2hpcEZvdW5kYXRpb24gZnJvbSBcIkBtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb25cIjtcbmltcG9ydCB7IEN1c3RvbUxpbmtNaXhpbiwgRGlzcGF0Y2hFdmVudE1peGluIH0gZnJvbSBcIi4uL2Jhc2VcIjtcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tIFwiLi4vcmlwcGxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJtZGMtY2hpcFwiLFxuICBtaXhpbnM6IFtDdXN0b21MaW5rTWl4aW4sIERpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgbGVhZGluZ0ljb246IFtTdHJpbmddLFxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZ10sXG4gICAgbGVhZGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XSxcbiAgICB0cmFpbGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7fSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hpcEZvdW5kYXRpb24oe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBub3RpZnlJbnRlcmFjdGlvbjogKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAnY2xpY2snIH0pXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKTtcbiAgICB0aGlzLnJpcHBsZS5pbml0KCk7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGF2ZWxlYWRpbmdJY29uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5sZWFkaW5nSWNvbiB8fCB0aGlzLmxlYWRpbmdJY29uQ2xhc3NlcztcbiAgICB9LFxuICAgIGhhdmV0cmFpbGluZ0ljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLnRyYWlsaW5nSWNvbkNsYXNzZXM7XG4gICAgfSxcbiAgICBsZWFkaW5nQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAge1xuICAgICAgICAgIFwibWF0ZXJpYWwtaWNvbnNcIjogISF0aGlzLmxlYWRpbmdJY29uXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMubGVhZGluZ0ljb25DbGFzc2VzXG4gICAgICApO1xuICAgIH0sXG4gICAgdHJhaWxpbmdDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJtYXRlcmlhbC1pY29uc1wiOiAhIXRoaXMudHJhaWxpbmdJY29uXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMudHJhaWxpbmdJY29uQ2xhc3Nlc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KCk7XG4gIH1cbn07XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hpcCBTZXQuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgQ2hpcCBTZXQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBTZXRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoaXBTZXRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ0hJUF9TRUxFQ1RPUjogJy5tZGMtY2hpcCcsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NoaXBTZXRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hpcFNldEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0NoaXBTZXRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0NoaXBTZXRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0NoaXBTZXRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDQ2hpcFNldEFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcFNldEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBTZXRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcFNldEZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgcmVmPVwicm9vdFwiIGNsYXNzPVwibWRjLWNoaXAtc2V0XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDQ2hpcFNldEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2NoaXBzL2NoaXAtc2V0L2ZvdW5kYXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hpcC1zZXQnLFxuICBwcm9wczoge30sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHt9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENDaGlwU2V0Rm91bmRhdGlvbih7XG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICB9KTtcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKTtcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNDaGlwIGZyb20gJy4vbWRjLWNoaXAudnVlJ1xuaW1wb3J0IG1kY0NoaXBTZXQgZnJvbSAnLi9tZGMtY2hpcC1zZXQudnVlJ1xuXG5leHBvcnQgeyBcbiAgbWRjQ2hpcCwgXG4gIG1kY0NoaXBTZXQgXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGlwLCBcbiAgbWRjQ2hpcFNldCBcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQge01EQ0ZvdW5kYXRpb24sIE1EQ0NvbXBvbmVudH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kaWFsb2cnLFxuICBPUEVOOiAnbWRjLWRpYWxvZy0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kaWFsb2ctLWFuaW1hdGluZycsXG4gIEJBQ0tEUk9QOiAnbWRjLWRpYWxvZ19fYmFja2Ryb3AnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kaWFsb2ctc2Nyb2xsLWxvY2snLFxuICBBQ0NFUFRfQlROOiAnbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWFjY2VwdCcsXG4gIENBTkNFTF9CVE46ICdtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tY2FuY2VsJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBPUEVOX0RJQUxPR19TRUxFQ1RPUjogJy5tZGMtZGlhbG9nLS1vcGVuJyxcbiAgRElBTE9HX1NVUkZBQ0VfU0VMRUNUT1I6ICcubWRjLWRpYWxvZ19fc3VyZmFjZScsXG4gIEFDQ0VQVF9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0JyxcbiAgQUNDRVBUX0VWRU5UOiAnTURDRGlhbG9nOmFjY2VwdCcsXG4gIENBTkNFTF9FVkVOVDogJ01EQ0RpYWxvZzpjYW5jZWwnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ0RpYWxvZ0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgvKiB0YXJnZXQ6IEV2ZW50VGFyZ2V0LCBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICB1bnRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICBpc0RpYWxvZzogKC8qIGVsOiBFbGVtZW50ICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgbGF5b3V0Rm9vdGVyUmlwcGxlczogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKGV2dC50YXJnZXQsIGNzc0NsYXNzZXMuQkFDS0RST1ApKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVEaWFsb2dDbGlja18oZXZ0KTtcbiAgICB0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgJiYgZXZ0LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZ0LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG4gIH07XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCBkaWFsb2cgaXMgY2xlYW5lZCB1cCB3aGVuIGRlc3Ryb3llZFxuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udW50cmFwRm9jdXNPblN1cmZhY2UoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgYWNjZXB0KHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5QWNjZXB0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgY2FuY2VsKHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgaGFuZGxlRGlhbG9nQ2xpY2tfKGV2dCkge1xuICAgIGNvbnN0IHt0YXJnZXR9ID0gZXZ0O1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzLkFDQ0VQVF9CVE4pKSB7XG4gICAgICB0aGlzLmFjY2VwdCh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNzc0NsYXNzZXMuQ0FOQ0VMX0JUTikpIHtcbiAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzRGlhbG9nKGV2dC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmxheW91dEZvb3RlclJpcHBsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudERvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCB8fCBlbDtcbiAgdmFyIGJhc2ljVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG5cbiAgLy8gQSBub2RlIGlzIFwiYXZhaWxhYmxlXCIgaWZcbiAgLy8gLSBpdCdzIGNvbXB1dGVkIHN0eWxlXG4gIHZhciBpc1VuYXZhaWxhYmxlID0gY3JlYXRlSXNVbmF2YWlsYWJsZShlbGVtZW50RG9jdW1lbnQpO1xuXG4gIHZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICAgJ2lucHV0JyxcbiAgICAnc2VsZWN0JyxcbiAgICAnYVtocmVmXScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnW3RhYmluZGV4XScsXG4gIF07XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJykpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgaWYgKFxuICAgICAgY2FuZGlkYXRlU2VsZWN0b3JzLnNvbWUoZnVuY3Rpb24oY2FuZGlkYXRlU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUsIGNhbmRpZGF0ZUluZGV4O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcbiAgICBjYW5kaWRhdGVJbmRleCA9IHBhcnNlSW50KGNhbmRpZGF0ZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSB8fCBjYW5kaWRhdGUudGFiSW5kZXg7XG5cbiAgICBpZiAoXG4gICAgICBjYW5kaWRhdGVJbmRleCA8IDBcbiAgICAgIHx8IChjYW5kaWRhdGUudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBjYW5kaWRhdGUudHlwZSA9PT0gJ2hpZGRlbicpXG4gICAgICB8fCBjYW5kaWRhdGUuZGlzYWJsZWRcbiAgICAgIHx8IGlzVW5hdmFpbGFibGUoY2FuZGlkYXRlLCBlbGVtZW50RG9jdW1lbnQpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2FuZGlkYXRlSW5kZXggPT09IDApIHtcbiAgICAgIGJhc2ljVGFiYmFibGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVJbmRleCxcbiAgICAgICAgbm9kZTogY2FuZGlkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmluZGV4IC0gYi5pbmRleCA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xuICAgIH0pXG4gICAgLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYS5ub2RlXG4gICAgfSk7XG5cbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGFiYmFibGVOb2RlcywgYmFzaWNUYWJiYWJsZXMpO1xuXG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJc1VuYXZhaWxhYmxlKGVsZW1lbnREb2N1bWVudCkge1xuICAvLyBOb2RlIGNhY2hlIG11c3QgYmUgcmVmcmVzaGVkIG9uIGV2ZXJ5IGNoZWNrLCBpbiBjYXNlXG4gIC8vIHRoZSBjb250ZW50IG9mIHRoZSBlbGVtZW50IGhhcyBjaGFuZ2VkXG4gIHZhciBpc09mZkNhY2hlID0gW107XG5cbiAgLy8gXCJvZmZcIiBtZWFucyBgZGlzcGxheTogbm9uZTtgLCBhcyBvcHBvc2VkIHRvIFwiaGlkZGVuXCIsXG4gIC8vIHdoaWNoIG1lYW5zIGB2aXNpYmlsaXR5OiBoaWRkZW47YC4gZ2V0Q29tcHV0ZWRTdHlsZVxuICAvLyBhY2N1cmF0ZWx5IHJlZmxlY3RzIHZpc2libGl0eSBpbiBjb250ZXh0IGJ1dCBub3RcbiAgLy8gXCJvZmZcIiBzdGF0ZSwgc28gd2UgbmVlZCB0byByZWN1cnNpdmVseSBjaGVjayBwYXJlbnRzLlxuXG4gIGZ1bmN0aW9uIGlzT2ZmKG5vZGUsIG5vZGVDb21wdXRlZFN0eWxlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVsZW1lbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEZpbmQgdGhlIGNhY2hlZCBub2RlIChBcnJheS5wcm90b3R5cGUuZmluZCBub3QgYXZhaWxhYmxlIGluIElFOSlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaXNPZmZDYWNoZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzT2ZmQ2FjaGVbaV1bMF0gPT09IG5vZGUpIHJldHVybiBpc09mZkNhY2hlW2ldWzFdO1xuICAgIH1cblxuICAgIG5vZGVDb21wdXRlZFN0eWxlID0gbm9kZUNvbXB1dGVkU3R5bGUgfHwgZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICBpZiAobm9kZUNvbXB1dGVkU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICByZXN1bHQgPSBpc09mZihub2RlLnBhcmVudE5vZGUpO1xuICAgIH1cblxuICAgIGlzT2ZmQ2FjaGUucHVzaChbbm9kZSwgcmVzdWx0XSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGlzVW5hdmFpbGFibGUobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbGVtZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGVsZW1lbnREb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgaWYgKGlzT2ZmKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBjb21wdXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nO1xuICB9XG59XG4iLCJ2YXIgdGFiYmFibGUgPSByZXF1aXJlKCd0YWJiYWJsZScpO1xuXG52YXIgbGlzdGVuaW5nRm9jdXNUcmFwID0gbnVsbDtcblxuZnVuY3Rpb24gZm9jdXNUcmFwKGVsZW1lbnQsIHVzZXJPcHRpb25zKSB7XG4gIHZhciB0YWJiYWJsZU5vZGVzID0gW107XG4gIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IG51bGw7XG4gIHZhciBsYXN0VGFiYmFibGVOb2RlID0gbnVsbDtcbiAgdmFyIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IG51bGw7XG4gIHZhciBhY3RpdmUgPSBmYWxzZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICB2YXIgdGFiRXZlbnQgPSBudWxsO1xuXG4gIHZhciBjb250YWluZXIgPSAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KVxuICAgIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0gdXNlck9wdGlvbnMgfHwge307XG4gIGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGVcbiAgICA6IHRydWU7XG4gIGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMuZXNjYXBlRGVhY3RpdmF0ZXNcbiAgICA6IHRydWU7XG5cbiAgdmFyIHRyYXAgPSB7XG4gICAgYWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgIGRlYWN0aXZhdGU6IGRlYWN0aXZhdGUsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIHVucGF1c2U6IHVucGF1c2UsXG4gIH07XG5cbiAgcmV0dXJuIHRyYXA7XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGUoYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKGFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIG9uQWN0aXZhdGU6IChhY3RpdmF0ZU9wdGlvbnMgJiYgYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkFjdGl2YXRlLFxuICAgIH07XG5cbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUpIHtcbiAgICAgIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKCFhY3RpdmUpIHJldHVybjtcblxuICAgIHZhciBkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIHJldHVybkZvY3VzOiAoZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1c1xuICAgICAgICA6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSxcbiAgICAgIG9uRGVhY3RpdmF0ZTogKGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgfTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5Rm9jdXMobm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaWYgKHBhdXNlZCB8fCAhYWN0aXZlKSByZXR1cm47XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKCFwYXVzZWQgfHwgIWFjdGl2ZSkgcmV0dXJuO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghYWN0aXZlKSByZXR1cm47XG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG4gICAgaWYgKGxpc3RlbmluZ0ZvY3VzVHJhcCkge1xuICAgICAgbGlzdGVuaW5nRm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgfVxuICAgIGxpc3RlbmluZ0ZvY3VzVHJhcCA9IHRyYXA7XG5cbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgdHJ5Rm9jdXMoZmlyc3RGb2N1c05vZGUoKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjaGVja0ZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFhY3RpdmUgfHwgbGlzdGVuaW5nRm9jdXNUcmFwICE9PSB0cmFwKSByZXR1cm47XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGNoZWNrRm9jdXMsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG5cbiAgICBsaXN0ZW5pbmdGb2N1c1RyYXAgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlRm9yT3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG4gICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTtcbiAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIHJlZmVycyB0byBubyBrbm93biBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgZGlkIG5vdCByZXR1cm4gYSBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyc3RGb2N1c05vZGUoKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJyk7XG4gICAgfSBlbHNlIGlmIChjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdGFiYmFibGVOb2Rlc1swXSB8fCBnZXROb2RlRm9yT3B0aW9uKCdmYWxsYmFja0ZvY3VzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5cXCd0IGhhdmUgYSBmb2N1cy10cmFwIHdpdGhvdXQgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgb24gbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGluc3RlYWQgb2YgY2xpY2tcbiAgLy8gc28gdGhhdCBpdCBwcmVjZWRlcyB0aGUgZm9jdXMgZXZlbnRcbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRG93bihlKSB7XG4gICAgaWYgKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcyAmJiAhY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgZGVhY3RpdmF0ZSh7IHJldHVybkZvY3VzOiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9jdXMoZSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgLy8gQ2hlY2tpbmcgZm9yIGEgYmx1ciBtZXRob2QgaGVyZSByZXNvbHZlcyBhIEZpcmVmb3ggaXNzdWUgKCMxNSlcbiAgICBpZiAodHlwZW9mIGUudGFyZ2V0LmJsdXIgPT09ICdmdW5jdGlvbicpIGUudGFyZ2V0LmJsdXIoKTtcblxuICAgIGlmICh0YWJFdmVudCkge1xuICAgICAgcmVhZGp1c3RGb2N1cyh0YWJFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICBoYW5kbGVUYWIoZSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gZmFsc2UgJiYgaXNFc2NhcGVFdmVudChlKSkge1xuICAgICAgZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYihlKSB7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuXG4gICAgaWYgKGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBOdW1iZXIoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKSA8IDApIHtcbiAgICAgIHJldHVybiB0YWJFdmVudCA9IGU7XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjdXJyZW50Rm9jdXNJbmRleCA9IHRhYmJhYmxlTm9kZXMuaW5kZXhPZihlLnRhcmdldCk7XG5cbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZSB8fCB0YWJiYWJsZU5vZGVzLmluZGV4T2YoZS50YXJnZXQpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ5Rm9jdXModGFiYmFibGVOb2Rlc1tjdXJyZW50Rm9jdXNJbmRleCAtIDFdKTtcbiAgICB9XG5cbiAgICBpZiAoZS50YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGUpIHJldHVybiB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyh0YWJiYWJsZU5vZGVzW2N1cnJlbnRGb2N1c0luZGV4ICsgMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGFiYmFibGVOb2RlcygpIHtcbiAgICB0YWJiYWJsZU5vZGVzID0gdGFiYmFibGUoY29udGFpbmVyKTtcbiAgICBmaXJzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbMF07XG4gICAgbGFzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRqdXN0Rm9jdXMoZSkge1xuICAgIGlmIChlLnNoaWZ0S2V5KSByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFc2NhcGVFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ0VzY2FwZScgfHwgZS5rZXkgPT09ICdFc2MnIHx8IGUua2V5Q29kZSA9PT0gMjc7XG59XG5cbmZ1bmN0aW9uIHRyeUZvY3VzKG5vZGUpIHtcbiAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSByZXR1cm47XG4gIGlmIChub2RlID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAgcmV0dXJuO1xuXG4gIG5vZGUuZm9jdXMoKTtcbiAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgbm9kZS5zZWxlY3QoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzVHJhcDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBjcmVhdGVGb2N1c1RyYXAgZnJvbSAnZm9jdXMtdHJhcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZShzdXJmYWNlRWwsIGFjY2VwdEJ1dHRvbkVsLCBmb2N1c1RyYXBGYWN0b3J5ID0gY3JlYXRlRm9jdXNUcmFwKSB7XG4gIHJldHVybiBmb2N1c1RyYXBGYWN0b3J5KHN1cmZhY2VFbCwge1xuICAgIGluaXRpYWxGb2N1czogYWNjZXB0QnV0dG9uRWwsXG4gICAgY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM6IHRydWUsXG4gIH0pO1xufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGUgY2xhc3M9XCJtZGMtZGlhbG9nXCIgcmVmPVwicm9vdFwiIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIHJvbGU9XCJhbGVydGRpYWxvZ1wiXG4gICAgOmFyaWEtbGFiZWxsZWRieT1cIidsYWJlbCcgKyBfdWlkXCJcbiAgICA6YXJpYS1kZXNjcmliZWRieT1cIidkZXNjJyArIF91aWRcIlxuICA+XG4gICAgPGRpdiAgcmVmPVwic3VyZmFjZVwiIGNsYXNzPVwibWRjLWRpYWxvZ19fc3VyZmFjZVwiIDpjbGFzcz1cInN1cmZhY2VDbGFzc2VzXCI+XG4gICAgICA8aGVhZGVyIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyXCI+XG4gICAgICAgIDxoMiA6aWQ9XCInbGFiZWwnICsgX3VpZFwiIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyX190aXRsZVwiPlxuICAgICAgICAgIHt7IHRpdGxlIH19XG4gICAgICAgIDwvaDI+XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIDxzZWN0aW9uIDppZD1cIidkZXNjJyArIF91aWRcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2JvZHlcIiA6Y2xhc3M9XCJib2R5Q2xhc3Nlc1wiPlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgICAgPGZvb3RlciBjbGFzcz1cIm1kYy1kaWFsb2dfX2Zvb3RlclwiPlxuICAgICAgICA8bWRjQnV0dG9uIHJlZj1cImNhbmNlbFwiIHYtaWY9XCJjYW5jZWxcIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b25cIlxuICAgICAgICAgIDpjbGFzcz1cInsnbWRjLWRpYWxvZ19fYWN0aW9uJzphY2NlbnR9XCJcbiAgICAgICAgICBAY2xpY2s9XCJvbkNhbmNlbFwiXG4gICAgICAgICAgPnt7IGNhbmNlbCB9fTwvbWRjQnV0dG9uPlxuICAgICAgICA8bWRjQnV0dG9uICByZWY9XCJhY2NlcHRcIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b25cIlxuICAgICAgICAgIDpjbGFzcz1cInsnbWRjLWRpYWxvZ19fYWN0aW9uJzphY2NlbnR9XCJcbiAgICAgICAgICA6ZGlzYWJsZWQ9XCJhY2NlcHREaXNhYmxlZFwiXG4gICAgICAgICAgQGNsaWNrPVwib25BY2NlcHRcIlxuICAgICAgICA+e3sgYWNjZXB0IH19PC9tZGNCdXR0b24+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRpYWxvZ19fYmFja2Ryb3BcIj48L2Rpdj5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDRGlhbG9nRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZSB9IGZyb20gJ0BtYXRlcmlhbC9kaWFsb2cvdXRpbCdcbmltcG9ydCB7bWRjQnV0dG9ufSBmcm9tICcuLi9idXR0b24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kaWFsb2cnLFxuICBwcm9wczoge1xuICAgIHRpdGxlOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICBhY2NlcHQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnT2snIH0sXG4gICAgYWNjZXB0RGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgY2FuY2VsOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ0NhbmNlbCcgfSxcbiAgICBhY2NlbnQ6IEJvb2xlYW4sXG4gICAgc2Nyb2xsYWJsZTogQm9vbGVhblxuICB9LFxuICBjb21wb25lbnRzOiB7XG4gICAgbWRjQnV0dG9uIDogbWRjQnV0dG9uXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGhlbWUtLWRhcmsnOiB0aGlzLmRhcmtcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgc3VyZmFjZUNsYXNzZXM6IHt9LFxuICAgICAgYm9keUNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1kaWFsb2dfX2JvZHktLXNjcm9sbGFibGUnOiB0aGlzLnNjcm9sbGFibGVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm9jdXNUcmFwID0gY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UoXG4gICAgICB0aGlzLiRyZWZzLnN1cmZhY2UsIHRoaXMuJHJlZnMuYWNjZXB0KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0RpYWxvZ0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGFkZEJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IChjbGFzc05hbWUpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICByZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKmV2dCwgaGFuZGxlciovKSA9PiB7XG4gICAgICAgIC8vIFZNQV9IQUNLOiBoYW5kbGUgYnV0dG9uIGNsaWNrcyBvdXJzZWx2ZXNcbiAgICAgICAgLy8gdGhpcy4kcmVmcy5zdXJmYWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLypldnQsIGhhbmRsZXIqLykgPT4ge1xuICAgICAgICAvLyBWTUFfSEFDSzogaGFuZGxlIGJ1dHRvbiBjbGlja3Mgb3Vyc2VsdmVzXG4gICAgICAgIC8vIHRoaXMuJHJlZnMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKSxcbiAgICAgIG5vdGlmeUFjY2VwdDogKCkgPT4gdGhpcy4kZW1pdCgnYWNjZXB0JyksXG4gICAgICBub3RpZnlDYW5jZWw6ICgpID0+IHRoaXMuJGVtaXQoJ2NhbmNlbCcpLFxuICAgICAgdHJhcEZvY3VzT25TdXJmYWNlOiAoKSA9PiB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpLFxuICAgICAgdW50cmFwRm9jdXNPblN1cmZhY2U6ICgpID0+IHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoKSxcbiAgICAgIGlzRGlhbG9nOiAoZWwpID0+ICh0aGlzLiRyZWZzLnN1cmZhY2UgPT09IGVsKSxcbiAgICAgIGxheW91dEZvb3RlclJpcHBsZXM6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5hY2NlcHQucmlwcGxlLmxheW91dCgpXG4gICAgICAgIHRoaXMuY2FuY2VsICYmIHRoaXMuJHJlZnMuY2FuY2VsLnJpcHBsZS5sYXlvdXQoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2FuY2VsKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNhbmNlbCh0cnVlKTtcbiAgICB9LFxuICAgIG9uQWNjZXB0KCkge1xuICAgICAgaWYgKHRoaXMuJGxpc3RlbmVyc1sndmFsaWRhdGUnXSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd2YWxpZGF0ZScsIHtcbiAgICAgICAgICBhY2NlcHQ6IChub3RpZnkgPSB0cnVlKSA9PiB0aGlzLmZvdW5kYXRpb24uYWNjZXB0KG5vdGlmeSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uYWNjZXB0KHRydWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93ICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICB9LFxuICAgIGNsb3NlICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEaWFsb2cgZnJvbSAnLi9tZGMtZGlhbG9nLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjRGlhbG9nXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEaWFsb2dcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgY2xhc3M9XCJtZGMtcGVybWFuZW50LWRyYXdlciBtZGMtZHJhd2VyLS1wZXJtYW5lbnQgbWRjLXR5cG9ncmFwaHlcIj5cbiAgICA8bmF2IGNsYXNzPVwibWRjLWRyYXdlcl9fY29udGVudFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIgXG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCI+PC9kaXY+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcGVybWFuZW50LWRyYXdlcicsXG4gIHByb3BzOiB7XG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhbixcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID1cbiAgJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCAnICtcbiAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgW3RhYmluZGV4XSwgW2NvbnRlbnRlZGl0YWJsZV0nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUcmFuc2xhdGVYOiAoLyogdmFsdWU6IG51bWJlciB8IG51bGwgKi8pID0+IHt9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IC8qIE5vZGVMaXN0ICovIHt9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKC8qIGVsOiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICBtYWtlRWxlbWVudFVudGFiYmFibGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7fSxcbiAgICAgIGlzUnRsOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCByb290Q3NzQ2xhc3MsIGFuaW1hdGluZ0Nzc0NsYXNzLCBvcGVuQ3NzQ2xhc3MpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5yb290Q3NzQ2xhc3NfID0gcm9vdENzc0NsYXNzO1xuICAgIHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfID0gYW5pbWF0aW5nQ3NzQ2xhc3M7XG4gICAgdGhpcy5vcGVuQ3NzQ2xhc3NfID0gb3BlbkNzc0NsYXNzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG5cbiAgICB0aGlzLmluZXJ0XyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoU3RhcnRfKGV2dCk7XG4gICAgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hNb3ZlXyhldnQpO1xuICAgIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hFbmRfKGV2dCk7XG4gICAgdGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2dC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3QgUk9PVCA9IHRoaXMucm9vdENzc0NsYXNzXztcbiAgICBjb25zdCBPUEVOID0gdGhpcy5vcGVuQ3NzQ2xhc3NfO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKFJPT1QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Uk9PVH0gY2xhc3MgcmVxdWlyZWQgaW4gcm9vdCBlbGVtZW50LmApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNOZWNlc3NhcnlEb20oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlZCBET00gbm9kZXMgbWlzc2luZyBpbiAke1JPT1R9IGNvbXBvbmVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhPUEVOKSkge1xuICAgICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXRhYmluYXRlXygpO1xuICAgICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaG1vdmUnLCB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaGVuZCcsIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNobW92ZScsIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hlbmQnLCB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8pO1xuICAgIC8vIERlcmVnaXN0ZXIgdGhlIGRvY3VtZW50IGtleWRvd24gaGFuZGxlciBqdXN0IGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgd2hpbGUgdGhlIG1lbnUgaXMgb3Blbi5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLnJldGFiaW5hdGVfKCk7XG4gICAgLy8gRGVib3VuY2UgbXVsdGlwbGUgY2FsbHNcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlPcGVuKCk7XG4gICAgfVxuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pO1xuICAgIHRoaXMuZGV0YWJpbmF0ZV8oKTtcbiAgICAvLyBEZWJvdW5jZSBtdWx0aXBsZSBjYWxsc1xuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuXztcbiAgfVxuXG4gIC8qKlxuICAgKiAgUmVuZGVyIGFsbCBjaGlsZHJlbiBvZiB0aGUgZHJhd2VyIGluZXJ0IHdoZW4gaXQncyBjbG9zZWQuXG4gICAqL1xuICBkZXRhYmluYXRlXygpIHtcbiAgICBpZiAodGhpcy5pbmVydF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zYXZlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5tYWtlRWxlbWVudFVudGFiYmFibGUoZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5lcnRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgTWFrZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGRyYXdlciB0YWJiYWJsZSBhZ2FpbiB3aGVuIGl0J3Mgb3Blbi5cbiAgICovXG4gIHJldGFiaW5hdGVfKCkge1xuICAgIGlmICghdGhpcy5pbmVydF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluZXJ0XyA9IGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hTdGFydF8oZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKHRoaXMub3BlbkNzc0NsYXNzXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpcmVjdGlvbl8gPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCkgPyAtMSA6IDE7XG4gICAgdGhpcy5kcmF3ZXJXaWR0aF8gPSB0aGlzLmFkYXB0ZXJfLmdldERyYXdlcldpZHRoKCk7XG4gICAgdGhpcy5zdGFydFhfID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5wYWdlWCA6IGV2dC5wYWdlWDtcbiAgICB0aGlzLmN1cnJlbnRYXyA9IHRoaXMuc3RhcnRYXztcblxuICAgIHRoaXMudXBkYXRlUmFmXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZURyYXdlcl8uYmluZCh0aGlzKSk7XG4gIH1cblxuICBoYW5kbGVUb3VjaE1vdmVfKGV2dCkge1xuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50WF8gPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLnBhZ2VYIDogZXZ0LnBhZ2VYO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hFbmRfKGV2dCkge1xuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmVwYXJlRm9yVG91Y2hFbmRfKCk7XG5cbiAgICAvLyBEaWQgdGhlIHVzZXIgY2xvc2UgdGhlIGRyYXdlciBieSBtb3JlIHRoYW4gNTAlP1xuICAgIGlmIChNYXRoLmFicyh0aGlzLm5ld1Bvc2l0aW9uXyAvIHRoaXMuZHJhd2VyV2lkdGhfKSA+PSAwLjUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJpZ2dlcmluZyBhbiBvcGVuIGhlcmUgbWVhbnMgd2UnbGwgZ2V0IGEgbmljZSBhbmltYXRpb24gYmFjayB0byB0aGUgZnVsbHkgb3BlbiBzdGF0ZS5cbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVGb3JUb3VjaEVuZF8oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVSYWZfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFRyYW5zbGF0ZVgobnVsbCk7XG4gIH1cblxuICB1cGRhdGVEcmF3ZXJfKCkge1xuICAgIHRoaXMudXBkYXRlUmFmXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZURyYXdlcl8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2xhdGVYKHRoaXMubmV3UG9zaXRpb25fKTtcbiAgfVxuXG4gIGdldCBuZXdQb3NpdGlvbl8oKSB7XG4gICAgbGV0IG5ld1BvcyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5kaXJlY3Rpb25fID09PSAxKSB7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1pbigwLCB0aGlzLmN1cnJlbnRYXyAtIHRoaXMuc3RhcnRYXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWF4KDAsIHRoaXMuY3VycmVudFhfIC0gdGhpcy5zdGFydFhfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZVxuICAgIC8vIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgdGhlIHJvb3QgZXZlbnQgdGFyZ2V0IGN1cnJlbnRseSB0cmFuc2l0aW9uaW5nLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIGlmICh0aGlzLmlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZXZ0LnRhcmdldCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIH1cbiAgfTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWRyYXdlci0tcGVyc2lzdGVudCcsXG4gIE9QRU46ICdtZGMtZHJhd2VyLS1vcGVuJyxcbiAgQU5JTUFUSU5HOiAnbWRjLWRyYXdlci0tYW5pbWF0aW5nJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBEUkFXRVJfU0VMRUNUT1I6ICcubWRjLWRyYXdlci0tcGVyc2lzdGVudCAubWRjLWRyYXdlcl9fZHJhd2VyJyxcbiAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICBPUEVOX0VWRU5UOiAnTURDUGVyc2lzdGVudERyYXdlcjpvcGVuJyxcbiAgQ0xPU0VfRVZFTlQ6ICdNRENQZXJzaXN0ZW50RHJhd2VyOmNsb3NlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIHtcbiAgICAgIGlzRHJhd2VyOiAoKSA9PiBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpLFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5ST09ULFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcsXG4gICAgICBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyhlbCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzRHJhd2VyKGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgVEFCX0RBVEEgPSAnZGF0YS1tZGMtdGFiaW5kZXgnO1xuY29uc3QgVEFCX0RBVEFfSEFORExFRCA9ICdkYXRhLW1kYy10YWJpbmRleC1oYW5kbGVkJztcblxubGV0IHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLy8gUmVtYXAgdG91Y2ggZXZlbnRzIHRvIHBvaW50ZXIgZXZlbnRzLCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdG91Y2ggZXZlbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHJlbWFwRXZlbnQoZXZlbnROYW1lLCBnbG9iYWxPYmogPSB3aW5kb3cpIHtcbiAgaWYgKCEoJ29udG91Y2hzdGFydCcgaW4gZ2xvYmFsT2JqLmRvY3VtZW50KSkge1xuICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICByZXR1cm4gJ3BvaW50ZXJkb3duJztcbiAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgcmV0dXJuICdwb2ludGVybW92ZSc7XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgcmV0dXJuICdwb2ludGVydXAnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbi8vIENob29zZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdXNlIG9uIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBjb25zdCBlbCA9IGdsb2JhbE9iai5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUgPSAoJ3RyYW5zZm9ybScgaW4gZWwuc3R5bGUgPyAndHJhbnNmb3JtJyA6ICctd2Via2l0LXRyYW5zZm9ybScpO1xuICAgIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPSB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWU7XG4gIH1cblxuICByZXR1cm4gc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcbn1cblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBDU1MgcHJvcGVydGllcy5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMoZ2xvYmFsT2JqID0gd2luZG93KSB7XG4gIGlmICgnQ1NTJyBpbiBnbG9iYWxPYmopIHtcbiAgICByZXR1cm4gZ2xvYmFsT2JqLkNTUy5zdXBwb3J0cygnKC0tY29sb3I6IHJlZCknKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZCBpZiBzbywgdXNlIHRoZW0uXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8vIFNhdmUgdGhlIHRhYiBzdGF0ZSBmb3IgYW4gZWxlbWVudC5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRWxlbWVudFRhYlN0YXRlKGVsKSB7XG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoVEFCX0RBVEEsIGVsLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSk7XG4gIH1cbiAgZWwuc2V0QXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQsIHRydWUpO1xufVxuXG4vLyBSZXN0b3JlIHRoZSB0YWIgc3RhdGUgZm9yIGFuIGVsZW1lbnQsIGlmIGl0IHdhcyBzYXZlZC5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKSB7XG4gIC8vIE9ubHkgbW9kaWZ5IGVsZW1lbnRzIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCwgaW4gY2FzZSBhbnl0aGluZyB3YXMgZHluYW1pY2FsbHkgYWRkZWQgc2luY2Ugd2Ugc2F2ZWQgc3RhdGUuXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCkpIHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKFRBQl9EQVRBKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIGVsLmdldEF0dHJpYnV0ZShUQUJfREFUQSkpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFRBQl9EQVRBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGFzaWRlIGNsYXNzPVwibWRjLXBlcnNpc3RlbnQtZHJhd2VyIG1kYy1kcmF3ZXItLXBlcnNpc3RlbnQgbWRjLXR5cG9ncmFwaHlcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPG5hdiByZWY9XCJkcmF3ZXJcIiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2RyYXdlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIgXG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCI+PC9kaXY+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L2FzaWRlPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3BlcnNpc3RlbnQvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL2RyYXdlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuLFxuICAgICdvcGVuJzpCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbigpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2goKVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIF9yZWZyZXNoKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKSAgICAgICAgICBcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKCkgICAgICAgICAgXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICBjb25zdCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSA9IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLnN0cmluZ3NcblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICB9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKGVsKSA9PiB7XG4gICAgICAgIHV0aWwuc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiAoZWwpID0+IHtcbiAgICAgICAgdXRpbC5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsdHJ1ZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyxmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKVxuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIC8qIGdsb2JhbCBnZXRDb21wdXRlZFN0eWxlICovXG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCdcbiAgICAgIH0sXG4gICAgICBpc0RyYXdlcjogKGVsKSA9PiB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uaW5pdCgpICBcbiAgICB0aGlzLl9yZWZyZXNoKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtGT0NVU0FCTEVfRUxFTUVOVFN9IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtZHJhd2VyLS10ZW1wb3JhcnknLFxuICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kcmF3ZXItLWFuaW1hdGluZycsXG4gIFNDUk9MTF9MT0NLOiAnbWRjLWRyYXdlci1zY3JvbGwtbG9jaycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgRFJBV0VSX1NFTEVDVE9SOiAnLm1kYy1kcmF3ZXItLXRlbXBvcmFyeSAubWRjLWRyYXdlcl9fZHJhd2VyJyxcbiAgT1BBQ0lUWV9WQVJfTkFNRTogJy0tbWRjLXRlbXBvcmFyeS1kcmF3ZXItb3BhY2l0eScsXG4gIEZPQ1VTQUJMRV9FTEVNRU5UUyxcbiAgT1BFTl9FVkVOVDogJ01EQ1RlbXBvcmFyeURyYXdlcjpvcGVuJyxcbiAgQ0xPU0VfRVZFTlQ6ICdNRENUZW1wb3JhcnlEcmF3ZXI6Y2xvc2UnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9ufSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCB7XG4gICAgICBhZGRCb2R5Q2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBpc0RyYXdlcjogKCkgPT4gZmFsc2UsXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKC8qIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKC8qIHRhcmdldDogRXZlbnRUYXJnZXQsIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbihNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5ST09ULFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoZXZ0LnRhcmdldCwgY3NzQ2xhc3Nlcy5ST09UKSkge1xuICAgICAgICB0aGlzLmNsb3NlKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIHN1cGVyLmluaXQoKTtcblxuICAgIC8vIE1ha2UgYnJvd3NlciBhd2FyZSBvZiBjdXN0b20gcHJvcGVydHkgYmVpbmcgdXNlZCBpbiB0aGlzIGVsZW1lbnQuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBoYXJkLXRvLXJlcHJvZHVjZSBoZWlzZW5idWdzLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoMCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmVuYWJsZVNjcm9sbF8oKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5kaXNhYmxlU2Nyb2xsXygpO1xuICAgIC8vIE1ha2Ugc3VyZSBjdXN0b20gcHJvcGVydHkgdmFsdWVzIGFyZSBjbGVhcmVkIGJlZm9yZSBzdGFydGluZy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcblxuICAgIHN1cGVyLm9wZW4oKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIC8vIE1ha2Ugc3VyZSBjdXN0b20gcHJvcGVydHkgdmFsdWVzIGFyZSBjbGVhcmVkIGJlZm9yZSBtYWtpbmcgYW55IGNoYW5nZXMuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgnJyk7XG5cbiAgICBzdXBlci5jbG9zZSgpO1xuICB9XG5cbiAgcHJlcGFyZUZvclRvdWNoRW5kXygpIHtcbiAgICBzdXBlci5wcmVwYXJlRm9yVG91Y2hFbmRfKCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcbiAgfVxuXG4gIHVwZGF0ZURyYXdlcl8oKSB7XG4gICAgc3VwZXIudXBkYXRlRHJhd2VyXygpO1xuXG4gICAgY29uc3QgbmV3T3BhY2l0eSA9IE1hdGgubWF4KDAsIDEgKyB0aGlzLmRpcmVjdGlvbl8gKiAodGhpcy5uZXdQb3NpdGlvbl8gLyB0aGlzLmRyYXdlcldpZHRoXykpO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUobmV3T3BhY2l0eSk7XG4gIH1cblxuICBpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNEcmF3ZXIoZWwpO1xuICB9XG5cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KSB7XG4gICAgc3VwZXIuaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KTtcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gICAgfVxuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGUgY2xhc3M9XCJtZGMtdGVtcG9yYXJ5LWRyYXdlciBtZGMtZHJhd2VyLS10ZW1wb3JhcnkgbWRjLXR5cG9ncmFwaHlcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPG5hdiByZWY9XCJkcmF3ZXJcIiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2RyYXdlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIgdi1pZj1cInRvb2xiYXJTcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL2RyYXdlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgICdvcGVuJzogQm9vbGVhbixcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuLFxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW4oKSB7XG4gICAgICB0aGlzLl9yZWZyZXNoKClcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKCkgICAgICAgICAgXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpICAgICAgICAgIFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgY29uc3Qge0ZPQ1VTQUJMRV9FTEVNRU5UUywgT1BBQ0lUWV9WQVJfTkFNRX0gPSBcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uc3RyaW5nc1xuICAgIFxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgYWRkQm9keUNsYXNzOiAoY2xhc3NOYW1lKSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAodGFyZ2V0LCBjbGFzc05hbWUpID0+IHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh1dGlsLnN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcygpKSB7XG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUuc2V0UHJvcGVydHkoT1BBQ0lUWV9WQVJfTkFNRSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICB9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKGVsKSA9PiB7XG4gICAgICAgIHV0aWwuc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiAoZWwpID0+IHtcbiAgICAgICAgdXRpbC5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsdHJ1ZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyxmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKVxuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIC8qIGdsb2JhbCBnZXRDb21wdXRlZFN0eWxlICovXG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCdcbiAgICAgIH0sXG4gICAgICBpc0RyYXdlcjogKGVsKSA9PiBlbCA9PT0gdGhpcy4kcmVmcy5kcmF3ZXIsXG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmluaXQoKSAgXG4gICAgdGhpcy5fcmVmcmVzaCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y29tcG9uZW50ICByZWY9XCJkcmF3ZXJcIiBjbGFzcz1cIm1kYy1kcmF3ZXJcIlxyXG4gICAgICA6aXM9XCJ0eXBlXCIgdi1tb2RlbD1cIm9wZW5fXCJcclxuICAgICAgOnRvb2xiYXItc3BhY2VyPVwidG9vbGJhclNwYWNlclwiXHJcbiAgICAgIEBjaGFuZ2U9XCIkcm9vdC4kZW1pdCgnbWRjOmxheW91dCcpXCIgXHJcbiAgICAgIEBvcGVuPVwiJGVtaXQoJ29wZW4nKVwiIFxyXG4gICAgICBAY2xvc2U9XCIkZW1pdCgnY2xvc2UnKVwiID5cclxuICAgIDxzbG90IC8+XHJcbiAgPC9jb21wb25lbnQ+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgbWRjUGVybWFuZW50RHJhd2VyIGZyb20gJy4vbWRjLXBlcm1hbmVudC1kcmF3ZXIudnVlJ1xyXG5pbXBvcnQgbWRjUGVyc2lzdGVudERyYXdlciBmcm9tICcuL21kYy1wZXJzaXN0ZW50LWRyYXdlci52dWUnXHJcbmltcG9ydCBtZGNUZW1wb3JhcnlEcmF3ZXIgZnJvbSAnLi9tZGMtdGVtcG9yYXJ5LWRyYXdlci52dWUnXHJcblxyXG5jb25zdCBtZWRpYSA9IG5ldyBjbGFzcyB7XHJcbiAgZ2V0IHNtYWxsICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zbWFsbCB8fCAodGhpcy5fc21hbGwgPVxyXG4gICAgICB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogODM5cHgpJykpXHJcbiAgfVxyXG5cclxuICBnZXQgbGFyZ2UgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xhcmdlIHx8ICh0aGlzLl9sYXJnZSA9XHJcbiAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiAxMjAwcHgpJykpXHJcbiAgfVxyXG59KClcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWRyYXdlcicsXHJcbiAgcHJvcHM6IHtcclxuICAgIHBlcm1hbmVudDogQm9vbGVhbixcclxuICAgIHBlcnNpc3RlbnQ6IEJvb2xlYW4sXHJcbiAgICB0ZW1wb3Jhcnk6IEJvb2xlYW4sXHJcbiAgICBkcmF3ZXJUeXBlOiB7XHJcbiAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgdmFsaWRhdG9yOiAodmFsKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCBpbiBbJ3RlbXBvcmFyeScsICdwZXJzaXN0ZW50JywgJ3Blcm1hbmVudCddXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0b29sYmFyU3BhY2VyOiBCb29sZWFuLFxyXG4gICAgdG9nZ2xlT246IFN0cmluZyxcclxuICAgIHRvZ2dsZU9uU291cmNlOiB7dHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2V9LFxyXG4gICAgb3Blbk9uOiBTdHJpbmcsXHJcbiAgICBvcGVuT25Tb3VyY2U6IHt0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZX0sXHJcbiAgICBjbG9zZU9uOiBTdHJpbmcsXHJcbiAgICBjbG9zZU9uU291cmNlOiB7dHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2V9LFxyXG4gIH0sXHJcbiAgcHJvdmlkZSAoKSB7XHJcbiAgICByZXR1cm4geyBtZGNEcmF3ZXI6IHRoaXMgfVxyXG4gIH0sXHJcbiAgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzbWFsbDogZmFsc2UsXHJcbiAgICAgIGxhcmdlOiBmYWxzZSxcclxuICAgICAgb3Blbl86IGZhbHNlLFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcG9uZW50czoge1xyXG4gICAgJ21kYy1wZXJtYW5lbnQtZHJhd2VyJzogbWRjUGVybWFuZW50RHJhd2VyLFxyXG4gICAgJ21kYy1wZXJzaXN0ZW50LWRyYXdlcic6IG1kY1BlcnNpc3RlbnREcmF3ZXIsXHJcbiAgICAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInOiBtZGNUZW1wb3JhcnlEcmF3ZXJcclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICB0eXBlICgpIHtcclxuICAgICAgaWYgKHRoaXMucGVybWFuZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICdtZGMtcGVybWFuZW50LWRyYXdlcidcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlcnNpc3RlbnQpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnRlbXBvcmFyeSkge1xyXG4gICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmRyYXdlclR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgJ3Blcm1hbmVudCc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXBlcm1hbmVudC1kcmF3ZXInO1xyXG4gICAgICAgICAgY2FzZSAncGVyc2lzdGVudCc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJztcclxuICAgICAgICAgIGNhc2UgJ3RlbXBvcmFyeSc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc21hbGwgPyAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInIDogJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgICAgICB9XHJcbiAgICAgIH0gIFxyXG4gICAgfSxcclxuICAgIGlzUGVybWFuZW50ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGVybWFuZW50IHx8IHRoaXMudHlwZSA9PT0gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzUGVyc2lzdGVudCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy50eXBlID09PSAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzVGVtcG9yYXJ5ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMudHlwZSA9PT0gJ21kYy10ZW1wb3JhcnktZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzUmVzcG9uc2l2ZSAoKSB7XHJcbiAgICAgIHJldHVybiAhKHRoaXMucGVybWFuZW50IHx8IHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLmRyYXdlclR5cGUpXHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBvcGVuICgpIHtcclxuICAgICAgdGhpcy5vcGVuXyA9IHRydWVcclxuICAgIH0sXHJcbiAgICBjbG9zZSAoKSB7XHJcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSBmYWxzZSlcclxuICAgIH0sXHJcbiAgICB0b2dnbGUgKCkge1xyXG4gICAgICB0aGlzLmlzUGVybWFuZW50IHx8ICh0aGlzLmlzT3BlbigpID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCkpXHJcbiAgICB9LFxyXG4gICAgaXNPcGVuICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaXNQZXJtYW5lbnR8fCAoIHRoaXMub3Blbl8gKVxyXG4gICAgfSxcclxuICAgIHJlZnJlc2hNZWRpYSAoKSB7XHJcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXHJcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzXHJcbiAgICAgIGlmICh0aGlzLmlzUmVzcG9uc2l2ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhcmdlKSB7XHJcbiAgICAgICAgICB0aGlzLm9wZW4oKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY3JlYXRlZCAoKSB7XHJcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5tYXRjaE1lZGlhKSB7XHJcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXHJcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkICgpIHtcclxuICAgIGlmICh0aGlzLnRvZ2dsZU9uKSB7XHJcbiAgICAgIGxldCBzb3VyY2UgPSB0aGlzLnRvZ2dsZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcclxuICAgICAgc291cmNlLiRvbih0aGlzLnRvZ2dsZU9uLCAoKSA9PiB0aGlzLnRvZ2dsZSgpKVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3Blbk9uKSB7XHJcbiAgICAgIGxldCBzb3VyY2UgPSB0aGlzLm9wZW5PblNvdXJjZSB8fCB0aGlzLiRyb290XHJcbiAgICAgIHNvdXJjZS4kb24odGhpcy5vcGVuT24sICgpID0+IHRoaXMub3BlbigpKVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY2xvc2VPbikge1xyXG4gICAgICBsZXQgc291cmNlID0gdGhpcy5jbG9zZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcclxuICAgICAgc291cmNlLiRvbih0aGlzLmNsb3NlT24sICgpID0+IHRoaXMuY2xvc2UoKSlcclxuICAgIH1cclxuICAgIG1lZGlhLnNtYWxsLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gICAgbWVkaWEubGFyZ2UuYWRkTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXHJcbiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB0aGlzLnJlZnJlc2hNZWRpYSgpKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICBtZWRpYS5zbWFsbC5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSlcclxuICAgIG1lZGlhLmxhcmdlLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlci1sYXlvdXRcIj5cbiAgICAgIDxzbG90IC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItbGF5b3V0Jyxcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aGVhZGVyIGNsYXNzPVwibWRjLWRyYXdlci1oZWFkZXIgbWRjLWRyYXdlcl9faGVhZGVyXCIgdi1pZj1cInNob3dcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlcl9faGVhZGVyLWNvbnRlbnRcIj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9kaXY+XG4gIDwvaGVhZGVyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItaGVhZGVyJyxcbiAgcHJvcHM6IHtcbiAgICAncGVybWFuZW50JzogQm9vbGVhbixcbiAgICAncGVyc2lzdGVudCc6IEJvb2xlYW4sXG4gICAgJ3RlbXBvcmFyeSc6IEJvb2xlYW5cbiAgfSxcbiAgaW5qZWN0OiBbJ21kY0RyYXdlciddLFxuICBjb21wdXRlZDoge1xuICAgIHNob3cgKCkge1xuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnBlcm1hbmVudCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGVtcG9yYXJ5ICYmIHRoaXMubWRjRHJhd2VyLmlzVGVtcG9yYXJ5KSB8fFxuICAgICAgICAgICh0aGlzLnBlcnNpc3RlbnQgJiYgdGhpcy5tZGNEcmF3ZXIuaXNQZXJzaXN0ZW50KSB8fFxuICAgICAgICAgICAgKHRoaXMucGVybWFuZW50ICYmIHRoaXMubWRjRHJhd2VyLmlzUGVybWFuZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bmF2IGNsYXNzPVwibWRjLWRyYXdlci1saXN0IG1kYy1saXN0XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICAnZGVuc2UnOiBCb29sZWFuLFxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWxpc3QtLWRlbnNlJzogdGhpcy5kZW5zZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbn1cbjwvc2NyaXB0PiIsIjx0ZW1wbGF0ZT5cclxuICA8Y3VzdG9tLWxpbmsgOmxpbms9XCJsaW5rXCIgXHJcbiAgICBjbGFzcz1cIm1kYy1kcmF3ZXItaXRlbSBtZGMtbGlzdC1pdGVtXCIgXHJcbiAgICA6Y2xhc3M9XCJbY2xhc3NlcywgaXRlbUNsYXNzZXNdXCIgOnN0eWxlPVwic3R5bGVzXCJcclxuICAgIEBjbGljaz1cIm9uQ2xpY2tcIj5cclxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fZ3JhcGhpY1wiIHYtaWY9XCJoYXNTdGFydERldGFpbFwiPlxyXG4gICAgICA8c2xvdCBuYW1lPVwic3RhcnQtZGV0YWlsXCI+XHJcbiAgICAgICAgPGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt7c3RhcnRJY29ufX08L2k+XHJcbiAgICAgIDwvc2xvdD5cclxuICAgIDwvc3Bhbj5cclxuICAgIDxzbG90Pjwvc2xvdD5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1kcmF3ZXItaXRlbScsXHJcbiAgaW5qZWN0OiBbJ21kY0RyYXdlciddLFxyXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgc3RhcnRJY29uOiBTdHJpbmcsXHJcbiAgICB0ZW1wb3JhcnlDbG9zZTogeyBcclxuICAgICAgdHlwZTogQm9vbGVhbiwgXHJcbiAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW4sXHJcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiB7IFxyXG4gICAgICB0eXBlOiBTdHJpbmcsIFxyXG4gICAgICBkZWZhdWx0OiAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJyBcclxuICAgIH1cclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBpdGVtQ2xhc3NlcyAoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCc6IHRoaXMuYWN0aXZhdGVkXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoYXNTdGFydERldGFpbCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0SWNvbiB8fCB0aGlzLiRzbG90c1snc3RhcnQtZGV0YWlsJ11cclxuICAgIH1cclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIG9uQ2xpY2sgKGV2dCkge1xyXG4gICAgICB0aGlzLm1kY0RyYXdlci5pc1RlbXBvcmFyeSAmJiB0aGlzLnRlbXBvcmFyeUNsb3NlIFxyXG4gICAgICAgICYmIHRoaXMubWRjRHJhd2VyLmNsb3NlKClcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dClcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95ICgpIHtcclxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5yaXBwbGUgPSBudWxsXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XG4gIDxociBjbGFzcz1cIm1kYy1saXN0LWRpdmlkZXJcIj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWRpdmlkZXInLFxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRHJhd2VyIGZyb20gJy4vbWRjLWRyYXdlci52dWUnXG5pbXBvcnQgbWRjRHJhd2VyTGF5b3V0IGZyb20gJy4vbWRjLWRyYXdlci1sYXlvdXQudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckhlYWRlciBmcm9tICcuL21kYy1kcmF3ZXItaGVhZGVyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMaXN0IGZyb20gJy4vbWRjLWRyYXdlci1saXN0LnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJJdGVtIGZyb20gJy4vbWRjLWRyYXdlci1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJEaXZpZGVyIGZyb20gJy4vbWRjLWRyYXdlci1kaXZpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjRHJhd2VyLFxuICBtZGNEcmF3ZXJMYXlvdXQsXG4gIG1kY0RyYXdlckhlYWRlcixcbiAgbWRjRHJhd2VyTGlzdCxcbiAgbWRjRHJhd2VySXRlbSxcbiAgbWRjRHJhd2VyRGl2aWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRHJhd2VyLFxuICBtZGNEcmF3ZXJMYXlvdXQsXG4gIG1kY0RyYXdlckhlYWRlcixcbiAgbWRjRHJhd2VyTGlzdCxcbiAgbWRjRHJhd2VySXRlbSxcbiAgbWRjRHJhd2VyRGl2aWRlclxufSkiLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZWxldmF0aW9uXCI+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWVsZXZhdGlvbicsXG4gIHByb3BzOiB7XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0VsZXZhdGlvbiBmcm9tICcuL21kYy1lbGV2YXRpb24udnVlJ1xuXG5leHBvcnQge1xuICBtZGNFbGV2YXRpb25cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0VsZXZhdGlvblxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1idXR0b24gY2xhc3M9XCJtZGMtZmFiXCIgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgOmhyZWY9XCJocmVmXCIgOmxpbms9XCJsaW5rXCIgXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiID5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1mYWJfX2ljb25cIj5cbiAgICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gICAgPC9zcGFuPlxuICA8L2N1c3RvbS1idXR0b24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGlufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHtSaXBwbGVNaXhpbn0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZmFiJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZyxcbiAgICBtaW5pOiBCb29sZWFuLFxuICAgIGFic29sdXRlOiBCb29sZWFuLFxuICAgIGZpeGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtYXRlcmlhbC1pY29ucyc6IHRoaXMuaWNvbixcbiAgICAgICAgJ21kYy1mYWItLW1pbmknOiB0aGlzLm1pbmksXG4gICAgICAgICdtZGMtZmFiLS1hYnNvbHV0ZSc6IHRoaXMuYWJzb2x1dGUsXG4gICAgICAgICdtZGMtZmFiLS1maXhlZCc6IHRoaXMuZml4ZWRcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGljb24gKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21hdGVyaWFsLWljb25zJywgdGhpcy5pY29uIClcbiAgICB9LFxuICAgIG1pbmkgKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1mYWItLW1pbmknLCB0aGlzLm1pbmkgKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRkFCIGZyb20gJy4vbWRjLWZhYi52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0ZBQlxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRkFCXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUSUxFU19TRUxFQ1RPUjogJy5tZGMtZ3JpZC1saXN0X190aWxlcycsXG4gIFRJTEVfU0VMRUNUT1I6ICcubWRjLWdyaWQtdGlsZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDR3JpZExpc3RGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldE51bWJlck9mVGlsZXM6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0U3R5bGVGb3JUaWxlc0VsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0dyaWRMaXN0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmFsaWduQ2VudGVyKCk7XG4gICAgdGhpcy5yZXNpemVGcmFtZV8gPSAwO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5hbGlnbkNlbnRlcigpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuICBhbGlnbkNlbnRlcigpIHtcbiAgICBpZiAodGhpcy5yZXNpemVGcmFtZV8gIT09IDApIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVzaXplRnJhbWVfKTtcbiAgICB9XG4gICAgdGhpcy5yZXNpemVGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hbGlnbkNlbnRlcl8oKTtcbiAgICAgIHRoaXMucmVzaXplRnJhbWVfID0gMDtcbiAgICB9KTtcbiAgfVxuICBhbGlnbkNlbnRlcl8oKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZUaWxlcygpID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ3JpZFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IGl0ZW1XaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleCgwKTtcbiAgICBjb25zdCB0aWxlc1dpZHRoID0gaXRlbVdpZHRoICogTWF0aC5mbG9vcihncmlkV2lkdGggLyBpdGVtV2lkdGgpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JUaWxlc0VsZW1lbnQoJ3dpZHRoJywgYCR7dGlsZXNXaWR0aH1weGApO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZ3JpZC1saXN0XCI+XG4gICAgPHVsIGNsYXNzPVwibWRjLWdyaWQtbGlzdF9fdGlsZXNcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPXN0eWxlcz5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvdWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENHcmlkTGlzdEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2dyaWQtbGlzdC9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZ3JpZC1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICAnd2lkdGgnOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICdyYXRpbyc6IFN0cmluZyxcbiAgICAnbmFycm93LWd1dHRlcic6IEJvb2xlYW4sXG4gICAgJ2hlYWRlci1jYXB0aW9uJzogQm9vbGVhbixcbiAgICAnaWNvbi1hbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2ljb24tYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnd2l0aC1zdXBwb3J0LXRleHQnOiBCb29sZWFuLFxuICAgICdpbnRlcmFjdGl2ZSc6IEJvb2xlYW5cbiAgfSxcbiAgcHJvdmlkZSAoKSB7XG4gICAgcmV0dXJuIHsgbWRjR3JpZDogdGhpcyB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcyAoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IHt9XG5cbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXRpbGUtZ3V0dGVyLTEnXSA9IHRoaXMubmFycm93R3V0dGVyXG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS1oZWFkZXItY2FwdGlvbiddID0gdGhpcy5oZWFkZXJDYXB0aW9uXG4gICAgICBjbGFzc2VzW2BtZGMtZ3JpZC1saXN0LS10aWxlLWFzcGVjdC0ke3RoaXMucmF0aW99YF0gPSB0aGlzLnJhdGlvXG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS13aXRoLWljb24tYWxpZ24tc3RhcnQnXSA9IHRoaXMuaWNvbkFsaWduU3RhcnRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXdpdGgtaWNvbi1hbGlnbi1lbmQnXSA9IHRoaXMuaWNvbkFsaWduRW5kXG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS10d29saW5lLWNhcHRpb24nXSA9IHRoaXMud2l0aFN1cHBvcnRUZXh0XG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS1ub24taW50ZXJhY3RpdmUnXSA9ICF0aGlzLmludGVyYWN0aXZlXG5cbiAgICAgIHJldHVybiBjbGFzc2VzXG4gICAgfSxcbiAgICBzdHlsZXMgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJy0tbWRjLWdyaWQtbGlzdC10aWxlLXdpZHRoJzogYCR7dGhpcy53aWR0aH1weGBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENHcmlkTGlzdEZvdW5kYXRpb24oe1xuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgZ2V0TnVtYmVyT2ZUaWxlczogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICBNRENHcmlkTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5USUxFX1NFTEVDVE9SKS5sZW5ndGhcbiAgICAgIH0sXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4OiAoaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUilbaW5kZXhdLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGVGb3JUaWxlc0VsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBNRENHcmlkTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5USUxFU19TRUxFQ1RPUikuc3R5bGVbcHJvcGVydHldID0gdmFsdWVcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIGNsYXNzPVwibWRjLWdyaWQtdGlsZVwiIEBjbGljaz1cIm9uQ2xpY2tcIlxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIiA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIlxuICAgIHYtb249XCJpc0ludGVyYWN0aXZlID8gJGxpc3RlbmVycyA6IHt9XCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3ByaW1hcnlcIiB2LWlmPVwiY292ZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5LWNvbnRlbnRcIlxuICAgICAgICA6c3R5bGU9XCJ7IGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgc3JjICsgJyknIH1cIj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCIgdi1lbHNlPlxuICAgICAgICA8aW1nIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeS1jb250ZW50XCIgOnNyYz1cInNyY1wiIC8+XG4gICAgPC9kaXY+XG4gICAgPHNwYW4gY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19zZWNvbmRhcnlcIiB2LWlmPVwidGl0bGUgfHwgc3VwcG9ydFRleHRcIj5cbiAgICAgIDxpIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9faWNvbiBtYXRlcmlhbC1pY29uc1wiIHYtaWY9XCJpY29uXCI+e3sgaWNvbiB9fTwvaT5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fdGl0bGVcIiB2LWlmPVwidGl0bGVcIj57eyB0aXRsZSB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fc3VwcG9ydC10ZXh0XCIgdi1pZj1cInN1cHBvcnRUZXh0XCI+e3sgc3VwcG9ydFRleHQgfX08L3NwYW4+XG4gICAgPC9zcGFuPlxuICA8L2xpPlxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0PlxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtdGlsZScsXG4gIGluamVjdDogWydtZGNHcmlkJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgJ3NyYyc6IFN0cmluZyxcbiAgICAnY292ZXInOiBCb29sZWFuLFxuICAgICdpY29uJzogU3RyaW5nLFxuICAgICd0aXRsZSc6IFN0cmluZyxcbiAgICAnc3VwcG9ydC10ZXh0JzogU3RyaW5nLFxuICAgICdzZWxlY3RlZCc6IEJvb2xlYW4sXG4gICAgJ2FjdGl2YXRlZCc6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpdGVtQ2xhc3NlcyAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkLFxuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzSW50ZXJhY3RpdmUgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjR3JpZCAmJiB0aGlzLm1kY0dyaWQuaW50ZXJhY3RpdmVcbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0SWNvbiB8fCB0aGlzLiRzbG90c1snc3RhcnQtZGV0YWlsJ11cbiAgICB9LFxuICAgIGhhc0VuZERldGFpbCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmRJY29uIHx8IHRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNJbnRlcmFjdGl2ZSAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFJpcHBsZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DbGljayAoZXZ0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KVxuICAgIH0sXG4gICAgYWRkUmlwcGxlICgpIHtcbiAgICAgIGlmICghdGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgICAgIHJpcHBsZS5pbml0KClcbiAgICAgICAgdGhpcy5yaXBwbGUgPSByaXBwbGVcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZVJpcHBsZSAoKSB7XG4gICAgICBpZiAodGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IHRoaXMucmlwcGxlXG4gICAgICAgIHRoaXMucmlwcGxlID0gbnVsbFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgJiYgdGhpcy5hZGRSaXBwbGUoKVxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBjb25zb2xlLmxvZyh0aGlzKVxuICAgIGNvbnNvbGUubG9nKHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKVxuICAgIGNvbnNvbGUubG9nKHRoaXMucmlwcGxlKVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0dyaWRMaXN0IGZyb20gJy4vbWRjLWdyaWQtbGlzdC52dWUnXG5pbXBvcnQgbWRjR3JpZFRpbGUgZnJvbSAnLi9tZGMtZ3JpZC10aWxlLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjR3JpZExpc3QsXG4gIG1kY0dyaWRUaWxlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNHcmlkTGlzdCxcbiAgbWRjR3JpZFRpbGVcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxzcGFuIGNsYXNzPVwibWRjLWljb24gbWRjLWljb24tLW1hdGVyaWFsXCIgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiPlxuICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gIDwvc3Bhbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtaWNvbicsXG4gIHByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgbWRjSWNvbiBmcm9tICcuL21kYy1pY29uLnZ1ZSdcclxuXHJcbmV4cG9ydCB7XHJcbiAgbWRjSWNvblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcclxuICBtZGNJY29uXHJcbn0pXHJcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgSWNvbiBUb2dnbGUuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gaW5uZXIgdGV4dFxuICogLSBldmVudCBoYW5kbGVyc1xuICogLSBldmVudCBkaXNwYXRjaFxuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuXG5jbGFzcyBNRENJY29uVG9nZ2xlQWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IHRleHQgKi9cbiAgc2V0VGV4dCh0ZXh0KSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFRhYkluZGV4KCkge31cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHRhYkluZGV4ICovXG4gIHNldFRhYkluZGV4KHRhYkluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBdHRyKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cihuYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbiAgcm1BdHRyKG5hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUljb25Ub2dnbGVFdmVudH0gZXZ0RGF0YSAqL1xuICBub3RpZnlDaGFuZ2UoZXZ0RGF0YSkge31cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgaXNPbjogYm9vbGVhbixcbiAqIH19XG4gKi9cbmxldCBJY29uVG9nZ2xlRXZlbnQ7XG5cbmV4cG9ydCB7TURDSWNvblRvZ2dsZUFkYXB0ZXIsIEljb25Ub2dnbGVFdmVudH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWljb24tdG9nZ2xlJyxcbiAgRElTQUJMRUQ6ICdtZGMtaWNvbi10b2dnbGUtLWRpc2FibGVkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgREFUQV9UT0dHTEVfT046ICdkYXRhLXRvZ2dsZS1vbicsXG4gIERBVEFfVE9HR0xFX09GRjogJ2RhdGEtdG9nZ2xlLW9mZicsXG4gIEFSSUFfUFJFU1NFRDogJ2FyaWEtcHJlc3NlZCcsXG4gIEFSSUFfRElTQUJMRUQ6ICdhcmlhLWRpc2FibGVkJyxcbiAgQVJJQV9MQUJFTDogJ2FyaWEtbGFiZWwnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENJY29uVG9nZ2xlOmNoYW5nZScsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDSWNvblRvZ2dsZUFkYXB0ZXIsIEljb25Ub2dnbGVFdmVudH0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENJY29uVG9nZ2xlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHNldFRleHQ6ICgvKiB0ZXh0OiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0VGFiSW5kZXg6ICgvKiB0YWJJbmRleDogbnVtYmVyICovKSA9PiB7fSxcbiAgICAgIGdldEF0dHI6ICgvKiBuYW1lOiBzdHJpbmcgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIHNldEF0dHI6ICgvKiBuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcm1BdHRyOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKC8qIGV2dERhdGE6IEljb25Ub2dnbGVFdmVudCAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5vbl8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmRpc2FibGVkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IC0xO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/SWNvblRvZ2dsZVN0YXRlfSAqL1xuICAgIHRoaXMudG9nZ2xlT25EYXRhXyA9IG51bGw7XG5cbiAgICAvKiogQHByaXZhdGUgez9JY29uVG9nZ2xlU3RhdGV9ICovXG4gICAgdGhpcy50b2dnbGVPZmZEYXRhXyA9IG51bGw7XG5cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoXG4gICAgICAoKSA9PiB0aGlzLnRvZ2dsZUZyb21FdnRfKCkpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNIYW5kbGluZ0tleWRvd25fID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovICgoLyoqIEB0eXBlIHshS2V5Ym9hcmRLZXl9ICovIGV2dCkgPT4ge1xuICAgICAgaWYgKGlzU3BhY2UoZXZ0KSkge1xuICAgICAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IHRydWU7XG4gICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMua2V5dXBIYW5kbGVyXyA9IC8qKiBAcHJpdmF0ZSB7IUV2ZW50TGlzdGVuZXJ9ICovICgoLyoqIEB0eXBlIHshS2V5Ym9hcmRLZXl9ICovIGV2dCkgPT4ge1xuICAgICAgaWYgKGlzU3BhY2UoZXZ0KSkge1xuICAgICAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvZ2dsZUZyb21FdnRfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucmVmcmVzaFRvZ2dsZURhdGEoKTtcbiAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRleCgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5rZXl1cEhhbmRsZXJfKTtcbiAgfVxuXG4gIHJlZnJlc2hUb2dnbGVEYXRhKCkge1xuICAgIGNvbnN0IHtEQVRBX1RPR0dMRV9PTiwgREFUQV9UT0dHTEVfT0ZGfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgdGhpcy50b2dnbGVPbkRhdGFfID0gdGhpcy5wYXJzZUpzb25EYXRhQXR0cl8oREFUQV9UT0dHTEVfT04pO1xuICAgIHRoaXMudG9nZ2xlT2ZmRGF0YV8gPSB0aGlzLnBhcnNlSnNvbkRhdGFBdHRyXyhEQVRBX1RPR0dMRV9PRkYpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdG9nZ2xlRnJvbUV2dF8oKSB7XG4gICAgdGhpcy50b2dnbGUoKTtcbiAgICBjb25zdCB7b25fOiBpc09ufSA9IHRoaXM7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoLyoqIEB0eXBlIHshSWNvblRvZ2dsZUV2ZW50fSAqLyAoe2lzT259KSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNPbigpIHtcbiAgICByZXR1cm4gdGhpcy5vbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFuPX0gaXNPbiAqL1xuICB0b2dnbGUoaXNPbiA9ICF0aGlzLm9uXykge1xuICAgIHRoaXMub25fID0gaXNPbjtcblxuICAgIGNvbnN0IHtBUklBX0xBQkVMLCBBUklBX1BSRVNTRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIGlmICh0aGlzLm9uXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfUFJFU1NFRCwgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfUFJFU1NFRCwgJ2ZhbHNlJyk7XG4gICAgfVxuXG4gICAgY29uc3Qge2Nzc0NsYXNzOiBjbGFzc1RvUmVtb3ZlfSA9XG4gICAgICAgIHRoaXMub25fID8gdGhpcy50b2dnbGVPZmZEYXRhXyA6IHRoaXMudG9nZ2xlT25EYXRhXztcblxuICAgIGlmIChjbGFzc1RvUmVtb3ZlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNsYXNzVG9SZW1vdmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHtjb250ZW50LCBsYWJlbCwgY3NzQ2xhc3N9ID0gdGhpcy5vbl8gPyB0aGlzLnRvZ2dsZU9uRGF0YV8gOiB0aGlzLnRvZ2dsZU9mZkRhdGFfO1xuXG4gICAgaWYgKGNzc0NsYXNzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGV4dChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoQVJJQV9MQUJFTCwgbGFiZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YUF0dHJcbiAgICogQHJldHVybiB7IUljb25Ub2dnbGVTdGF0ZX1cbiAgICovXG4gIHBhcnNlSnNvbkRhdGFBdHRyXyhkYXRhQXR0cikge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMuYWRhcHRlcl8uZ2V0QXR0cihkYXRhQXR0cik7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUljb25Ub2dnbGVTdGF0ZX0gKi8gKEpTT04ucGFyc2UodmFsKSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhYmxlZF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpc0Rpc2FibGVkICovXG4gIHNldERpc2FibGVkKGlzRGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGlzRGlzYWJsZWQ7XG5cbiAgICBjb25zdCB7RElTQUJMRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBjb25zdCB7QVJJQV9ESVNBQkxFRH0gPSBNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzO1xuXG4gICAgaWYgKHRoaXMuZGlzYWJsZWRfKSB7XG4gICAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRleCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleCgtMSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoQVJJQV9ESVNBQkxFRCwgJ3RydWUnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRhYkluZGV4KHRoaXMuc2F2ZWRUYWJJbmRleF8pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ybUF0dHIoQVJJQV9ESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNLZXlib2FyZEFjdGl2YXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl87XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAga2V5OiBzdHJpbmcsXG4gKiAgIGtleUNvZGU6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEtleWJvYXJkS2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7IUtleWJvYXJkS2V5fSBrZXlib2FyZEtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShrZXlib2FyZEtleSkge1xuICByZXR1cm4ga2V5Ym9hcmRLZXkua2V5ID09PSAnU3BhY2UnIHx8IGtleWJvYXJkS2V5LmtleUNvZGUgPT09IDMyO1xufVxuXG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBJY29uVG9nZ2xlU3RhdGUge31cblxuLyoqXG4gKiBUaGUgYXJpYS1sYWJlbCB2YWx1ZSBvZiB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBhcmlhLWxhYmVsLlxuICogQGV4cG9ydCB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuSWNvblRvZ2dsZVN0YXRlLnByb3RvdHlwZS5sYWJlbDtcblxuLyoqXG4gKiBUaGUgdGV4dCBmb3IgdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gdGV4dC5cbiAqIEBleHBvcnQge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbkljb25Ub2dnbGVTdGF0ZS5wcm90b3R5cGUuY29udGVudDtcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBDU1MgY2xhc3MuXG4gKiBAZXhwb3J0IHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5JY29uVG9nZ2xlU3RhdGUucHJvdG90eXBlLmNzc0NsYXNzO1xuXG5leHBvcnQgZGVmYXVsdCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gY2xhc3M9XCJtZGMtaWNvbi10b2dnbGVcIiByb2xlPVwiYnV0dG9uXCIgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDp0YWJpbmRleD1cInRhYkluZGV4XCJcbiAgICA6ZGF0YS10b2dnbGUtb249XCJ0b2dnbGVPbkRhdGFcIlxuICAgIDpkYXRhLXRvZ2dsZS1vZmY9XCJ0b2dnbGVPZmZEYXRhXCI+XG4gICAgPGkgOmNsYXNzPVwiaWNvbkNsYXNzZXNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj57e3RleHR9fTwvaT5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbidcbmltcG9ydCB7UmlwcGxlQmFzZX0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtaWNvbi10b2dnbGUnLFxuICBwcm9wczoge1xuICAgIHRvZ2dsZU9uOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHRvZ2dsZU9mZjogW1N0cmluZywgT2JqZWN0XSxcbiAgICB2YWx1ZTogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhY2NlbnQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1pY29uLXRvZ2dsZS0tYWNjZW50JzogdGhpcy5hY2NlbnRcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgaWNvbkNsYXNzZXM6IHt9LFxuICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnRvZ2dsZSh2YWx1ZSlcbiAgICB9LFxuICAgIGRpc2FibGVkIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZChkaXNhYmxlZClcbiAgICB9LFxuICAgIHRvZ2dsZU9uRGF0YSAoKSB7XG4gICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ucmVmcmVzaFRvZ2dsZURhdGEoKVxuICAgIH0sXG4gICAgdG9nZ2xlT2ZmRGF0YSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5yZWZyZXNoVG9nZ2xlRGF0YSgpXG4gICAgfSxcbiAgICBhY2NlbnQgKHZhbHVlKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWljb24tdG9nZ2xlLS1zZWNvbmRhcnknLCB2YWx1ZSlcbiAgICB9LFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHRvZ2dsZU9uRGF0YSAoKSB7XG4gICAgICBsZXQgdG9nZ2xlID0gdGhpcy50b2dnbGVPblxuICAgICAgcmV0dXJuIHRvZ2dsZSAmJiBKU09OLnN0cmluZ2lmeSgodHlwZW9mIHRvZ2dsZSA9PT0gJ3N0cmluZycpID8geyBcbiAgICAgICAgY29udGVudDogdG9nZ2xlLCBcbiAgICAgICAgY3NzQ2xhc3M6ICdtYXRlcmlhbC1pY29ucycgXG4gICAgICB9IDoge1xuICAgICAgICBjb250ZW50OiB0b2dnbGUuaWNvbiB8fCB0b2dnbGUuY29udGVudCxcbiAgICAgICAgbGFiZWw6IHRvZ2dsZS5sYWJlbCxcbiAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgfSlcbiAgICB9ICxcbiAgICB0b2dnbGVPZmZEYXRhICgpIHtcbiAgICAgIGxldCB0b2dnbGUgPSB0aGlzLnRvZ2dsZU9mZlxuICAgICAgcmV0dXJuIHRvZ2dsZSAmJiBKU09OLnN0cmluZ2lmeSgodHlwZW9mIHRvZ2dsZSA9PT0gJ3N0cmluZycpID8geyBcbiAgICAgICAgY29udGVudDogdG9nZ2xlLCBcbiAgICAgICAgY3NzQ2xhc3M6ICdtYXRlcmlhbC1pY29ucycgXG4gICAgICB9IDoge1xuICAgICAgICBjb250ZW50OiB0b2dnbGUuaWNvbiB8fCB0b2dnbGUuY29udGVudCxcbiAgICAgICAgbGFiZWw6IHRvZ2dsZS5sYWJlbCxcbiAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgfSlcbiAgICB9LFxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDSWNvblRvZ2dsZUZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHNldCh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIHNldFRleHQ6ICh0ZXh0KSA9PiB7IHRoaXMudGV4dCA9IHRleHQgfSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiB0aGlzLnRhYkluZGV4LFxuICAgICAgc2V0VGFiSW5kZXg6ICh0YWJJbmRleCkgPT4geyB0aGlzLnRhYkluZGV4ID0gdGFiSW5kZXggfSxcbiAgICAgIGdldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4gdGhpcy4kZWwuZ2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSxcbiAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4geyB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIH0sXG4gICAgICBybUF0dHI6IChuYW1lKSA9PiB7IHRoaXMuJGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoZXZ0RGF0YSkgPT4geyB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2dERhdGEuaXNPbikgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuZm91bmRhdGlvbi50b2dnbGUodGhpcy52YWx1ZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IHRoaXMuZm91bmRhdGlvbi5pc0tleWJvYXJkQWN0aXZhdGVkKCksXG4gICAgfSlcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNJQ29uVG9nZ2xlIGZyb20gJy4vbWRjLWljb24tdG9nZ2xlLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjSUNvblRvZ2dsZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjSUNvblRvZ2dsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLXRvb2xiYXItd3JhcHBlclwiPlxuICAgICAgPHNsb3QgbmFtZT1cInRvb2xiYXJcIiAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS1tYWluLWNvbnRhaW5lclwiPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLWRyYXdlci13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJkcmF3ZXJcIiAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcC0tY29udGVudC13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWFwcCcsXG59XG48L3NjcmlwdD4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjTGF5b3V0QXBwIGZyb20gJy4vbWRjLWxheW91dC1hcHAudnVlJ1xuXG5leHBvcnQge1xuICBtZGNMYXlvdXRBcHBcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0xheW91dEFwcFxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtZ3JpZFwiIDpjbGFzcz1jbGFzc2VzPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWdyaWRfX2lubmVyXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1ncmlkJyxcbiAgcHJvcHM6IHtcbiAgICAnZml4ZWQtY29sdW1uLXdpZHRoJzogQm9vbGVhblxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWxheW91dC1ncmlkLS1maXhlZC1jb2x1bW4td2lkdGgnOiB0aGlzLmZpeGVkQ29sdW1uV2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1jZWxsIG1kYy1sYXlvdXQtZ3JpZF9fY2VsbFwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmNvbnN0IHNwYW5PcHRpb25zID0ge1xuICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICBkZWZhdWx0OiBudWxsLFxuICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpXG4gICAgcmV0dXJuIGlzRmluaXRlKG51bSkgJiYgKG51bSA8PSAxMikgJiYgKG51bSA+IDApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1jZWxsJyxcbiAgcHJvcHM6IHtcbiAgICBzcGFuOiBzcGFuT3B0aW9ucyxcbiAgICBvcmRlcjogc3Bhbk9wdGlvbnMsXG4gICAgcGhvbmU6IHNwYW5PcHRpb25zLFxuICAgIHRhYmxldDogc3Bhbk9wdGlvbnMsXG4gICAgZGVza3RvcDogc3Bhbk9wdGlvbnMsXG4gICAgYWxpZ246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbJ3RvcCcsICdib3R0b20nLCAnbWlkZGxlJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgbGV0IGNsYXNzZXMgPSBbXVxuXG4gICAgICBpZiAodGhpcy5zcGFuKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy5zcGFufWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9yZGVyKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1vcmRlci0ke3RoaXMub3JkZXJ9YClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGhvbmUpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLnBob25lfS1waG9uZWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRhYmxldCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMudGFibGV0fS10YWJsZXRgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZXNrdG9wKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy5kZXNrdG9wfS1kZXNrdG9wYClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYWxpZ24pIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLWFsaWduLSR7dGhpcy5hbGlnbn1gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3Nlc1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWlubmVyLWdyaWQgbWRjLWxheW91dC1ncmlkX19pbm5lclwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1pbm5lci1ncmlkJyxcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xheW91dEdyaWQgZnJvbSAnLi9tZGMtbGF5b3V0LWdyaWQudnVlJ1xuaW1wb3J0IG1kY0xheW91dENlbGwgZnJvbSAnLi9tZGMtbGF5b3V0LWNlbGwudnVlJ1xuaW1wb3J0IG1kY0xheW91dElubmVyR3JpZCBmcm9tICcuL21kYy1sYXlvdXQtaW5uZXItZ3JpZC52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0xheW91dEdyaWQsXG4gIG1kY0xheW91dENlbGwsXG4gIG1kY0xheW91dElubmVyR3JpZFxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGF5b3V0R3JpZCxcbiAgbWRjTGF5b3V0Q2VsbCxcbiAgbWRjTGF5b3V0SW5uZXJHcmlkXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIENMT1NFRF9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWNsb3NlZCcsXG4gIElOREVURVJNSU5BVEVfQ0xBU1M6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1pbmRldGVybWluYXRlJyxcbiAgUkVWRVJTRURfQ0xBU1M6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1yZXZlcnNlZCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgUFJJTUFSWV9CQVJfU0VMRUNUT1I6ICcubWRjLWxpbmVhci1wcm9ncmVzc19fcHJpbWFyeS1iYXInLFxuICBCVUZGRVJfU0VMRUNUT1I6ICcubWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7dHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcblxuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFByaW1hcnlCYXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHt9LFxuICAgICAgZ2V0QnVmZmVyOiAoKSA9PiAvKiBlbDogRWxlbWVudCAqLyB7fSxcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IGZhbHNlLFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKC8qIGVsOiBFbGVtZW50LCBzdHlsZVByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENMaW5lYXJQcm9ncmVzc0ZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5kZXRlcm1pbmF0ZV8gPSAhdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ0xBU1MpO1xuICAgIHRoaXMucmV2ZXJzZV8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuUkVWRVJTRURfQ0xBU1MpO1xuICAgIHRoaXMucHJvZ3Jlc3NfID0gMDtcbiAgfVxuXG4gIHNldERldGVybWluYXRlKGlzRGV0ZXJtaW5hdGUpIHtcbiAgICB0aGlzLmRldGVybWluYXRlXyA9IGlzRGV0ZXJtaW5hdGU7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldFByaW1hcnlCYXIoKSwgdGhpcy5wcm9ncmVzc18pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldFByaW1hcnlCYXIoKSwgMSk7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldEJ1ZmZlcigpLCAxKTtcbiAgICB9XG4gIH1cblxuICBzZXRQcm9ncmVzcyh2YWx1ZSkge1xuICAgIHRoaXMucHJvZ3Jlc3NfID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldFByaW1hcnlCYXIoKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldEJ1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRldGVybWluYXRlXykge1xuICAgICAgdGhpcy5zZXRTY2FsZV8odGhpcy5hZGFwdGVyXy5nZXRCdWZmZXIoKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldFJldmVyc2UoaXNSZXZlcnNlZCkge1xuICAgIHRoaXMucmV2ZXJzZV8gPSBpc1JldmVyc2VkO1xuICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuUkVWRVJTRURfQ0xBU1MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuUkVWRVJTRURfQ0xBU1MpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkNMT1NFRF9DTEFTUyk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQ0xPU0VEX0NMQVNTKTtcbiAgfVxuXG4gIHNldFNjYWxlXyhlbCwgc2NhbGVWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gJ3NjYWxlWCgnICsgc2NhbGVWYWx1ZSArICcpJztcbiAgICB0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXMuZm9yRWFjaCgodHJhbnNmb3JtU3R5bGVQcm9wZXJ0eSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZShlbCwgdHJhbnNmb3JtU3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH0pO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgcm9sZT1cInByb2dyZXNzYmFyXCIgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzXCIgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXJpbmctZG90c1wiPjwvZGl2PlxuICAgIDxkaXYgcmVmPVwiYnVmZmVyXCIgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXJcIj48L2Rpdj5cbiAgICA8ZGl2IHJlZj1cInByaW1hcnlcIiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXItaW5uZXJcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lclwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvZm91bmRhdGlvbidcblxuY29uc3QgUHJvZ3Jlc3NQcm9wVHlwZSA9IHtcbiAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgdmFsaWRhdG9yICh2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpID49IDAgJiYgTnVtYmVyKHZhbHVlKSA8PSAxXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpbmVhci1wcm9ncmVzcycsXG4gIHByb3BzOiB7XG4gICAgJ29wZW4nOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICAnaW5kZXRlcm1pbmF0ZSc6IEJvb2xlYW4sXG4gICAgJ3JldmVyc2UnOiBCb29sZWFuLFxuICAgICdhY2NlbnQnOiBCb29sZWFuLFxuICAgICdwcm9ncmVzcyc6IFByb2dyZXNzUHJvcFR5cGUsXG4gICAgJ2J1ZmZlcic6IFByb2dyZXNzUHJvcFR5cGVcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHsnbWRjLWxpbmVhci1wcm9ncmVzcy0tYWNjZW50JzogdGhpcy5hY2NlbnR9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuICgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2dyZXNzICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRQcm9ncmVzcyhOdW1iZXIodGhpcy5wcm9ncmVzcykpXG4gICAgfSxcbiAgICBidWZmZXIgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEJ1ZmZlcihOdW1iZXIodGhpcy5idWZmZXIpKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICB9LFxuICAgIHJldmVyc2UgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFJldmVyc2UodGhpcy5yZXZlcnNlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgZ2V0UHJpbWFyeUJhcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5wcmltYXJ5XG4gICAgICB9LFxuICAgICAgZ2V0QnVmZmVyOiAoKSA9PiAvKiBlbDogRWxlbWVudCAqLyB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmJ1ZmZlclxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAoZWwsIHN0eWxlUHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW3N0eWxlUHJvcGVydHldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRCdWZmZXIoTnVtYmVyKHRoaXMuYnVmZmVyKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xpbmVhclByb2dyZXNzIGZyb20gJy4vbWRjLWxpbmVhci1wcm9ncmVzcy52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0xpbmVhclByb2dyZXNzXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMaW5lYXJQcm9ncmVzc1xufSkiLCI8dGVtcGxhdGU+XG4gIDx1bCBjbGFzcz1cIm1kYy1saXN0XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC91bD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgZGVuc2U6IEJvb2xlYW4sXG4gICAgYXZhdGFyTGlzdDogQm9vbGVhbixcbiAgICB0d29MaW5lOiBCb29sZWFuLFxuICAgIGJvcmRlcmVkOiBCb29sZWFuLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuXG4gIH0sXG4gIHByb3ZpZGUgKCkge1xuICAgIHJldHVybiB7IG1kY0xpc3Q6IHRoaXMgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtbGlzdC0tYXZhdGFyLWxpc3QnOiB0aGlzLmF2YXRhckxpc3QsXG4gICAgICAgICdtZGMtbGlzdC0tdHdvLWxpbmUnOiB0aGlzLnR3b0xpbmUsXG4gICAgICAgICdtZGMtbGlzdC0tYm9yZGVyZWQnOiB0aGlzLmJvcmRlcmVkLFxuICAgICAgICAnbWRjLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSc6ICF0aGlzLmludGVyYWN0aXZlXG4gICAgICB9ICAgICAgXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIGNsYXNzPVwibWRjLWxpc3QtaXRlbVwiXG4gICAgOmNsYXNzPVwiW2NsYXNzZXMsIGl0ZW1DbGFzc2VzXVwiIDpzdHlsZT1cInN0eWxlc1wiICAgXG4gICAgOnRhYmluZGV4PVwiaXNJbnRlcmFjdGl2ZSA/ICcwJyA6IHVuZGVmaW5lZFwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyAkbGlzdGVuZXJzIDoge31cIj5cblxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fZ3JhcGhpY1wiIHYtaWY9XCJoYXNTdGFydERldGFpbFwiPlxuICAgICAgPHNsb3QgbmFtZT1cInN0YXJ0LWRldGFpbFwiPjwvc2xvdD5cbiAgICA8L3NwYW4+XG5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX3RleHRcIiB2LWlmPVwiaGFzU2Vjb25kYXJ5XCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX3NlY29uZGFyeS10ZXh0XCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJzZWNvbmRhcnlcIj48L3Nsb3Q+XG4gICAgICA8L3NwYW4+XG4gICAgPC9zcGFuPlxuICAgIDxzbG90IHYtZWxzZT48L3Nsb3Q+XG5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX21ldGFcIiB2LWlmPVwiaGFzRW5kRGV0YWlsXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiZW5kLWRldGFpbFwiPjwvc2xvdD5cbiAgICA8L3NwYW4+XG5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtaXRlbScsXG4gIGluamVjdDogWydtZGNMaXN0J10sXG4gIHByb3BzOiB7XG4gICAgc2VsZWN0ZWQ6IEJvb2xlYW4sXG4gICAgYWN0aXZhdGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9IFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1DbGFzc2VzICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtbGlzdC1pdGVtLS1zZWxlY3RlZCc6IHRoaXMuc2VsZWN0ZWQsXG4gICAgICAgICdtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWQnOiB0aGlzLmFjdGl2YXRlZFxuICAgICAgfVxuICAgIH0sXG4gICAgaXNJbnRlcmFjdGl2ZSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNMaXN0ICYmIHRoaXMubWRjTGlzdC5pbnRlcmFjdGl2ZVxuICAgIH0sXG4gICAgaGFzU2Vjb25kYXJ5ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzbG90c1snc2Vjb25kYXJ5J10gJiYgKFxuICAgICAgICB0aGlzLm1kY0xpc3QgJiYgdGhpcy5tZGNMaXN0LnR3b0xpbmVcbiAgICAgICkgXG4gICAgfSxcbiAgICBoYXNFbmREZXRhaWwgKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ2VuZC1kZXRhaWwnXVxuICAgIH0sXG4gICAgaGFzU3RhcnREZXRhaWwgKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzSW50ZXJhY3RpdmUgKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuYWRkUmlwcGxlKCkgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICAgICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgJiYgdGhpcy5hZGRSaXBwbGUoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhZGRSaXBwbGUgKCkge1xuICAgICAgaWYgKCF0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgICAgcmlwcGxlLmluaXQoKVxuICAgICAgICB0aGlzLnJpcHBsZSA9IHJpcHBsZSAgICAgICAgICAgICAgICAgXG4gICAgICB9IFxuICAgIH0sXG4gICAgcmVtb3ZlUmlwcGxlICgpIHtcbiAgICAgIGlmICh0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gdGhpcy5yaXBwbGVcbiAgICAgICAgdGhpcy5yaXBwbGUgPSBudWxsIFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9ICAgICAgICAgICAgICAgIFxuICAgIH1cbiAgfVxuICBcbn1cbjwvc2NyaXB0PlxuICAiLCI8dGVtcGxhdGU+XG4gIDxsaSByb2xlPVwic2VwYXJhdG9yXCIgY2xhc3M9XCJtZGMtbGlzdC1kaXZpZGVyXCIgXG4gIDpjbGFzcz1cImNsYXNzZXNcIj48L2xpPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWRpdmlkZXInLFxuICBwcm9wczoge1xuICAgIGluc2V0OiBCb29sZWFuLFxuICAgIHBhZGRlZDogQm9vbGVhblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLWluc2V0JzogdGhpcy5pbnNldCxcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLXBhZGRlZCc6IHRoaXMucGFkZGVkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1saXN0LWdyb3VwXCI+PHNsb3Q+PC9zbG90PjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwJyxcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDMgY2xhc3M9XCJtZGMtbGlzdC1ncm91cC1oZWFkZXIgbWRjLWxpc3QtZ3JvdXBfX3N1YmhlYWRlclwiPjxzbG90Pjwvc2xvdD48L2gzPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwLWhlYWRlcicsXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhyIGNsYXNzPVwibWRjLWxpc3QtZ3JvdXAtZGl2aWRlciBtZGMtbGlzdC1kaXZpZGVyXCI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtZ3JvdXAtZGl2aWRlcicsXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMaXN0IGZyb20gJy4vbWRjLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0xpc3RJdGVtIGZyb20gJy4vbWRjLWxpc3QtaXRlbS52dWUnXG5pbXBvcnQgbWRjTGlzdERpdmlkZXIgZnJvbSAnLi9tZGMtbGlzdC1kaXZpZGVyLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXAgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC52dWUnXG5pbXBvcnQgbWRjTGlzdEdyb3VwSGVhZGVyIGZyb20gJy4vbWRjLWxpc3QtZ3JvdXAtaGVhZGVyLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXBEaXZpZGVyIGZyb20gJy4vbWRjLWxpc3QtZ3JvdXAtZGl2aWRlci52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0xpc3QsXG4gIG1kY0xpc3RJdGVtLFxuICBtZGNMaXN0RGl2aWRlcixcbiAgbWRjTGlzdEdyb3VwLFxuICBtZGNMaXN0R3JvdXBIZWFkZXIsXG4gIG1kY0xpc3RHcm91cERpdmlkZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0xpc3QsXG4gIG1kY0xpc3RJdGVtLFxuICBtZGNMaXN0RGl2aWRlcixcbiAgbWRjTGlzdEdyb3VwLFxuICBtZGNMaXN0R3JvdXBIZWFkZXIsXG4gIG1kY0xpc3RHcm91cERpdmlkZXJcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIE1lbnUuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZm9jdXNcbiAqIC0gcG9zaXRpb25cbiAqIC0gZGltZW5zaW9uc1xuICogLSBldmVudCBoYW5kbGVyc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDTWVudUFkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGhhc05lY2Vzc2FyeURvbSgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldCh0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3sgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgZ2V0SW5uZXJEaW1lbnNpb25zKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaGFzQW5jaG9yKCkge31cblxuICAvKiogQHJldHVybiB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19ICovXG4gIGdldEFuY2hvckRpbWVuc2lvbnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gIGdldFdpbmRvd0RpbWVuc2lvbnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldE51bWJlck9mSXRlbXMoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqIEBwYXJhbSB7e2luZGV4OiBudW1iZXJ9fSBldnREYXRhICovXG4gIG5vdGlmeVNlbGVjdGVkKGV2dERhdGEpIHt9XG5cbiAgbm90aWZ5Q2FuY2VsKCkge31cblxuICBzYXZlRm9jdXMoKSB7fVxuXG4gIHJlc3RvcmVGb2N1cygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRm9jdXNlZCgpIHt9XG5cbiAgZm9jdXMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldEZvY3VzZWRJdGVtSW5kZXgoKSAvKiBudW1iZXIgKi8ge31cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IGluZGV4ICovXG4gIGZvY3VzSXRlbUF0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzUnRsKCkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAqL1xuICBzZXRUcmFuc2Zvcm1PcmlnaW4ob3JpZ2luKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3tcbiAgKiAgIHRvcDogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgcmlnaHQ6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgKiAgIGJvdHRvbTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgbGVmdDogKHN0cmluZ3x1bmRlZmluZWQpXG4gICogfX0gcG9zaXRpb24gKi9cbiAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgKi9cbiAgc2V0TWF4SGVpZ2h0KGhlaWdodCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJtQXR0ckZvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJtQ2xhc3NGb3JPcHRpb25BdEluZGV4KGluZGV4LCBjbGFzc05hbWUpIHt9XG59XG5cbmV4cG9ydCB7TURDTWVudUFkYXB0ZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1tZW51JyxcbiAgT1BFTjogJ21kYy1tZW51LS1vcGVuJyxcbiAgQU5JTUFUSU5HX09QRU46ICdtZGMtbWVudS0tYW5pbWF0aW5nLW9wZW4nLFxuICBBTklNQVRJTkdfQ0xPU0VEOiAnbWRjLW1lbnUtLWFuaW1hdGluZy1jbG9zZWQnLFxuICBTRUxFQ1RFRF9MSVNUX0lURU06ICdtZGMtbGlzdC1pdGVtLS1zZWxlY3RlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElURU1TX1NFTEVDVE9SOiAnLm1kYy1tZW51X19pdGVtcycsXG4gIFNFTEVDVEVEX0VWRU5UOiAnTURDTWVudTpzZWxlY3RlZCcsXG4gIENBTkNFTF9FVkVOVDogJ01EQ01lbnU6Y2FuY2VsJyxcbiAgQVJJQV9ESVNBQkxFRF9BVFRSOiAnYXJpYS1kaXNhYmxlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIC8vIEFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRyaWdnZXJpbmcgYSBzZWxlY3RlZCBldmVudCBvbiB0aGUgbWVudS4gTm90ZSB0aGF0IHRoaXMgdGltZVxuICAvLyB3aWxsIG1vc3QgbGlrZWx5IGJlIGJ1bXBlZCB1cCBvbmNlIGludGVyYWN0aXZlIGxpc3RzIGFyZSBzdXBwb3J0ZWQgdG8gYWxsb3cgZm9yIHRoZSByaXBwbGUgdG9cbiAgLy8gYW5pbWF0ZSBiZWZvcmUgY2xvc2luZyB0aGUgbWVudVxuICBTRUxFQ1RFRF9UUklHR0VSX0RFTEFZOiA1MCxcbiAgLy8gVG90YWwgZHVyYXRpb24gb2YgbWVudSBvcGVuIGFuaW1hdGlvbi5cbiAgVFJBTlNJVElPTl9PUEVOX0RVUkFUSU9OOiAxMjAsXG4gIC8vIFRvdGFsIGR1cmF0aW9uIG9mIG1lbnUgY2xvc2UgYW5pbWF0aW9uLlxuICBUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OOiA3NSxcbiAgLy8gTWFyZ2luIGxlZnQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IHdoZW4gbWVudSBpcyBhdCBtYXhpbXVtIHBvc3NpYmxlIGhlaWdodC5cbiAgTUFSR0lOX1RPX0VER0U6IDMyLFxuICAvLyBSYXRpbyBvZiBhbmNob3Igd2lkdGggdG8gbWVudSB3aWR0aCBmb3Igc3dpdGNoaW5nIGZyb20gY29ybmVyIHBvc2l0aW9uaW5nIHRvIGNlbnRlciBwb3NpdGlvbmluZy5cbiAgQU5DSE9SX1RPX01FTlVfV0lEVEhfUkFUSU86IDAuNjcsXG4gIC8vIFJhdGlvIG9mIHZlcnRpY2FsIG9mZnNldCB0byBtZW51IGhlaWdodCBmb3Igc3dpdGNoaW5nIGZyb20gY29ybmVyIHRvIG1pZC13YXkgb3JpZ2luIHBvc2l0aW9uaW5nLlxuICBPRkZTRVRfVE9fTUVOVV9IRUlHSFRfUkFUSU86IDAuMSxcbn07XG5cbi8qKlxuICogRW51bSBmb3IgYml0cyBpbiB0aGUge0BzZWUgQ29ybmVyKSBiaXRtYXAuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBDb3JuZXJCaXQgPSB7XG4gIEJPVFRPTTogMSxcbiAgQ0VOVEVSOiAyLFxuICBSSUdIVDogNCxcbiAgRkxJUF9SVEw6IDgsXG59O1xuXG4vKipcbiAqIEVudW0gZm9yIHJlcHJlc2VudGluZyBhbiBlbGVtZW50IGNvcm5lciBmb3IgcG9zaXRpb25pbmcgdGhlIG1lbnUuXG4gKlxuICogVGhlIFNUQVJUIGNvbnN0YW50cyBtYXAgdG8gTEVGVCBpZiBlbGVtZW50IGRpcmVjdGlvbmFsaXR5IGlzIGxlZnRcbiAqIHRvIHJpZ2h0IGFuZCBSSUdIVCBpZiB0aGUgZGlyZWN0aW9uYWxpdHkgaXMgcmlnaHQgdG8gbGVmdC5cbiAqIExpa2V3aXNlIEVORCBtYXBzIHRvIFJJR0hUIG9yIExFRlQgZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb25hbGl0eS5cbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBDb3JuZXIgPSB7XG4gIFRPUF9MRUZUOiAwLFxuICBUT1BfUklHSFQ6IENvcm5lckJpdC5SSUdIVCxcbiAgQk9UVE9NX0xFRlQ6IENvcm5lckJpdC5CT1RUT00sXG4gIEJPVFRPTV9SSUdIVDogQ29ybmVyQml0LkJPVFRPTSB8IENvcm5lckJpdC5SSUdIVCxcbiAgVE9QX1NUQVJUOiBDb3JuZXJCaXQuRkxJUF9SVEwsXG4gIFRPUF9FTkQ6IENvcm5lckJpdC5GTElQX1JUTCB8IENvcm5lckJpdC5SSUdIVCxcbiAgQk9UVE9NX1NUQVJUOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LkZMSVBfUlRMLFxuICBCT1RUT01fRU5EOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LlJJR0hUIHwgQ29ybmVyQml0LkZMSVBfUlRMLFxufTtcblxuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnMsIENvcm5lckJpdCwgQ29ybmVyfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHRvcDogbnVtYmVyLFxuICogICByaWdodDogbnVtYmVyLFxuICogICBib3R0b206IG51bWJlcixcbiAqICAgbGVmdDogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgQW5jaG9yTWFyZ2luO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB2aWV3cG9ydDogeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9LFxuICogICB2aWV3cG9ydERpc3RhbmNlOiB7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9LFxuICogICBhbmNob3JIZWlnaHQ6IG51bWJlcixcbiAqICAgYW5jaG9yV2lkdGg6IG51bWJlcixcbiAqICAgbWVudUhlaWdodDogbnVtYmVyLFxuICogICBtZW51V2lkdGg6IG51bWJlcixcbiAqIH19XG4gKi9cbmxldCBBdXRvTGF5b3V0TWVhc3VyZW1lbnRzO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7TURDTWVudUFkYXB0ZXJ9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnMsIENvcm5lciwgQ29ybmVyQml0fSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ01lbnVBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDTWVudUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJ9ICovXG4gIHN0YXRpYyBnZXQgQ29ybmVyKCkge1xuICAgIHJldHVybiBDb3JuZXI7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTWVudUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTWVudUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENNZW51QWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiBmYWxzZSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gZmFsc2UsXG4gICAgICBnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldDogKCkgPT4ge30sXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+ICh7fSksXG4gICAgICBoYXNBbmNob3I6ICgpID0+IGZhbHNlLFxuICAgICAgZ2V0QW5jaG9yRGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGdldFdpbmRvd0RpbWVuc2lvbnM6ICgpID0+ICh7fSksXG4gICAgICBnZXROdW1iZXJPZkl0ZW1zOiAoKSA9PiAwLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldDogKCkgPT4gMCxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4ge30sXG4gICAgICBzYXZlRm9jdXM6ICgpID0+IHt9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4gZmFsc2UsXG4gICAgICBmb2N1czogKCkgPT4ge30sXG4gICAgICBnZXRGb2N1c2VkSXRlbUluZGV4OiAoKSA9PiAtMSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IGZhbHNlLFxuICAgICAgc2V0VHJhbnNmb3JtT3JpZ2luOiAoKSA9PiB7fSxcbiAgICAgIHNldFBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgICAgIHNldE1heEhlaWdodDogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBybUF0dHJGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBybUNsYXNzRm9yT3B0aW9uQXRJbmRleDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHshTURDTWVudUFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTWVudUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMua2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVLZXlib2FyZERvd25fKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMua2V5dXBIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5Ym9hcmRVcF8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2tfKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHsheyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSAqL1xuICAgIHRoaXMuZGltZW5zaW9uc187XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pdGVtSGVpZ2h0XztcbiAgICAvKiogQHByaXZhdGUge0Nvcm5lcn0gKi9cbiAgICB0aGlzLmFuY2hvckNvcm5lcl8gPSBDb3JuZXIuVE9QX1NUQVJUO1xuICAgIC8qKiBAcHJpdmF0ZSB7QW5jaG9yTWFyZ2lufSAqL1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXyA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9O1xuICAgIC8qKiBAcHJpdmF0ZSB7P0F1dG9MYXlvdXRNZWFzdXJlbWVudHN9ICovXG4gICAgdGhpcy5tZWFzdXJlc18gPSBudWxsO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSAtMTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbl8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5xdWlja09wZW5fID0gZmFsc2U7XG5cbiAgICAvLyBBIGtleXVwIGV2ZW50IG9uIHRoZSBtZW51IG5lZWRzIHRvIGhhdmUgYSBjb3JyZXNwb25kaW5nIGtleWRvd25cbiAgICAvLyBldmVudCBvbiB0aGUgbWVudS4gSWYgdGhlIHVzZXIgb3BlbnMgdGhlIG1lbnUgd2l0aCBhIGtleWRvd24gZXZlbnQgb24gYVxuICAgIC8vIGJ1dHRvbiwgdGhlIG1lbnUgd2lsbCBvbmx5IGdldCB0aGUga2V5IHVwIGV2ZW50IGNhdXNpbmcgYnVnZ3kgYmVoYXZpb3Igd2l0aCBzZWxlY3RlZCBlbGVtZW50cy5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5rZXlEb3duV2l0aGluTWVudV8gPSBmYWxzZTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3Qge1JPT1QsIE9QRU59ID0gTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhST09UKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1JPT1R9IGNsYXNzIHJlcXVpcmVkIGluIHJvb3QgZWxlbWVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzTmVjZXNzYXJ5RG9tKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgRE9NIG5vZGVzIG1pc3NpbmcgaW4gJHtST09UfSBjb21wb25lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoT1BFTikpIHtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5rZXl1cEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfKTtcbiAgICAvLyBDYW5jZWwgYW55IGN1cnJlbnRseSBydW5uaW5nIGFuaW1hdGlvbnMuXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5rZXl1cEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcih0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQ29ybmVyfSBjb3JuZXIgRGVmYXVsdCBhbmNob3IgY29ybmVyIGFsaWdubWVudCBvZiB0b3AtbGVmdCBtZW51IGNvcm5lci5cbiAgICovXG4gIHNldEFuY2hvckNvcm5lcihjb3JuZXIpIHtcbiAgICB0aGlzLmFuY2hvckNvcm5lcl8gPSBjb3JuZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQW5jaG9yTWFyZ2lufSBtYXJnaW4gNC1wbGV0IG9mIG1hcmdpbnMgZnJvbSBhbmNob3IuXG4gICAqL1xuICBzZXRBbmNob3JNYXJnaW4obWFyZ2luKSB7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLnRvcCA9IHR5cGVvZiBtYXJnaW4udG9wID09PSAnbnVtYmVyJyA/IG1hcmdpbi50b3AgOiAwO1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA9IHR5cGVvZiBtYXJnaW4ucmlnaHQgPT09ICdudW1iZXInID8gbWFyZ2luLnJpZ2h0IDogMDtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tID0gdHlwZW9mIG1hcmdpbi5ib3R0b20gPT09ICdudW1iZXInID8gbWFyZ2luLmJvdHRvbSA6IDA7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLmxlZnQgPSB0eXBlb2YgbWFyZ2luLmxlZnQgPT09ICdudW1iZXInID8gbWFyZ2luLmxlZnQgOiAwO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtZW1iZXJTZWxlY3Rpb24gKi9cbiAgc2V0UmVtZW1iZXJTZWxlY3Rpb24ocmVtZW1iZXJTZWxlY3Rpb24pIHtcbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyA9IHJlbWVtYmVyU2VsZWN0aW9uO1xuICAgIHRoaXMuc2V0U2VsZWN0ZWRJbmRleCgtMSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBxdWlja09wZW4gKi9cbiAgc2V0UXVpY2tPcGVuKHF1aWNrT3Blbikge1xuICAgIHRoaXMucXVpY2tPcGVuXyA9IHF1aWNrT3BlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9udW1iZXJ9IGZvY3VzSW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZvY3VzT25PcGVuXyhmb2N1c0luZGV4KSB7XG4gICAgaWYgKGZvY3VzSW5kZXggPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaW5zdGFuY2Ugb2YgTURDTWVudSByZW1lbWJlcnMgc2VsZWN0aW9ucywgYW5kIHRoZSB1c2VyIGhhc1xuICAgICAgLy8gbWFkZSBhIHNlbGVjdGlvbiwgdGhlbiBmb2N1cyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtXG4gICAgICBpZiAodGhpcy5yZW1lbWJlclNlbGVjdGlvbl8gJiYgdGhpcy5zZWxlY3RlZEluZGV4XyA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzKCk7XG4gICAgICAvLyBJZiB0aGF0IGRvZXNuJ3Qgd29yaywgZm9jdXMgZmlyc3QgaXRlbSBpbnN0ZWFkLlxuICAgICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleCgwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGZvY3VzSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIGFuZCBjYW5jZWwgdGhlIG1lbnUgaWYgbm90IGEgY2hpbGQgbGlzdC1pdGVtXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZURvY3VtZW50Q2xpY2tfKGV2dCkge1xuICAgIGxldCBlbCA9IGV2dC50YXJnZXQ7XG5cbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0SW5kZXhGb3JFdmVudFRhcmdldChlbCkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNhbmNlbCgpO1xuICAgIHRoaXMuY2xvc2UoZXZ0KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGtleXMgdGhhdCB3ZSB3YW50IHRvIHJlcGVhdCBvbiBob2xkICh0YWIgYW5kIGFycm93cykuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUtleWJvYXJkRG93bl8oZXZ0KSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBBbHQsIEN0cmwgb3IgTWV0YSBhcmUgcHJlc3NlZC5cbiAgICBpZiAoZXZ0LmFsdEtleSB8fCBldnQuY3RybEtleSB8fCBldnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qge2tleUNvZGUsIGtleSwgc2hpZnRLZXl9ID0gZXZ0O1xuICAgIGNvbnN0IGlzVGFiID0ga2V5ID09PSAnVGFiJyB8fCBrZXlDb2RlID09PSA5O1xuICAgIGNvbnN0IGlzQXJyb3dVcCA9IGtleSA9PT0gJ0Fycm93VXAnIHx8IGtleUNvZGUgPT09IDM4O1xuICAgIGNvbnN0IGlzQXJyb3dEb3duID0ga2V5ID09PSAnQXJyb3dEb3duJyB8fCBrZXlDb2RlID09PSA0MDtcbiAgICBjb25zdCBpc1NwYWNlID0ga2V5ID09PSAnU3BhY2UnIHx8IGtleUNvZGUgPT09IDMyO1xuICAgIGNvbnN0IGlzRW50ZXIgPSBrZXkgPT09ICdFbnRlcicgfHwga2V5Q29kZSA9PT0gMTM7XG4gICAgLy8gVGhlIG1lbnUgbmVlZHMgdG8ga25vdyBpZiB0aGUga2V5ZG93biBldmVudCB3YXMgdHJpZ2dlcmVkIG9uIHRoZSBtZW51XG4gICAgdGhpcy5rZXlEb3duV2l0aGluTWVudV8gPSBpc0VudGVyIHx8IGlzU3BhY2U7XG5cbiAgICBjb25zdCBmb2N1c2VkSXRlbUluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2VkSXRlbUluZGV4KCk7XG4gICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZJdGVtcygpIC0gMTtcblxuICAgIGlmIChzaGlmdEtleSAmJiBpc1RhYiAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgobGFzdEl0ZW1JbmRleCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXNoaWZ0S2V5ICYmIGlzVGFiICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IGxhc3RJdGVtSW5kZXgpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleCgwKTtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBBcnJvd3tVcCxEb3dufSBhbmQgc3BhY2UgZG8gbm90IGNhdXNlIGluYWR2ZXJ0ZW50IHNjcm9sbGluZ1xuICAgIGlmIChpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24gfHwgaXNTcGFjZSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyb3dVcCkge1xuICAgICAgaWYgKGZvY3VzZWRJdGVtSW5kZXggPT09IDAgfHwgdGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgobGFzdEl0ZW1JbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNlZEl0ZW1JbmRleCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBcnJvd0Rvd24pIHtcbiAgICAgIGlmIChmb2N1c2VkSXRlbUluZGV4ID09PSBsYXN0SXRlbUluZGV4IHx8IHRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGZvY3VzZWRJdGVtSW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5cyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gcmVwZWF0IG9uIGhvbGQgKEVudGVyLCBTcGFjZSwgRXNjYXBlKS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlS2V5Ym9hcmRVcF8oZXZ0KSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBBbHQsIEN0cmwgb3IgTWV0YSBhcmUgcHJlc3NlZC5cbiAgICBpZiAoZXZ0LmFsdEtleSB8fCBldnQuY3RybEtleSB8fCBldnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qge2tleUNvZGUsIGtleX0gPSBldnQ7XG4gICAgY29uc3QgaXNFbnRlciA9IGtleSA9PT0gJ0VudGVyJyB8fCBrZXlDb2RlID09PSAxMztcbiAgICBjb25zdCBpc1NwYWNlID0ga2V5ID09PSAnU3BhY2UnIHx8IGtleUNvZGUgPT09IDMyO1xuICAgIGNvbnN0IGlzRXNjYXBlID0ga2V5ID09PSAnRXNjYXBlJyB8fCBrZXlDb2RlID09PSAyNztcblxuICAgIGlmIChpc0VudGVyIHx8IGlzU3BhY2UpIHtcbiAgICAgIC8vIElmIHRoZSBrZXlkb3duIGV2ZW50IGRpZG4ndCBvY2N1ciBvbiB0aGUgbWVudSwgdGhlbiBpdCBzaG91bGRcbiAgICAgIC8vIGRpc3JlZ2FyZCB0aGUgcG9zc2libGUgc2VsZWN0ZWQgZXZlbnQuXG4gICAgICBpZiAodGhpcy5rZXlEb3duV2l0aGluTWVudV8pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyhldnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXlEb3duV2l0aGluTWVudV8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNFc2NhcGUpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUG9zc2libGVTZWxlY3RlZF8oZXZ0KSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQoZXZ0LnRhcmdldCwgc3RyaW5ncy5BUklBX0RJU0FCTEVEX0FUVFIpID09PSAndHJ1ZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldEluZGV4Rm9yRXZlbnRUYXJnZXQoZXZ0LnRhcmdldCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWJvdW5jZSBtdWx0aXBsZSBzZWxlY3Rpb25zXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyA9IDA7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICBpZiAodGhpcy5yZW1lbWJlclNlbGVjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KHRhcmdldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoe2luZGV4OiB0YXJnZXRJbmRleH0pO1xuICAgIH0sIG51bWJlcnMuU0VMRUNURURfVFJJR0dFUl9ERUxBWSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXV0b0xheW91dE1lYXN1cmVtZW50c30gTWVhc3VyZW1lbnRzIHVzZWQgdG8gcG9zaXRpb24gbWVudSBwb3B1cC5cbiAgICovXG4gIGdldEF1dG9MYXlvdXRNZWFzdXJlbWVudHNfKCkge1xuICAgIGNvbnN0IGFuY2hvclJlY3QgPSB0aGlzLmFkYXB0ZXJfLmdldEFuY2hvckRpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93RGltZW5zaW9ucygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2U6IHtcbiAgICAgICAgdG9wOiBhbmNob3JSZWN0LnRvcCxcbiAgICAgICAgcmlnaHQ6IHZpZXdwb3J0LndpZHRoIC0gYW5jaG9yUmVjdC5yaWdodCxcbiAgICAgICAgbGVmdDogYW5jaG9yUmVjdC5sZWZ0LFxuICAgICAgICBib3R0b206IHZpZXdwb3J0LmhlaWdodCAtIGFuY2hvclJlY3QuYm90dG9tLFxuICAgICAgfSxcbiAgICAgIGFuY2hvckhlaWdodDogYW5jaG9yUmVjdC5oZWlnaHQsXG4gICAgICBhbmNob3JXaWR0aDogYW5jaG9yUmVjdC53aWR0aCxcbiAgICAgIG1lbnVIZWlnaHQ6IHRoaXMuZGltZW5zaW9uc18uaGVpZ2h0LFxuICAgICAgbWVudVdpZHRoOiB0aGlzLmRpbWVuc2lvbnNfLndpZHRoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGNvcm5lciBvZiB0aGUgYW5jaG9yIGZyb20gd2hpY2ggdG8gYW5pbWF0ZSBhbmQgcG9zaXRpb24gdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge0Nvcm5lcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE9yaWdpbkNvcm5lcl8oKSB7XG4gICAgLy8gRGVmYXVsdHM6IG9wZW4gZnJvbSB0aGUgdG9wIGxlZnQuXG4gICAgbGV0IGNvcm5lciA9IENvcm5lci5UT1BfTEVGVDtcblxuICAgIGNvbnN0IHt2aWV3cG9ydERpc3RhbmNlLCBhbmNob3JIZWlnaHQsIGFuY2hvcldpZHRoLCBtZW51SGVpZ2h0LCBtZW51V2lkdGh9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgY29uc3QgaXNCb3R0b21BbGlnbmVkID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKTtcbiAgICBjb25zdCBhdmFpbGFibGVUb3AgPSBpc0JvdHRvbUFsaWduZWQgPyB2aWV3cG9ydERpc3RhbmNlLnRvcCArIGFuY2hvckhlaWdodCArIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b21cbiAgICAgIDogdmlld3BvcnREaXN0YW5jZS50b3AgKyB0aGlzLmFuY2hvck1hcmdpbl8udG9wO1xuICAgIGNvbnN0IGF2YWlsYWJsZUJvdHRvbSA9IGlzQm90dG9tQWxpZ25lZCA/IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tIC0gdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbVxuICAgICAgOiB2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSArIGFuY2hvckhlaWdodCAtIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG5cbiAgICBjb25zdCB0b3BPdmVyZmxvdyA9IG1lbnVIZWlnaHQgLSBhdmFpbGFibGVUb3A7XG4gICAgY29uc3QgYm90dG9tT3ZlcmZsb3cgPSBtZW51SGVpZ2h0IC0gYXZhaWxhYmxlQm90dG9tO1xuICAgIGlmIChib3R0b21PdmVyZmxvdyA+IDAgJiYgdG9wT3ZlcmZsb3cgPCBib3R0b21PdmVyZmxvdykge1xuICAgICAgY29ybmVyIHw9IENvcm5lckJpdC5CT1RUT007XG4gICAgfVxuXG4gICAgY29uc3QgaXNSdGwgPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCk7XG4gICAgY29uc3QgaXNGbGlwUnRsID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuRkxJUF9SVEwpO1xuICAgIGNvbnN0IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5SSUdIVCk7XG4gICAgY29uc3QgaXNBbGlnbmVkUmlnaHQgPSAoYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiAhaXNSdGwpIHx8XG4gICAgICAoIWF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgJiYgaXNGbGlwUnRsICYmIGlzUnRsKTtcbiAgICBjb25zdCBhdmFpbGFibGVMZWZ0ID0gaXNBbGlnbmVkUmlnaHQgPyB2aWV3cG9ydERpc3RhbmNlLmxlZnQgKyBhbmNob3JXaWR0aCArIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6XG4gICAgICB2aWV3cG9ydERpc3RhbmNlLmxlZnQgKyB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdDtcbiAgICBjb25zdCBhdmFpbGFibGVSaWdodCA9IGlzQWxpZ25lZFJpZ2h0ID8gdmlld3BvcnREaXN0YW5jZS5yaWdodCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6XG4gICAgICB2aWV3cG9ydERpc3RhbmNlLnJpZ2h0ICsgYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdDtcblxuICAgIGNvbnN0IGxlZnRPdmVyZmxvdyA9IG1lbnVXaWR0aCAtIGF2YWlsYWJsZUxlZnQ7XG4gICAgY29uc3QgcmlnaHRPdmVyZmxvdyA9IG1lbnVXaWR0aCAtIGF2YWlsYWJsZVJpZ2h0O1xuXG4gICAgaWYgKChsZWZ0T3ZlcmZsb3cgPCAwICYmIGlzQWxpZ25lZFJpZ2h0ICYmIGlzUnRsKSB8fFxuICAgICAgICAoYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiAhaXNBbGlnbmVkUmlnaHQgJiYgbGVmdE92ZXJmbG93IDwgMCkgfHxcbiAgICAgICAgKHJpZ2h0T3ZlcmZsb3cgPiAwICYmIGxlZnRPdmVyZmxvdyA8IHJpZ2h0T3ZlcmZsb3cpKSB7XG4gICAgICBjb3JuZXIgfD0gQ29ybmVyQml0LlJJR0hUO1xuICAgIH1cblxuICAgIHJldHVybiBjb3JuZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBPcmlnaW4gY29ybmVyIG9mIHRoZSBtZW51LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhvcml6b250YWwgb2Zmc2V0IG9mIG1lbnUgb3JpZ2luIGNvcm5lciBmcm9tIGNvcnJlc3BvbmRpbmcgYW5jaG9yIGNvcm5lci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfKGNvcm5lcikge1xuICAgIGNvbnN0IHthbmNob3JXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc1JpZ2h0QWxpZ25lZCA9IEJvb2xlYW4oY29ybmVyICYgQ29ybmVyQml0LlJJR0hUKTtcbiAgICBjb25zdCBhdm9pZEhvcml6b250YWxPdmVybGFwID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuUklHSFQpO1xuICAgIGxldCB4ID0gMDtcbiAgICBpZiAoaXNSaWdodEFsaWduZWQpIHtcbiAgICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA/IGFuY2hvcldpZHRoIC0gdGhpcy5hbmNob3JNYXJnaW5fLmxlZnQgOiB0aGlzLmFuY2hvck1hcmdpbl8ucmlnaHQ7XG4gICAgICB4ID0gcmlnaHRPZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBhdm9pZEhvcml6b250YWxPdmVybGFwID8gYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ucmlnaHQgOiB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdDtcbiAgICAgIHggPSBsZWZ0T2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVmVydGljYWwgb2Zmc2V0IG9mIG1lbnUgb3JpZ2luIGNvcm5lciBmcm9tIGNvcnJlc3BvbmRpbmcgYW5jaG9yIGNvcm5lci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpIHtcbiAgICBjb25zdCB7dmlld3BvcnQsIHZpZXdwb3J0RGlzdGFuY2UsIGFuY2hvckhlaWdodCwgbWVudUhlaWdodH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IHtNQVJHSU5fVE9fRURHRX0gPSBNRENNZW51Rm91bmRhdGlvbi5udW1iZXJzO1xuICAgIGNvbnN0IGF2b2lkVmVydGljYWxPdmVybGFwID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKTtcbiAgICBjb25zdCBjYW5PdmVybGFwVmVydGljYWxseSA9ICFhdm9pZFZlcnRpY2FsT3ZlcmxhcDtcbiAgICBsZXQgeSA9IDA7XG5cbiAgICBpZiAoaXNCb3R0b21BbGlnbmVkKSB7XG4gICAgICB5ID0gYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPyBhbmNob3JIZWlnaHQgLSB0aGlzLmFuY2hvck1hcmdpbl8udG9wIDogLXRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b207XG4gICAgICAvLyBhZGp1c3QgZm9yIHdoZW4gbWVudSBjYW4gb3ZlcmxhcCBhbmNob3IsIGJ1dCB0b28gdGFsbCB0byBiZSBhbGlnbmVkIHRvIGJvdHRvbVxuICAgICAgLy8gYW5jaG9yIGNvcm5lci4gQm90dG9tIG1hcmdpbiBpcyBpZ25vcmVkIGluIHN1Y2ggY2FzZXMuXG4gICAgICBpZiAoY2FuT3ZlcmxhcFZlcnRpY2FsbHkgJiYgbWVudUhlaWdodCA+IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0KSB7XG4gICAgICAgIHkgPSAtKE1hdGgubWluKG1lbnVIZWlnaHQsIHZpZXdwb3J0LmhlaWdodCAtIE1BUkdJTl9UT19FREdFKSAtICh2aWV3cG9ydERpc3RhbmNlLnRvcCArIGFuY2hvckhlaWdodCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB5ID0gYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPyAoYW5jaG9ySGVpZ2h0ICsgdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbSkgOiB0aGlzLmFuY2hvck1hcmdpbl8udG9wO1xuICAgICAgLy8gYWRqdXN0IGZvciB3aGVuIG1lbnUgY2FuIG92ZXJsYXAgYW5jaG9yLCBidXQgdG9vIHRhbGwgdG8gYmUgYWxpZ25lZCB0byB0b3BcbiAgICAgIC8vIGFuY2hvciBjb3JuZXJzLiBUb3AgbWFyZ2luIGlzIGlnbm9yZWQgaW4gdGhhdCBjYXNlLlxuICAgICAgaWYgKGNhbk92ZXJsYXBWZXJ0aWNhbGx5ICYmIG1lbnVIZWlnaHQgPiB2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSArIGFuY2hvckhlaWdodCkge1xuICAgICAgICB5ID0gLShNYXRoLm1pbihtZW51SGVpZ2h0LCB2aWV3cG9ydC5oZWlnaHQgLSBNQVJHSU5fVE9fRURHRSkgLSAodmlld3BvcnREaXN0YW5jZS5ib3R0b20gKyBhbmNob3JIZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBPcmlnaW4gY29ybmVyIG9mIHRoZSBtZW51LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1heGltdW0gaGVpZ2h0IG9mIHRoZSBtZW51LCBiYXNlZCBvbiBhdmFpbGFibGUgc3BhY2UuIDAgaW5kaWNhdGVzIHNob3VsZCBub3QgYmUgc2V0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWVudU1heEhlaWdodF8oY29ybmVyKSB7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgY29uc3Qge3ZpZXdwb3J0RGlzdGFuY2V9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgY29uc3QgaXNCb3R0b21BbGlnbmVkID0gQm9vbGVhbihjb3JuZXIgJiBDb3JuZXJCaXQuQk9UVE9NKTtcblxuICAgIC8vIFdoZW4gbWF4aW11bSBoZWlnaHQgaXMgbm90IHNwZWNpZmllZCwgaXQgaXMgaGFuZGxlZCBmcm9tIGNzcy5cbiAgICBpZiAodGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkJPVFRPTSkge1xuICAgICAgaWYgKGlzQm90dG9tQWxpZ25lZCkge1xuICAgICAgICBtYXhIZWlnaHQgPSB2aWV3cG9ydERpc3RhbmNlLnRvcCArIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhIZWlnaHQgPSB2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSAtIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b207XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heEhlaWdodDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBhdXRvUG9zaXRpb25fKCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNBbmNob3IoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgbWVhc3VyZW1lbnRzIGZvciBhdXRvcG9zaXRpb24gbWV0aG9kcyByZXVzZS5cbiAgICB0aGlzLm1lYXN1cmVzXyA9IHRoaXMuZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18oKTtcblxuICAgIGNvbnN0IGNvcm5lciA9IHRoaXMuZ2V0T3JpZ2luQ29ybmVyXygpO1xuICAgIGNvbnN0IG1heE1lbnVIZWlnaHQgPSB0aGlzLmdldE1lbnVNYXhIZWlnaHRfKGNvcm5lcik7XG4gICAgbGV0IHZlcnRpY2FsQWxpZ25tZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICBsZXQgaG9yaXpvbnRhbEFsaWdubWVudCA9IChjb3JuZXIgJiBDb3JuZXJCaXQuUklHSFQpID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICBjb25zdCBob3Jpem9udGFsT2Zmc2V0ID0gdGhpcy5nZXRIb3Jpem9udGFsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpO1xuICAgIGNvbnN0IHZlcnRpY2FsT2Zmc2V0ID0gdGhpcy5nZXRWZXJ0aWNhbE9yaWdpbk9mZnNldF8oY29ybmVyKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgIFtob3Jpem9udGFsQWxpZ25tZW50XTogaG9yaXpvbnRhbE9mZnNldCA/IGhvcml6b250YWxPZmZzZXQgKyAncHgnIDogJzAnLFxuICAgICAgW3ZlcnRpY2FsQWxpZ25tZW50XTogdmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldCArICdweCcgOiAnMCcsXG4gICAgfTtcbiAgICBjb25zdCB7YW5jaG9yV2lkdGgsIG1lbnVIZWlnaHQsIG1lbnVXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICAvLyBDZW50ZXIgYWxpZ24gd2hlbiBhbmNob3Igd2lkdGggaXMgY29tcGFyYWJsZSBvciBncmVhdGVyIHRoYW4gbWVudSwgb3RoZXJ3aXNlIGtlZXAgY29ybmVyLlxuICAgIGlmIChhbmNob3JXaWR0aCAvIG1lbnVXaWR0aCA+IG51bWJlcnMuQU5DSE9SX1RPX01FTlVfV0lEVEhfUkFUSU8pIHtcbiAgICAgIGhvcml6b250YWxBbGlnbm1lbnQgPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgdmVydGljYWwgb3JpZ2luIHdoZW4gbWVudSBpcyBwb3NpdGlvbmVkIHdpdGggc2lnbmlmaWNhbnQgb2Zmc2V0IGZyb20gYW5jaG9yLiBUaGlzIGlzIGRvbmUgc28gdGhhdFxuICAgIC8vIHNjYWxlIGFuaW1hdGlvbiBpcyBcImFuY2hvcmVkXCIgb24gdGhlIGFuY2hvci5cbiAgICBpZiAoISh0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKSAmJlxuICAgICAgICBNYXRoLmFicyh2ZXJ0aWNhbE9mZnNldCAvIG1lbnVIZWlnaHQpID4gbnVtYmVycy5PRkZTRVRfVE9fTUVOVV9IRUlHSFRfUkFUSU8pIHtcbiAgICAgIGNvbnN0IHZlcnRpY2FsT2Zmc2V0UGVyY2VudCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0IC8gbWVudUhlaWdodCkgKiAxMDA7XG4gICAgICBjb25zdCBvcmlnaW5QZXJjZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pID8gMTAwIC0gdmVydGljYWxPZmZzZXRQZXJjZW50IDogdmVydGljYWxPZmZzZXRQZXJjZW50O1xuICAgICAgdmVydGljYWxBbGlnbm1lbnQgPSBNYXRoLnJvdW5kKG9yaWdpblBlcmNlbnQgKiAxMDApIC8gMTAwICsgJyUnO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhbnNmb3JtT3JpZ2luKGAke2hvcml6b250YWxBbGlnbm1lbnR9ICR7dmVydGljYWxBbGlnbm1lbnR9YCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNYXhIZWlnaHQobWF4TWVudUhlaWdodCA/IG1heE1lbnVIZWlnaHQgKyAncHgnIDogJycpO1xuXG4gICAgLy8gQ2xlYXIgbWVhc3VyZXMgYWZ0ZXIgcG9zaXRpb25pbmcgaXMgY29tcGxldGUuXG4gICAgdGhpcy5tZWFzdXJlc18gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7e2ZvY3VzSW5kZXg6ID9udW1iZXJ9PX0gb3B0aW9uc1xuICAgKi9cbiAgb3Blbih7Zm9jdXNJbmRleCA9IG51bGx9ID0ge30pIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNhdmVGb2N1cygpO1xuXG4gICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfT1BFTik7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuZGltZW5zaW9uc18gPSB0aGlzLmFkYXB0ZXJfLmdldElubmVyRGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5hdXRvUG9zaXRpb25fKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gICAgICB0aGlzLmZvY3VzT25PcGVuXyhmb2N1c0luZGV4KTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcbiAgICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICAgIHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfT1BFTik7XG4gICAgICAgIH0sIG51bWJlcnMuVFJBTlNJVElPTl9PUEVOX0RVUkFUSU9OKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2dFxuICAgKi9cbiAgY2xvc2UoZXZ0ID0gbnVsbCkge1xuICAgIGNvbnN0IHRhcmdldElzRGlzYWJsZWQgPSBldnQgP1xuICAgICAgdGhpcy5hZGFwdGVyXy5nZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldChldnQudGFyZ2V0LCBzdHJpbmdzLkFSSUFfRElTQUJMRURfQVRUUikgPT09ICd0cnVlJyA6XG4gICAgICBmYWxzZTtcblxuICAgIGlmICh0YXJnZXRJc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcih0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyk7XG5cbiAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19DTE9TRUQpO1xuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gICAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfQ0xPU0VEKTtcbiAgICAgICAgfSwgbnVtYmVycy5UUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlc3RvcmVGb2N1cygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0U2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGl0ZW0gdG8gc2V0IGFzIHNlbGVjdGVkLlxuICAgKi9cbiAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdGhpcy5zZWxlY3RlZEluZGV4Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgICBpZiAocHJldlNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ybUF0dHJGb3JPcHRpb25BdEluZGV4KHByZXZTZWxlY3RlZEluZGV4LCAnYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ybUNsYXNzRm9yT3B0aW9uQXRJbmRleChwcmV2U2VsZWN0ZWRJbmRleCwgY3NzQ2xhc3Nlcy5TRUxFQ1RFRF9MSVNUX0lURU0pO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZkl0ZW1zKCkgPyBpbmRleCA6IC0xO1xuICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXhfID49IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0ckZvck9wdGlvbkF0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4XywgJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4XywgY3NzQ2xhc3Nlcy5TRUxFQ1RFRF9MSVNUX0lURU0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQge01EQ01lbnVGb3VuZGF0aW9uLCBBbmNob3JNYXJnaW59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xubGV0IHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdXNlIG9uIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKiBAcGFyYW0geyFXaW5kb3d9IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZShnbG9iYWxPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgZWwgPSBnbG9iYWxPYmouZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydHlOYW1lID0gKCd0cmFuc2Zvcm0nIGluIGVsLnN0eWxlID8gJ3RyYW5zZm9ybScgOiAnd2Via2l0VHJhbnNmb3JtJyk7XG4gICAgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9IHRyYW5zZm9ybVByb3BlcnR5TmFtZTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xufVxuXG4vKipcbiAqIENsYW1wcyBhIHZhbHVlIGJldHdlZW4gdGhlIG1pbmltdW0gYW5kIHRoZSBtYXhpbXVtLCByZXR1cm5pbmcgdGhlIGNsYW1wZWQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWFzaW5nIHZhbHVlIHRvIGFwcGx5IGF0IHRpbWUgdCwgZm9yIGEgZ2l2ZW4gY3ViaWMgYmV6aWVyIGN1cnZlLlxuICogQ29udHJvbCBwb2ludHMgUDAgYW5kIFAzIGFyZSBhc3N1bWVkIHRvIGJlICgwLDApIGFuZCAoMSwxKSwgcmVzcGVjdGl2ZWx5LlxuICogUGFyYW1ldGVycyBhcmUgYXMgZm9sbG93czpcbiAqIC0gdGltZTogVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgYW5pbWF0aW9uLCBzY2FsZWQgYmV0d2VlbiAwIGFuZCAxLlxuICogLSB4MTogVGhlIHggdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMS5cbiAqIC0geTE6IFRoZSB5IHZhbHVlIG9mIGNvbnRyb2wgcG9pbnQgUDEuXG4gKiAtIHgyOiBUaGUgeCB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAyLlxuICogLSB5MjogVGhlIHkgdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gYmV6aWVyUHJvZ3Jlc3ModGltZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgcmV0dXJuIGdldEJlemllckNvb3JkaW5hdGVfKHNvbHZlUG9zaXRpb25Gcm9tWFZhbHVlXyh0aW1lLCB4MSwgeDIpLCB5MSwgeTIpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgYSBzaW5nbGUgY29vcmRpbmF0ZSBhdCBhIHBvc2l0aW9uIHBvaW50IGJldHdlZW4gMCBhbmQgMS5cbiAqIGMxIGFuZCBjMiBhcmUgdGhlIG1hdGNoaW5nIGNvb3JkaW5hdGUgb24gY29udHJvbCBwb2ludHMgUDEgYW5kIFAyLCByZXNwZWN0aXZlbHkuXG4gKiBDb250cm9sIHBvaW50cyBQMCBhbmQgUDMgYXJlIGFzc3VtZWQgdG8gYmUgKDAsMCkgYW5kICgxLDEpLCByZXNwZWN0aXZlbHkuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvYmV6aWVyLmpzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMVxuICogQHBhcmFtIHtudW1iZXJ9IGMyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJlemllckNvb3JkaW5hdGVfKHQsIGMxLCBjMikge1xuICAvLyBTcGVjaWFsIGNhc2Ugc3RhcnQgYW5kIGVuZC5cbiAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkge1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLy8gU3RlcCBvbmUgLSBmcm9tIDQgcG9pbnRzIHRvIDNcbiAgbGV0IGljMCA9IHQgKiBjMTtcbiAgbGV0IGljMSA9IGMxICsgdCAqIChjMiAtIGMxKTtcbiAgY29uc3QgaWMyID0gYzIgKyB0ICogKDEgLSBjMik7XG5cbiAgLy8gU3RlcCB0d28gLSBmcm9tIDMgcG9pbnRzIHRvIDJcbiAgaWMwICs9IHQgKiAoaWMxIC0gaWMwKTtcbiAgaWMxICs9IHQgKiAoaWMyIC0gaWMxKTtcblxuICAvLyBGaW5hbCBzdGVwIC0gbGFzdCBwb2ludFxuICByZXR1cm4gaWMwICsgdCAqIChpYzEgLSBpYzApO1xufVxuXG4vKipcbiAqIFByb2plY3QgYSBwb2ludCBvbnRvIHRoZSBCZXppZXIgY3VydmUsIGZyb20gYSBnaXZlbiBYLiBDYWxjdWxhdGVzIHRoZSBwb3NpdGlvbiB0IGFsb25nIHRoZSBjdXJ2ZS5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9iZXppZXIuanMuXG4gKiBAcGFyYW0ge251bWJlcn0geFZhbFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc29sdmVQb3NpdGlvbkZyb21YVmFsdWVfKHhWYWwsIHgxLCB4Mikge1xuICBjb25zdCBFUFNJTE9OID0gMWUtNjtcbiAgY29uc3QgTUFYX0lURVJBVElPTlMgPSA4O1xuXG4gIGlmICh4VmFsIDw9IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmICh4VmFsID49IDEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIEluaXRpYWwgZXN0aW1hdGUgb2YgdCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAgbGV0IHQgPSB4VmFsO1xuXG4gIC8vIFRyeSBncmFkaWVudCBkZXNjZW50IHRvIHNvbHZlIGZvciB0LiBJZiBpdCB3b3JrcywgaXQgaXMgdmVyeSBmYXN0LlxuICBsZXQgdE1pbiA9IDA7XG4gIGxldCB0TWF4ID0gMTtcbiAgbGV0IHZhbHVlID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgdmFsdWUgPSBnZXRCZXppZXJDb29yZGluYXRlXyh0LCB4MSwgeDIpO1xuICAgIGNvbnN0IGRlcml2YXRpdmUgPSAoZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCArIEVQU0lMT04sIHgxLCB4MikgLSB2YWx1ZSkgLyBFUFNJTE9OO1xuICAgIGlmIChNYXRoLmFicyh2YWx1ZSAtIHhWYWwpIDwgRVBTSUxPTikge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZXJpdmF0aXZlKSA8IEVQU0lMT04pIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgPCB4VmFsKSB7XG4gICAgICAgIHRNaW4gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdE1heCA9IHQ7XG4gICAgICB9XG4gICAgICB0IC09ICh2YWx1ZSAtIHhWYWwpIC8gZGVyaXZhdGl2ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgZ3JhZGllbnQgZGVzY2VudCBnb3Qgc3R1Y2sgaW4gYSBsb2NhbCBtaW5pbXVtLCBlLmcuIGJlY2F1c2VcbiAgLy8gdGhlIGRlcml2YXRpdmUgd2FzIGNsb3NlIHRvIDAsIHVzZSBhIERpY2hvdG9teSByZWZpbmVtZW50IGluc3RlYWQuXG4gIC8vIFdlIGxpbWl0IHRoZSBudW1iZXIgb2YgaW50ZXJhdGlvbnMgdG8gOC5cbiAgZm9yIChsZXQgaSA9IDA7IE1hdGguYWJzKHZhbHVlIC0geFZhbCkgPiBFUFNJTE9OICYmIGkgPCBNQVhfSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgaWYgKHZhbHVlIDwgeFZhbCkge1xuICAgICAgdE1pbiA9IHQ7XG4gICAgICB0ID0gKHQgKyB0TWF4KSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRNYXggPSB0O1xuICAgICAgdCA9ICh0ICsgdE1pbikgLyAyO1xuICAgIH1cbiAgICB2YWx1ZSA9IGdldEJlemllckNvb3JkaW5hdGVfKHQsIHgxLCB4Mik7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCB7Z2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lLCBjbGFtcCwgYmV6aWVyUHJvZ3Jlc3N9O1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJlZj1cInJvb3RcIiBjbGFzcz1cIm1kYy1tZW51IG1kYy1zaW1wbGUtbWVudVwiXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIHRhYmluZGV4PVwiLTFcIj5cbiAgICA8dWwgcmVmPVwiaXRlbXNcIiBjbGFzcz1cIm1kYy1zaW1wbGUtbWVudV9faXRlbXMgbWRjLWxpc3RcIiBcbiAgICAgIHJvbGU9XCJtZW51XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC91bD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHtNRENNZW51Rm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL21lbnUvZm91bmRhdGlvbidcbmltcG9ydCB7Z2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lfSBmcm9tICdAbWF0ZXJpYWwvbWVudS91dGlsJ1xuaW1wb3J0IHtlbWl0Q3VzdG9tRXZlbnR9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51JyxcbiAgcHJvcHM6IHtcbiAgICAnb3Blbi1mcm9tLXRvcC1sZWZ0JzogQm9vbGVhbixcbiAgICAnb3Blbi1mcm9tLXRvcC1yaWdodCc6IEJvb2xlYW4sXG4gICAgJ29wZW4tZnJvbS1ib3R0b20tbGVmdCc6IEJvb2xlYW4sXG4gICAgJ29wZW4tZnJvbS1ib3R0b20tcmlnaHQnOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtc2ltcGxlLW1lbnUtLW9wZW4tZnJvbS10b3AtbGVmdCc6IHRoaXMub3BlbkZyb21Ub3BMZWZ0LFxuICAgICAgICAnbWRjLXNpbXBsZS1tZW51LS1vcGVuLWZyb20tdG9wLXJpZ2h0JzogdGhpcy5vcGVuRnJvbVRvcFJpZ2h0LFxuICAgICAgICAnbWRjLXNpbXBsZS1tZW51LS1vcGVuLWZyb20tYm90dG9tLWxlZnQnOiB0aGlzLm9wZW5Gcm9tQm90dG9tTGVmdCxcbiAgICAgICAgJ21kYy1zaW1wbGUtbWVudS0tb3Blbi1mcm9tLWJvdHRvbS1yaWdodCc6IHRoaXMub3BlbkZyb21Cb3R0b21SaWdodFxuICAgICAgfSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBpdGVtczogW11cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzaG93IChvcHRpb25zKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbihvcHRpb25zKVxuICAgIH0sXG4gICAgaGlkZSAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgIH0sXG4gICAgaXNPcGVuICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24gPyB0aGlzLmZvdW5kYXRpb24uaXNPcGVuKCkgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgY29uc3QgcmVmcmVzaEl0ZW1zID0gKCkgPT4ge1xuICAgICAgdGhpcy5pdGVtcyA9IFtdLnNsaWNlLmNhbGwoXG4gICAgICAgIHRoaXMuJHJlZnMuaXRlbXMucXVlcnlTZWxlY3RvckFsbCgnLm1kYy1saXN0LWl0ZW1bcm9sZV0nKSlcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZScpXG4gICAgfVxuICAgIHRoaXMuc2xvdE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gcmVmcmVzaEl0ZW1zKCkpXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSlcblxuICAgIHRoaXMuX3ByZXZpb3VzRm9jdXMgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENNZW51Rm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgaGFzQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gQm9vbGVhbih0aGlzLiRyZWZzLml0ZW1zKSxcbiAgICAgIGdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0OiAodGFyZ2V0LCBhdHRyaWJ1dGVOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgZ2V0SW5uZXJEaW1lbnNpb25zOiAoKSA9PiAoe1xuICAgICAgICB3aWR0aDogdGhpcy4kcmVmcy5pdGVtcy5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLiRyZWZzLml0ZW1zLm9mZnNldEhlaWdodFxuICAgICAgfSksXG4gICAgICBoYXNBbmNob3I6ICgpID0+IHRoaXMuJHJlZnMucm9vdC5wYXJlbnRFbGVtZW50ICYmXG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbWRjLW1lbnUtYW5jaG9yJyksXG4gICAgICBnZXRBbmNob3JEaW1lbnNpb25zOiAoKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdldFdpbmRvd0RpbWVuc2lvbnM6ICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgIH0pLFxuICAgICAgZ2V0TnVtYmVyT2ZJdGVtczogKCkgPT4gdGhpcy5pdGVtcy5sZW5ndGgsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiB0aGlzLml0ZW1zLmluZGV4T2YodGFyZ2V0KSxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoZXZ0RGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBldnQgPSB7XG4gICAgICAgICAgaW5kZXg6IGV2dERhdGEuaW5kZXgsXG4gICAgICAgICAgaXRlbTogdGhpcy5pdGVtc1tldnREYXRhLmluZGV4XVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVtaXQoJ3NlbGVjdCcsIGV2dClcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KHRoaXMuJGVsLFxuICAgICAgICAgIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsXG4gICAgICAgICAgZXZ0KVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjYW5jZWwnKVxuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQodGhpcy4kZWwsXG4gICAgICAgICAgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5DQU5DRUxfRVZFTlQsXG4gICAgICAgICAge30pXG4gICAgICB9LFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7IHRoaXMuX3ByZXZpb3VzRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IH0sXG4gICAgICByZXN0b3JlRm9jdXM6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c0ZvY3VzLmZvY3VzKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy4kcmVmcy5yb290LFxuICAgICAgZm9jdXM6ICgpID0+IHRoaXMuJHJlZnMucm9vdC5mb2N1cygpLFxuICAgICAgZ2V0Rm9jdXNlZEl0ZW1JbmRleDogKCkgPT4gdGhpcy5pdGVtcy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLFxuICAgICAgZm9jdXNJdGVtQXRJbmRleDogKGluZGV4KSA9PiB0aGlzLml0ZW1zW2luZGV4XS5mb2N1cygpLFxuICAgICAgaXNSdGw6ICgpID0+IGdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5yb290KVxuICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnLFxuICAgICAgc2V0VHJhbnNmb3JtT3JpZ2luOiAob3JpZ2luKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgYCR7Z2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKHdpbmRvdyl9LW9yaWdpbmAsIG9yaWdpbilcbiAgICAgIH0sXG4gICAgICBzZXRQb3NpdGlvbjogKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywnbGVmdCcsIHBvc2l0aW9uLmxlZnQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywncmlnaHQnLCBwb3NpdGlvbi5yaWdodClcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCd0b3AnLCBwb3NpdGlvbi50b3ApXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywnYm90dG9tJywgcG9zaXRpb24uYm90dG9tKVxuICAgICAgfSxcbiAgICAgIHNldE1heEhlaWdodDogKGhlaWdodCkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdHlsZXMsJ21heC1oZWlnaHQnLCBoZWlnaHQpXG4gICAgICB9LFxuICAgICAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0cikgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5yZW1vdmVBdHRyaWJ1dGUoYXR0cilcbiAgICAgIH0sXG4gICAgICBhZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHJtQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHJlZnJlc2hJdGVtcygpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLl9wcmV2aW91c0ZvY3VzID0gbnVsbFxuICAgIHRoaXMuc2xvdE9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBjbGFzcz1cIm1kYy1tZW51LWl0ZW0gbWRjLWxpc3QtaXRlbVwiIHJvbGU9XCJtZW51aXRlbVwiIFxuICAgIDp0YWJpbmRleD1cImRpc2FibGVkPyctMSc6JzAnXCJcbiAgICA6YXJpYS1kaXNhYmxlZD1cImRpc2FibGVkXCJcbiAgICA+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2xpPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51LWl0ZW0nLFxuICBwcm9wczoge1xuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bGkgcm9sZT1cInNlcGFyYXRvclwiIGNsYXNzPVwibWRjLW1lbnUtZGl2aWRlciBtZGMtbGlzdC1kaXZpZGVyXCI+PC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1kaXZpZGVyJyxcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuPGRpdiBjbGFzcz1cIm1kYy1tZW51LWFuY2hvclwiPlxuICA8c2xvdD5cbiAgPC9zbG90PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtYW5jaG9yJyxcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY01lbnUgZnJvbSAnLi9tZGMtbWVudS52dWUnXG5pbXBvcnQgbWRjTWVudUl0ZW0gZnJvbSAnLi9tZGMtbWVudS1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNNZW51RGl2aWRlciBmcm9tICcuL21kYy1tZW51LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY01lbnVBbmNob3IgZnJvbSAnLi9tZGMtbWVudS1hbmNob3IudnVlJ1xuXG5leHBvcnQge1xuICBtZGNNZW51LFxuICBtZGNNZW51SXRlbSxcbiAgbWRjTWVudURpdmlkZXIsXG4gIG1kY01lbnVBbmNob3Jcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY01lbnUsXG4gIG1kY01lbnVJdGVtLFxuICBtZGNNZW51RGl2aWRlcixcbiAgbWRjTWVudUFuY2hvclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBSYWRpby4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDUmFkaW9BZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHJldHVybiB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gKi9cbiAgZ2V0TmF0aXZlQ29udHJvbCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JhZGlvQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIE5BVElWRV9DT05UUk9MX1NFTEVDVE9SOiAnLm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2wnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXJhZGlvJyxcbiAgRElTQUJMRUQ6ICdtZGMtcmFkaW8tLWRpc2FibGVkJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5pbXBvcnQgTURDUmFkaW9BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmFkaW9BZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDUmFkaW9Gb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDUmFkaW9BZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENSYWRpb0FkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gLyogIU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSAqLyB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0NoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZCAqL1xuICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBjb25zdCB7RElTQUJMRUR9ID0gTURDUmFkaW9Gb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkudmFsdWU7XG4gIH1cblxuICAvKiogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROYXRpdmVDb250cm9sXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVDb250cm9sKCkgfHwge1xuICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JhZGlvRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbjxkaXYgOmNsYXNzPVwiZm9ybUZpZWxkQ2xhc3Nlc1wiIGNsYXNzPVwibWRjLXJhZGlvLXdyYXBwZXJcIj5cbiAgPGRpdiByZWY9XCJyb290XCIgY2xhc3M9XCJtZGMtcmFkaW9cIiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCI+XG4gICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIHJlZj1cImNvbnRyb2xcIiA6aWQ9XCJfdWlkXCIgOm5hbWU9XCJuYW1lXCIgXG4gICAgICBjbGFzcz1cIm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2xcIiBAY2hhbmdlPVwic3luY1wiPlxuICBcbiAgICA8ZGl2IHJlZj1cImxhYmVsXCIgY2xhc3M9XCJtZGMtcmFkaW9fX2JhY2tncm91bmRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX291dGVyLWNpcmNsZVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1yYWRpb19faW5uZXItY2lyY2xlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8bGFiZWwgcmVmPVwibGFiZWxcIiA6Zm9yPVwiX3VpZFwiPjxzbG90Pnt7bGFiZWx9fTwvc2xvdD48L2xhYmVsPlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1JhZGlvRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvcmFkaW8vZm91bmRhdGlvbidcbmltcG9ydCBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQge0Rpc3BhdGNoRm9jdXNNaXhpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7UmlwcGxlQmFzZX0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1yYWRpbycsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3BpY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgJ25hbWUnOiB7dHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZX0sXG4gICAgJ3ZhbHVlJzogU3RyaW5nLFxuICAgICdwaWNrZWQnOiBTdHJpbmcsXG4gICAgJ2NoZWNrZWQnOiBCb29sZWFuLFxuICAgICdsYWJlbCc6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnZGlzYWJsZWQnOiBCb29sZWFuLFxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgZm9ybUZpZWxkQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLWZvcm0tZmllbGQnOiB0aGlzLmxhYmVsLFxuICAgICAgICAnbWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZCc6IHRoaXMubGFiZWwgJiYgdGhpcy5hbGlnbkVuZFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgLy8gYWRkIGZvdW5kYXRpb25cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDUmFkaW9Gb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiB0aGlzLiRyZWZzLmNvbnRyb2xcbiAgICB9KVxuXG4gICAgLy8gYWRkIHJpcHBsZVxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvcm1GaWVsZCA9IG5ldyBNRENGb3JtRmllbGRGb3VuZGF0aW9uKHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVhY3RpdmF0ZSgpXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICAgIHRoaXMuZm9ybUZpZWxkLmluaXQoKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlIDogdGhpcy5sYWJlbClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZCh0aGlzLmNoZWNrZWQgfHwgdGhpcy5waWNrZWQgPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG5cbiAgICAvLyByZWZyZXNoIG1vZGVsXG4gICAgdGhpcy5jaGVja2VkICYmIHRoaXMuc3luYygpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm9ybUZpZWxkLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBkaXNhYmxlZCAodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSlcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBpc0NoZWNrZWQgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc0NoZWNrZWQoKVxuICAgIH0sXG4gICAgc3luYyAoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1JhZGlvIGZyb20gJy4vbWRjLXJhZGlvLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjUmFkaW9cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1JhZGlvXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8c2VsZWN0IHJlZj1cInJvb3RcIiBjbGFzcz1cIm1kYy1zZWxlY3QgbWRjLW5hdGl2ZS1zZWxlY3RcIiBcbiAgICB2LW1vZGVsPVwic2VsZWN0ZWRcIiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgPlxuICAgIDxvcHRpb24gZGlzYWJsZWQgdmFsdWU9XCJcIiB2LWlmPVwibGFiZWxcIj57eyBsYWJlbCB9fTwvb3B0aW9uPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9zZWxlY3Q+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW5hdGl2ZS1zZWxlY3QnLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RlZDogdGhpcy52YWx1ZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlICgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuc2VsZWN0ZWQpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQk9UVE9NX0xJTkU6ICdtZGMtc2VsZWN0X19ib3R0b20tbGluZScsXG4gIEJPVFRPTV9MSU5FX0FDVElWRTogJ21kYy1zZWxlY3RfX2JvdHRvbS1saW5lLS1hY3RpdmUnLFxuICBCT1g6ICdtZGMtc2VsZWN0LS1ib3gnLFxuICBESVNBQkxFRDogJ21kYy1zZWxlY3QtLWRpc2FibGVkJyxcbiAgT1BFTjogJ21kYy1zZWxlY3QtLW9wZW4nLFxuICBST09UOiAnbWRjLXNlbGVjdCcsXG4gIFNDUk9MTF9MT0NLOiAnbWRjLXNlbGVjdC1zY3JvbGwtbG9jaycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ0hBTkdFX0VWRU5UOiAnTURDU2VsZWN0OmNoYW5nZScsXG4gIEJPVFRPTV9MSU5FX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX2JvdHRvbS1saW5lJyxcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLXNlbGVjdF9fbGFiZWwnLFxuICBNRU5VX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX21lbnUnLFxuICBTVVJGQUNFX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX3N1cmZhY2UnLFxuICBTRUxFQ1RFRF9URVhUX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX3NlbGVjdGVkLXRleHQnLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQge2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZX0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7TURDTWVudUZvdW5kYXRpb24sIEFuY2hvck1hcmdpbn0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCB7Q29ybmVyLCBDb3JuZXJCaXR9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyBNRENDb21wb25lbnQ8IU1EQ01lbnVGb3VuZGF0aW9uPlxuICovXG5jbGFzcyBNRENNZW51IGV4dGVuZHMgTURDQ29tcG9uZW50IHtcbiAgLyoqIEBwYXJhbSB7Li4uP30gYXJncyAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgLyoqIEBwcml2YXRlIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnByZXZpb3VzRm9jdXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ01lbnV9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDTWVudShyb290KTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5pc09wZW4oKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG4gIHNldCBvcGVuKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb25fLm9wZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uXy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3tmb2N1c0luZGV4OiA/bnVtYmVyfT19IG9wdGlvbnMgKi9cbiAgc2hvdyh7Zm9jdXNJbmRleCA9IG51bGx9ID0ge30pIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLm9wZW4oe2ZvY3VzSW5kZXg6IGZvY3VzSW5kZXh9KTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5jbG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgRGVmYXVsdCBhbmNob3IgY29ybmVyIGFsaWdubWVudCBvZiB0b3AtbGVmdFxuICAgKiAgICAgbWVudSBjb3JuZXIuXG4gICAqL1xuICBzZXRBbmNob3JDb3JuZXIoY29ybmVyKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRBbmNob3JDb3JuZXIoY29ybmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FuY2hvck1hcmdpbn0gbWFyZ2luXG4gICAqL1xuICBzZXRBbmNob3JNYXJnaW4obWFyZ2luKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRBbmNob3JNYXJnaW4obWFyZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGl0ZW0gY29udGFpbmVyIGVsZW1lbnQgaW5zaWRlIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fVxuICAgKi9cbiAgZ2V0IGl0ZW1zQ29udGFpbmVyXygpIHtcbiAgICByZXR1cm4gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuSVRFTVNfU0VMRUNUT1IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaXRlbXMgd2l0aGluIHRoZSBtZW51LiBOb3RlIHRoYXQgdGhpcyBvbmx5IGNvbnRhaW5zIHRoZSBzZXQgb2YgZWxlbWVudHMgd2l0aGluXG4gICAqIHRoZSBpdGVtcyBjb250YWluZXIgdGhhdCBhcmUgcHJvcGVyIGxpc3QgaXRlbXMsIGFuZCBub3Qgc3VwcGxlbWVudGFsIC8gcHJlc2VudGF0aW9uYWwgRE9NXG4gICAqIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8IUVsZW1lbnQ+fVxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIGNvbnN0IHtpdGVtc0NvbnRhaW5lcl86IGl0ZW1zQ29udGFpbmVyfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaXRlbXNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLm1kYy1saXN0LWl0ZW1bcm9sZV0nKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpdGVtIHdpdGhpbiB0aGUgbWVudSB0aGF0IGlzIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7P0VsZW1lbnR9XG4gICAqL1xuICBnZXRPcHRpb25CeUluZGV4KGluZGV4KSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuXG4gICAgaWYgKGluZGV4IDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gaW5kZXggKi9cbiAgc2V0IHNlbGVjdGVkSXRlbUluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRTZWxlY3RlZEluZGV4KGluZGV4KTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldCBzZWxlY3RlZEl0ZW1JbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uXy5nZXRTZWxlY3RlZEluZGV4KCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHshYm9vbGVhbn0gcmVtZW1iZXJTZWxlY3Rpb24gKi9cbiAgc2V0IHJlbWVtYmVyU2VsZWN0aW9uKHJlbWVtYmVyU2VsZWN0aW9uKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRSZW1lbWJlclNlbGVjdGlvbihyZW1lbWJlclNlbGVjdGlvbik7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBxdWlja09wZW4gKi9cbiAgc2V0IHF1aWNrT3BlbihxdWlja09wZW4pIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLnNldFF1aWNrT3BlbihxdWlja09wZW4pO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENNZW51Rm91bmRhdGlvbn0gKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENNZW51Rm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy5yb290Xy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gQm9vbGVhbih0aGlzLml0ZW1zQ29udGFpbmVyXyksXG4gICAgICBnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldDogKHRhcmdldCwgYXR0cmlidXRlTmFtZSkgPT4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIGdldElubmVyRGltZW5zaW9uczogKCkgPT4ge1xuICAgICAgICBjb25zdCB7aXRlbXNDb250YWluZXJfOiBpdGVtc0NvbnRhaW5lcn0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge3dpZHRoOiBpdGVtc0NvbnRhaW5lci5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBpdGVtc0NvbnRhaW5lci5vZmZzZXRIZWlnaHR9O1xuICAgICAgfSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT4gdGhpcy5yb290Xy5wYXJlbnRFbGVtZW50ICYmIHRoaXMucm9vdF8ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ21kYy1tZW51LWFuY2hvcicpLFxuICAgICAgZ2V0QW5jaG9yRGltZW5zaW9uczogKCkgPT4gdGhpcy5yb290Xy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4ge1xuICAgICAgICByZXR1cm4ge3dpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCwgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHR9O1xuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mSXRlbXM6ICgpID0+IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4gdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4gZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiB0aGlzLml0ZW1zLmluZGV4T2YodGFyZ2V0KSxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoZXZ0RGF0YSkgPT4gdGhpcy5lbWl0KE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsIHtcbiAgICAgICAgaW5kZXg6IGV2dERhdGEuaW5kZXgsXG4gICAgICAgIGl0ZW06IHRoaXMuaXRlbXNbZXZ0RGF0YS5pbmRleF0sXG4gICAgICB9KSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4gdGhpcy5lbWl0KE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULCB7fSksXG4gICAgICBzYXZlRm9jdXM6ICgpID0+IHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0ZvY3VzXyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzRm9jdXNfKSB7XG4gICAgICAgICAgdGhpcy5wcmV2aW91c0ZvY3VzXy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNGb2N1c2VkOiAoKSA9PiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnJvb3RfLFxuICAgICAgZm9jdXM6ICgpID0+IHRoaXMucm9vdF8uZm9jdXMoKSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IHRoaXMuaXRlbXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6IChpbmRleCkgPT4gdGhpcy5pdGVtc1tpbmRleF0uZm9jdXMoKSxcbiAgICAgIGlzUnRsOiAoKSA9PiBnZXRDb21wdXRlZFN0eWxlKHRoaXMucm9vdF8pLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogKG9yaWdpbikgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlW2Ake2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZSh3aW5kb3cpfS1vcmlnaW5gXSA9IG9yaWdpbjtcbiAgICAgIH0sXG4gICAgICBzZXRQb3NpdGlvbjogKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdF8uc3R5bGUubGVmdCA9ICdsZWZ0JyBpbiBwb3NpdGlvbiA/IHBvc2l0aW9uLmxlZnQgOiBudWxsO1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlLnJpZ2h0ID0gJ3JpZ2h0JyBpbiBwb3NpdGlvbiA/IHBvc2l0aW9uLnJpZ2h0IDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290Xy5zdHlsZS50b3AgPSAndG9wJyBpbiBwb3NpdGlvbiA/IHBvc2l0aW9uLnRvcCA6IG51bGw7XG4gICAgICAgIHRoaXMucm9vdF8uc3R5bGUuYm90dG9tID0gJ2JvdHRvbScgaW4gcG9zaXRpb24gPyBwb3NpdGlvbi5ib3R0b20gOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNldE1heEhlaWdodDogKGhlaWdodCkgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlLm1heEhlaWdodCA9IGhlaWdodDtcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT4gdGhpcy5pdGVtc1tpbmRleF0uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0cikgPT4gdGhpcy5pdGVtc1tpbmRleF0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpLFxuICAgICAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGNsYXNzTmFtZSkgPT4gdGhpcy5pdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB0aGlzLml0ZW1zW2luZGV4XS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHtNRENNZW51Rm91bmRhdGlvbiwgTURDTWVudSwgQW5jaG9yTWFyZ2luLCBDb3JuZXIsIENvcm5lckJpdH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtNRENNZW51Rm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL21lbnUvaW5kZXgnO1xuXG5jb25zdCBPUEVORVJfS0VZUyA9IFtcbiAge2tleTogJ0Fycm93VXAnLCBrZXlDb2RlOiAzOCwgZm9yVHlwZTogJ2tleWRvd24nfSxcbiAge2tleTogJ0Fycm93RG93bicsIGtleUNvZGU6IDQwLCBmb3JUeXBlOiAna2V5ZG93bid9LFxuICB7a2V5OiAnU3BhY2UnLCBrZXlDb2RlOiAzMiwgZm9yVHlwZTogJ2tleXVwJ30sXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENTZWxlY3RGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoLyogdmFsdWU6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgYWRkQ2xhc3NUb0JvdHRvbUxpbmU6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0Zyb21Cb3R0b21MaW5lOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0Qm90dG9tTGluZUF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYWRkQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0QXR0cjogKC8qIGF0dHI6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBybUF0dHI6ICgvKiBhdHRyOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9ICovICh7bGVmdDogMCwgdG9wOiAwfSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIG1ha2VUYWJiYWJsZTogKCkgPT4ge30sXG4gICAgICBtYWtlVW50YWJiYWJsZTogKCkgPT4ge30sXG4gICAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWU6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZyAqLykgPT4gLyogc3RyaW5nICovICcnLFxuICAgICAgc2V0U3R5bGU6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBjcmVhdGUyZFJlbmRlcmluZ0NvbnRleHQ6ICgpID0+IC8qIHtmb250OiBzdHJpbmcsIG1lYXN1cmVUZXh0OiAoc3RyaW5nKSA9PiB7d2lkdGg6IG51bWJlcn19ICovICh7XG4gICAgICAgIGZvbnQ6ICcnLFxuICAgICAgICBtZWFzdXJlVGV4dDogKCkgPT4gKHt3aWR0aDogMH0pLFxuICAgICAgfSksXG4gICAgICBzZXRNZW51RWxTdHlsZTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1lbnVFbEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcm1NZW51RWxBdHRyOiAoLyogYXR0cjogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldE1lbnVFbE9mZnNldEhlaWdodDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBvcGVuTWVudTogKC8qIGZvY3VzSW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBpc01lbnVPcGVuOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgc2V0U2VsZWN0ZWRUZXh0Q29udGVudDogKC8qIHRleHRDb250ZW50OiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0TnVtYmVyT2ZPcHRpb25zOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldFRleHRGb3JPcHRpb25BdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogc3RyaW5nICovICcnLFxuICAgICAgZ2V0VmFsdWVGb3JPcHRpb25BdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogc3RyaW5nICovICcnLFxuICAgICAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyLCBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIsIGF0dHI6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRUb3BGb3JPcHRpb25BdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICByZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIGdldFdpbmRvd0lubmVySGVpZ2h0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2VsZWN0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIHRoaXMuY3R4XyA9IG51bGw7XG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IC0xO1xuICAgIHRoaXMuZGlzYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZvY3VzZWRfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8gPSAwO1xuXG4gICAgdGhpcy5kaXNwbGF5SGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghdGhpcy5hZGFwdGVyXy5pc01lbnVPcGVuKCkpIHtcbiAgICAgICAgdGhpcy5vcGVuXygpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kaXNwbGF5VmlhS2V5Ym9hcmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRGlzcGxheVZpYUtleWJvYXJkXyhldnQpO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcl8gPSAoe2RldGFpbH0pID0+IHtcbiAgICAgIGNvbnN0IHtpbmRleH0gPSBkZXRhaWw7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gdGhpcy5zZWxlY3RlZEluZGV4Xykge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9zZV8oKTtcbiAgICB9O1xuICAgIHRoaXMuY2FuY2VsSGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlXygpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleF8gPT09IC0xKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbChmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5jdHhfID0gdGhpcy5hZGFwdGVyXy5jcmVhdGUyZFJlbmRlcmluZ0NvbnRleHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuZGlzcGxheUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5kaXNwbGF5VmlhS2V5Ym9hcmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRpc3BsYXlWaWFLZXlib2FyZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5DQU5DRUxfRVZFTlQsIHRoaXMuY2FuY2VsSGFuZGxlcl8pO1xuICAgIHRoaXMucmVzaXplKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIERyb3AgcmVmZXJlbmNlIHRvIGNvbnRleHQgb2JqZWN0IHRvIHByZXZlbnQgcG90ZW50aWFsIGxlYWtzXG4gICAgdGhpcy5jdHhfID0gbnVsbDtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpc3BsYXlIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5kaXNwbGF5VmlhS2V5Ym9hcmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGlzcGxheVZpYUtleWJvYXJkSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULCB0aGlzLnNlbGVjdGlvbkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5DQU5DRUxfRVZFTlQsIHRoaXMuY2FuY2VsSGFuZGxlcl8pO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleF8gPj0gMCA/IHRoaXMuYWRhcHRlcl8uZ2V0VmFsdWVGb3JPcHRpb25BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8pIDogJyc7XG4gIH1cblxuICBnZXRTZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICB9XG5cbiAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCkge1xuICAgIGNvbnN0IHByZXZTZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgICBpZiAocHJldlNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ybUF0dHJGb3JPcHRpb25BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8sICdhcmlhLXNlbGVjdGVkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mT3B0aW9ucygpID8gaW5kZXggOiAtMTtcbiAgICBsZXQgc2VsZWN0ZWRUZXh0Q29udGVudCA9ICcnO1xuICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXhfID49IDApIHtcbiAgICAgIHNlbGVjdGVkVGV4dENvbnRlbnQgPSB0aGlzLmFkYXB0ZXJfLmdldFRleHRGb3JPcHRpb25BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8pLnRyaW0oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0ckZvck9wdGlvbkF0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4XywgJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNlbGVjdGVkVGV4dENvbnRlbnQoc2VsZWN0ZWRUZXh0Q29udGVudCk7XG4gIH1cblxuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkXztcbiAgfVxuXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ1NlbGVjdEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmRpc2FibGVkXyA9IGRpc2FibGVkO1xuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5tYWtlVW50YWJiYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyKCdhcmlhLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm1ha2VUYWJiYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICBjb25zdCBmb250ID0gdGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ2ZvbnQnKTtcbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gcGFyc2VGbG9hdCh0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnbGV0dGVyLXNwYWNpbmcnKSk7XG5cbiAgICBpZiAoZm9udCkge1xuICAgICAgdGhpcy5jdHhfLmZvbnQgPSBmb250O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmltYXJ5Rm9udEZhbWlseSA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250LWZhbWlseScpLnNwbGl0KCcsJylbMF07XG4gICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250LXNpemUnKTtcbiAgICAgIHRoaXMuY3R4Xy5mb250ID0gYCR7Zm9udFNpemV9ICR7cHJpbWFyeUZvbnRGYW1pbHl9YDtcbiAgICB9XG5cbiAgICBsZXQgbWF4VGV4dExlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZPcHRpb25zKCk7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1cmZhY2VQYWRkaW5nUmlnaHQgPSBwYXJzZUludCh0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpLCAxMCk7XG4gICAgICBjb25zdCBzdXJmYWNlUGFkZGluZ0xlZnQgPSBwYXJzZUludCh0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksIDEwKTtcbiAgICAgIGNvbnN0IHNlbGVjdEJveEFkZGVkUGFkZGluZyA9IHN1cmZhY2VQYWRkaW5nUmlnaHQgKyBzdXJmYWNlUGFkZGluZ0xlZnQ7XG4gICAgICBjb25zdCB0eHQgPSB0aGlzLmFkYXB0ZXJfLmdldFRleHRGb3JPcHRpb25BdEluZGV4KGkpLnRyaW0oKTtcbiAgICAgIGNvbnN0IHt3aWR0aH0gPSB0aGlzLmN0eF8ubWVhc3VyZVRleHQodHh0KTtcbiAgICAgIGNvbnN0IGFkZGVkU3BhY2UgPSBsZXR0ZXJTcGFjaW5nICogdHh0Lmxlbmd0aDtcblxuICAgICAgbWF4VGV4dExlbmd0aCA9XG4gICAgICAgIE1hdGgubWF4KG1heFRleHRMZW5ndGgsIE1hdGguY2VpbCh3aWR0aCArIGFkZGVkU3BhY2UgKyBzZWxlY3RCb3hBZGRlZFBhZGRpbmcpKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd3aWR0aCcsIGAke21heFRleHRMZW5ndGh9cHhgKTtcbiAgfVxuXG4gIG9wZW5fKCkge1xuICAgIHRoaXMuZGlzYWJsZVNjcm9sbF8oKTtcbiAgICBjb25zdCB7T1BFTn0gPSBNRENTZWxlY3RGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3QgZm9jdXNJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleF8gPCAwID8gMCA6IHRoaXMuc2VsZWN0ZWRJbmRleF87XG5cbiAgICB0aGlzLnNldE1lbnVTdHlsZXNGb3JPcGVuQXRJbmRleF8oZm9jdXNJbmRleCk7XG4gICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3NUb0JvdHRvbUxpbmUoY3NzQ2xhc3Nlcy5CT1RUT01fTElORV9BQ1RJVkUpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoT1BFTik7XG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ub3Blbk1lbnUoZm9jdXNJbmRleCk7XG4gICAgICB0aGlzLmlzRm9jdXNlZF8gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0TWVudVN0eWxlc0Zvck9wZW5BdEluZGV4XyhpbmRleCkge1xuICAgIGNvbnN0IGlubmVySGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dJbm5lckhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWZ0LCB0b3B9ID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lbnVFbEF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lbnVFbFN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgY29uc3QgbWVudUhlaWdodCA9IHRoaXMuYWRhcHRlcl8uZ2V0TWVudUVsT2Zmc2V0SGVpZ2h0KCk7XG4gICAgY29uc3QgaXRlbU9mZnNldFRvcCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0VG9wRm9yT3B0aW9uQXRJbmRleChpbmRleCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZW51RWxTdHlsZSgnZGlzcGxheScsICcnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJtTWVudUVsQXR0cignYXJpYS1oaWRkZW4nKTtcblxuICAgIGxldCBhZGp1c3RlZFRvcCA9IHRvcCAtIGl0ZW1PZmZzZXRUb3A7XG4gICAgY29uc3Qgb3ZlcmZsb3dzVG9wID0gYWRqdXN0ZWRUb3AgPCAwO1xuICAgIGNvbnN0IG92ZXJmbG93c0JvdHRvbSA9IGFkanVzdGVkVG9wICsgbWVudUhlaWdodCA+IGlubmVySGVpZ2h0O1xuICAgIGlmIChvdmVyZmxvd3NUb3ApIHtcbiAgICAgIGFkanVzdGVkVG9wID0gMDtcbiAgICB9IGVsc2UgaWYgKG92ZXJmbG93c0JvdHRvbSkge1xuICAgICAgYWRqdXN0ZWRUb3AgPSBNYXRoLm1heCgwLCBpbm5lckhlaWdodCAtIG1lbnVIZWlnaHQpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lbnVFbFN0eWxlKCdsZWZ0JywgYCR7bGVmdH1weGApO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0TWVudUVsU3R5bGUoJ3RvcCcsIGAke2FkanVzdGVkVG9wfXB4YCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZW51RWxTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGBjZW50ZXIgJHtpdGVtT2Zmc2V0VG9wfXB4YCk7XG4gIH1cblxuICBjbG9zZV8oKSB7XG4gICAgY29uc3Qge09QRU59ID0gTURDU2VsZWN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoT1BFTik7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzc0Zyb21Cb3R0b21MaW5lKGNzc0NsYXNzZXMuQk9UVE9NX0xJTkVfQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzKCk7XG4gICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gIH1cblxuICBoYW5kbGVEaXNwbGF5VmlhS2V5Ym9hcmRfKGV2dCkge1xuICAgIC8vIFdlIHVzZSBhIGhhcmQtY29kZWQgMiBpbnN0ZWFkIG9mIEV2ZW50LkFUX1RBUkdFVCB0byBhdm9pZCBoYXZpbmcgdG8gcmVmZXJlbmNlIGEgYnJvd3NlclxuICAgIC8vIGdsb2JhbC5cbiAgICBjb25zdCBFVkVOVF9QSEFTRV9BVF9UQVJHRVQgPSAyO1xuICAgIGlmIChldnQuZXZlbnRQaGFzZSAhPT0gRVZFTlRfUEhBU0VfQVRfVEFSR0VUKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBwcmVzc2luZyBzcGFjZSBkb3duIGZyb20gc2Nyb2xsaW5nIHRoZSBwYWdlXG4gICAgY29uc3QgaXNTcGFjZURvd24gPSBldnQudHlwZSA9PT0gJ2tleWRvd24nICYmIChldnQua2V5ID09PSAnU3BhY2UnIHx8IGV2dC5rZXlDb2RlID09PSAzMik7XG4gICAgaWYgKGlzU3BhY2VEb3duKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc09wZW5lcktleSA9IE9QRU5FUl9LRVlTLnNvbWUoKHtrZXksIGtleUNvZGUsIGZvclR5cGV9KSA9PiB7XG4gICAgICByZXR1cm4gZXZ0LnR5cGUgPT09IGZvclR5cGUgJiYgKGV2dC5rZXkgPT09IGtleSB8fCBldnQua2V5Q29kZSA9PT0ga2V5Q29kZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXNPcGVuZXJLZXkpIHtcbiAgICAgIHRoaXMuZGlzcGxheUhhbmRsZXJfKGV2dCk7XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZVNjcm9sbF8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG4gIH1cblxuICBlbmFibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFNlbGVjdCBMYWJlbC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBTZWxlY3QgbGFiZWwgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdExhYmVsQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2VsZWN0TGFiZWxBZGFwdGVyO1xuIiwiZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIExBQkVMX0ZMT0FUX0FCT1ZFOiAnbWRjLXNlbGVjdF9fbGFiZWwtLWZsb2F0LWFib3ZlJyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDU2VsZWN0TGFiZWxBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENTZWxlY3RMYWJlbEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdExhYmVsRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENTZWxlY3RMYWJlbEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0TGFiZWxBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2VsZWN0TGFiZWxBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgZ2V0V2lkdGg6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1NlbGVjdExhYmVsQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2VsZWN0TGFiZWxGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBsYWJlbCB0byBmbG9hdCBvciBkZWZsb2F0IGFzIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGb2N1c2VkIFdoZXRoZXIgdGhlIGlucHV0IGlzIGZvY3VzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNCYWRJbnB1dCBUaGUgaW5wdXQncyBgdmFsaWRpdHkuYmFkSW5wdXRgIHZhbHVlLlxuICAgKi9cbiAgc3R5bGVGbG9hdCh2YWx1ZSkge1xuICAgIGNvbnN0IHtMQUJFTF9GTE9BVF9BQk9WRX0gPSBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoISF2YWx1ZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfRkxPQVRfQUJPVkUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1zZWxlY3QgbWRjLW1lbnUtc2VsZWN0XCIgXHJcbiAgICByb2xlPVwibGlzdGJveFwiIFxyXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiPlxyXG4gICAgPGRpdiByZWY9XCJzdXJmYWNlXCIgY2xhc3M9XCJtZGMtc2VsZWN0X19zdXJmYWNlXCJcclxuICAgICAgOnN0eWxlPVwic3VyZmFjZVN0eWxlc1wiIDp0YWJpbmRleD1cInRhYkluZGV4XCI+XHJcbiAgICAgICAgPGRpdiByZWY9XCJsYWJlbFwiIGNsYXNzPVwibWRjLXNlbGVjdF9fbGFiZWxcIlxyXG4gICAgICAgICAgOmNsYXNzPVwibGFiZWxDbGFzc2VzXCJcclxuICAgICAgICA+e3tsYWJlbH19PC9kaXY+XHJcbiAgICAgICAgPGRpdiByZWY9XCJzZWxlY3RlZENvbnRlbnRcIiBjbGFzcz1cIm1kYy1zZWxlY3RfX3NlbGVjdGVkLXRleHRcIiBcclxuICAgICAgICA+e3tzZWxlY3RlZFRleHRDb250ZW50fX08L2Rpdj5cclxuICAgICAgICA8ZGl2IHJlZj1cImJvdHRvbUxpbmVcIiBjbGFzcz1cIm1kYy1zZWxlY3RfX2JvdHRvbS1saW5lXCJcclxuICAgICAgICAgIDpjbGFzcz1cImJvdHRvbUxpbmVDbGFzc2VzXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxtZGMtbWVudSByZWY9XCJtZW51XCIgXHJcbiAgICAgIGNsYXNzPVwibWRjLXNlbGVjdF9fbWVudVwiXHJcbiAgICAgIEB1cGRhdGU9XCJyZWZyZXNoSW5kZXhcIj5cclxuICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgPC9tZGMtbWVudT5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IG1kY01lbnUgfSBmcm9tICcuLi9tZW51J1xyXG5pbXBvcnQgTURDU2VsZWN0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0L2ZvdW5kYXRpb24nXHJcbmltcG9ydCBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdC9sYWJlbC9mb3VuZGF0aW9uJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtbWVudS1zZWxlY3QnLFxyXG4gIG1vZGVsOiB7XHJcbiAgICBwcm9wOiAndmFsdWUnLFxyXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXHJcbiAgICB2YWx1ZTogW1N0cmluZywgQXJyYXldLFxyXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXHJcbiAgICBsYWJlbDogU3RyaW5nLCBcclxuICAgIGJveDogQm9vbGVhblxyXG4gIH0sXHJcbiAgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy1zZWxlY3QtLWJveCc6IHRoaXMuYm94XHJcbiAgICAgIH0sXHJcbiAgICAgIGxhYmVsQ2xhc3Nlczoge30sXHJcbiAgICAgIGJvdHRvbUxpbmVDbGFzc2VzOiB7fSxcclxuICAgICAgc3VyZmFjZVN0eWxlczoge30sXHJcbiAgICAgIHRhYkluZGV4OiAwLFxyXG4gICAgICBzZWxlY3RlZFRleHRDb250ZW50OiAnJ1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcG9uZW50czoge1xyXG4gICAgJ21kYy1tZW51JzogbWRjTWVudSBcclxuICB9LFxyXG4gIHdhdGNoOiB7XHJcbiAgICBkaXNhYmxlZCAodmFsdWUpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSlcclxuICAgIH0sXHJcbiAgICB2YWx1ZSAoKSB7XHJcbiAgICAgIHRoaXMucmVmcmVzaEluZGV4KClcclxuICAgIH0sXHJcbiAgICBib3ggKCkge1xyXG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLXNlbGVjdC0tYm94JyAsIHRoaXMuYm94KVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgcmVmcmVzaEluZGV4ICgpIHtcclxuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xyXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy4kcmVmcy5tZW51Lml0ZW1zXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgb3B0aW9uVmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpIHx8IG9wdGlvbnNbaV0udGV4dENvbnRlbnQudHJpbSgpXHJcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSBvcHRpb25WYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0U2VsZWN0ZWRJbmRleChpKVxyXG4gICAgICAgICAgICAvL1RPRE86IE1EQ0ZJWCBmb3JjZSBmbG9hdCBhYm92ZSBpZiB2YWx1ZSBpcyB2YWxpZFxyXG4gICAgICAgICAgICB0aGlzLiRzZXQodGhpcy5sYWJlbENsYXNzZXMsICdtZGMtc2VsZWN0X19sYWJlbC0tZmxvYXQtYWJvdmUnLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL1RPRE86IE1EQ0ZJWCBmb3JjZSBmbG9hdCBhYm92ZSBpZiB2YWx1ZSBpcyB2YWxpZFxyXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTZWxlY3RlZEluZGV4KC0xKVxyXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgJ21kYy1zZWxlY3RfX2xhYmVsLS1mbG9hdC1hYm92ZScsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSkgLy8gVE9ETzogTURDRklYXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSxcclxuICBtb3VudGVkICgpIHtcclxuXHJcbiAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiA9IG5ldyBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24oe1xyXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT5cclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXHJcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PlxyXG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lKSxcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5mb3VuZGF0aW9uICA9IG5ldyBNRENTZWxlY3RGb3VuZGF0aW9uKHtcclxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcclxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+XHJcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcclxuICAgICAgZmxvYXRMYWJlbDogKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uc3R5bGVGbG9hdCh2YWx1ZSkgXHJcbiAgICAgIH0sXHJcbiAgICAgIGFkZENsYXNzVG9Cb3R0b21MaW5lOiAoY2xhc3NOYW1lKSA9PiBcclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5ib3R0b21MaW5lQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcclxuICAgICAgcmVtb3ZlQ2xhc3NGcm9tQm90dG9tTGluZTogKGNsYXNzTmFtZSkgPT5cclxuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5ib3R0b21MaW5lQ2xhc3NlcywgY2xhc3NOYW1lKSxcclxuICAgICAgc2V0Qm90dG9tTGluZUF0dHI6IChhdHRyLCB2YWx1ZSkgPT4gXHJcbiAgICAgICAgdGhpcy4kcmVmcy5ib3R0b21MaW5lLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXHJcbiAgICAgIHNldEF0dHI6IChhdHRyLCB2YWx1ZSkgPT5cclxuICAgICAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBybUF0dHI6IChhdHRyLCB2YWx1ZSkgPT5cclxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMuc3VyZmFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMuc3VyZmFjZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxyXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZm9jdXM6ICgpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLmZvY3VzKCksXHJcbiAgICAgIG1ha2VUYWJiYWJsZTogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAwXHJcbiAgICAgIH0sXHJcbiAgICAgIG1ha2VVbnRhYmJhYmxlOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IC0xXHJcbiAgICAgIH0sXHJcbiAgICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZTogKHByb3ApID0+XHJcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5zdXJmYWNlKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApLFxyXG4gICAgICBzZXRTdHlsZTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3VyZmFjZVN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSksXHJcbiAgICAgIGNyZWF0ZTJkUmVuZGVyaW5nQ29udGV4dDogKCkgPT5cclxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgICBzZXRNZW51RWxTdHlsZTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51LiRlbC5zdHlsZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWUsXHJcbiAgICAgIHNldE1lbnVFbEF0dHI6IChhdHRyLCB2YWx1ZSkgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuJGVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXHJcbiAgICAgIHJtTWVudUVsQXR0cjogKGF0dHIpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51LiRlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXHJcbiAgICAgIGdldE1lbnVFbE9mZnNldEhlaWdodDogKCkgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuJGVsLm9mZnNldEhlaWdodCxcclxuICAgICAgb3Blbk1lbnU6IChmb2N1c0luZGV4KSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS5zaG93KHtmb2N1c0luZGV4fSksXHJcbiAgICAgIGlzTWVudU9wZW46ICgpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51LmlzT3BlbigpLFxyXG4gICAgICBzZXRTZWxlY3RlZFRleHRDb250ZW50OiAoc2VsZWN0ZWRUZXh0Q29udGVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUZXh0Q29udGVudCA9IHNlbGVjdGVkVGV4dENvbnRlbnRcclxuICAgICAgfSxcclxuICAgICAgZ2V0TnVtYmVyT2ZPcHRpb25zOiAoKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS5pdGVtcy5sZW5ndGgsXHJcbiAgICAgIGdldFRleHRGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51Lml0ZW1zW2luZGV4XS50ZXh0Q29udGVudC50cmltKCksXHJcbiAgICAgIGdldFZhbHVlRm9yT3B0aW9uQXRJbmRleDogKGluZGV4KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMubWVudS5pdGVtc1tpbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykgXHJcbiAgICAgICAgICB8fCB0aGlzLiRyZWZzLm1lbnUuaXRlbXNbaW5kZXhdLnRleHRDb250ZW50LnRyaW0oKVxyXG4gICAgICB9LFxyXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuaXRlbXNbaW5kZXhdLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXHJcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0cikgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuaXRlbXNbaW5kZXhdLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSxcclxuICAgICAgZ2V0T2Zmc2V0VG9wRm9yT3B0aW9uQXRJbmRleDogKGluZGV4KSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS5pdGVtc1tpbmRleF0ub2Zmc2V0VG9wLFxyXG4gICAgICByZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZGVyZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXHJcbiAgICAgIH0sXHJcbiAgICAgIGdldFdpbmRvd0lubmVySGVpZ2h0OiAoKSA9PiB3aW5kb3cuaW5uZXJIZWlnaHQsXHJcbiAgICAgIGFkZEJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXHJcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICAvL1RPRE86IE1EQ0ZJWFxyXG4gICAgbGV0IGZvdW5kYXRpb24gPSB0aGlzLmZvdW5kYXRpb25cclxuICAgIGZvdW5kYXRpb24ucmVzaXplID0gKCkgPT4ge1xyXG4gICAgICBcclxuICAgICAgY29uc3QgZm9udCA9IGZvdW5kYXRpb24uYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250Jyk7XHJcbiAgICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSBwYXJzZUZsb2F0KGZvdW5kYXRpb24uYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdsZXR0ZXItc3BhY2luZycpKTtcclxuXHJcbiAgICAgIGlmIChmb250KSB7XHJcbiAgICAgICAgZm91bmRhdGlvbi5jdHhfLmZvbnQgPSBmb250O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHByaW1hcnlGb250RmFtaWx5ID0gZm91bmRhdGlvbi5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ2ZvbnQtZmFtaWx5Jykuc3BsaXQoJywnKVswXTtcclxuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGZvdW5kYXRpb24uYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250LXNpemUnKTtcclxuICAgICAgICBmb3VuZGF0aW9uLmN0eF8uZm9udCA9IGAke2ZvbnRTaXplfSAke3ByaW1hcnlGb250RmFtaWx5fWA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBtYXhUZXh0TGVuZ3RoID0gMDtcclxuXHJcbiAgICAgIGNvbnN0IHN1cmZhY2VQYWRkaW5nUmlnaHQgPSBwYXJzZUludChmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpLCAxMCk7XHJcbiAgICAgIGNvbnN0IHN1cmZhY2VQYWRkaW5nTGVmdCA9IHBhcnNlSW50KGZvdW5kYXRpb24uYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdwYWRkaW5nLWxlZnQnKSwgMTApO1xyXG4gICAgICBjb25zdCBzZWxlY3RCb3hBZGRlZFBhZGRpbmcgPSBzdXJmYWNlUGFkZGluZ1JpZ2h0ICsgc3VyZmFjZVBhZGRpbmdMZWZ0O1xyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldE51bWJlck9mT3B0aW9ucygpOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHh0ID0gZm91bmRhdGlvbi5hZGFwdGVyXy5nZXRUZXh0Rm9yT3B0aW9uQXRJbmRleChpKS50cmltKCk7XHJcbiAgICAgICAgY29uc3Qge3dpZHRofSA9IGZvdW5kYXRpb24uY3R4Xy5tZWFzdXJlVGV4dCh0eHQpO1xyXG4gICAgICAgIGNvbnN0IGFkZGVkU3BhY2UgPSBsZXR0ZXJTcGFjaW5nICogdHh0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgbWF4VGV4dExlbmd0aCA9XHJcbiAgICAgICAgICBNYXRoLm1heChtYXhUZXh0TGVuZ3RoLCBNYXRoLmNlaWwod2lkdGggKyBhZGRlZFNwYWNlICsgc2VsZWN0Qm94QWRkZWRQYWRkaW5nKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGxhYmVsVHh0ID0gdGhpcy5sYWJlbDtcclxuICAgICAgY29uc3Qge3dpZHRofSA9IGZvdW5kYXRpb24uY3R4Xy5tZWFzdXJlVGV4dChsYWJlbFR4dCk7XHJcbiAgICAgIGNvbnN0IGFkZGVkU3BhY2UgPSBsZXR0ZXJTcGFjaW5nICogbGFiZWxUeHQubGVuZ3RoO1xyXG5cclxuICAgICAgbWF4VGV4dExlbmd0aCA9XHJcbiAgICAgICAgTWF0aC5tYXgobWF4VGV4dExlbmd0aCwgTWF0aC5jZWlsKHdpZHRoICsgYWRkZWRTcGFjZSArIHNlbGVjdEJveEFkZGVkUGFkZGluZykpO1xyXG5cclxuXHJcbiAgICAgIGZvdW5kYXRpb24uYWRhcHRlcl8uc2V0U3R5bGUoJ3dpZHRoJywgYCR7bWF4VGV4dExlbmd0aH1weGApO1xyXG4gICAgfVxyXG4gICAgLy8vIFxyXG4gICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcclxuICAgIHRoaXMucmVmcmVzaEluZGV4ICgpXHJcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpIHtcclxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXHJcbiAgICB9XHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95ICgpIHtcclxuICAgIGxldCBmb3VuZGF0aW9uID0gdGhpcy5mb3VuZGF0aW9uXHJcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXHJcbiAgICBmb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgXHJcbiAgICBsZXQgZm91bmRhdGlvbkxhYmVsID0gdGhpcy5mb3VuZGF0aW9uTGFiZWxcclxuICAgIHRoaXMuZm91bmRhdGlvbkxhYmVsID0gbnVsbFxyXG4gICAgZm91bmRhdGlvbkxhYmVsLmRlc3Ryb3koKVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxzZWxlY3QgOm11bHRpcGxlPVwibXVsdGlwbGVcIiAgcmVmPVwicm9vdFwiIHYtbW9kZWw9XCJzZWxlY3RlZFwiIFxyXG4gICAgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiAgOnN0eWxlPVwic3R5bGVzXCIgIFxyXG4gICAgY2xhc3M9XCJtZGMtc2VsZWN0IG1kYy1tdWx0aS1zZWxlY3QgbWRjLWxpc3RcIlxyXG4gICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcclxuICA+XHJcbiAgICA8b3B0Z3JvdXAgcmVmPVwib3B0Z3JvdXBcIiBjbGFzcz1cIm1kYy1saXN0LWdyb3VwXCIgOmxhYmVsPVwibGFiZWxcIiB2LWlmPVwibGFiZWxcIj5cclxuICAgICAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgICA8L29wdGdyb3VwPlxyXG4gICAgPHNsb3Qgdi1lbHNlPjwvc2xvdD5cclxuICA8L3NlbGVjdD5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLW11bHRpLXNlbGVjdCcsXHJcbiAgbW9kZWw6IHtcclxuICAgIHByb3A6ICd2YWx1ZScsXHJcbiAgICBldmVudDogJ2NoYW5nZSdcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBtdWx0aXBsZTogQm9vbGVhbixcclxuICAgIHZhbHVlOiBbU3RyaW5nLCBBcnJheV0sXHJcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcclxuICAgIGxhYmVsOiBTdHJpbmcsXHJcbiAgICBtYXhTaXplOiB7XHJcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXHJcbiAgICAgIGRlZmF1bHQ6IDRcclxuICAgIH1cclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2VsZWN0ZWQ6IHRoaXMudmFsdWUsXHJcbiAgICAgIHNpemU6IHVuZGVmaW5lZCxcclxuICAgICAgY291bnQ6IHVuZGVmaW5lZFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIHN0eWxlcyAoKSB7XHJcbiAgICAgIGxldCBzY3JvbGwgPSAodGhpcy5jb3VudCA+IHRoaXMuc2l6ZSlcclxuICAgICAgbGV0IHNpemUgPSA0OCogdGhpcy5zaXplICsgKHNjcm9sbD8gMCA6IDE2KVxyXG5cclxuICAgICAgbGV0IHN0eWxlcyA9ICB7XHJcbiAgICAgICAgJ2hlaWdodCc6IHNpemUgKyAncHgnLFxyXG4gICAgICAgICdvdmVyZmxvdy15JzogIHNjcm9sbCA/ICdzY3JvbGwnIDogJ2hpZGRlbidcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXNjcm9sbCkge1xyXG4gICAgICAgIHN0eWxlc1snYmFja2dyb3VuZC1pbWFnZSddID0gJ3Vuc2V0J1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzdHlsZXNcclxuICAgIH1cclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIG9uQ2hhbmdlICgpIHtcclxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5zZWxlY3RlZClcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG4gICAgY29uc3QgcmVmcmVzaFNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGxldCBjb3VudCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb24sIG9wdGdyb3VwJykubGVuZ3RoXHJcbiAgICAgIHRoaXMuY291bnQgPSBjb3VudFxyXG4gICAgICBsZXQgbWF4ID0gTnVtYmVyKHRoaXMubWF4U2l6ZSlcclxuICAgICAgaWYgKHRoaXMubGFiZWwpIHtcclxuICAgICAgICBtYXggKz0gMVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2l6ZSA9IE1hdGgubWluKGNvdW50LCBtYXgpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiByZWZyZXNoU2l6ZSgpKVxyXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSlcclxuXHJcbiAgICByZWZyZXNoU2l6ZSgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95ICgpIHtcclxuICAgIHRoaXMuc2xvdE9ic2VydmVyLmRpc2Nvbm5lY3QoKVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjb21wb25lbnQgOmlzPVwidHlwZVwiIDptdWx0aXBsZT1cIm11bHRpcGxlXCJcclxuICAgIDpsYWJlbD1cImxhYmVsXCIgXHJcbiAgICA6dmFsdWU9XCJ2YWx1ZVwiIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXHJcbiAgICB2LWJpbmQ9XCIkYXR0cnNcIlxyXG4gID5cclxuICAgIDxzbG90Pjwvc2xvdD5cclxuICA8L2NvbXBvbmVudD5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBNRENOYXRpdmVTZWxlY3QgZnJvbSAnLi9tZGMtbmF0aXZlLXNlbGVjdC52dWUnXHJcbmltcG9ydCBNRENNZW51U2VsZWN0IGZyb20gJy4vbWRjLW1lbnUtc2VsZWN0LnZ1ZSdcclxuaW1wb3J0IE1EQ011bHRpU2VsZWN0IGZyb20gJy4vbWRjLW11bHRpLXNlbGVjdC52dWUnXHJcbmltcG9ydCB7IERpc3BhdGNoRm9jdXNNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXHJcbiBcclxuY29uc3QgbWVkaWEgPSBuZXcgY2xhc3Mge1xyXG4gIGdldCBtb2JpbGUgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vYmlsZSB8fCAodGhpcy5fbW9iaWxlID1cclxuICAgICAgd2luZG93Lm1hdGNoTWVkaWEoJyhtYXgtd2lkdGg6IDYwMHB4KSBhbmQgKHBvaW50ZXI6IGNvYXJzZSknKSlcclxuICB9XHJcbn0oKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtc2VsZWN0JyxcclxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxyXG4gIG1vZGVsOiB7XHJcbiAgICBwcm9wOiAndmFsdWUnLFxyXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXHJcbiAgICB2YWx1ZTogW1N0cmluZywgQXJyYXldLFxyXG4gICAgbGFiZWw6IFN0cmluZyxcclxuICAgIG5hdGl2ZTogQm9vbGVhblxyXG4gIH0sXHJcbiAgcHJvdmlkZSAoKSB7XHJcbiAgICByZXR1cm4ge21kY1NlbGVjdDogdGhpc31cclxuICB9LFxyXG4gIGNvbXBvbmVudHM6IHtcclxuICAgICdtZGMtbmF0aXZlLXNlbGVjdCc6IE1EQ05hdGl2ZVNlbGVjdCxcclxuICAgICdtZGMtbWVudS1zZWxlY3QnOiBNRENNZW51U2VsZWN0LFxyXG4gICAgJ21kYy1tdWx0aS1zZWxlY3QnOiBNRENNdWx0aVNlbGVjdFxyXG4gIH0sXHJcbiAgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtb2JpbGU6ICh3aW5kb3cpID8gbWVkaWEubW9iaWxlLm1hdGNoZXMgOiB0cnVlXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgdHlwZSAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGxlID8gJ21kYy1tdWx0aS1zZWxlY3QnXHJcbiAgICAgICAgOiB0aGlzLm1lbnUgPyAnbWRjLW1lbnUtc2VsZWN0J1xyXG4gICAgICAgIDogdGhpcy5pc05hdGl2ZSA/ICdtZGMtbmF0aXZlLXNlbGVjdCdcclxuICAgICAgICAgIDogJ21kYy1tZW51LXNlbGVjdCdcclxuICAgIH0sXHJcbiAgICBpc05hdGl2ZSAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5hdGl2ZSB8fCB0aGlzLm11bHRpcGxlIHx8IHRoaXMubW9iaWxlXHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBvbkNoYW5nZSAodmFsdWUpIHtcclxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdmFsdWUpXHJcbiAgICB9LFxyXG4gICAgcmVmcmVzaE1lZGlhICgpIHtcclxuICAgICAgdGhpcy5tb2JpbGUgPSBtZWRpYS5tb2JpbGUubWF0Y2hlc1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgYmVmb3JlTW91bnQgKCkge1xyXG4gICAgbWVkaWEubW9iaWxlLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gICAgdGhpcy5yZWZyZXNoTWVkaWEoKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICBtZWRpYS5tb2JpbGUucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XG4gICA8b3B0aW9uIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOnZhbHVlPVwidmFsdWVcIiB2LWlmPVwiaGFzVmFsdWVcIlxuICAgIGNsYXNzPVwibWRjLW9wdGlvbiBtZGMtbmF0aXZlLW9wdGlvblwiPlxuICAgICA8c2xvdD48L3Nsb3Q+XG4gICA8L29wdGlvbj5cbiAgIDxvcHRpb24gOmRpc2FibGVkPVwiZGlzYWJsZWRcIiB2LWVsc2VcbiAgICBjbGFzcz1cIm1kYy1vcHRpb24gbWRjLW5hdGl2ZS1vcHRpb25cIj5cbiAgICAgPHNsb3Q+PC9zbG90PlxuICAgPC9vcHRpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW5hdGl2ZS1vcHRpb24nLFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXNWYWx1ZSAoKSB7XG4gICAgICByZXR1cm4gISh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgIDxsaSBjbGFzcz1cIm1kYy1vcHRpb24gbWRjLW1lbnUtb3B0aW9uIG1kYy1saXN0LWl0ZW1cIiBcbiAgICByb2xlPVwib3B0aW9uXCIgXG4gICAgOnRhYmluZGV4PVwiZGlzYWJsZWQ/LTE6MFwiXG4gICAgOmFyaWEtZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgOmRhdGEtdmFsdWU9XCJ2YWx1ZVwiPlxuICAgICA8c2xvdD48L3Nsb3Q+XG4gICA8L2xpPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51LW9wdGlvbicsXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgIDxvcHRpb24gY2xhc3M9XCJtZGMtb3B0aW9uIG1kYy1tdWx0aS1vcHRpb24gbWRjLWxpc3QtaXRlbVwiIFxuICAgIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgOnZhbHVlPVwidmFsdWVcIiB2LWlmPVwiaGFzVmFsdWVcIj5cbiAgICAgPHNsb3Q+PC9zbG90PlxuICAgPC9vcHRpb24+XG4gICA8b3B0aW9uIGNsYXNzPVwibWRjLW9wdGlvbiBtZGMtbXVsdGktb3B0aW9uIG1kYy1saXN0LWl0ZW1cIiBcbiAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIHYtZWxzZT5cbiAgICAgPHNsb3Q+PC9zbG90PlxuICAgPC9vcHRpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW11bHRpLW9wdGlvbicsXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGhhc1ZhbHVlICgpIHtcbiAgICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLnZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8Y29tcG9uZW50IDppcz1cInR5cGVcIiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIDp2YWx1ZT12YWx1ZT5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENOYXRpdmVPcHRpb24gZnJvbSAnLi9tZGMtbmF0aXZlLW9wdGlvbi52dWUnXG5pbXBvcnQgTURDTWVudU9wdGlvbiBmcm9tICcuL21kYy1tZW51LW9wdGlvbi52dWUnXG5pbXBvcnQgTURDTXVsdGlPcHRpb24gZnJvbSAnLi9tZGMtbXVsdGktb3B0aW9uLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW9wdGlvbicsXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9LFxuICBpbmplY3Q6IFsnbWRjU2VsZWN0J10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICAnbWRjLW5hdGl2ZS1vcHRpb24nOiBNRENOYXRpdmVPcHRpb24sXG4gICAgJ21kYy1tdWx0aS1vcHRpb24nOiBNRENNdWx0aU9wdGlvbixcbiAgICAnbWRjLW1lbnUtb3B0aW9uJzogTURDTWVudU9wdGlvblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzTmF0aXZlICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kY1NlbGVjdC5pc05hdGl2ZVxuICAgIH0sXG4gICAgbXVsdGlwbGUgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjU2VsZWN0Lm11bHRpcGxlXG4gICAgfSxcbiAgICB0eXBlICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGxlID8gJ21kYy1tdWx0aS1vcHRpb24nXG4gICAgICAgIDogdGhpcy5pc05hdGl2ZSA/ICdtZGMtbmF0aXZlLW9wdGlvbidcbiAgICAgICAgICA6ICdtZGMtbWVudS1vcHRpb24nXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNTZWxlY3QgZnJvbSAnLi9tZGMtc2VsZWN0LnZ1ZSdcbmltcG9ydCBtZGNPcHRpb24gZnJvbSAnLi9tZGMtb3B0aW9uLnZ1ZSdcblxuXG5leHBvcnQge1xuICBtZGNTZWxlY3QsXG4gIG1kY09wdGlvbixcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1NlbGVjdCxcbiAgbWRjT3B0aW9uLFxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEFDVElWRTogJ21kYy1zbGlkZXItLWFjdGl2ZScsXG4gIERJU0FCTEVEOiAnbWRjLXNsaWRlci0tZGlzYWJsZWQnLFxuICBESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcbiAgRk9DVVM6ICdtZGMtc2xpZGVyLS1mb2N1cycsXG4gIElOX1RSQU5TSVQ6ICdtZGMtc2xpZGVyLS1pbi10cmFuc2l0JyxcbiAgSVNfRElTQ1JFVEU6ICdtZGMtc2xpZGVyLS1kaXNjcmV0ZScsXG4gIEhBU19UUkFDS19NQVJLRVI6ICdtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBUUkFDS19TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjaycsXG4gIFRSQUNLX01BUktFUl9DT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyLWNvbnRhaW5lcicsXG4gIExBU1RfVFJBQ0tfTUFSS0VSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlcjpsYXN0LWNoaWxkJyxcbiAgVEhVTUJfQ09OVEFJTkVSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lcicsXG4gIFBJTl9WQUxVRV9NQVJLRVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlcicsXG4gIEFSSUFfVkFMVUVNSU46ICdhcmlhLXZhbHVlbWluJyxcbiAgQVJJQV9WQUxVRU1BWDogJ2FyaWEtdmFsdWVtYXgnLFxuICBBUklBX1ZBTFVFTk9XOiAnYXJpYS12YWx1ZW5vdycsXG4gIEFSSUFfRElTQUJMRUQ6ICdhcmlhLWRpc2FibGVkJyxcbiAgU1RFUF9EQVRBX0FUVFI6ICdkYXRhLXN0ZXAnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENTbGlkZXI6Y2hhbmdlJyxcbiAgSU5QVVRfRVZFTlQ6ICdNRENTbGlkZXI6aW5wdXQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBQQUdFX0ZBQ1RPUjogNCxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFNsaWRlci5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBTbGlkZXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NsaWRlckFkYXB0ZXIge1xuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNsYXNzTmFtZSBleGlzdHMgZm9yIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIGlmIGF0dHJpYnV0ZSBuYW1lIGV4aXN0cyBvbiB0aGUgc2xpZGVyIEVsZW1lbnQsXG4gICAqIG90aGVyd2lzZSByZXR1cm5zIG51bGxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGF0dHJpYnV0ZSBuYW1lIG9uIHNsaWRlciBFbGVtZW50IHRvIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGF0dHJpYnV0ZSBuYW1lIGZyb20gc2xpZGVyIEVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBmb3IgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEByZXR1cm4gez9DbGllbnRSZWN0fVxuICAgKi9cbiAgY29tcHV0ZUJvdW5kaW5nUmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhYiBpbmRleCBvZiB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VGFiSW5kZXgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHRodW1iIGNvbnRhaW5lciBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSBib2R5IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIGJvZHkgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIHdpbmRvdyByZXNpemUgZXZlbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgd2luZG93IHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgTURDU2xpZGVyOmlucHV0IGZyb20gdGhlIHJvb3RcbiAgICovXG4gIG5vdGlmeUlucHV0KCkge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgTURDU2xpZGVyOmNoYW5nZSBmcm9tIHRoZSByb290XG4gICAqL1xuICBub3RpZnlDaGFuZ2UoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIHRodW1iIGNvbnRhaW5lciBlbGVtZW50IHRvIHRoZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIHRyYWNrIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0VHJhY2tTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlubmVyIHRleHQgb2YgdGhlIHBpbiBtYXJrZXIgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIHNldE1hcmtlclZhbHVlKHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBwYXNzZWQgbnVtYmVyIG9mIHRyYWNrIG1hcmtlcnMgdG8gdGhlIHRyYWNrIG1hcmsgY29udGFpbmVyIGVsZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bU1hcmtlcnNcbiAgICovXG4gIGFwcGVuZFRyYWNrTWFya2VycyhudW1NYXJrZXJzKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0cmFjayBtYXJrZXJzIGZyb210IGhlIHRyYWNrIG1hcmsgY29udGFpbmVyIGVsZW1lbnRcbiAgICovXG4gIHJlbW92ZVRyYWNrTWFya2VycygpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgbGFzdCB0cmFjayBtYXJrZXIgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0TGFzdFRyYWNrTWFya2Vyc1N0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgaXMgUlRMLCBvdGhlcndpc2UgZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUlRMKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGVyQWRhcHRlcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICp5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1NsaWRlckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcblxuaW1wb3J0IHtnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IEtFWV9JRFMgPSB7XG4gIEFSUk9XX0xFRlQ6ICdBcnJvd0xlZnQnLFxuICBBUlJPV19SSUdIVDogJ0Fycm93UmlnaHQnLFxuICBBUlJPV19VUDogJ0Fycm93VXAnLFxuICBBUlJPV19ET1dOOiAnQXJyb3dEb3duJyxcbiAgSE9NRTogJ0hvbWUnLFxuICBFTkQ6ICdFbmQnLFxuICBQQUdFX1VQOiAnUGFnZVVwJyxcbiAgUEFHRV9ET1dOOiAnUGFnZURvd24nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBNT1ZFX0VWRU5UX01BUCA9IHtcbiAgJ21vdXNlZG93bic6ICdtb3VzZW1vdmUnLFxuICAndG91Y2hzdGFydCc6ICd0b3VjaG1vdmUnLFxuICAncG9pbnRlcmRvd24nOiAncG9pbnRlcm1vdmUnLFxufTtcblxuY29uc3QgRE9XTl9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdwb2ludGVyZG93bicsICd0b3VjaHN0YXJ0J107XG5jb25zdCBVUF9FVkVOVFMgPSBbJ21vdXNldXAnLCAncG9pbnRlcnVwJywgJ3RvdWNoZW5kJ107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1NsaWRlckFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENTbGlkZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2xpZGVyQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2xpZGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmd8bnVsbCAqLyBudWxsLFxuICAgICAgc2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiAvKiBDbGllbnRSZWN0ICovICh7XG4gICAgICAgIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgIH0pLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFRyYWNrU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiAoLyogdmFsdWU6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBhcHBlbmRUcmFja01hcmtlcnM6ICgvKiBudW1NYXJrZXJzOiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlVHJhY2tNYXJrZXJzOiAoKSA9PiB7fSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNSVEw6ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNRENTbGlkZXJGb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7P01EQ1NsaWRlckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICAvKiogQHByaXZhdGUgez9DbGllbnRSZWN0fSAqL1xuICAgIHRoaXMucmVjdF8gPSBudWxsO1xuICAgIC8vIFdlIHNldCB0aGlzIHRvIE5hTiBzaW5jZSB3ZSB3YW50IGl0IHRvIGJlIGEgbnVtYmVyLCBidXQgd2UgY2FuJ3QgdXNlICcwJyBvciAnLTEnXG4gICAgLy8gYmVjYXVzZSB0aG9zZSBjb3VsZCBiZSB2YWxpZCB0YWJpbmRpY2VzIHNldCBieSB0aGUgY2xpZW50IGNvZGUuXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IE5hTjtcbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmluVHJhbnNpdF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gZmFsc2U7XG4gICAgdGhpcy5oYXNUcmFja01hcmtlcl8gPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5taW5fID0gMDtcbiAgICB0aGlzLm1heF8gPSAxMDA7XG4gICAgdGhpcy5zdGVwXyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSAwO1xuICAgIHRoaXMuZGlzYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVVJRnJhbWVfID0gMDtcbiAgICB0aGlzLnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG93bl8oZXZ0KTtcbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5ZG93bl8oZXZ0KTtcbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUZvY3VzXygpO1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVCbHVyXygpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLklTX0RJU0NSRVRFKTtcbiAgICB0aGlzLmhhc1RyYWNrTWFya2VyXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IQVNfVFJBQ0tfTUFSS0VSKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgICAvLyBBdCBsYXN0IHN0ZXAsIHByb3ZpZGUgYSByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWUgdG8gZGlzY3JldGUgc2xpZGVyXG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5nZXRTdGVwKCkgPT0gMCkge1xuICAgICAgdGhpcy5zdGVwXyA9IDE7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIHNldHVwVHJhY2tNYXJrZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5oYXNUcmFja01hcmtlcl8mJiB0aGlzLmdldFN0ZXAoKSAhPSAwKSB7XG4gICAgICBjb25zdCBtaW4gPSB0aGlzLmdldE1pbigpO1xuICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRNYXgoKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFN0ZXAoKTtcbiAgICAgIGxldCBudW1NYXJrZXJzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuXG4gICAgICAvLyBJbiBjYXNlIGRpc3RhbmNlIGJldHdlZW4gbWF4ICYgbWluIGlzIGluZGl2aXNpYmxlIHRvIHN0ZXAsXG4gICAgICAvLyB3ZSBwbGFjZSB0aGUgc2Vjb25kYXJ5IHRvIGxhc3QgbWFya2VyIHByb3BvcnRpb25hbGx5IGF0IHdoZXJlIHRodW1iXG4gICAgICAvLyBjb3VsZCByZWFjaCBhbmQgcGxhY2UgdGhlIGxhc3QgbWFya2VyIGF0IG1heCB2YWx1ZVxuICAgICAgY29uc3QgaW5kaXZpc2libGUgPSBNYXRoLmNlaWwobnVtTWFya2VycykgIT09IG51bU1hcmtlcnM7XG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgbnVtTWFya2VycyA9IE1hdGguY2VpbChudW1NYXJrZXJzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVUcmFja01hcmtlcnMoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpO1xuXG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgbGFzdFN0ZXBSYXRpbyA9IChtYXggLSBudW1NYXJrZXJzICogc3RlcCkgLyBzdGVwICsgMTtcbiAgICAgICAgY29uc3QgZmxleCA9IGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAnZmxleCcpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5KGZsZXgsIFN0cmluZyhsYXN0U3RlcFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMucmVjdF8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCBmYWxzZSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRNYXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4XztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gbWF4ICovXG4gIHNldE1heChtYXgpIHtcbiAgICBpZiAobWF4IDwgdGhpcy5taW5fKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbWF4IHRvIGJlIGxlc3MgdGhhbiB0aGUgc2xpZGVyXFwncyBtaW5pbXVtIHZhbHVlJyk7XG4gICAgfVxuICAgIHRoaXMubWF4XyA9IG1heDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU1BWCwgU3RyaW5nKHRoaXMubWF4XykpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TWluKCkge1xuICAgIHJldHVybiB0aGlzLm1pbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IG1pbiAqL1xuICBzZXRNaW4obWluKSB7XG4gICAgaWYgKG1pbiA+IHRoaXMubWF4Xykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG1pbiB0byBiZSBncmVhdGVyIHRoYW4gdGhlIHNsaWRlclxcJ3MgbWF4aW11bSB2YWx1ZScpO1xuICAgIH1cbiAgICB0aGlzLm1pbl8gPSBtaW47XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVNSU4sIFN0cmluZyh0aGlzLm1pbl8pKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgKi9cbiAgc2V0U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0ZXAgY2Fubm90IGJlIHNldCB0byBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXyAmJiAodHlwZW9mKHN0ZXApICE9PSAnbnVtYmVyJyB8fCBzdGVwIDwgMSkpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBfID0gc3RlcDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGRpc2FibGVkO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuRElTQUJMRUQsIHRoaXMuZGlzYWJsZWRfKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkluZGV4KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX0RJU0FCTEVEKTtcbiAgICAgIGlmICghaXNOYU4odGhpcy5zYXZlZFRhYkluZGV4XykpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgU3RyaW5nKHRoaXMuc2F2ZWRUYWJJbmRleF8pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGludGVyYWN0aW5nIHdpdGggdGhlIHNsaWRlclxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEb3duXyhldnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZlbnRGb2N1c1N0YXRlXyA9IHRydWU7XG4gICAgdGhpcy5zZXRJblRyYW5zaXRfKCF0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfKTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmVfKHRydWUpO1xuXG4gICAgY29uc3QgbW92ZUhhbmRsZXIgPSAoZXZ0KSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVfKGV2dCk7XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IHVwSGFuZGxlciBpcyBbZGVdcmVnaXN0ZXJlZCBvbiBBTEwgcG90ZW50aWFsIHBvaW50ZXItcmVsYXRlZCByZWxlYXNlIGV2ZW50IHR5cGVzLCBzaW5jZSBzb21lIGJyb3dzZXJzXG4gICAgLy8gZG8gbm90IGFsd2F5cyBmaXJlIHRoZXNlIGNvbnNpc3RlbnRseSBpbiBwYWlycy5cbiAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2lzc3Vlcy8xMTkyKVxuICAgIGNvbnN0IHVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVXBfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgICAgVVBfRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdXBIYW5kbGVyKSk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgIFVQX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB1cEhhbmRsZXIpKTtcbiAgICB0aGlzLnNldFZhbHVlRnJvbUV2dF8oZXZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1vdmVfKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0VmFsdWVGcm9tRXZ0XyhldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2xpZGVyIGVuZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVVwXygpIHtcbiAgICB0aGlzLnNldEFjdGl2ZV8oZmFsc2UpO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFnZVggb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFnZVhfKGV2dCkge1xuICAgIGlmIChldnQudGFyZ2V0VG91Y2hlcyAmJiBldnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZXZ0LnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgfVxuICAgIHJldHVybiBldnQucGFnZVg7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2xpZGVyIHZhbHVlIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VmFsdWVGcm9tRXZ0XyhldnQpIHtcbiAgICBjb25zdCBwYWdlWCA9IHRoaXMuZ2V0UGFnZVhfKGV2dCk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZUZyb21QYWdlWF8ocGFnZVgpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbmV3IHZhbHVlIGZyb20gdGhlIHBhZ2VYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb21wdXRlVmFsdWVGcm9tUGFnZVhfKHBhZ2VYKSB7XG4gICAgY29uc3Qge21heF86IG1heCwgbWluXzogbWlufSA9IHRoaXM7XG4gICAgY29uc3QgeFBvcyA9IHBhZ2VYIC0gdGhpcy5yZWN0Xy5sZWZ0O1xuICAgIGxldCBwY3RDb21wbGV0ZSA9IHhQb3MgLyB0aGlzLnJlY3RfLndpZHRoO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzUlRMKCkpIHtcbiAgICAgIHBjdENvbXBsZXRlID0gMSAtIHBjdENvbXBsZXRlO1xuICAgIH1cbiAgICAvLyBGaXQgdGhlIHBlcmNlbnRhZ2UgY29tcGxldGUgYmV0d2VlbiB0aGUgcmFuZ2UgW21pbixtYXhdXG4gICAgLy8gYnkgcmVtYXBwaW5nIGZyb20gWzAsIDFdIHRvIFttaW4sIG1pbisobWF4LW1pbildLlxuICAgIHJldHVybiBtaW4gKyBwY3RDb21wbGV0ZSAqIChtYXggLSBtaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudHNcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bl8oZXZ0KSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkXyhldnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvcktleUlkXyhrZXlJZCk7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcGFnZSBmcm9tIHNjcm9sbGluZyBkdWUgdG8ga2V5IHByZXNzZXMgdGhhdCB3b3VsZCBub3JtYWxseSBzY3JvbGwgdGhlIHBhZ2VcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBrYmRFdnRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0S2V5SWRfKGtiZEV2dCkge1xuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX0xFRlQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM3KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19MRUZUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19SSUdIVCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1JJR0hUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1VQO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19ET1dOIHx8IGtiZEV2dC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfRE9XTjtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuSE9NRSB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzYpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkhPTUU7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkVORCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzUpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkVORDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuUEFHRV9VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfVVA7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLlBBR0VfRE9XTiB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzQpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfRE9XTjtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHZhbHVlIGdpdmVuIGEga2V5Ym9hcmQga2V5IElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRWYWx1ZUZvcktleUlkXyhrZXlJZCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgc3RlcF86IHN0ZXB9ID0gdGhpcztcbiAgICBsZXQgZGVsdGEgPSBzdGVwIHx8IChtYXggLSBtaW4pIC8gMTAwO1xuICAgIGNvbnN0IHZhbHVlTmVlZHNUb0JlRmxpcHBlZCA9IHRoaXMuYWRhcHRlcl8uaXNSVEwoKSAmJiAoXG4gICAgICBrZXlJZCA9PT0gS0VZX0lEUy5BUlJPV19MRUZUIHx8IGtleUlkID09PSBLRVlfSURTLkFSUk9XX1JJR0hUXG4gICAgKTtcbiAgICBpZiAodmFsdWVOZWVkc1RvQmVGbGlwcGVkKSB7XG4gICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleUlkKSB7XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0xFRlQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YTtcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfUklHSFQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGE7XG4gICAgY2FzZSBLRVlfSURTLkhPTUU6XG4gICAgICByZXR1cm4gdGhpcy5taW5fO1xuICAgIGNhc2UgS0VZX0lEUy5FTkQ6XG4gICAgICByZXR1cm4gdGhpcy5tYXhfO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGEgKiBudW1iZXJzLlBBR0VfRkFDVE9SO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YSAqIG51bWJlcnMuUEFHRV9GQUNUT1I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXNfKCkge1xuICAgIGlmICh0aGlzLnByZXZlbnRGb2N1c1N0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgaGFuZGxlQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmlyZUlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlXG4gICAqL1xuICBzZXRWYWx1ZV8odmFsdWUsIHNob3VsZEZpcmVJbnB1dCwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy52YWx1ZV8gJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge21pbl86IG1pbiwgbWF4XzogbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgdmFsdWVTZXRUb0JvdW5kYXJ5ID0gdmFsdWUgPT09IG1pbiB8fCB2YWx1ZSA9PT0gbWF4O1xuICAgIGlmICh0aGlzLnN0ZXBfICYmICF2YWx1ZVNldFRvQm91bmRhcnkpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5xdWFudGl6ZV8odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgIHZhbHVlID0gbWluO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cbiAgICB0aGlzLnZhbHVlXyA9IHZhbHVlO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU5PVywgU3RyaW5nKHRoaXMudmFsdWVfKSk7XG4gICAgdGhpcy51cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKTtcblxuICAgIGlmIChzaG91bGRGaXJlSW5wdXQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SW5wdXQoKTtcbiAgICAgIGlmICh0aGlzLmlzRGlzY3JldGVfKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TWFya2VyVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBxdWFudGl6ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHF1YW50aXplXyh2YWx1ZSkge1xuICAgIGNvbnN0IG51bVN0ZXBzID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuc3RlcF8pO1xuICAgIGNvbnN0IHF1YW50aXplZFZhbCA9IG51bVN0ZXBzICogdGhpcy5zdGVwXztcbiAgICByZXR1cm4gcXVhbnRpemVkVmFsO1xuICB9XG5cbiAgdXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgdmFsdWVfOiB2YWx1ZX0gPSB0aGlzO1xuICAgIGNvbnN0IHBjdENvbXBsZXRlID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIGxldCB0cmFuc2xhdGVQeCA9IHBjdENvbXBsZXRlICogdGhpcy5yZWN0Xy53aWR0aDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1JUTCgpKSB7XG4gICAgICB0cmFuc2xhdGVQeCA9IHRoaXMucmVjdF8ud2lkdGggLSB0cmFuc2xhdGVQeDtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wID0gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3csICd0cmFuc2Zvcm0nKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uZW5kRXZ0TmFtZSA9IGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpO1xuXG4gICAgaWYgKHRoaXMuaW5UcmFuc2l0Xykge1xuICAgICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldEluVHJhbnNpdF8oZmFsc2UpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0cmFuc2l0aW9uZW5kRXZ0TmFtZSwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHJhbnNpdGlvbmVuZEV2dE5hbWUsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVVSUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBOT1RFKHRyYXZpc2thdWZtYW4pOiBJdCB3b3VsZCBiZSBuaWNlIHRvIHVzZSBjYWxjKCkgaGVyZSxcbiAgICAgIC8vIGJ1dCBJRSBjYW5ub3QgaGFuZGxlIGNhbGNzIGluIHRyYW5zZm9ybXMgY29ycmVjdGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dvby5nbC9OQzJpdGtcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHRoZSAtNTAlIG9mZnNldCBpcyB1c2VkIHRvIGNlbnRlciB0aGUgc2xpZGVyIHRodW1iLlxuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVQeH1weCkgdHJhbnNsYXRlWCgtNTAlKWApO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFja1N0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHNjYWxlWCgke3BjdENvbXBsZXRlfSlgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZVxuICAgKi9cbiAgc2V0QWN0aXZlXyhhY3RpdmUpIHtcbiAgICB0aGlzLmFjdGl2ZV8gPSBhY3RpdmU7XG4gICAgdGhpcy50b2dnbGVDbGFzc18oY3NzQ2xhc3Nlcy5BQ1RJVkUsIHRoaXMuYWN0aXZlXyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgaW5UcmFuc2l0IHN0YXRlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBpblRyYW5zaXRcbiAgICovXG4gIHNldEluVHJhbnNpdF8oaW5UcmFuc2l0KSB7XG4gICAgdGhpcy5pblRyYW5zaXRfID0gaW5UcmFuc2l0O1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuSU5fVFJBTlNJVCwgdGhpcy5pblRyYW5zaXRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IGFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIGJhc2VkIG9uIHNob3VsZEJlUHJlc2VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQmVQcmVzZW50XG4gICAqL1xuICB0b2dnbGVDbGFzc18oY2xhc3NOYW1lLCBzaG91bGRCZVByZXNlbnQpIHtcbiAgICBpZiAoc2hvdWxkQmVQcmVzZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGVyRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cInNsaWRlclwiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFjay1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFja1wiIDpzdHlsZT1cInRyYWNrU3R5bGVzXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2stbWFya2VyLWNvbnRhaW5lclwiIHYtaWY9XCJoYXNNYXJrZXJzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFjay1tYXJrZXJcIiBcbiAgICAgICAgICB2LWZvcj1cIm1hcmtlck51bSBpbiBudW1NYXJrZXJzXCJcbiAgICAgICAgICA6a2V5PVwibWFya2VyTnVtXCJcbiAgICAgICAgICA6c3R5bGU9XCIobWFya2VyTnVtID09IG51bU1hcmtlcnMpID8gbGFzdFRyYWNrTWFya2Vyc1N0eWxlcyA6IHt9XCJcbiAgICAgICAgICA+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IHJlZj1cInRodW1iQ29udGFpbmVyXCIgOnN0eWxlPVwidGh1bWJTdHlsZXNcIiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3BpblwiIHYtaWY9XCJpc0Rpc2NyZXRlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlclwiPnt7bWFya2VyVmFsdWV9fTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPHN2ZyBjbGFzcz1cIm1kYy1zbGlkZXJfX3RodW1iXCIgd2lkdGg9XCIyMVwiIGhlaWdodD1cIjIxXCI+XG4gICAgICAgIDxjaXJjbGUgY3g9XCIxMC41XCIgY3k9XCIxMC41XCIgcj1cIjcuODc1XCI+PC9jaXJjbGU+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19mb2N1cy1yaW5nXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENTbGlkZXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zbGlkZXIvZm91bmRhdGlvbidcbmltcG9ydCB7RGlzcGF0Y2hGb2N1c01peGlufSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc2xpZGVyJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgIG1pbjogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgbWF4OiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDEwMCB9LFxuICAgIHN0ZXA6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMCB9LFxuICAgIGRpc3BsYXlNYXJrZXJzOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxheW91dE9uOiBTdHJpbmcsXG4gICAgbGF5b3V0T25Tb3VyY2U6IHt0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZX0sXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtc2xpZGVyLS1kaXNjcmV0ZSc6ICEhdGhpcy5zdGVwLFxuICAgICAgICAnbWRjLXNsaWRlci0tZGlzcGxheS1tYXJrZXJzJzogdGhpcy5kaXNwbGF5TWFya2Vyc1xuICAgICAgfSxcbiAgICAgIHRyYWNrU3R5bGVzOiB7fSxcbiAgICAgIGxhc3RUcmFja01hcmtlcnNTdHlsZXM6IHt9LFxuICAgICAgdGh1bWJTdHlsZXM6IHt9LFxuICAgICAgbWFya2VyVmFsdWU6ICcnLFxuICAgICAgbnVtTWFya2VyczogMFxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc0Rpc2NyZXRlICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc3RlcFxuICAgIH0sXG4gICAgaGFzTWFya2VycyAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXAgJiYgdGhpcy5kaXNwbGF5TWFya2VycyAmJiB0aGlzLm51bU1hcmtlcnNcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUgKCkge1xuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpICE9PSBOdW1iZXIodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBtaW4gKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldE1pbihOdW1iZXIodGhpcy5taW4pKVxuICAgIH0sXG4gICAgbWF4ICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICB9LFxuICAgIHN0ZXAgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpXG4gICAgfSxcbiAgICBkaXNhYmxlZCAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXQgKCkge1xuICAgICAgdGhpcy4kbmV4dFRpY2soICgpID0+IHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5sYXlvdXQoKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbGlkZXJGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgZ2V0QXR0cmlidXRlOiAobmFtZSkgPT4gdGhpcy4kZWwuZ2V0QXR0cmlidXRlKG5hbWUpLFxuICAgICAgc2V0QXR0cmlidXRlOiAobmFtZSwgdmFsdWUpID0+IHRoaXMuJGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSksXG4gICAgICByZW1vdmVBdHRyaWJ1dGU6IChuYW1lKSA9PiB0aGlzLiRlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSksXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiB0aGlzLiRlbC50YWJJbmRleCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy50aHVtYkNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgICB9LFxuICAgICAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy50aHVtYlN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRUcmFja1N0eWxlUHJvcGVydHk6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnRyYWNrU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5tYXJrZXJWYWx1ZSA9IHZhbHVlXG4gICAgICB9LFxuICAgICAgYXBwZW5kVHJhY2tNYXJrZXJzOiAobnVtTWFya2VycykgPT4ge1xuICAgICAgICB0aGlzLm51bU1hcmtlcnMgPSBudW1NYXJrZXJzXG4gICAgICB9LFxuICAgICAgcmVtb3ZlVHJhY2tNYXJrZXJzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMubnVtTWFya2VycyA9IDBcbiAgICAgIH0sXG4gICAgICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMubGFzdFRyYWNrTWFya2Vyc1N0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBpc1JUTDogKCkgPT4gZmFsc2VcbiAgICB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKE51bWJlcih0aGlzLnZhbHVlKSlcbiAgICBpZiAodGhpcy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0dXBUcmFja01hcmtlcigpXG4gICAgfVxuICAgIFxuICAgIHRoaXMuJHJvb3QuJG9uKCdtZGM6bGF5b3V0JywgdGhpcy5sYXlvdXQpXG5cbiAgICBpZiAodGhpcy5sYXlvdXRPbikge1xuICAgICAgbGV0IHNvdXJjZSA9IHRoaXMubGF5b3V0T25Tb3VyY2UgfHwgdGhpcy4kcm9vdFxuICAgICAgc291cmNlLiRvbih0aGlzLmxheW91dE9uLCB0aGlzLmxheW91dClcbiAgICB9XG4gICAgXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU2xpZGVyIGZyb20gJy4vbWRjLXNsaWRlci52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1NsaWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU2xpZGVyXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXNuYWNrYmFyJyxcbiAgVEVYVDogJ21kYy1zbmFja2Jhcl9fdGV4dCcsXG4gIEFDVElPTl9XUkFQUEVSOiAnbWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlcicsXG4gIEFDVElPTl9CVVRUT046ICdtZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBBQ1RJVkU6ICdtZGMtc25hY2tiYXItLWFjdGl2ZScsXG4gIE1VTFRJTElORTogJ21kYy1zbmFja2Jhci0tbXVsdGlsaW5lJyxcbiAgQUNUSU9OX09OX0JPVFRPTTogJ21kYy1zbmFja2Jhci0tYWN0aW9uLW9uLWJvdHRvbScsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgVEVYVF9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX3RleHQnLFxuICBBQ1RJT05fV1JBUFBFUl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi13cmFwcGVyJyxcbiAgQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBTSE9XX0VWRU5UOiAnTURDU25hY2tiYXI6c2hvdycsXG4gIEhJREVfRVZFTlQ6ICdNRENTbmFja2JhcjpoaWRlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xuICBNRVNTQUdFX1RJTUVPVVQ6IDI3NTAsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDU25hY2tiYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRBcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25UZXh0OiAoLyogYWN0aW9uVGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1lc3NhZ2VUZXh0OiAoLyogbWVzc2FnZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIHZpc2liaWxpdHlJc0hpZGRlbjogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5U2hvdzogKCkgPT4ge30sXG4gICAgICBub3RpZnlIaWRlOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVfO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU25hY2tiYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFjdGlvbldhc0NsaWNrZWRfID0gZmFsc2U7XG4gICAgdGhpcy5kaXNtaXNzT25BY3Rpb25fID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSBmYWxzZTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgdGhpcy5zbmFja2JhckRhdGFfID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlXyA9IFtdO1xuICAgIHRoaXMuYWN0aW9uQ2xpY2tIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aW9uV2FzQ2xpY2tlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5pbnZva2VBY3Rpb25fKCk7XG4gICAgfTtcbiAgICB0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5hZGFwdGVyXy52aXNpYmlsaXR5SXNIaWRkZW4oKSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC50eXBlID09ICd0b3VjaHN0YXJ0JyB8fCBldnQudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKGV2dCk7XG5cbiAgICAgIGlmIChldnQudHlwZSA9PSAnZm9jdXMnKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICAgIHRoaXMuc25hY2tiYXJIYXNGb2N1c18gPSBmYWxzZTtcbiAgICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlcih0aGlzLmFjdGlvbkNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXJpYUhpZGRlbigpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QWN0aW9uQXJpYUhpZGRlbigpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIodGhpcy5hY3Rpb25DbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyKHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcih0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNtaXNzZXNPbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNtaXNzT25BY3Rpb25fO1xuICB9XG5cbiAgc2V0RGlzbWlzc09uQWN0aW9uKGRpc21pc3NPbkFjdGlvbikge1xuICAgIHRoaXMuZGlzbWlzc09uQWN0aW9uXyA9ICEhZGlzbWlzc09uQWN0aW9uO1xuICB9XG5cbiAgc2hvdyhkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdQbGVhc2UgcHJvdmlkZSBhIGRhdGEgb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBtZXNzYWdlIHRvIGRpc3BsYXkuJyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5tZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmFjdGlvbkhhbmRsZXIgJiYgIWRhdGEuYWN0aW9uVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhY3Rpb24gdGV4dCB3aXRoIHRoZSBoYW5kbGVyLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMucXVldWVfLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgIHRoaXMuc25hY2tiYXJEYXRhXyA9IGRhdGE7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyKHRoaXMudmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcih0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lc3NhZ2VUZXh0KHRoaXMuc25hY2tiYXJEYXRhXy5tZXNzYWdlKTtcblxuICAgIGlmICh0aGlzLnNuYWNrYmFyRGF0YV8ubXVsdGlsaW5lKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1VTFRJTElORSk7XG4gICAgICBpZiAodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvbk9uQm90dG9tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvblRleHQpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyO1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKHRydWUpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IG51bGw7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVfID0gdHJ1ZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnNldEFyaWFIaWRkZW4oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNob3coKTtcblxuICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gIH1cblxuICBoYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKCkge1xuICAgIGNvbnN0IGhpamFja0ZvY3VzID1cbiAgICAgIHRoaXMuZmlyc3RGb2N1c18gJiYgIXRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXztcblxuICAgIGlmIChoaWphY2tGb2N1cykge1xuICAgICAgdGhpcy5zZXRGb2N1c09uQWN0aW9uXygpO1xuICAgIH1cblxuICAgIHRoaXMuZmlyc3RGb2N1c18gPSBmYWxzZTtcbiAgfVxuXG4gIHNldEZvY3VzT25BY3Rpb25fKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Rm9jdXMoKTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gZmFsc2U7XG4gIH1cblxuICBpbnZva2VBY3Rpb25fKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aW9uSGFuZGxlcl8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFjdGlvbkhhbmRsZXJfKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmRpc21pc3NPbkFjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwXygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFudXBfKCkge1xuICAgIGNvbnN0IGFsbG93RGlzbWlzc2FsID0gIXRoaXMuc25hY2tiYXJIYXNGb2N1c18gfHwgdGhpcy5hY3Rpb25XYXNDbGlja2VkXztcblxuICAgIGlmIChhbGxvd0Rpc21pc3NhbCkge1xuICAgICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSVZFKTtcblxuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1VTFRJTElORSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyh0cnVlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBcmlhSGlkZGVuKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SGlkZSgpO1xuICAgICAgICB0aGlzLnNob3dOZXh0XygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHNob3dOZXh0XygpIHtcbiAgICBpZiAoIXRoaXMucXVldWVfLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNob3codGhpcy5xdWV1ZV8uc2hpZnQoKSk7XG4gIH1cblxuICBzZXRBY3Rpb25IaWRkZW5fKGlzSGlkZGVuKSB7XG4gICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy51bnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbjxkaXYgcmVmPVwicm9vdFwiIGNsYXNzPVwibWRjLXNuYWNrYmFyXCIgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgYXJpYS1hdG9taWM9XCJ0cnVlXCIgOmFyaWEtaGlkZGVuPVwiaGlkZGVuXCI+XG4gIDxkaXYgY2xhc3M9XCJtZGMtc25hY2tiYXJfX3RleHRcIj57e21lc3NhZ2V9fTwvZGl2PlxuICA8ZGl2IGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlclwiPlxuICAgIDxidXR0b24gcmVmPVwiYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uXCJcbiAgICAgICAgOmFyaWEtaGlkZGVuPVwiYWN0aW9uSGlkZGVuXCI+e3thY3Rpb25UZXh0fX08L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU25hY2tiYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zbmFja2Jhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0Q29ycmVjdEV2ZW50TmFtZSB9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbmFja2JhcicsXG4gIHByb3BzOiB7XG4gICAgJ2FsaWduLXN0YXJ0JzogQm9vbGVhbixcbiAgICAnZXZlbnQnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0ICgpIHsgcmV0dXJuICdzaG93LXNuYWNrYmFyJyB9XG4gICAgfSxcbiAgICAnZXZlbnQtc291cmNlJzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdCAoKSB7IHJldHVybiB0aGlzLiRyb290IH1cbiAgICB9LFxuICAgICdkaXNtaXNzZXMtb24tYWN0aW9uJzoge3R5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWV9XG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtc25hY2tiYXItLWFsaWduLXN0YXJ0JzogdGhpcy5hbGlnblN0YXJ0XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogJycsXG4gICAgICBhY3Rpb25UZXh0OiAnJyxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBhY3Rpb25IaWRkZW46IGZhbHNlLFxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNob3cgKGRhdGEpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zaG93KGRhdGEpXG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDU25hY2tiYXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBzZXRBcmlhSGlkZGVuOiAoKSA9PiB0aGlzLmhpZGRlbiA9IHRydWUsXG4gICAgICB1bnNldEFyaWFIaWRkZW46ICgpID0+IHRoaXMuaGlkZGVuID0gZmFsc2UsXG4gICAgICBzZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiB0aGlzLmFjdGlvbkhpZGRlbiA9IHRydWUsXG4gICAgICB1bnNldEFjdGlvbkFyaWFIaWRkZW46ICgpID0+IHRoaXMuYWN0aW9uSGlkZGVuID0gZmFsc2UsXG4gICAgICBzZXRBY3Rpb25UZXh0OiAodGV4dCkgPT4geyB0aGlzLmFjdGlvblRleHQgPSB0ZXh0IH0sXG4gICAgICBzZXRNZXNzYWdlVGV4dDogKHRleHQpID0+IHsgdGhpcy5tZXNzYWdlID0gdGV4dCAgfSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5mb2N1cygpLFxuICAgICAgdmlzaWJpbGl0eUlzSGlkZGVuOiAoKSA9PiBkb2N1bWVudC5oaWRkZW4sXG4gICAgICByZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlciwgdHJ1ZSksXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcjogKGhhbmRsZXIpID0+IHRoaXMuJHJlZnMuYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVyLCB0cnVlKSxcbiAgICAgIHJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6IChoYW5kbGVyKSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6IChoYW5kbGVyKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlciksXG4gICAgICByZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCB0cnVlKSxcbiAgICAgIGRlcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgdHJ1ZSksXG4gICAgICByZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlcjogKGhhbmRsZXIpID0+IHRoaXMuJHJlZnMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyQWN0aW9uQ2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy4kcmVmcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5hZGRFdmVudExpc3RlbmVyKGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICd0cmFuc2l0aW9uZW5kJyksIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgbm90aWZ5U2hvdzogKCkgPT4gdGhpcy4kZW1pdCgnc2hvdycpLFxuICAgICAgbm90aWZ5SGlkZTogKCkgPT4gdGhpcy4kZW1pdCgnaGlkZScpLFxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIGlmICh0aGlzLmV2ZW50KSB7XG4gICAgICB0aGlzLmV2ZW50U291cmNlLiRvbih0aGlzLmV2ZW50LCAoZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2hvdyhkYXRhKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc21pc3NPbkFjdGlvbih0aGlzLmRpc21pc3Nlc09uQWN0aW9uKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NuYWNrYmFyIGZyb20gJy4vbWRjLXNuYWNrYmFyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjU25hY2tiYXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1NuYWNrYmFyXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLXN3aXRjaC13cmFwcGVyXCIgXG4gICAgOmNsYXNzPVwie1xuICAgICAgICAnbWRjLWZvcm0tZmllbGQnOiB0aGlzLmhhc0xhYmVsLFxuICAgICAgICAnbWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZCc6IHRoaXMuaGFzTGFiZWwgJiYgdGhpcy5hbGlnbkVuZFxuICAgICAgfVwiID5cblxuICAgIDxkaXYgY2xhc3M9XCJtZGMtc3dpdGNoXCIgXG4gICAgICA6Y2xhc3M9XCJ7J21kYy1zd2l0Y2gtLWRpc2FibGVkJzogZGlzYWJsZWQgfVwiPlxuICAgICAgPGlucHV0IHJlZj1cImNvbnRyb2xcIiB0eXBlPVwiY2hlY2tib3hcIiBcbiAgICAgICAgOm5hbWU9XCJuYW1lXCIgOmlkPVwiX3VpZFwiIFxuICAgICAgICBjbGFzcz1cIm1kYy1zd2l0Y2hfX25hdGl2ZS1jb250cm9sXCIgXG4gICAgICAgIDpjaGVja2VkPVwiY2hlY2tlZFwiIFxuICAgICAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgICAgIEBjaGFuZ2U9XCJvbkNoYW5nZWRcIiAvPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXN3aXRjaF9fYmFja2dyb3VuZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLXN3aXRjaF9fa25vYlwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxsYWJlbCA6Zm9yPVwiX3VpZFwiIHYtaWY9XCJoYXNMYWJlbFwiXG4gICAgICBjbGFzcz1cIm1kYy1zd2l0Y2gtbGFiZWxcIj5cbiAgICAgIDxzbG90Pnt7bGFiZWx9fTwvc2xvdD5cbiAgICA8L2xhYmVsPlxuXG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hGb2N1c01peGlufSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc3dpdGNoJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgJ2NoZWNrZWQnOiBCb29sZWFuLFxuICAgICdsYWJlbCc6IFN0cmluZyxcbiAgICAnYWxpZ25FbmQnOiBCb29sZWFuLFxuICAgICdkaXNhYmxlZCc6IEJvb2xlYW4sXG4gICAgJ3ZhbHVlJzogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQgKCkgeyByZXR1cm4gJ29uJyB9IH0sXG4gICAgJ25hbWUnOiBTdHJpbmdcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXNMYWJlbCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbCB8fCB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DaGFuZ2VkIChldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQudGFyZ2V0LmNoZWNrZWQpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNTd2l0Y2ggZnJvbSAnLi9tZGMtc3dpdGNoLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjU3dpdGNoXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTd2l0Y2hcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXRhYi0tYWN0aXZlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBTRUxFQ1RFRF9FVkVOVDogJ01EQ1RhYjpzZWxlY3RlZCcsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRMZWZ0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmNvbXB1dGVkV2lkdGhfID0gMDtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSAwO1xuICAgIHRoaXMuaXNBY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgZ2V0Q29tcHV0ZWRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZFdpZHRoXztcbiAgfVxuXG4gIGdldENvbXB1dGVkTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZExlZnRfO1xuICB9XG5cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBY3RpdmVfO1xuICB9XG5cbiAgc2V0QWN0aXZlKGlzQWN0aXZlKSB7XG4gICAgdGhpcy5pc0FjdGl2ZV8gPSBpc0FjdGl2ZTtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB9XG4gIH1cblxuICBwcmV2ZW50c0RlZmF1bHRPbkNsaWNrKCkge1xuICAgIHJldHVybiB0aGlzLnByZXZlbnREZWZhdWx0T25DbGlja187XG4gIH1cblxuICBzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKSB7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gcHJldmVudERlZmF1bHRPbkNsaWNrO1xuICB9XG5cbiAgbWVhc3VyZVNlbGYoKSB7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldExlZnQoKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBjbGFzcz1cIm1kYy10YWJcIiBcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIlxyXG4gICAgOmxpbms9XCJsaW5rXCIgXHJcbiAgICBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCI+XHJcblxyXG4gICAgPGkgcmVmPVwiaWNvblwiIHYtaWY9XCIhIWhhc0ljb25cIlxyXG4gICAgICB0YWJpbmRleD1cIjBcIiBcclxuICAgICAgY2xhc3M9XCJtZGMtdGFiX19pY29uXCIgIFxyXG4gICAgICA6Y2xhc3M9XCJoYXNJY29uLmNsYXNzZXNcIj5cclxuICAgICAgPHNsb3QgbmFtZT1cImljb25cIj57eyBoYXNJY29uLmNvbnRlbnQgfX08L3Nsb3Q+XHJcbiAgICA8L2k+XHJcblxyXG4gICAgPHNwYW4gOmNsYXNzPVwieydtZGMtdGFiX19pY29uLXRleHQnOiAhIWhhc0ljb259XCIgdi1pZj1cImhhc1RleHRcIj5cclxuICAgICAgPHNsb3Q+PC9zbG90PiAgXHJcbiAgICA8L3NwYW4+XHJcblxyXG4gIDwvY3VzdG9tLWxpbms+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgTURDVGFiRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGFicy90YWIvZm91bmRhdGlvbidcclxuaW1wb3J0IHtDdXN0b21MaW5rTWl4aW4sIERpc3BhdGNoRXZlbnRNaXhpbiwgZW1pdEN1c3RvbUV2ZW50LCBleHRyYWN0SWNvblByb3AgfSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLXRhYicsXHJcbiAgbWl4aW5zOiBbQ3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBhY3RpdmU6IEJvb2xlYW4sXHJcbiAgICBpY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBoYXNJY29uICgpIHtcclxuICAgICAgaWYgKHRoaXMuaWNvbiB8fCB0aGlzLiRzbG90cy5pY29uKSB7XHJcbiAgICAgICAgdGhpcy5pY29uID8gZXh0cmFjdEljb25Qcm9wKHRoaXMuaWNvbikgOiB7fVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuICAgIGhhc1RleHQgKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLiRzbG90cy5kZWZhdWx0XHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBnZXRDb21wdXRlZFdpZHRoICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5nZXRDb21wdXRlZFdpZHRoKClcclxuICAgIH0sXHJcbiAgICBnZXRDb21wdXRlZExlZnQgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmdldENvbXB1dGVkTGVmdCgpXHJcbiAgICB9LFxyXG4gICAgaXNBY3RpdmUgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmlzQWN0aXZlKClcclxuICAgIH0sXHJcbiAgICBzZXRBY3RpdmUgKGlzQWN0aXZlKSB7XHJcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRBY3RpdmUoaXNBY3RpdmUpXHJcbiAgICB9LFxyXG4gICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGljayAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24ucHJldmVudHNEZWZhdWx0T25DbGljaygpXHJcbiAgICB9LFxyXG4gICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrIChwcmV2ZW50RGVmYXVsdE9uQ2xpY2spIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFByZXZlbnREZWZhdWx0T25DbGljayhwcmV2ZW50RGVmYXVsdE9uQ2xpY2spXHJcbiAgICB9LFxyXG4gICAgbWVhc3VyZVNlbGYgKCkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24ubWVhc3VyZVNlbGYoKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCAoKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGFiRm91bmRhdGlvbih7XHJcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PlxyXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXHJcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PlxyXG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXHJcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cclxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxyXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cclxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxyXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5vZmZzZXRXaWR0aFxyXG4gICAgICB9LFxyXG4gICAgICBnZXRPZmZzZXRMZWZ0OiAoKSA9PlxyXG4gICAgICAgIHRoaXMuJGVsLm9mZnNldExlZnQsXHJcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7XHJcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KHRoaXMuJGVsLFxyXG4gICAgICAgICAgTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULCB7dGFiOiB0aGlzfSwgdHJ1ZSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcclxuICAgIHRoaXMuc2V0QWN0aXZlKHRoaXMuYWN0aXZlKVxyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95ICgpIHtcclxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcclxuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFVQR1JBREVEOiAnbWRjLXRhYi1iYXItdXBncmFkZWQnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRBQl9TRUxFQ1RPUjogJy5tZGMtdGFiJyxcbiAgSU5ESUNBVE9SX1NFTEVDVE9SOiAnLm1kYy10YWItYmFyX19pbmRpY2F0b3InLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENUYWJCYXI6Y2hhbmdlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7Z2V0Q29ycmVjdFByb3BlcnR5TmFtZX0gZnJvbSAnQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleCc7XG5cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENUYWJCYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBiaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50OiAoKSA9PiB7fSxcbiAgICAgIHVuYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBzZXRTdHlsZUZvckluZGljYXRvcjogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldE9mZnNldFdpZHRoRm9ySW5kaWNhdG9yOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeUNoYW5nZTogKC8qIGV2dERhdGE6IHthY3RpdmVUYWJJbmRleDogbnVtYmVyfSAqLykgPT4ge30sXG4gICAgICBnZXROdW1iZXJPZlRhYnM6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgaXNUYWJBY3RpdmVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHNldFRhYkFjdGl2ZUF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyLCBpc0FjdGl2ZTogdHJ1ZSAqLykgPT4ge30sXG4gICAgICBpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrRm9yVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2tGb3JUYWJBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciwgcHJldmVudERlZmF1bHRPbkNsaWNrOiBib29sZWFuICovKSA9PiB7fSxcbiAgICAgIG1lYXN1cmVUYWJBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBnZXRDb21wdXRlZFdpZHRoRm9yVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIG51bWJlciAqLyAwLFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJCYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmlzSW5kaWNhdG9yU2hvd25fID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IDA7XG4gICAgdGhpcy5jb21wdXRlZExlZnRfID0gMDtcbiAgICB0aGlzLmFjdGl2ZVRhYkluZGV4XyA9IDA7XG4gICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8uYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudCgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIGNvbnN0IGFjdGl2ZVRhYkluZGV4ID0gdGhpcy5maW5kQWN0aXZlVGFiSW5kZXhfKCk7XG4gICAgaWYgKGFjdGl2ZVRhYkluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFiSW5kZXhfID0gYWN0aXZlVGFiSW5kZXg7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0KCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy51bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG5cbiAgbGF5b3V0SW50ZXJuYWxfKCkge1xuICAgIHRoaXMuZm9yRWFjaFRhYkluZGV4XygoaW5kZXgpID0+IHRoaXMuYWRhcHRlcl8ubWVhc3VyZVRhYkF0SW5kZXgoaW5kZXgpKTtcbiAgICB0aGlzLmNvbXB1dGVkV2lkdGhfID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aCgpO1xuICAgIHRoaXMubGF5b3V0SW5kaWNhdG9yXygpO1xuICB9XG5cbiAgbGF5b3V0SW5kaWNhdG9yXygpIHtcbiAgICBjb25zdCBpc0luZGljYXRvckZpcnN0UmVuZGVyID0gIXRoaXMuaXNJbmRpY2F0b3JTaG93bl87XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBpbmRpY2F0b3IgYXBwZWFycyBpbiB0aGUgcmlnaHQgcG9zaXRpb24gaW1tZWRpYXRlbHkgZm9yIGNvcnJlY3QgZmlyc3QgcmVuZGVyLlxuICAgIGlmIChpc0luZGljYXRvckZpcnN0UmVuZGVyKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9ySW5kaWNhdG9yKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2xhdGVBbXRGb3JBY3RpdmVUYWJMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZExlZnRGb3JUYWJBdEluZGV4KHRoaXMuYWN0aXZlVGFiSW5kZXhfKTtcbiAgICBjb25zdCBzY2FsZUFtdEZvckFjdGl2ZVRhYldpZHRoID1cbiAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXgodGhpcy5hY3RpdmVUYWJJbmRleF8pIC8gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aCgpO1xuXG4gICAgY29uc3QgdHJhbnNmb3JtVmFsdWUgPSBgdHJhbnNsYXRlWCgke3RyYW5zbGF0ZUFtdEZvckFjdGl2ZVRhYkxlZnR9cHgpIHNjYWxlKCR7c2NhbGVBbXRGb3JBY3RpdmVUYWJXaWR0aH0sIDEpYDtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9ySW5kaWNhdG9yKGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAndHJhbnNmb3JtJyksIHRyYW5zZm9ybVZhbHVlKTtcblxuICAgIGlmIChpc0luZGljYXRvckZpcnN0UmVuZGVyKSB7XG4gICAgICAvLyBGb3JjZSBsYXlvdXQgc28gdGhhdCB0cmFuc2Zvcm0gc3R5bGVzIHRvIHRha2UgZWZmZWN0LlxuICAgICAgdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcigpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcigndHJhbnNpdGlvbicsICcnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JJbmRpY2F0b3IoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgdGhpcy5pc0luZGljYXRvclNob3duXyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZmluZEFjdGl2ZVRhYkluZGV4XygpIHtcbiAgICBsZXQgYWN0aXZlVGFiSW5kZXggPSAtMTtcbiAgICB0aGlzLmZvckVhY2hUYWJJbmRleF8oKGluZGV4KSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1RhYkFjdGl2ZUF0SW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIGFjdGl2ZVRhYkluZGV4ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY3RpdmVUYWJJbmRleDtcbiAgfVxuXG4gIGZvckVhY2hUYWJJbmRleF8oaXRlcmF0b3IpIHtcbiAgICBjb25zdCBudW1UYWJzID0gdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZlRhYnMoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtVGFiczsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBpdGVyYXRvcihpbmRleCk7XG4gICAgICBpZiAoc2hvdWxkQnJlYWspIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmxheW91dEZyYW1lXykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pO1xuICAgIH1cblxuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG4gICAgfSk7XG4gIH1cblxuICBzd2l0Y2hUb1RhYkF0SW5kZXgoaW5kZXgsIHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChpbmRleCA9PT0gdGhpcy5hY3RpdmVUYWJJbmRleF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZUYWJzKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3V0IG9mIGJvdW5kcyBpbmRleCBzcGVjaWZpZWQgZm9yIHRhYjogJHtpbmRleH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2QWN0aXZlVGFiSW5kZXggPSB0aGlzLmFjdGl2ZVRhYkluZGV4XztcbiAgICB0aGlzLmFjdGl2ZVRhYkluZGV4XyA9IGluZGV4O1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAocHJldkFjdGl2ZVRhYkluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJBY3RpdmVBdEluZGV4KHByZXZBY3RpdmVUYWJJbmRleCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJBY3RpdmVBdEluZGV4KHRoaXMuYWN0aXZlVGFiSW5kZXhfLCB0cnVlKTtcbiAgICAgIHRoaXMubGF5b3V0SW5kaWNhdG9yXygpO1xuICAgICAgaWYgKHNob3VsZE5vdGlmeSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSh7YWN0aXZlVGFiSW5kZXg6IHRoaXMuYWN0aXZlVGFiSW5kZXhffSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRBY3RpdmVUYWJJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kQWN0aXZlVGFiSW5kZXhfKCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPG5hdiBjbGFzcz1cIm1kYy10YWItYmFyXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8c3BhbiByZWY9XCJpbmRpY2F0b3JcIiBjbGFzcz1cIm1kYy10YWItYmFyX19pbmRpY2F0b3JcIiBcbiAgICAgIDpzdHlsZT1cImluZGljYXRvclN0eWxlc1wiPjwvc3Bhbj5cbiAgPC9uYXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVGFiQmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGFicy90YWItYmFyL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDVGFiRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGFicy90YWIvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRhYi1iYXInLFxuICBwcm9wczoge1xuICAgICdpbmRpY2F0b3ItcHJpbWFyeSc6IEJvb2xlYW4sXG4gICAgJ2luZGljYXRvci1hY2NlbnQnOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGFiLWJhci0taW5kaWNhdG9yLXByaW1hcnknOiB0aGlzLmluZGljYXRvclByaW1hcnksXG4gICAgICAgICdtZGMtdGFiLWJhci0taW5kaWNhdG9yLWFjY2VudCc6IHRoaXMuaW5kaWNhdG9yQWNjZW50XG4gICAgICB9LFxuICAgICAgaW5kaWNhdG9yU3R5bGVzOiB7fSxcbiAgICAgIHRhYnM6IFtdXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25TZWxlY3QgKHtkZXRhaWx9KSB7XG4gICAgICBjb25zdCB7dGFifSA9IGRldGFpbFxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhYnMuaW5kZXhPZih0YWIpXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWRjLXRhYi1iYXIgaW50ZXJuYWwgZXJyb3I6IGluZGV4IG5vdCBmb3VuZCcpXG4gICAgICB9XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc3dpdGNoVG9UYWJBdEluZGV4KGluZGV4LCB0cnVlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RhYkJhckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT5cbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsIHRoaXMub25TZWxlY3QpXG4gICAgICB9LFxuICAgICAgdW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50OiAoKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwgdGhpcy5vblNlbGVjdCksXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PlxuICAgICAgICB0aGlzLiRlbC5vZmZzZXRXaWR0aCxcbiAgICAgIHNldFN0eWxlRm9ySW5kaWNhdG9yOiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT5cbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuaW5kaWNhdG9yU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKSxcbiAgICAgIGdldE9mZnNldFdpZHRoRm9ySW5kaWNhdG9yOiAoKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLmluZGljYXRvci5vZmZzZXRXaWR0aCxcbiAgICAgIG5vdGlmeUNoYW5nZTogKGV2dERhdGEpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZ0RGF0YS5hY3RpdmVUYWJJbmRleClcbiAgICAgIH0sXG4gICAgICBnZXROdW1iZXJPZlRhYnM6ICgpID0+XG4gICAgICAgIHRoaXMudGFicy5sZW5ndGgsXG4gICAgICBpc1RhYkFjdGl2ZUF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5pc0FjdGl2ZSgpLFxuICAgICAgc2V0VGFiQWN0aXZlQXRJbmRleDogKGluZGV4LCBpc0FjdGl2ZSkgPT4ge1xuICAgICAgICB0aGlzLnRhYnNbaW5kZXhdLnNldEFjdGl2ZShpc0FjdGl2ZSlcbiAgICAgIH0sXG4gICAgICBpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrRm9yVGFiQXRJbmRleDogKGluZGV4KSA9PlxuICAgICAgICB0aGlzLnRhYnNbaW5kZXhdLmlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2soKSxcbiAgICAgIHNldFByZXZlbnREZWZhdWx0T25DbGlja0ZvclRhYkF0SW5kZXg6IChpbmRleCwgcHJldmVudERlZmF1bHRPbkNsaWNrKSA9PiB7XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaylcbiAgICAgIH0sXG4gICAgICBtZWFzdXJlVGFiQXRJbmRleDogKGluZGV4KSA9PlxuICAgICAgICB0aGlzLnRhYnNbaW5kZXhdLm1lYXN1cmVTZWxmKCksXG4gICAgICBnZXRDb21wdXRlZFdpZHRoRm9yVGFiQXRJbmRleDogKGluZGV4KSA9PlxuICAgICAgICB0aGlzLnRhYnNbaW5kZXhdLmdldENvbXB1dGVkV2lkdGgoKSxcbiAgICAgIGdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5nZXRDb21wdXRlZExlZnQoKVxuICAgIH0pXG5cbiAgICBjb25zdCByZXNldFRhYnMgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0YWJFbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoXG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoTURDVGFiQmFyRm91bmRhdGlvbi5zdHJpbmdzLlRBQl9TRUxFQ1RPUikpXG4gICAgICB0aGlzLnRhYnMgPSB0YWJFbGVtZW50cy5tYXAoKGVsKSA9PiBlbC5fX3Z1ZV9fKVxuXG4gICAgICBsZXQgaGFzVGV4dCwgaGFzSWNvblxuICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFic1xuICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgaWYgKHRhYi5oYXNUZXh0KSB7XG4gICAgICAgICAgaGFzVGV4dCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB0YWIgb2YgdGFicykge1xuICAgICAgICBpZiAodGFiLmhhc0ljb24pIHtcbiAgICAgICAgICBoYXNJY29uID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1RleHQgJiYgaGFzSWNvbikge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLXRhYi1iYXItLWljb25zLXdpdGgtdGV4dCcsIHRydWUpXG4gICAgICB9IGVsc2UgaWYgKGhhc0ljb24pIHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy10YWItYmFyLS1pY29uLXRhYi1iYXInLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhYkluZGV4ID0gdGhpcy5mb3VuZGF0aW9uLmdldEFjdGl2ZVRhYkluZGV4KClcbiAgICAgICAgaWYgKGFjdGl2ZVRhYkluZGV4ID49IDApIHtcbiAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uc3dpdGNoVG9UYWJBdEluZGV4KGFjdGl2ZVRhYkluZGV4LCB0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zd2l0Y2hUb1RhYkF0SW5kZXgoMCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldFRhYnMoKVxuXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiByZXNldFRhYnMoKSlcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsLCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1RhYiBmcm9tICcuL21kYy10YWIudnVlJ1xuaW1wb3J0IG1kY1RhYkJhciBmcm9tICcuL21kYy10YWItYmFyLnZ1ZSdcblxuZXhwb3J0IHsgXG4gIG1kY1RhYiwgXG4gIG1kY1RhYkJhciBcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RhYiwgXG4gIG1kY1RhYkJhciBcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRleHRGaWVsZCBMaW5lIFJpcHBsZS5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBsaW5lIHJpcHBsZSBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDTGluZVJpcHBsZUFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgd2l0aCBhIGdpdmVuIHZhbHVlIG9uIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbGluZSByaXBwbGUgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENMaW5lUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIExJTkVfUklQUExFX0FDVElWRTogJ21kYy1saW5lLXJpcHBsZS0tYWN0aXZlJyxcbiAgTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HOiAnbWRjLWxpbmUtcmlwcGxlLS1kZWFjdGl2YXRpbmcnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENMaW5lUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDTGluZVJpcHBsZUFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0xpbmVSaXBwbGVBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IC8qKiBAdHlwZSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyfSAqLyAoe30pKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENMaW5lUmlwcGxlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgbGluZSByaXBwbGVcbiAgICovXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9BQ1RJVkUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgcmlwcGxlIGFuaW1hdGlvbiB0byB0aGUgZ2l2ZW4gWCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHhDb29yZGluYXRlXG4gICAqL1xuICBzZXRSaXBwbGVDZW50ZXIoeENvb3JkaW5hdGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVTdHJpbmcgPVxuICAgICAgICBgdHJhbnNmb3JtLW9yaWdpbjogJHt4Q29vcmRpbmF0ZX1weCBjZW50ZXJgO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCdzdHlsZScsIGF0dHJpYnV0ZVN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlXG4gICAqL1xuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSB0cmFuc2l0aW9uIGVuZCBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCkge1xuICAgIC8vIFdhaXQgZm9yIHRoZSBsaW5lIHJpcHBsZSB0byBiZSBlaXRoZXIgdHJhbnNwYXJlbnQgb3Igb3BhcXVlXG4gICAgLy8gYmVmb3JlIGVtaXR0aW5nIHRoZSBhbmltYXRpb24gZW5kIGV2ZW50XG4gICAgY29uc3QgaXNEZWFjdGl2YXRpbmcgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcblxuICAgIGlmIChldnQucHJvcGVydHlOYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgIGlmIChpc0RlYWN0aXZhdGluZykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfQUNUSVZFKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEhlbHBlciBUZXh0LlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHRGaWVsZCBoZWxwZXIgdGV4dCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcmVtb3ZlQXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfSElEREVOOiAnYXJpYS1oaWRkZW4nLFxuICBST0xFOiAncm9sZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEhFTFBFUl9URVhUX1BFUlNJU1RFTlQ6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCcsXG4gIEhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0Q29udGVudDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQgZmllbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpc1BlcnNpc3RlbnQgU2V0cyB0aGUgcGVyc2lzdGVuY3kgb2YgdGhlIGhlbHBlciB0ZXh0LiAqL1xuICBzZXRQZXJzaXN0ZW50KGlzUGVyc2lzdGVudCkge1xuICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRhdGlvbiBUcnVlIHRvIG1ha2UgdGhlIGhlbHBlciB0ZXh0IGFjdCBhcyBhblxuICAgKiAgIGVycm9yIHZhbGlkYXRpb24gbWVzc2FnZS5cbiAgICovXG4gIHNldFZhbGlkYXRpb24oaXNWYWxpZGF0aW9uKSB7XG4gICAgaWYgKGlzVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9XG4gIH1cblxuICAvKiogTWFrZXMgdGhlIGhlbHBlciB0ZXh0IHZpc2libGUgdG8gdGhlIHNjcmVlbiByZWFkZXIuICovXG4gIHNob3dUb1NjcmVlblJlYWRlcigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHIoc3RyaW5ncy5BUklBX0hJRERFTik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsaWRpdHkgb2YgdGhlIGhlbHBlciB0ZXh0IGJhc2VkIG9uIHRoZSBpbnB1dCB2YWxpZGl0eS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dElzVmFsaWRcbiAgICovXG4gIHNldFZhbGlkaXR5KGlucHV0SXNWYWxpZCkge1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1BlcnNpc3RlbnQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgY29uc3QgaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSA9IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgJiYgIWlucHV0SXNWYWxpZDtcblxuICAgIGlmICh2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5ST0xFLCAnYWxlcnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKHN0cmluZ3MuUk9MRSk7XG4gICAgfVxuXG4gICAgaWYgKCFoZWxwZXJUZXh0SXNQZXJzaXN0ZW50ICYmICF2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmhpZGVfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBoZWxwIHRleHQgZnJvbSBzY3JlZW4gcmVhZGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhpZGVfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLkFSSUFfSElEREVOLCAndHJ1ZScpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEljb24uXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgdGV4dCBmaWVsZCBpY29uIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRJY29uQWRhcHRlciB7XG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgXCJNRENUZXh0RmllbGQ6aWNvblwiIGRlbm90aW5nIGEgdXNlciBoYXMgY2xpY2tlZCB0aGUgaWNvbi5cbiAgICovXG4gIG5vdGlmeUljb25BY3Rpb24oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElDT05fRVZFTlQ6ICdNRENUZXh0RmllbGQ6aWNvbicsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRJY29uQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gKi8gKHtcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJY29uQWN0aW9uOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dCBmaWVsZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICAgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCd0YWJpbmRleCcsICcwJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUljb25BY3Rpb24oKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRleHQgRmllbGQgTGFiZWwuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGV4dCBGaWVsZCBsYWJlbCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkTGFiZWxBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRMYWJlbEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBMQUJFTF9GTE9BVF9BQk9WRTogJ21kYy10ZXh0LWZpZWxkX19sYWJlbC0tZmxvYXQtYWJvdmUnLFxuICBMQUJFTF9TSEFLRTogJ21kYy10ZXh0LWZpZWxkX19sYWJlbC0tc2hha2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRMYWJlbEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZExhYmVsQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZExhYmVsQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENUZXh0RmllbGRMYWJlbEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRMYWJlbEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBnZXRXaWR0aDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkTGFiZWxBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRMYWJlbEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgbGFiZWwgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0V2lkdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGxhYmVsIHRvIHByb2R1Y2UgdGhlIGxhYmVsIHNoYWtlIGZvciBlcnJvcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZCBXaGV0aGVyIHRoZSBpbnB1dCdzIHZhbHVlIGlzIHZhbGlkIChwYXNzZXMgYWxsXG4gICAqICAgICB2YWxpZGl0eSBjaGVja3MpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZCBXaGV0aGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkLlxuICAgKi9cbiAgc3R5bGVTaGFrZShpc1ZhbGlkLCBpc0ZvY3VzZWQpIHtcbiAgICBjb25zdCB7TEFCRUxfU0hBS0V9ID0gTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzVmFsaWQgfHwgaXNGb2N1c2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgbGFiZWwgdG8gZmxvYXQgb3IgZGVmbG9hdCBhcyBuZWNlc3NhcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZCBXaGV0aGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQmFkSW5wdXQgVGhlIGlucHV0J3MgYHZhbGlkaXR5LmJhZElucHV0YCB2YWx1ZS5cbiAgICovXG4gIHN0eWxlRmxvYXQodmFsdWUsIGlzRm9jdXNlZCwgaXNCYWRJbnB1dCkge1xuICAgIGNvbnN0IHtMQUJFTF9GTE9BVF9BQk9WRSwgTEFCRUxfU0hBS0V9ID0gTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKCEhdmFsdWUgfHwgaXNGb2N1c2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKExBQkVMX0ZMT0FUX0FCT1ZFKTtcbiAgICB9IGVsc2UgaWYgKCFpc0JhZElucHV0KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX0ZMT0FUX0FCT1ZFKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRMYWJlbEZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRleHQgRmllbGQgT3V0bGluZS5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUZXh0IEZpZWxkIG91dGxpbmUgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZE91dGxpbmVBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEhlaWdodCgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFwiZFwiIGF0dHJpYnV0ZSBvZiB0aGUgb3V0bGluZSBlbGVtZW50J3MgU1ZHIHBhdGguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0T3V0bGluZVBhdGhBdHRyKHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpZGxlIG91dGxpbmUgZWxlbWVudCdzIGNvbXB1dGVkIHN0eWxlIHZhbHVlIG9mIHRoZSBnaXZlbiBjc3MgcHJvcGVydHkgYHByb3BlcnR5TmFtZWAuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGdldENvbXB1dGVkU3R5bGUoLi4uKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSlgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZE91dGxpbmVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgUEFUSF9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9fb3V0bGluZS1wYXRoJyxcbiAgSURMRV9PVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy10ZXh0LWZpZWxkX19pZGxlLW91dGxpbmUnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZE91dGxpbmVBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRPdXRsaW5lRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZE91dGxpbmVBZGFwdGVyfSAqLyAoe1xuICAgICAgZ2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZ2V0SGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIHNldE91dGxpbmVQYXRoQXR0cjogKCkgPT4ge30sXG4gICAgICBnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWU6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RleHRGaWVsZE91dGxpbmVBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRPdXRsaW5lRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFNWRyBwYXRoIG9mIHRoZSBmb2N1cyBvdXRsaW5lIGVsZW1lbnQgYmFzZWQgb24gdGhlIGdpdmVuIHdpZHRoIG9mIHRoZVxuICAgKiBsYWJlbCBlbGVtZW50IGFuZCB0aGUgUlRMIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFdpZHRoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUnRsXG4gICAqL1xuICB1cGRhdGVTdmdQYXRoKGxhYmVsV2lkdGgsIGlzUnRsID0gZmFsc2UpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyBhIHNwZWNpZmljIGNvcm5lcidzIHN0eWxlIGJlY2F1c2UgRmlyZWZveCBkb2Vzbid0IHJlcG9ydCB0aGUgc3R5bGUgb24gYm9yZGVyLXJhZGl1cy5cbiAgICBjb25zdCByYWRpdXNTdHlsZVZhbHVlID0gdGhpcy5hZGFwdGVyXy5nZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUoJ2JvcmRlci1yYWRpdXMnKSB8fFxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZSgnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycpO1xuICAgIGNvbnN0IHJhZGl1cyA9IHBhcnNlRmxvYXQocmFkaXVzU3R5bGVWYWx1ZSk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCBjb3JuZXJXaWR0aCA9IHJhZGl1cyArIDEuMjtcbiAgICBjb25zdCBsZWFkaW5nU3Ryb2tlTGVuZ3RoID0gTWF0aC5hYnMoMTEgLSBjb3JuZXJXaWR0aCk7XG4gICAgY29uc3QgcGFkZGVkTGFiZWxXaWR0aCA9IGxhYmVsV2lkdGggKyA4O1xuXG4gICAgLy8gVGhlIHJpZ2h0LCBib3R0b20sIGFuZCBsZWZ0IHNpZGVzIG9mIHRoZSBvdXRsaW5lIGZvbGxvdyB0aGUgc2FtZSBTVkcgcGF0aC5cbiAgICBjb25zdCBwYXRoTWlkZGxlID0gJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgcmFkaXVzICsgJywnICsgcmFkaXVzXG4gICAgICArICd2JyArIChoZWlnaHQgLSAoMiAqIGNvcm5lcldpZHRoKSlcbiAgICAgICsgJ2EnICsgcmFkaXVzICsgJywnICsgcmFkaXVzICsgJyAwIDAgMSAnICsgLXJhZGl1cyArICcsJyArIHJhZGl1c1xuICAgICAgKyAnaCcgKyAoLXdpZHRoICsgKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIC1yYWRpdXMgKyAnLCcgKyAtcmFkaXVzXG4gICAgICArICd2JyArICgtaGVpZ2h0ICsgKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIHJhZGl1cyArICcsJyArIC1yYWRpdXM7XG5cbiAgICBsZXQgcGF0aDtcbiAgICBpZiAoIWlzUnRsKSB7XG4gICAgICBwYXRoID0gJ00nICsgKGNvcm5lcldpZHRoICsgbGVhZGluZ1N0cm9rZUxlbmd0aCArIHBhZGRlZExhYmVsV2lkdGgpICsgJywnICsgMVxuICAgICAgICArICdoJyArICh3aWR0aCAtICgyICogY29ybmVyV2lkdGgpIC0gcGFkZGVkTGFiZWxXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpXG4gICAgICAgICsgcGF0aE1pZGRsZVxuICAgICAgICArICdoJyArIGxlYWRpbmdTdHJva2VMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSAnTScgKyAod2lkdGggLSBjb3JuZXJXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpICsgJywnICsgMVxuICAgICAgICArICdoJyArIGxlYWRpbmdTdHJva2VMZW5ndGhcbiAgICAgICAgKyBwYXRoTWlkZGxlXG4gICAgICAgICsgJ2gnICsgKHdpZHRoIC0gKDIgKiBjb3JuZXJXaWR0aCkgLSBwYWRkZWRMYWJlbFdpZHRoIC0gbGVhZGluZ1N0cm9rZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRPdXRsaW5lUGF0aEF0dHIocGF0aCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnLi9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiBmcm9tICcuL2ljb24vZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uIGZyb20gJy4vbGFiZWwvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb24gZnJvbSAnLi9vdXRsaW5lL2ZvdW5kYXRpb24nO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB2YWx1ZTogc3RyaW5nLFxuICogICBkaXNhYmxlZDogYm9vbGVhbixcbiAqICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgIHZhbGlkaXR5OiB7XG4gKiAgICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgICAgdmFsaWQ6IGJvb2xlYW4sXG4gKiAgIH0sXG4gKiB9fVxuICovXG5sZXQgTmF0aXZlSW5wdXRUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGxpbmVSaXBwbGU6ICghTURDTGluZVJpcHBsZUZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqICAgaGVscGVyVGV4dDogKCFNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogICBpY29uOiAoIU1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9ufHVuZGVmaW5lZCksXG4gKiAgIGxhYmVsOiAoIU1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogICBvdXRsaW5lOiAoIU1EQ1RleHRGaWVsZE91dGxpbmVGb3VuZGF0aW9ufHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBGb3VuZGF0aW9uTWFwVHlwZTtcblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUZXh0IEZpZWxkIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgcm9vdCBFbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZWxlbWVudCwgd2l0aCBhXG4gICAqIHNpbWlsYXIgQVBJIHNoYXBlLiBUaGUgb2JqZWN0IHJldHVybmVkIHNob3VsZCBpbmNsdWRlIHRoZSB2YWx1ZSwgZGlzYWJsZWRcbiAgICogYW5kIGJhZElucHV0IHByb3BlcnRpZXMsIGFzIHdlbGwgYXMgdGhlIGNoZWNrVmFsaWRpdHkoKSBmdW5jdGlvbi4gV2UgbmV2ZXJcbiAgICogYWx0ZXIgdGhlIHZhbHVlIHdpdGhpbiBvdXIgY29kZSwgaG93ZXZlciB3ZSBkbyB1cGRhdGUgdGhlIGRpc2FibGVkXG4gICAqIHByb3BlcnR5LCBzbyBpZiB5b3UgY2hvb3NlIHRvIGR1Y2stdHlwZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGlzIG1ldGhvZFxuICAgKiBpbiB5b3VyIGltcGxlbWVudGF0aW9uIGl0J3MgaW1wb3J0YW50IHRvIGtlZXAgdGhpcyBpbiBtaW5kLiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIG51bGwsIHdoaWNoIHRoZSBmb3VuZGF0aW9uIHdpbGwgaGFuZGxlIGdyYWNlZnVsbHkuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fD9OYXRpdmVJbnB1dFR5cGV9XG4gICAqL1xuICBnZXROYXRpdmVJbnB1dCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dGZpZWxkIGlzIGZvY3VzZWQuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdF9gLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJvb3QgZWxlbWVudCBpcyBzZXQgdG8gUlRMLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgYWN0aXZhdGVMaW5lUmlwcGxlKCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUxpbmVSaXBwbGUoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb3JpZ2luIG9mIHRoZSBsaW5lIHJpcHBsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRYXG4gICAqL1xuICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKSB7fVxufVxuXG5leHBvcnQge01EQ1RleHRGaWVsZEFkYXB0ZXIsIE5hdGl2ZUlucHV0VHlwZSwgRm91bmRhdGlvbk1hcFR5cGV9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJJQV9DT05UUk9MUzogJ2FyaWEtY29udHJvbHMnLFxuICBJTlBVVF9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9faW5wdXQnLFxuICBMQUJFTF9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9fbGFiZWwnLFxuICBJQ09OX1NFTEVDVE9SOiAnLm1kYy10ZXh0LWZpZWxkX19pY29uJyxcbiAgT1VUTElORV9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9fb3V0bGluZScsXG4gIEJPVFRPTV9MSU5FX1NFTEVDVE9SOiAnLm1kYy1saW5lLXJpcHBsZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtdGV4dC1maWVsZCcsXG4gIFVQR1JBREVEOiAnbWRjLXRleHQtZmllbGQtLXVwZ3JhZGVkJyxcbiAgRElTQUJMRUQ6ICdtZGMtdGV4dC1maWVsZC0tZGlzYWJsZWQnLFxuICBERU5TRTogJ21kYy10ZXh0LWZpZWxkLS1kZW5zZScsXG4gIEZPQ1VTRUQ6ICdtZGMtdGV4dC1maWVsZC0tZm9jdXNlZCcsXG4gIElOVkFMSUQ6ICdtZGMtdGV4dC1maWVsZC0taW52YWxpZCcsXG4gIEJPWDogJ21kYy10ZXh0LWZpZWxkLS1ib3gnLFxuICBPVVRMSU5FRDogJ21kYy10ZXh0LWZpZWxkLS1vdXRsaW5lZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIExBQkVMX1NDQUxFOiAwLjc1LFxuICBERU5TRV9MQUJFTF9TQ0FMRTogMC45MjMsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtNRENUZXh0RmllbGRBZGFwdGVyLCBOYXRpdmVJbnB1dFR5cGUsIEZvdW5kYXRpb25NYXBUeXBlfSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnLi9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiBmcm9tICcuL2ljb24vZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uIGZyb20gJy4vbGFiZWwvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb24gZnJvbSAnLi9vdXRsaW5lL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGV4dEZpZWxkQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENUZXh0RmllbGRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZ2V0TmF0aXZlSW5wdXQ6ICgpID0+IHt9LFxuICAgICAgaXNGb2N1c2VkOiAoKSA9PiB7fSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7fSxcbiAgICAgIGFjdGl2YXRlTGluZVJpcHBsZTogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlTGluZVJpcHBsZTogKCkgPT4ge30sXG4gICAgICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRBZGFwdGVyfSBhZGFwdGVyXG4gICAqIEBwYXJhbSB7IUZvdW5kYXRpb25NYXBUeXBlPX0gZm91bmRhdGlvbk1hcCBNYXAgZnJvbSBzdWJjb21wb25lbnQgbmFtZXMgdG8gdGhlaXIgc3ViZm91bmRhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCBmb3VuZGF0aW9uTWFwID0gLyoqIEB0eXBlIHshRm91bmRhdGlvbk1hcFR5cGV9ICovICh7fSkpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhlbHBlclRleHRfID0gZm91bmRhdGlvbk1hcC5oZWxwZXJUZXh0O1xuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmljb25fID0gZm91bmRhdGlvbk1hcC5pY29uO1xuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5sYWJlbF8gPSBmb3VuZGF0aW9uTWFwLmxhYmVsO1xuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZE91dGxpbmVGb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLm91dGxpbmVfID0gZm91bmRhdGlvbk1hcC5vdXRsaW5lO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNWYWxpZF8gPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuZGVhY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8gPSAoKSA9PiB0aGlzLmF1dG9Db21wbGV0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8gPSAoZXZ0KSA9PiB0aGlzLnNldFRyYW5zZm9ybU9yaWdpbihldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24oKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIC8vIEVuc3VyZSBsYWJlbCBkb2VzIG5vdCBjb2xsaWRlIHdpdGggYW55IHByZS1maWxsZWQgdmFsdWUuXG4gICAgaWYgKHRoaXMubGFiZWxfICYmIHRoaXMuZ2V0VmFsdWUoKSkge1xuICAgICAgdGhpcy5sYWJlbF8uc3R5bGVGbG9hdChcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSgpLCB0aGlzLmlzRm9jdXNlZF8sIHRoaXMuaXNCYWRJbnB1dF8oKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmlucHV0Qmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2lucHV0JywgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8pO1xuICAgIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8pO1xuICAgIH0pO1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy50ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuaW5wdXRCbHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdpbnB1dCcsIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfKTtcbiAgICBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8pO1xuICAgIH0pO1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgVGV4dCBGaWVsZC5cbiAgICovXG4gIGhhbmRsZVRleHRGaWVsZEludGVyYWN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUlucHV0KCkuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWNlaXZlZFVzZXJJbnB1dF8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZvY3VzIG91dGxpbmUgZm9yIG91dGxpbmVkIHRleHQgZmllbGRzLlxuICAgKi9cbiAgdXBkYXRlT3V0bGluZSgpIHtcbiAgICBpZiAoIXRoaXMub3V0bGluZV8gfHwgIXRoaXMubGFiZWxfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXNEZW5zZSA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5ERU5TRSk7XG4gICAgY29uc3QgbGFiZWxTY2FsZSA9IGlzRGVuc2UgPyBudW1iZXJzLkRFTlNFX0xBQkVMX1NDQUxFIDogbnVtYmVycy5MQUJFTF9TQ0FMRTtcbiAgICBjb25zdCBsYWJlbFdpZHRoID0gdGhpcy5sYWJlbF8uZ2V0V2lkdGgoKSAqIGxhYmVsU2NhbGU7XG4gICAgY29uc3QgaXNSdGwgPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCk7XG4gICAgdGhpcy5vdXRsaW5lXy51cGRhdGVTdmdQYXRoKGxhYmVsV2lkdGgsIGlzUnRsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRleHQgZmllbGQgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBhY3RpdmF0ZUZvY3VzKCkge1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IHRydWU7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUxpbmVSaXBwbGUoKTtcbiAgICBpZiAodGhpcy5vdXRsaW5lXykge1xuICAgICAgdGhpcy51cGRhdGVPdXRsaW5lKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhYmVsXykge1xuICAgICAgdGhpcy5sYWJlbF8uc3R5bGVTaGFrZSh0aGlzLmlzVmFsaWQoKSwgdGhpcy5pc0ZvY3VzZWRfKTtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlRmxvYXQoXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5pc0ZvY3VzZWRfLCB0aGlzLmlzQmFkSW5wdXRfKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Xy5zaG93VG9TY3JlZW5SZWFkZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGluZSByaXBwbGUncyB0cmFuc2Zvcm0gb3JpZ2luLCBzbyB0aGF0IHRoZSBsaW5lIHJpcHBsZSBhY3RpdmF0ZVxuICAgKiBhbmltYXRpb24gd2lsbCBhbmltYXRlIG91dCBmcm9tIHRoZSB1c2VyJ3MgY2xpY2sgbG9jYXRpb24uXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIHNldFRyYW5zZm9ybU9yaWdpbihldnQpIHtcbiAgICBjb25zdCB0YXJnZXRDbGllbnRSZWN0ID0gZXZ0LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBldnRDb29yZHMgPSB7eDogZXZ0LmNsaWVudFgsIHk6IGV2dC5jbGllbnRZfTtcbiAgICBjb25zdCBub3JtYWxpemVkWCA9IGV2dENvb3Jkcy54IC0gdGFyZ2V0Q2xpZW50UmVjdC5sZWZ0O1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbihub3JtYWxpemVkWCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBUZXh0IEZpZWxkJ3MgZm9jdXMgc3RhdGUgaW4gY2FzZXMgd2hlbiB0aGUgaW5wdXQgdmFsdWVcbiAgICogY2hhbmdlcyB3aXRob3V0IHVzZXIgaW5wdXQgKGUuZy4gcHJvZ3JhbWF0aWNhbGx5KS5cbiAgICovXG4gIGF1dG9Db21wbGV0ZUZvY3VzKCkge1xuICAgIGlmICghdGhpcy5yZWNlaXZlZFVzZXJJbnB1dF8pIHtcbiAgICAgIHRoaXMuYWN0aXZhdGVGb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgVGV4dCBGaWVsZCdzIGZvY3VzIHN0YXRlLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUZvY3VzKCkge1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVhY3RpdmF0ZUxpbmVSaXBwbGUoKTtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCk7XG4gICAgY29uc3Qgc2hvdWxkUmVtb3ZlTGFiZWxGbG9hdCA9ICFpbnB1dC52YWx1ZSAmJiAhdGhpcy5pc0JhZElucHV0XygpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLmlzVmFsaWQoKTtcbiAgICB0aGlzLnN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpO1xuICAgIHRoaXMuc3R5bGVGb2N1c2VkXyh0aGlzLmlzRm9jdXNlZF8pO1xuICAgIGlmICh0aGlzLmxhYmVsXykge1xuICAgICAgdGhpcy5sYWJlbF8uc3R5bGVTaGFrZSh0aGlzLmlzVmFsaWQoKSwgdGhpcy5pc0ZvY3VzZWRfKTtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlRmxvYXQoXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5pc0ZvY3VzZWRfLCB0aGlzLmlzQmFkSW5wdXRfKCkpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmVtb3ZlTGFiZWxGbG9hdCkge1xuICAgICAgdGhpcy5yZWNlaXZlZFVzZXJJbnB1dF8gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0IEVsZW1lbnQuXG4gICAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBvbiB0aGUgaW5wdXQgRWxlbWVudC5cbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWx1ZSA9IHZhbHVlO1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLmlzVmFsaWQoKTtcbiAgICB0aGlzLnN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpO1xuICAgIGlmICh0aGlzLmxhYmVsXykge1xuICAgICAgdGhpcy5sYWJlbF8uc3R5bGVTaGFrZShpc1ZhbGlkLCB0aGlzLmlzRm9jdXNlZF8pO1xuICAgICAgdGhpcy5sYWJlbF8uc3R5bGVGbG9hdChcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSgpLCB0aGlzLmlzRm9jdXNlZF8sIHRoaXMuaXNCYWRJbnB1dF8oKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGEgY3VzdG9tIHZhbGlkaXR5IGlzIHNldCwgcmV0dXJucyB0aGF0IHZhbHVlLlxuICAgKiAgICAgT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSByZXN1bHQgb2YgbmF0aXZlIHZhbGlkaXR5IGNoZWNrcy5cbiAgICovXG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ19cbiAgICAgID8gdGhpcy5pc1ZhbGlkXyA6IHRoaXMuaXNOYXRpdmVJbnB1dFZhbGlkXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZCBTZXRzIHRoZSB2YWxpZGl0eSBzdGF0ZSBvZiB0aGUgVGV4dCBGaWVsZC5cbiAgICovXG4gIHNldFZhbGlkKGlzVmFsaWQpIHtcbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gdHJ1ZTtcbiAgICB0aGlzLmlzVmFsaWRfID0gaXNWYWxpZDtcbiAgICAvLyBSZXRyaWV2ZSBmcm9tIHRoZSBnZXR0ZXIgdG8gZW5zdXJlIGNvcnJlY3QgbG9naWMgaXMgYXBwbGllZC5cbiAgICBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICBpZiAodGhpcy5sYWJlbF8pIHtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlU2hha2UoaXNWYWxpZCwgdGhpcy5pc0ZvY3VzZWRfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgVGV4dCBGaWVsZCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCBTZXRzIHRoZSB0ZXh0LWZpZWxkIGRpc2FibGVkIG9yIGVuYWJsZWQuXG4gICAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB0aGlzLnN0eWxlRGlzYWJsZWRfKGRpc2FibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBUZXh0IEZpZWxkIGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgaXNSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS5yZXF1aXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVxdWlyZWQgU2V0cyB0aGUgdGV4dC1maWVsZCByZXF1aXJlZCBvciBub3QuXG4gICAqL1xuICBzZXRSZXF1aXJlZChpc1JlcXVpcmVkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVJbnB1dF8oKS5yZXF1aXJlZCA9IGlzUmVxdWlyZWQ7XG4gICAgLy8gQWRkaXRpb24gb2YgdGhlIGFzdGVyaXNrIGlzIGF1dG9tYXRpYyBiYXNlZCBvbiBDU1MsIGJ1dCB2YWxpZGl0eSBjaGVja2luZ1xuICAgIC8vIG5lZWRzIHRvIGJlIG1hbnVhbGx5IHJ1bi5cbiAgICB0aGlzLnN0eWxlVmFsaWRpdHlfKHRoaXMuaXNWYWxpZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dC5cbiAgICovXG4gIHNldEhlbHBlclRleHRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Xy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBUZXh0IEZpZWxkIGlucHV0IGZhaWxzIGluIGNvbnZlcnRpbmcgdGhlXG4gICAqICAgICB1c2VyLXN1cHBsaWVkIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNCYWRJbnB1dF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsaWRpdHkuYmFkSW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlc3VsdCBvZiBuYXRpdmUgdmFsaWRpdHkgY2hlY2tpbmdcbiAgICogICAgIChWYWxpZGl0eVN0YXRlLnZhbGlkKS5cbiAgICovXG4gIGlzTmF0aXZlSW5wdXRWYWxpZF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsaWRpdHkudmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIHZhbGlkaXR5IHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlVmFsaWRpdHlfKGlzVmFsaWQpIHtcbiAgICBjb25zdCB7SU5WQUxJRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoSU5WQUxJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoSU5WQUxJRCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNldFZhbGlkaXR5KGlzVmFsaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgZm9jdXNlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ZvY3VzZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlRm9jdXNlZF8oaXNGb2N1c2VkKSB7XG4gICAgY29uc3Qge0ZPQ1VTRUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc0ZvY3VzZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRk9DVVNFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRk9DVVNFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0Rpc2FibGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdHlsZURpc2FibGVkXyhpc0Rpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVELCBJTlZBTElEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKElOVkFMSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWNvbl8pIHtcbiAgICAgIHRoaXMuaWNvbl8uc2V0RGlzYWJsZWQoaXNEaXNhYmxlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFFbGVtZW50fCFOYXRpdmVJbnB1dFR5cGV9IFRoZSBuYXRpdmUgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICAgKiBob3N0IGVudmlyb25tZW50LCBvciBhIGR1bW15IGlmIG5vbmUgZXhpc3RzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlSW5wdXRfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUlucHV0KCkgfHxcbiAgICAvKiogQHR5cGUgeyFOYXRpdmVJbnB1dFR5cGV9ICovICh7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWxpZGl0eToge1xuICAgICAgICBiYWRJbnB1dDogZmFsc2UsXG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgY2xhc3M9XCJtZGMtdGV4dGZpZWxkLXdyYXBwZXJcIiA6c3R5bGU9XCJ7d2lkdGg6ZnVsbHdpZHRoPycxMDAlJzp1bmRlZmluZWR9XCI+XHJcblxyXG4gICAgPGRpdiByZWY9XCJyb290XCIgOmNsYXNzPVwicm9vdENsYXNzZXNcIj5cclxuXHJcbiAgICAgIDxpIHJlZj1cImljb25cIiB2LWlmPVwiISFoYXNMZWFkaW5nSWNvblwiXHJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCIgXHJcbiAgICAgICAgY2xhc3M9XCJtZGMtdGV4dC1maWVsZF9faWNvblwiICBcclxuICAgICAgICA6Y2xhc3M9XCJoYXNMZWFkaW5nSWNvbi5jbGFzc2VzXCI+XHJcbiAgICAgICAgPHNsb3QgbmFtZT1cImxlYWRpbmctaWNvblwiPnt7IGhhc0xlYWRpbmdJY29uLmNvbnRlbnQgfX08L3Nsb3Q+XHJcbiAgICAgIDwvaT5cclxuXHJcbiAgICAgIDx0ZXh0YXJlYSByZWY9XCJpbnB1dFwiIHYtaWY9XCJtdWx0aWxpbmVcIlxyXG4gICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCJcclxuICAgICAgICB2LWJpbmQ9XCJpbnB1dEF0dHJzXCJcclxuICAgICAgICA6Y2xhc3M9XCJpbnB1dENsYXNzZXNcIlxyXG4gICAgICAgIEBpbnB1dD1cInVwZGF0ZVZhbHVlKCRldmVudC50YXJnZXQudmFsdWUpXCJcclxuICAgICAgICA6bWlubGVuZ3RoPVwibWlubGVuZ3RoXCIgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXHJcbiAgICAgICAgOnBsYWNlaG9sZGVyPVwiaW5wdXRQbGFjZUhvbGRlclwiXHJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJpbnB1dFBsYWNlSG9sZGVyXCJcclxuICAgICAgICA6YXJpYS1jb250cm9scz1cImlucHV0QXJpYUNvbnRyb2xzXCJcclxuICAgICAgICA6cm93cz1cInJvd3NcIiA6Y29scz1cImNvbHNcIiBcclxuICAgICAgICA+PC90ZXh0YXJlYT5cclxuXHJcbiAgICAgIDxpbnB1dCByZWY9XCJpbnB1dFwiIHYtZWxzZVxyXG4gICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCIgXHJcbiAgICAgICAgdi1iaW5kPVwiaW5wdXRBdHRyc1wiXHJcbiAgICAgICAgOmNsYXNzPVwiaW5wdXRDbGFzc2VzXCJcclxuICAgICAgICBAaW5wdXQ9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXHJcbiAgICAgICAgOnR5cGU9XCJ0eXBlXCJcclxuICAgICAgICA6bWlubGVuZ3RoPVwibWlubGVuZ3RoXCIgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXHJcbiAgICAgICAgOnBsYWNlaG9sZGVyPVwiaW5wdXRQbGFjZUhvbGRlclwiXHJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJpbnB1dFBsYWNlSG9sZGVyXCJcclxuICAgICAgICA6YXJpYS1jb250cm9scz1cImlucHV0QXJpYUNvbnRyb2xzXCIgXHJcbiAgICAgICAgLz5cclxuXHJcbiAgICAgIDxsYWJlbCByZWY9XCJsYWJlbFwiIDpjbGFzcz1cImxhYmVsQ2xhc3Nlc1VwZ3JhZGVkXCIgOmZvcj1cIl91aWRcIiAgdi1pZj1cImhhc0xhYmVsXCI+XHJcbiAgICAgICAge3sgbGFiZWwgfX1cclxuICAgICAgPC9sYWJlbD5cclxuXHJcbiAgICAgIDxpIHJlZj1cImljb25cIiB2LWlmPVwiISFoYXNUcmFpbGluZ0ljb25cIlxyXG4gICAgICAgIHRhYmluZGV4PVwiMFwiIFxyXG4gICAgICAgIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2ljb25cIiAgXHJcbiAgICAgICAgOmNsYXNzPVwiaGFzVHJhaWxpbmdJY29uLmNsYXNzZXNcIj5cclxuICAgICAgICA8c2xvdCBuYW1lPVwidHJhaWxpbmctaWNvblwiPnt7IGhhc1RyYWlsaW5nSWNvbi5jb250ZW50IH19PC9zbG90PlxyXG4gICAgICA8L2k+XHJcblxyXG4gICAgICA8ZGl2IHJlZj1cIm91dGxpbmVcIiBjbGFzcz1cIm1kYy10ZXh0LWZpZWxkX19vdXRsaW5lXCIgdi1pZj1cImhhc091dGxpbmVcIj5cclxuICAgICAgICA8c3ZnPlxyXG4gICAgICAgICAgPHBhdGggY2xhc3M9XCJtZGMtdGV4dC1maWVsZF9fb3V0bGluZS1wYXRoXCIgOmQ9XCJvdXRsaW5lUGF0aEF0dHJcIiAvPlxyXG4gICAgICAgIDwvc3ZnPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiByZWY9XCJvdXRsaW5lSWRsZVwiIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2lkbGUtb3V0bGluZVwiIHYtaWY9XCJoYXNPdXRsaW5lXCI+PC9kaXY+XHJcbiAgICAgIDxkaXYgcmVmPVwiYm90dG9tXCIgOmNsYXNzPVwiYm90dG9tQ2xhc3Nlc1wiIHYtaWY9XCJoYXNCb3R0b21MaW5lXCI+PC9kaXY+XHJcblxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPHAgcmVmPVwiaGVscFwiIDppZD1cIidoZWxwLScrX3VpZFwiIDpjbGFzcz1cImhlbHBDbGFzc2VzXCJcclxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdi1pZj1cImhlbHB0ZXh0XCI+XHJcbiAgICAgIHt7IGhlbHB0ZXh0ICB9fVxyXG4gICAgPC9wPlxyXG5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBNRENUZXh0ZmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvZm91bmRhdGlvbidcclxuaW1wb3J0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lLXJpcHBsZS9mb3VuZGF0aW9uJ1xyXG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJ1xyXG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24nO1xyXG5pbXBvcnQgTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvbGFiZWwvZm91bmRhdGlvbic7XHJcbmltcG9ydCBNRENUZXh0RmllbGRPdXRsaW5lRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL291dGxpbmUvZm91bmRhdGlvbic7XHJcblxyXG5pbXBvcnQge1xyXG4gIGV4dHJhY3RJY29uUHJvcCwgXHJcbiAgRGlzcGF0Y2hGb2N1c01peGluLCBDdXN0b21FbGVtZW50TWl4aW59IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCB7UmlwcGxlQmFzZX0gZnJvbSAnLi4vcmlwcGxlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtdGV4dGZpZWxkJyxcclxuICBtaXhpbnM6IFtDdXN0b21FbGVtZW50TWl4aW4sIERpc3BhdGNoRm9jdXNNaXhpbl0sXHJcbiAgbW9kZWw6IHtcclxuICAgIHByb3A6ICd2YWx1ZScsXHJcbiAgICBldmVudDogJ21vZGVsJ1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIHZhbHVlOiBTdHJpbmcsXHJcbiAgICB0eXBlOiB7XHJcbiAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgZGVmYXVsdDogJ3RleHQnLFxyXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBbJ3RleHQnLCAnZW1haWwnLCAnc2VhcmNoJywgJ3Bhc3N3b3JkJywgJ3RlbCcsICd1cmwnXVxyXG4gICAgICAgICAgLmluZGV4T2YodmFsdWUpICE9PSAtMVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGVuc2U6IEJvb2xlYW4sXHJcbiAgICBsYWJlbDogU3RyaW5nLFxyXG4gICAgaGVscHRleHQ6IFN0cmluZyxcclxuICAgIGhlbHB0ZXh0UGVyc2lzdGVudDogQm9vbGVhbixcclxuICAgIGhlbHB0ZXh0VmFsaWRhdGlvbjogQm9vbGVhbixcclxuICAgIGJveDogQm9vbGVhbixcclxuICAgIG91dGxpbmU6IEJvb2xlYW4sXHJcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcclxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxyXG4gICAgdmFsaWQ6IHt0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB1bmRlZmluZWR9LCBcclxuICAgIGZ1bGx3aWR0aDogQm9vbGVhbixcclxuICAgIG11bHRpbGluZTogQm9vbGVhbixcclxuICAgIGxlYWRpbmdJY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcclxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXHJcbiAgICBzaXplOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDIwIH0sXHJcbiAgICBtaW5sZW5ndGg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXHJcbiAgICBtYXhsZW5ndGg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXHJcbiAgICByb3dzOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDggfSxcclxuICAgIGNvbHM6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogNDAgfSxcclxuICAgIFxyXG4gICAgLy8gb3RoZXIgaW5wdXQgcHJvcHMgIFxyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgcmVhZG9ubHk6IEJvb2xlYW4sXHJcbiAgICBhdXRvY29tcGxldGU6IEJvb2xlYW4sXHJcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXHJcbiAgfSxcclxuICBkYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0OiB0aGlzLnZhbHVlLFxyXG4gICAgICByb290Q2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtdGV4dGZpZWxkJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQnOiB0cnVlLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tdXBncmFkZWQnOiB0cnVlLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZGlzYWJsZWQnOiB0aGlzLmRpc2FibGVkLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnOiB0aGlzLmRlbnNlLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZnVsbHdpZHRoJzogdGhpcy5mdWxsd2lkdGgsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS10ZXh0YXJlYSc6IHRoaXMubXVsdGlsaW5lLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tYm94JzogIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMuYm94LFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnOiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5vdXRsaW5lLFxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dENsYXNzZXM6IHtcclxuICAgICAgICAnbWRjLXRleHQtZmllbGRfX2lucHV0JzogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBsYWJlbENsYXNzZXM6IHtcclxuICAgICAgICAnbWRjLXRleHQtZmllbGRfX2xhYmVsJzogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBib3R0b21DbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy1saW5lLXJpcHBsZSc6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgaGVscENsYXNzZXM6IHtcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQnOiB0cnVlLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCc6IHRoaXMuaGVscHRleHRQZXJzaXN0ZW50LFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tdmFsaWRhdGlvbi1tc2cnOiB0aGlzLmhlbHB0ZXh0VmFsaWRhdGlvblxyXG4gICAgICB9LFxyXG4gICAgICBvdXRsaW5lUGF0aEF0dHI6IHVuZGVmaW5lZCxcclxuICAgIH1cclxuICB9LFxyXG4gIHdhdGNoOiAge1xyXG4gICAgZGlzYWJsZWQgKCkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXHJcbiAgICB9LFxyXG4gICAgcmVxdWlyZWQgKCkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldFJlcXVpcmVkKHRoaXMuZGlzYWJsZWQpXHJcbiAgICB9LFxyXG4gICAgdmFsaWQgKCkge1xyXG4gICAgICBpZiAodHlwZW9mIHRoaXMudmFsaWQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkZW5zZSAoKSB7XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnLCB0aGlzLmRlbnNlKVxyXG4gICAgfSxcclxuICAgIGhlbHB0ZXh0UGVyc2lzdGVudCAoKSB7XHJcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gXHJcbiAgICAgICAgJiYgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5zZXRQZXJzaXN0ZW50KHRoaXMuaGVscHRleHRQZXJzaXN0ZW50KVxyXG4gICAgfSxcclxuICAgIGhlbHB0ZXh0VmFsaWRhdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gXHJcbiAgICAgICAgJiYgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5zZXRWYWxpZGF0aW9uKHRoaXMuaGVscHRleHRWYWxpZGF0aW9uKVxyXG4gICAgfSxcclxuICAgIHZhbHVlICh2YWx1ZSkge1xyXG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSkge1xyXG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBcclxuICAgIH1cclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIHVwZGF0ZVZhbHVlICh2YWx1ZSkge1xyXG4gICAgICB0aGlzLiRlbWl0KCdtb2RlbCcsIHZhbHVlKVxyXG4gICAgfSxcclxuICAgIGZvY3VzICgpIHtcclxuICAgICAgdGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LmZvY3VzKCkgXHJcbiAgICB9LFxyXG4gICAgYmx1ciAoKSB7XHJcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5ibHVyKCkgXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaW5wdXRBdHRycyAoKSB7XHJcbiAgICAgIGxldCB7IG5hbWUsIHJlYWRvbmx5LCBhdXRvY29tcGxldGUsIGF1dG9mb2N1c30gPSB0aGlzXHJcbiAgICAgIHJldHVybiB7IG5hbWUsIHJlYWRvbmx5LCBhdXRvY29tcGxldGUsIGF1dG9mb2N1c307XHJcbiAgICB9LFxyXG4gICAgaW5wdXRQbGFjZUhvbGRlciAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZ1bGx3aWR0aCA/IHRoaXMubGFiZWwgOiB1bmRlZmluZWRcclxuICAgIH0sXHJcbiAgICBpbnB1dEFyaWFDb250cm9scyAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmhlbHAgPyAnaGVscC0nICsgdGhpcy5fdWlkOiB1bmRlZmluZWRcclxuICAgIH0sXHJcbiAgICBoYXNMYWJlbCAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5sYWJlbFxyXG4gICAgfSxcclxuICAgIGhhc091dGxpbmUgKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMub3V0bGluZSBcclxuICAgIH0sXHJcbiAgICBoYXNCb3R0b21MaW5lICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLmhhc091dGxpbmUgJiYgIXRoaXMubXVsdGlsaW5lXHJcbiAgICB9LFxyXG4gICAgaGFzTGVhZGluZ0ljb24gKCkge1xyXG4gICAgICBpZiAoKHRoaXMubGVhZGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ2xlYWRpbmctaWNvbiddKVxyXG4gICAgICAgICAmJiAhKHRoaXMudHJhaWxpbmdJY29uIHx8IHRoaXMuJHNsb3RzWyd0cmFpbGluZy1pY29uJ10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZGluZ0ljb24gPyBleHRyYWN0SWNvblByb3AodGhpcy5sZWFkaW5nSWNvbikgOiB7fVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuICAgIGhhc1RyYWlsaW5nSWNvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLiRzbG90c1sndHJhaWxpbmctaWNvbiddKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhaWxpbmdJY29uID8gZXh0cmFjdEljb25Qcm9wKHRoaXMudHJhaWxpbmdJY29uKSA6IHt9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9LFxyXG4gICAgbGFiZWxDbGFzc2VzVXBncmFkZWQgKCkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLmxhYmVsQ2xhc3Nlcywge1xyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZF9fbGFiZWwtLWZsb2F0LWFib3ZlJzogdGhpcy52YWx1ZVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCAoKSB7XHJcblxyXG4gICAgaWYgKHRoaXMuJHJlZnMuYm90dG9tKSB7XHJcbiAgICAgIHRoaXMuYm90dG9tTGluZUZvdW5kYXRpb24gPSBuZXcgTURDTGluZVJpcHBsZUZvdW5kYXRpb24oe1xyXG4gICAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5ib3R0b21DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuYm90dG9tQ2xhc3NlcywgY2xhc3NOYW1lKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICAgIHRoaXMuYm90dG9tQ2xhc3Nlcy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmJvdHRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcclxuICAgICAgICAgIHRoaXMuJHJlZnMuYm90dG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmJvdHRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXHJcbiAgICAgICAgfSxcclxuICAgICAgfSlcclxuICAgICAgdGhpcy5ib3R0b21MaW5lRm91bmRhdGlvbi5pbml0KClcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy4kcmVmcy5oZWxwKSB7XHJcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24oe1xyXG4gICAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmhlbHBDbGFzc2VzLCBjbGFzc05hbWUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuaGVscC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmhlbHAuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlQXR0cjogKG5hbWUpID0+IHtcclxuICAgICAgICAgIHRoaXMuJHJlZnMuaGVscC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldENvbnRlbnQ6ICggLypjb250ZW50Ki8pID0+IHtcclxuICAgICAgICAgIC8vIGhlbHAgdGV4dCBnZXQncyB1cGRhdGVkIGZyb20ge3toZWxwdGV4dH19XHJcbiAgICAgICAgICAvLyB0aGlzLiRyZWZzLmhlbHAudGV4dENvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5pbml0KClcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy4kcmVmcy5pY29uKSB7XHJcbiAgICAgIGlmICh0aGlzLmhhc0xlYWRpbmdJY29uKXtcclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgJ21kYy10ZXh0LWZpZWxkLS13aXRoLWxlYWRpbmctaWNvbicsIHRydWUpXHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNUcmFpbGluZ0ljb24pIHtcclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgJ21kYy10ZXh0LWZpZWxkLS13aXRoLXRyYWlsaW5nLWljb24nLCB0cnVlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmljb25Gb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uKHtcclxuICAgICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHRoaXMuJHJlZnMuaWNvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5pY29uLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm90aWZ5SWNvbkFjdGlvbjogKCkgPT4gdGhpcy4kZW1pdCgnaWNvbi1hY3Rpb24nKVxyXG4gICAgICB9KVxyXG4gICAgICB0aGlzLmljb25Gb3VuZGF0aW9uLmluaXQoKVxyXG4gICAgfSAgICBcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuJHJlZnMubGFiZWwpIHtcclxuICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uKHtcclxuICAgICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMubGFiZWxDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMubGFiZWxDbGFzc2VzLCBjbGFzc05hbWUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRXaWR0aDogKCkgPT4gdGhpcy4kcmVmcy5sYWJlbC5vZmZzZXRXaWR0aCxcclxuICAgICAgfSlcclxuICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB9ICAgIFxyXG5cclxuICAgIGlmICh0aGlzLiRyZWZzLm91dGxpbmUpIHtcclxuICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiA9IG5ldyBNRENUZXh0RmllbGRPdXRsaW5lRm91bmRhdGlvbih7XHJcbiAgICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZS5vZmZzZXRXaWR0aCxcclxuICAgICAgICBnZXRIZWlnaHQ6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZS5vZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgc2V0T3V0bGluZVBhdGhBdHRyOiAodmFsdWUpID0+IHtcclxuICAgICAgICAgIHRoaXMub3V0bGluZVBhdGhBdHRyID0gdmFsdWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZTogKHByb3BlcnR5TmFtZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgaWRsZU91dGxpbmVFbGVtZW50ID0gdGhpcy4kcmVmcy5vdXRsaW5lSWRsZTtcclxuICAgICAgICAgIGlmIChpZGxlT3V0bGluZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGlkbGVPdXRsaW5lRWxlbWVudClcclxuICAgICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pXHJcbiAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB9ICAgIFxyXG5cclxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUZXh0ZmllbGRGb3VuZGF0aW9uKHtcclxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxyXG4gICAgICB9LFxyXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpXHJcbiAgICAgIH0sXHJcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXHJcbiAgICAgIH0sXHJcbiAgICAgIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcclxuICAgICAgfSxcclxuICAgICAgaXNGb2N1c2VkOiAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJHJlZnMuaW5wdXRcclxuICAgICAgfSxcclxuICAgICAgaXNSdGw6ICgpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMucm9vdCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnLCAgICAgXHJcbiAgICAgIGRlYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuYm90dG9tKSB7XHJcbiAgICAgICAgICB0aGlzLmJvdHRvbS5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5ib3R0b20pIHtcclxuICAgICAgICAgIHRoaXMuYm90dG9tLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luOiAobm9ybWFsaXplZFgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5ib3R0b20pIHtcclxuICAgICAgICAgIHRoaXMuYm90dG9tLnNldFJpcHBsZUNlbnRlcihub3JtYWxpemVkWCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxyXG4gICAgICB9LFxyXG4gICAgICBkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXHJcbiAgICAgIH0sXHJcbiAgICAgIGdldE5hdGl2ZUlucHV0OiAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuaW5wdXRcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICB9LCB7XHJcbiAgICAgIGJvdHRvbUxpbmU6IHRoaXMuYm90dG9tTGluZUZvdW5kYXRpb24sXHJcbiAgICAgIGhlbHBlclRleHQ6IHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24sXHJcbiAgICAgIGljb246IHRoaXMuaWNvbkZvdW5kYXRpb24sXHJcbiAgICAgIGxhYmVsOiB0aGlzLmxhYmVsRm91bmRhdGlvbixcclxuICAgICAgb3V0bGluZTogdGhpcy5vdXRsaW5lRm91bmRhdGlvbixcclxuICAgIH0pXHJcblxyXG5cclxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcclxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlKVxyXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UmVxdWlyZWQodGhpcy5yZXF1aXJlZClcclxuICAgIGlmICh0eXBlb2YgdGhpcy52YWxpZCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsaWQodGhpcy52YWxpZClcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy50ZXh0Ym94KSB7XHJcbiAgICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcclxuICAgICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgICB9XHJcblxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5ib3R0b21MaW5lRm91bmRhdGlvbiAmJiB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiAmJiB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5pY29uRm91bmRhdGlvbiAmJiB0aGlzLmljb25Gb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5sYWJlbEZvdW5kYXRpb24gJiYgdGhpcy5sYWJlbEZvdW5kYXRpb24uZGVzdHJveSgpXHJcbiAgICB0aGlzLm91dGxpbmVGb3VuZGF0aW9uICYmIHRoaXMub3V0bGluZUZvdW5kYXRpb24uZGVzdHJveSgpXHJcbiAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZXN0cm95KClcclxuICB9XHJcbn1cclxuXHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGV4dEZpZWxkIGZyb20gJy4vbWRjLXRleHRmaWVsZC52dWUnXG5cbmV4cG9ydCB7bWRjVGV4dEZpZWxkfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVGV4dEZpZWxkXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWVsZW1lbnQgOnRhZz1cInRhZ1wiIFxuICAgIGNsYXNzPVwibWRjLXRoZW1lXCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tZWxlbWVudD5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuLi9iYXNlJ1xuXG5cbmNvbnN0IFRIRU1FX0NPTE9SUyA9IFtcbiAgJ3ByaW1hcnknLFxuICAnc2Vjb25kYXJ5JyxcbiAgJ2JhY2tncm91bmQnLFxuICAncHJpbWFyeS1saWdodCcsXG4gICdzZWNvbmRhcnktbGlnaHQnLFxuICAnc2Vjb25kYXJ5LWRhcmsnLFxuICAncHJpbWFyeS1kYXJrJ1xuXVxuXG5jb25zdCBUSEVNRV9TVFlMRVMgPSBbXG4gICd0ZXh0LXByaW1hcnknLFxuICAndGV4dC1zZWNvbmRhcnknLFxuICAndGV4dC1oaW50JyxcbiAgJ3RleHQtaWNvbicsXG4gICd0ZXh0LWRpc2FibGVkJ1xuXVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGhlbWUnLFxuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tRWxlbWVudFxuICB9LFxuICBwcm9wczoge1xuICAgIHRhZzoge3R5cGU6IFN0cmluZywgZGVmYXVsdDogJ2RpdicgfSxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmQ6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMgKCkge1xuICAgICAgbGV0IGNsYXNzZXMgPSB7fVxuXG4gICAgICBpZiAodGhpcy5jb2xvciAmJiBUSEVNRV9DT0xPUlMuaW5kZXhPZih0aGlzLmNvbG9yKSAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5jb2xvcn1gXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCAmJiBUSEVNRV9DT0xPUlMuaW5kZXhPZih0aGlzLmJhY2tncm91bmQpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5iYWNrZ3JvdW5kfS1iZ2BdID0gdHJ1ZVxuXG4gICAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX1NUWUxFUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXNbYG1kYy10aGVtZS0tJHt0aGlzLmNvbG9yfS1vbi0ke3RoaXMuYmFja2dyb3VuZH1gXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1RoZW1lIGZyb20gJy4vbWRjLXRoZW1lLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjVGhlbWVcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RoZW1lXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEZJWEVEOiAnbWRjLXRvb2xiYXItLWZpeGVkJyxcbiAgRklYRURfTEFTVFJPVzogJ21kYy10b29sYmFyLS1maXhlZC1sYXN0cm93LW9ubHknLFxuICBGSVhFRF9BVF9MQVNUX1JPVzogJ21kYy10b29sYmFyLS1maXhlZC1hdC1sYXN0LXJvdycsXG4gIFRPT0xCQVJfUk9XX0ZMRVhJQkxFOiAnbWRjLXRvb2xiYXItLWZsZXhpYmxlJyxcbiAgRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUjogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1kZWZhdWx0LWJlaGF2aW9yJyxcbiAgRkxFWElCTEVfTUFYOiAnbWRjLXRvb2xiYXItLWZsZXhpYmxlLXNwYWNlLW1heGltaXplZCcsXG4gIEZMRVhJQkxFX01JTjogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1zcGFjZS1taW5pbWl6ZWQnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRJVExFX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX190aXRsZScsXG4gIEZJUlNUX1JPV19TRUxFQ1RPUjogJy5tZGMtdG9vbGJhcl9fcm93OmZpcnN0LWNoaWxkJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDVG9vbGJhcjpjaGFuZ2UnLFxufTtcblxuZXhwb3J0IGNvbnN0IG51bWJlcnMgPSB7XG4gIE1BWF9USVRMRV9TSVpFOiAyLjEyNSxcbiAgTUlOX1RJVExFX1NJWkU6IDEuMjUsXG4gIFRPT0xCQVJfUk9XX0hFSUdIVDogNjQsXG4gIFRPT0xCQVJfUk9XX01PQklMRV9IRUlHSFQ6IDU2LFxuICBUT09MQkFSX01PQklMRV9CUkVBS1BPSU5UOiA2MDAsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1Rvb2xiYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0Vmlld3BvcnRXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0T2Zmc2V0SGVpZ2h0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiB7ZmxleGlibGVFeHBhbnNpb25SYXRpbzogbnVtYmVyfSAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50OiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUb29sYmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmNoZWNrUm93SGVpZ2h0XygpO1xuICAgIHRoaXMuc2Nyb2xsSGFuZGxlcl8gPSAoKSA9PiB0aGlzLnVwZGF0ZVRvb2xiYXJTdHlsZXNfKCk7XG4gICAgdGhpcy5jaGVja1Jvd0hlaWdodEZyYW1lXyA9IDA7XG4gICAgdGhpcy5zY3JvbGxGcmFtZV8gPSAwO1xuICAgIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfID0ge1xuICAgICAgdG9vbGJhclJvd0hlaWdodDogMCxcbiAgICAgIC8vIENhbGN1bGF0ZWQgSGVpZ2h0IHJhdGlvLiBXZSB1c2UgcmF0aW8gdG8gY2FsY3VsYXRlIGNvcnJlc3BvbmRpbmcgaGVpZ2h0cyBpbiByZXNpemUgZXZlbnQuXG4gICAgICB0b29sYmFyUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiB0b29sYmFyIGhlaWdodCB0byByb3cgaGVpZ2h0XG4gICAgICBmbGV4aWJsZUV4cGFuc2lvblJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgZmxleGlibGUgc3BhY2UgaGVpZ2h0IHRvIHJvdyBoZWlnaHRcbiAgICAgIG1heFRyYW5zbGF0ZVlSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIG1heCB0b29sYmFyIG1vdmUgdXAgZGlzdGFuY2UgdG8gcm93IGhlaWdodFxuICAgICAgc2Nyb2xsVGhyZXNob2xkUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiBtYXggc2Nyb2xsVG9wIHRoYXQgd2Ugc2hvdWxkIGxpc3RlbiB0byB0byByb3cgaGVpZ2h0XG4gICAgICAvLyBEZXJpdmVkIEhlaWdodHMgYmFzZWQgb24gdGhlIGFib3ZlIGtleSByYXRpb3MuXG4gICAgICB0b29sYmFySGVpZ2h0OiAwLFxuICAgICAgZmxleGlibGVFeHBhbnNpb25IZWlnaHQ6IDAsIC8vIEZsZXhpYmxlIHJvdyBtaW51cyB0b29sYmFyIGhlaWdodCAoZGVyaXZlZClcbiAgICAgIG1heFRyYW5zbGF0ZVlEaXN0YW5jZTogMCwgLy8gV2hlbiB0b29sYmFyIG9ubHkgZml4IGxhc3Qgcm93IChkZXJpdmVkKVxuICAgICAgc2Nyb2xsVGhyZXNob2xkOiAwLFxuICAgIH07XG4gICAgLy8gVG9vbGJhciBmaXhlZCBiZWhhdmlvclxuICAgIC8vIElmIHRvb2xiYXIgaXMgZml4ZWRcbiAgICB0aGlzLmZpeGVkXyA9IGZhbHNlO1xuICAgIC8vIElmIGZpeGVkIGlzIHRhcmdldGVkIG9ubHkgYXQgdGhlIGxhc3Qgcm93XG4gICAgdGhpcy5maXhlZExhc3Ryb3dfID0gZmFsc2U7XG4gICAgLy8gVG9vbGJhciBmbGV4aWJsZSBiZWhhdmlvclxuICAgIC8vIElmIHRoZSBmaXJzdCByb3cgaXMgZmxleGlibGVcbiAgICB0aGlzLmhhc0ZsZXhpYmxlUm93XyA9IGZhbHNlO1xuICAgIC8vIElmIHVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgIHRoaXMudXNlRmxleERlZmF1bHRCZWhhdmlvcl8gPSBmYWxzZTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5maXhlZF8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRUQpO1xuICAgIHRoaXMuZml4ZWRMYXN0cm93XyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRF9MQVNUUk9XKSAmIHRoaXMuZml4ZWRfO1xuICAgIHRoaXMuaGFzRmxleGlibGVSb3dfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlRPT0xCQVJfUk9XX0ZMRVhJQkxFKTtcbiAgICBpZiAodGhpcy5oYXNGbGV4aWJsZVJvd18pIHtcbiAgICAgIHRoaXMudXNlRmxleERlZmF1bHRCZWhhdmlvcl8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUik7XG4gICAgfVxuICAgIHRoaXMuaW5pdEtleVJhdGlvXygpO1xuICAgIHRoaXMuc2V0S2V5SGVpZ2h0c18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cbiAgdXBkYXRlQWRqdXN0RWxlbWVudFN0eWxlcygpIHtcbiAgICBpZiAodGhpcy5maXhlZF8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQoJ21hcmdpbi10b3AnLCBgJHt0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhckhlaWdodH1weGApO1xuICAgIH1cbiAgfVxuXG4gIGdldEZsZXhpYmxlRXhwYW5zaW9uUmF0aW9fKHNjcm9sbFRvcCkge1xuICAgIC8vIFRvIHByZXZlbnQgZGl2aXNpb24gYnkgemVybyB3aGVuIHRoZXJlIGlzIG5vIGZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0XG4gICAgY29uc3QgZGVsdGEgPSAwLjAwMDE7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIDEgLSBzY3JvbGxUb3AgLyAodGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ICsgZGVsdGEpKTtcbiAgfVxuXG4gIGNoZWNrUm93SGVpZ2h0XygpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmNoZWNrUm93SGVpZ2h0RnJhbWVfKTtcbiAgICB0aGlzLmNoZWNrUm93SGVpZ2h0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuc2V0S2V5SGVpZ2h0c18oKSk7XG4gIH1cblxuICBzZXRLZXlIZWlnaHRzXygpIHtcbiAgICBjb25zdCBuZXdUb29sYmFyUm93SGVpZ2h0ID0gdGhpcy5nZXRSb3dIZWlnaHRfKCk7XG4gICAgaWYgKG5ld1Rvb2xiYXJSb3dIZWlnaHQgIT09IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0KSB7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodCA9IG5ld1Rvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhckhlaWdodCA9IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCA9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvblJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWURpc3RhbmNlID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlSYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZCA9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGRSYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy51cGRhdGVBZGp1c3RFbGVtZW50U3R5bGVzKCk7XG4gICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJTdHlsZXNfKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlVG9vbGJhclN0eWxlc18oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxGcmFtZV8pO1xuICAgIHRoaXMuc2Nyb2xsRnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRTY3JvbGxZKCk7XG4gICAgICBjb25zdCBoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkID0gdGhpcy5zY3JvbGxlZE91dE9mVGhyZXNob2xkXyhzY3JvbGxUb3ApO1xuXG4gICAgICBpZiAoaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZCAmJiB0aGlzLmV4ZWN1dGVkTGFzdENoYW5nZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmbGV4aWJsZUV4cGFuc2lvblJhdGlvID0gdGhpcy5nZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyhzY3JvbGxUb3ApO1xuXG4gICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKTtcbiAgICAgIGlmICh0aGlzLmZpeGVkTGFzdHJvd18pIHtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sYmFyRml4ZWRTdGF0ZV8oc2Nyb2xsVG9wKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0ZsZXhpYmxlUm93Xykge1xuICAgICAgICB0aGlzLnVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18oZmxleGlibGVFeHBhbnNpb25SYXRpbyk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVkTGFzdENoYW5nZV8gPSBoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2Uoe2ZsZXhpYmxlRXhwYW5zaW9uUmF0aW86IGZsZXhpYmxlRXhwYW5zaW9uUmF0aW99KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNjcm9sbGVkT3V0T2ZUaHJlc2hvbGRfKHNjcm9sbFRvcCkge1xuICAgIHJldHVybiBzY3JvbGxUb3AgPiB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkO1xuICB9XG5cbiAgaW5pdEtleVJhdGlvXygpIHtcbiAgICBjb25zdCB0b29sYmFyUm93SGVpZ2h0ID0gdGhpcy5nZXRSb3dIZWlnaHRfKCk7XG4gICAgY29uc3QgZmlyc3RSb3dNYXhSYXRpbyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0KCkgLyB0b29sYmFyUm93SGVpZ2h0O1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldEhlaWdodCgpIC8gdG9vbGJhclJvd0hlaWdodDtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25SYXRpbyA9IGZpcnN0Um93TWF4UmF0aW8gLSAxO1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZUmF0aW8gPVxuICAgICAgdGhpcy5maXhlZExhc3Ryb3dfID8gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyAtIGZpcnN0Um93TWF4UmF0aW8gOiAwO1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGRSYXRpbyA9XG4gICAgICAodGhpcy5maXhlZExhc3Ryb3dfID8gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyA6IGZpcnN0Um93TWF4UmF0aW8pIC0gMTtcbiAgfVxuXG4gIGdldFJvd0hlaWdodF8oKSB7XG4gICAgY29uc3QgYnJlYWtwb2ludCA9IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuVE9PTEJBUl9NT0JJTEVfQlJFQUtQT0lOVDtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRWaWV3cG9ydFdpZHRoKCkgPCBicmVha3BvaW50ID9cbiAgICAgIE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVCA6IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuVE9PTEJBUl9ST1dfSEVJR0hUO1xuICB9XG5cbiAgdXBkYXRlVG9vbGJhckZsZXhpYmxlU3RhdGVfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUFYKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUlOKTtcbiAgICBpZiAoZmxleGlibGVFeHBhbnNpb25SYXRpbyA9PT0gMSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01BWCk7XG4gICAgfSBlbHNlIGlmIChmbGV4aWJsZUV4cGFuc2lvblJhdGlvID09PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUlOKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUb29sYmFyRml4ZWRTdGF0ZV8oc2Nyb2xsVG9wKSB7XG4gICAgY29uc3QgdHJhbnNsYXRlRGlzdGFuY2UgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihcbiAgICAgIHNjcm9sbFRvcCAtIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCxcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZRGlzdGFuY2UpKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWSgkey10cmFuc2xhdGVEaXN0YW5jZX1weClgKTtcblxuICAgIGlmICh0cmFuc2xhdGVEaXN0YW5jZSA9PT0gdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlEaXN0YW5jZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEX0FUX0xBU1RfUk9XKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEX0FUX0xBU1RfUk9XKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVGbGV4aWJsZVJvd0VsZW1lbnRTdHlsZXNfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pIHtcbiAgICBpZiAodGhpcy5maXhlZF8pIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCAqIGZsZXhpYmxlRXhwYW5zaW9uUmF0aW87XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50KCdoZWlnaHQnLFxuICAgICAgICBgJHtoZWlnaHQgKyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodH1weGApO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50U3R5bGVzRGVmYXVsdEJlaGF2aW9yXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVFbGVtZW50U3R5bGVzRGVmYXVsdEJlaGF2aW9yXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKSB7XG4gICAgY29uc3QgbWF4VGl0bGVTaXplID0gTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5NQVhfVElUTEVfU0laRTtcbiAgICBjb25zdCBtaW5UaXRsZVNpemUgPSBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLk1JTl9USVRMRV9TSVpFO1xuICAgIGNvbnN0IGN1cnJlbnRUaXRsZVNpemUgPSAobWF4VGl0bGVTaXplIC0gbWluVGl0bGVTaXplKSAqIGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gKyBtaW5UaXRsZVNpemU7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9yVGl0bGVFbGVtZW50KCdmb250LXNpemUnLCBgJHtjdXJyZW50VGl0bGVTaXplfXJlbWApO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhlYWRlciBjbGFzcz1cIm1kYy10b29sYmFyLXdyYXBwZXJcIj5cbiAgICA8IS0tVG9vbGJhci0tPlxuICAgIDxkaXYgcmVmPVwicm9vdFwiIDpjbGFzcz1cInJvb3RDbGFzc2VzXCIgOnN0eWxlPVwicm9vdFN0eWxlc1wiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG4gICAgPCEtLSBGaXhlZCBBZGp1c3QgRWxlbWVudC0tPlxuICAgIDxkaXYgcmVmPVwiZml4ZWQtYWRqdXN0XCIgY2xhc3M9XCJtZGMtdG9vbGJhci1maXhlZC1hZGp1c3RcIiBcbiAgICAgIDpzdHlsZT1cImFkanVzdFN0eWxlc1wiXG4gICAgICB2LWlmPVwiZml4ZWQgfHwgd2F0ZXJmYWxsIHx8IGZpeGVkTGFzdHJvd1wiPjwvZGl2PlxuICA8L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBNRENUb29sYmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdG9vbGJhci9mb3VuZGF0aW9uJ1xuICBpbXBvcnQgKiBhcyB1dGlsIGZyb20gJ0BtYXRlcmlhbC90b29sYmFyL3V0aWwnXG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdtZGMtdG9vbGJhcicsXG4gICAgcHJvcHM6IHtcbiAgICAgICdmaXhlZCc6IEJvb2xlYW4sXG4gICAgICAnd2F0ZXJmYWxsJzogQm9vbGVhbixcbiAgICAgICdmaXhlZC1sYXN0cm93JzogQm9vbGVhbixcbiAgICAgICdmbGV4aWJsZSc6IEJvb2xlYW4sXG4gICAgICAnZmxleGlibGUtZGVmYXVsdCc6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9XG4gICAgfSxcbiAgICBkYXRhICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvb3RDbGFzc2VzOiB7XG4gICAgICAgICAgJ21kYy10b29sYmFyJzogdHJ1ZSxcbiAgICAgICAgICAnbWRjLXRvb2xiYXItLWZpeGVkJzogdGhpcy5maXhlZCB8fCB0aGlzLndhdGVyZmFsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRMYXN0cm93LFxuICAgICAgICAgICdtZGMtdG9vbGJhci0td2F0ZXJmYWxsJzogdGhpcy53YXRlcmZhbGwsXG4gICAgICAgICAgJ21kYy10b29sYmFyLS1maXhlZC1sYXN0cm93LW9ubHknOiB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgICAnbWRjLXRvb2xiYXItLWZsZXhpYmxlJzogdGhpcy5mbGV4aWJsZSxcbiAgICAgICAgICAnbWRjLXRvb2xiYXItLWZsZXhpYmxlLWRlZmF1bHQtYmVoYXZpb3InOiB0aGlzLmZsZXhpYmxlICYmXG4gICAgICAgICAgICB0aGlzLmZsZXhpYmxlRGVmYXVsdFxuICAgICAgICB9LFxuICAgICAgICByb290U3R5bGVzOiB7fSxcbiAgICAgICAgYWRqdXN0U3R5bGVzOiB7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgdG9wIG1hcmdpbiBjb2xsYXBzZSB3aXRoIDphZnRlciBlbFxuICAgICAgICAgIC8vIDAuMSBweCBzaG91bGQgYmUgcm91bmRlZCB0byAwcHhcbiAgICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHRyaWNrXG4gICAgICAgICAgLy8gaGVpZ2h0OiAnMC4xcHgnXG4gICAgICAgIH0sXG4gICAgICAgIGZvdW5kYXRpb246IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uKHtcbiAgICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgIH0sXG4gICAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBnZXRWaWV3cG9ydFdpZHRoOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIGdldFZpZXdwb3J0U2Nyb2xsWTogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T2Zmc2V0SGVpZ2h0OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5vZmZzZXRIZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0OiAoKSA9PiB7XG4gICAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1IpXG4gICAgICAgICAgcmV0dXJuIChlbCkgPyBlbC5vZmZzZXRIZWlnaHQgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZ5Q2hhbmdlOiAoZXZ0RGF0YSkgPT4ge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2dERhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIHNldFN0eWxlOiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdFN0eWxlcywgcHJvcGVydHksIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZUZvclRpdGxlRWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBlbCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLnN0cmluZ3MuVElUTEVfU0VMRUNUT1IpXG4gICAgICAgICAgaWYgKGVsKSBlbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1IpXG4gICAgICAgICAgaWYgKGVsKSBlbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldFN0eWxlRm9yRml4ZWRBZGp1c3RFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMuYWRqdXN0U3R5bGVzLCBwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLXRvb2xiYXItcm93IG1kYy10b29sYmFyX19yb3dcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXJvdydcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy10b29sYmFyLXNlY3Rpb24gbWRjLXRvb2xiYXJfX3NlY3Rpb25cIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXItc2VjdGlvbicsXG4gIHByb3BzOiB7XG4gICAgJ2FsaWduLXN0YXJ0JzogQm9vbGVhbixcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnc2hyaW5rLXRvLWZpdCc6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10b29sYmFyX19zZWN0aW9uLS1hbGlnbi1zdGFydCc6IHRoaXMuYWxpZ25TdGFydCxcbiAgICAgICAgJ21kYy10b29sYmFyX19zZWN0aW9uLS1hbGlnbi1lbmQnOiB0aGlzLmFsaWduRW5kLFxuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLXNocmluay10by1maXQnOiB0aGlzLnNocmlua1RvRml0XG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGEgY2xhc3M9XCJtZGMtdG9vbGJhci1tZW51LWljb24gbWRjLXRvb2xiYXJfX21lbnUtaWNvblwiXG4gICAgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxuICAgIDxzbG90Pnt7aWNvbn19PC9zbG90PlxuICA8L2E+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW59IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLW1lbnUtaWNvbicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjoge3R5cGU6IFN0cmluZywgJ2RlZmF1bHQnOiBcIm1lbnVcIn1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGEgY2xhc3M9XCJtZGMtdG9vbGJhci10aXRsZSBtZGMtdG9vbGJhcl9fdGl0bGVcIiBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2E+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW59IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXRpdGxlJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluXVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxhIGNsYXNzPVwibWRjLXRvb2xiYXItaWNvbiBtZGMtdG9vbGJhcl9faWNvblwiIFxuICAgIDpjbGFzcz1cInsnbWF0ZXJpYWwtaWNvbnMnOiEhaWNvbn1cIlxuICAgIEBjbGljaz1cImRpc3BhdGNoRXZlbnRcIj5cbiAgICA8c2xvdD57e2ljb259fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1pY29uJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluXSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVG9vbGJhciBmcm9tICcuL21kYy10b29sYmFyLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyUm93IGZyb20gJy4vbWRjLXRvb2xiYXItcm93LnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyU2VjdGlvbiBmcm9tICcuL21kYy10b29sYmFyLXNlY3Rpb24udnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJNZW51SWNvbiBmcm9tICcuL21kYy10b29sYmFyLW1lbnUtaWNvbi52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclRpdGxlIGZyb20gJy4vbWRjLXRvb2xiYXItdGl0bGUudnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJJY29uIGZyb20gJy4vbWRjLXRvb2xiYXItaWNvbi52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1Rvb2xiYXIsXG4gIG1kY1Rvb2xiYXJSb3csXG4gIG1kY1Rvb2xiYXJTZWN0aW9uLFxuICBtZGNUb29sYmFyTWVudUljb24sXG4gIG1kY1Rvb2xiYXJUaXRsZSxcbiAgbWRjVG9vbGJhckljb25cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1Rvb2xiYXIsXG4gIG1kY1Rvb2xiYXJSb3csXG4gIG1kY1Rvb2xiYXJTZWN0aW9uLFxuICBtZGNUb29sYmFyTWVudUljb24sXG4gIG1kY1Rvb2xiYXJUaXRsZSxcbiAgbWRjVG9vbGJhckljb25cbn0pXG5cbiIsImNvbnN0IHR5cG9zID0gW1xuICAnZGlzcGxheTQnLCBcbiAgJ2Rpc3BsYXkzJywgXG4gICdkaXNwbGF5MicsIFxuICAnZGlzcGxheTEnLCBcbiAgJ2hlYWRsaW5lJyxcbiAgJ3RpdGxlJyxcbiAgJ3N1YmhlYWRpbmcxJyxcbiAgJ3N1YmhlYWRpbmcyJyxcbiAgJ2JvZHkxJyxcbiAgJ2JvZHkyJyxcbiAgJ2NhcHRpb24nLFxuICAnYnV0dG9uJ1xuXVxuXG5leHBvcnQgY29uc3QgbWRjVHlwb01peGluID0gKG5hbWUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXIgKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRoaXMudGFnLCB7XG4gICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAnbWRjLXR5cG8nOiB0cnVlLFxuICAgICAgICAgIFtuYW1lXTogdHJ1ZSxcbiAgICAgICAgICBbYG1kYy10eXBvZ3JhcGh5LS0ke3RoaXMudHlwb31gXTogdHJ1ZSxcbiAgICAgICAgICAnbWRjLXR5cG9ncmFwaHktLWFkanVzdC1tYXJnaW4nOiB0aGlzLmFkanVzdE1hcmdpblxuICAgICAgICB9LFxuICAgICAgICAnYXR0cnMnOiB0aGlzLiRhdHRycyxcbiAgICAgICAgJ29uJzogdGhpcy4kbGlzdGVuZXJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdCApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZGNUeXBvUHJvcE1peGluKGRlZmF1bHRUYWcsIGRlZmF1bHRUeXBvLCB2YWxpZFR5cG9zKSB7XG4gIHJldHVybiAge1xuICAgIHByb3BzOiB7XG4gICAgICAndGFnJzogeyBcbiAgICAgICAgdHlwZTogU3RyaW5nLCBcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdFRhZyBcbiAgICAgIH0sXG4gICAgICAndHlwbyc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VHlwbyxcbiAgICAgICAgdmFsaWRhdG9yOiAgKHZhbHVlKSA9PiB2YWxpZFR5cG9zLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgfSxcbiAgICAgICdhZGp1c3QtbWFyZ2luJzogeyBcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RleHRTZWN0aW9uID0ge1xuICBuYW1lOiAnbWRjLXRleHQtc2VjdGlvbicsXG4gIHByb3BzOiB7XG4gICAgJ3RhZyc6IHtcbiAgICAgIHR5cGU6IFN0cmluZywgXG4gICAgICBkZWZhdWx0OiAnc2VjdGlvbicgXG4gICAgfSxcbiAgfSxcbiAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGhpcy50YWcsIHtcbiAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgJ21kYy10eXBvZ3JhcGh5JzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LXNlY3Rpb24nOiB0cnVlLFxuICAgICAgfSxcbiAgICAgICdhdHRycyc6IHRoaXMuJGF0dHJzLFxuICAgICAgJ29uJzogdGhpcy4kbGlzdGVuZXJzXG4gICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCApXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RleHQgPSB7XG4gIG5hbWU6ICdtZGMtdGV4dCcsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLXRleHQnKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbigncCcsICdib2R5MScsIHR5cG9zKVxuICBdLFxufVxuXG5leHBvcnQgY29uc3QgbWRjRGlzcGxheSA9IHtcbiAgbmFtZTogJ21kYy1kaXNwbGF5JyxcbiAgbWl4aW5zOiBbIFxuICAgIG1kY1R5cG9NaXhpbignbWRjLWRpc3BsYXknKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDEnLCAnZGlzcGxheTEnLCBbJ2Rpc3BsYXk0JywgJ2Rpc3BsYXkzJywgJ2Rpc3BsYXkyJywgJ2Rpc3BsYXkxJ10pXSxcbn1cblxuZXhwb3J0IGNvbnN0IG1kY0hlYWRsaW5lID0ge1xuICBuYW1lOiAnbWRjLWhlYWRsaW5lJyxcbiAgbWl4aW5zOiBbIFxuICAgIG1kY1R5cG9NaXhpbignbWRjLWhlYWRsaW5lJyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gyJywgJ2hlYWRsaW5lJywgWydoZWFkbGluZSddKV0sXG59XG5cbmV4cG9ydCBjb25zdCBtZGNUaXRsZSA9IHtcbiAgbmFtZTogJ21kYy10aXRsZScsXG4gIG1peGluczogWyBcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy10aXRsZScpLCBcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoMycsICd0aXRsZScsIFsndGl0bGUnXSldLFxufVxuXG5leHBvcnQgY29uc3QgbWRjU3ViSGVhZGluZyA9IHtcbiAgbmFtZTogJ21kYy1zdWJoZWFkaW5nJyxcbiAgbWl4aW5zOiBbIFxuICAgIG1kY1R5cG9NaXhpbignbWRjLXN1YmhlYWRpbmcnKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDQnLCAnc3ViaGVhZGluZzInLCBbJ3N1YmhlYWRpbmcxJywgJ3N1YmhlYWRpbmcyJ10pXSxcbn1cblxuZXhwb3J0IGNvbnN0ICBtZGNCb2R5ID0ge1xuICBuYW1lOiAnbWRjLWJvZHknLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1ib2R5JyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ3AnLCAnYm9keTEnLCBbJ2JvZHkxJywgJ2JvZHkyJ10pXSxcbn1cblxuZXhwb3J0IGNvbnN0IG1kY0NhcHRpb24gPSB7XG4gIG5hbWU6ICdtZGMtY2FwdGlvbicsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLWNhcHRpb24nKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbignc3BhbicsICdjYXB0aW9uJywgWydjYXB0aW9uJ10pXSxcbn1cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7ICBcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufSBmcm9tICcuL21kYy10eXBvZ3JhcGh5LmpzJ1xuXG5leHBvcnQge1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59KVxuIiwiLy9cbi8vIHZ1ZSBQbHVnSW5cbi8vXG5pbXBvcnQgVnVlTURDQnV0dG9uIGZyb20gJy4vYnV0dG9uJ1xuaW1wb3J0IFZ1ZU1EQ0NhcmQgZnJvbSAnLi9jYXJkJ1xuaW1wb3J0IFZ1ZU1EQ0NoZWNrYm94IGZyb20gJy4vY2hlY2tib3gnXG5pbXBvcnQgVnVlTURDQ2hpcFNldCBmcm9tICcuL2NoaXBzJ1xuaW1wb3J0IFZ1ZU1EQ0RpYWxvZyBmcm9tICcuL2RpYWxvZydcbmltcG9ydCBWdWVNRENEcmF3ZXIgZnJvbSAnLi9kcmF3ZXInXG5pbXBvcnQgVnVlTURDRWxldmF0aW9uIGZyb20gJy4vZWxldmF0aW9uJ1xuaW1wb3J0IFZ1ZU1EQ0ZhYiBmcm9tICcuL2ZhYidcbmltcG9ydCBWdWVNRENHcmlkTGlzdCBmcm9tICcuL2dyaWQtbGlzdCdcbmltcG9ydCBWdWVNRENJY29uIGZyb20gJy4vaWNvbidcbmltcG9ydCBWdWVNRENJY29uVG9nZ2xlIGZyb20gJy4vaWNvbi10b2dnbGUnXG5pbXBvcnQgVnVlTURDTGF5b3V0QXBwIGZyb20gJy4vbGF5b3V0LWFwcCdcbmltcG9ydCBWdWVNRENMYXlvdXRHcmlkIGZyb20gJy4vbGF5b3V0LWdyaWQnXG5pbXBvcnQgVnVlTURDTGluZWFyUHJvZ3Jlc3MgZnJvbSAnLi9saW5lYXItcHJvZ3Jlc3MnXG5pbXBvcnQgVnVlTURDTGlzdCBmcm9tICcuL2xpc3QnXG5pbXBvcnQgVnVlTURDTWVudSBmcm9tICcuL21lbnUnXG5pbXBvcnQgVnVlTURDUmFkaW8gZnJvbSAnLi9yYWRpbydcbmltcG9ydCBWdWVNRENSaXBwbGUgZnJvbSAnLi9yaXBwbGUnXG5pbXBvcnQgVnVlTURDU2VsZWN0IGZyb20gJy4vc2VsZWN0J1xuaW1wb3J0IFZ1ZU1EQ1NsaWRlciBmcm9tICcuL3NsaWRlcidcbmltcG9ydCBWdWVNRENTbmFja2JhciBmcm9tICcuL3NuYWNrYmFyJ1xuaW1wb3J0IFZ1ZU1EQ1N3aXRjaCBmcm9tICcuL3N3aXRjaCdcbmltcG9ydCBWdWVNRENUYWJzIGZyb20gJy4vdGFicydcbmltcG9ydCBWdWVNRENUZXh0ZmllbGQgZnJvbSAnLi90ZXh0ZmllbGQnXG5pbXBvcnQgVnVlTURDVGhlbWUgZnJvbSAnLi90aGVtZSdcbmltcG9ydCBWdWVNRENUb29sYmFyIGZyb20gJy4vdG9vbGJhcidcbmltcG9ydCBWdWVNRENUeXBvZ3JhcGh5IGZyb20gJy4vdHlwb2dyYXBoeSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uOiAnX19WRVJTSU9OX18nLFxuICBpbnN0YWxsICAodm0pIHtcbiAgICB2bS51c2UoVnVlTURDQnV0dG9uKVxuICAgIHZtLnVzZShWdWVNRENDYXJkKVxuICAgIHZtLnVzZShWdWVNRENDaGVja2JveClcbiAgICB2bS51c2UoVnVlTURDQ2hpcFNldClcbiAgICB2bS51c2UoVnVlTURDRGlhbG9nKVxuICAgIHZtLnVzZShWdWVNRENEcmF3ZXIpXG4gICAgdm0udXNlKFZ1ZU1EQ0VsZXZhdGlvbilcbiAgICB2bS51c2UoVnVlTURDRmFiKVxuICAgIHZtLnVzZShWdWVNRENHcmlkTGlzdClcbiAgICB2bS51c2UoVnVlTURDSWNvbilcbiAgICB2bS51c2UoVnVlTURDSWNvblRvZ2dsZSlcbiAgICB2bS51c2UoVnVlTURDTGF5b3V0QXBwKVxuICAgIHZtLnVzZShWdWVNRENMYXlvdXRHcmlkKVxuICAgIHZtLnVzZShWdWVNRENMaW5lYXJQcm9ncmVzcylcbiAgICB2bS51c2UoVnVlTURDTGlzdClcbiAgICB2bS51c2UoVnVlTURDTWVudSlcbiAgICB2bS51c2UoVnVlTURDUmFkaW8pXG4gICAgdm0udXNlKFZ1ZU1EQ1JpcHBsZSlcbiAgICB2bS51c2UoVnVlTURDU2VsZWN0KVxuICAgIHZtLnVzZShWdWVNRENTbGlkZXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1NuYWNrYmFyKVxuICAgIHZtLnVzZShWdWVNRENTd2l0Y2gpXG4gICAgdm0udXNlKFZ1ZU1EQ1RhYnMpXG4gICAgdm0udXNlKFZ1ZU1EQ1RleHRmaWVsZClcbiAgICB2bS51c2UoVnVlTURDVGhlbWUpXG4gICAgdm0udXNlKFZ1ZU1EQ1Rvb2xiYXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1R5cG9ncmFwaHkpXG4gIH1cbn1cbiIsImltcG9ydCAnLi9zdHlsZXMuc2NzcydcbmltcG9ydCB7YXV0b0luaXR9IGZyb20gJy4vYmFzZSdcbmltcG9ydCBwbHVnaW4gZnJvbSAnLi9pbmRleC5qcydcbmV4cG9ydCBkZWZhdWx0IHBsdWdpblxuXG5hdXRvSW5pdChwbHVnaW4pXG4iXSwibmFtZXMiOlsiYXV0b0luaXQiLCJwbHVnaW4iLCJfVnVlIiwid2luZG93IiwiVnVlIiwiZ2xvYmFsIiwidXNlIiwiQmFzZVBsdWdpbiIsImNvbXBvbmVudHMiLCJ2bSIsImtleSIsImNvbXBvbmVudCIsIm5hbWUiLCJDdXN0b21FbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJwcm9wcyIsImlzIiwidGFnIiwiZGF0YSIsImNoaWxkcmVuIiwiQ3VzdG9tRWxlbWVudE1peGluIiwiQ3VzdG9tTGluayIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwiT2JqZWN0IiwiaCIsImVsZW1lbnQiLCJiYWJlbEhlbHBlcnMuZXh0ZW5kcyIsImxpbmsiLCJwYXJlbnQiLCIkcm91dGVyIiwiJHJvb3QiLCIkb3B0aW9ucyIsIm9uIiwiY2xpY2siLCJuYXRpdmVPbiIsIkN1c3RvbUxpbmtNaXhpbiIsIkJvb2xlYW4iLCJ0byIsImV4YWN0IiwiYXBwZW5kIiwicmVwbGFjZSIsImFjdGl2ZUNsYXNzIiwiZXhhY3RBY3RpdmVDbGFzcyIsImVtaXRDdXN0b21FdmVudCIsImVsIiwiZXZ0VHlwZSIsImV2dERhdGEiLCJzaG91bGRCdWJibGUiLCJldnQiLCJDdXN0b21FdmVudCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tQnV0dG9uIiwiYXR0cnMiLCJyb2xlIiwiaHJlZiIsIkN1c3RvbUJ1dHRvbk1peGluIiwiZXh0cmFjdEljb25Qcm9wIiwiaWNvblByb3AiLCJBcnJheSIsInJlZHVjZSIsInJlc3VsdCIsInZhbHVlIiwiY2xhc3NOYW1lIiwic3BsaXQiLCJ0ZXh0Q29udGVudCIsIkRpc3BhdGNoRXZlbnRNaXhpbiIsIiRlbWl0IiwiZXZlbnQiLCJ0YXJnZXQiLCJldmVudFRhcmdldCIsImFyZ3MiLCJldmVudEFyZ3MiLCJEaXNwYXRjaEZvY3VzTWl4aW4iLCJoYXNGb2N1cyIsIl9hY3RpdmUiLCJkaXNwYXRjaEZvY3VzRXZlbnQiLCJzZXRUaW1lb3V0IiwiJGVsIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uRm9jdXNFdmVudCIsIm9uQmx1ckV2ZW50Iiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiTURDRm91bmRhdGlvbiIsImFkYXB0ZXIiLCJhZGFwdGVyXyIsIk1EQ1JpcHBsZUFkYXB0ZXIiLCJoYW5kbGVyIiwidmFyTmFtZSIsImNzc0NsYXNzZXMiLCJzdHJpbmdzIiwibnVtYmVycyIsInN1cHBvcnRzQ3NzVmFyaWFibGVzXyIsInN1cHBvcnRzUGFzc2l2ZV8iLCJkZXRlY3RFZGdlUHNldWRvVmFyQnVnIiwid2luZG93T2JqIiwibm9kZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiaGFzUHNldWRvVmFyQnVnIiwiYm9yZGVyVG9wU3R5bGUiLCJyZW1vdmUiLCJzdXBwb3J0c0Nzc1ZhcmlhYmxlcyIsImZvcmNlUmVmcmVzaCIsInN1cHBvcnRzRnVuY3Rpb25QcmVzZW50IiwiQ1NTIiwic3VwcG9ydHMiLCJleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIiwid2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzIiwiYXBwbHlQYXNzaXZlIiwiZ2xvYmFsT2JqIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiZSIsImdldE1hdGNoZXNQcm9wZXJ0eSIsIkhUTUxFbGVtZW50UHJvdG90eXBlIiwiZmlsdGVyIiwicCIsInBvcCIsImdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyIsImV2IiwicGFnZU9mZnNldCIsImNsaWVudFJlY3QiLCJ4IiwieSIsImRvY3VtZW50WCIsImxlZnQiLCJkb2N1bWVudFkiLCJ0b3AiLCJub3JtYWxpemVkWCIsIm5vcm1hbGl6ZWRZIiwiY2hhbmdlZFRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiQUNUSVZBVElPTl9FVkVOVF9UWVBFUyIsIlBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiYWN0aXZhdGVkVGFyZ2V0cyIsIk1EQ1JpcHBsZUZvdW5kYXRpb24iLCJkZWZhdWx0QWRhcHRlciIsImxheW91dEZyYW1lXyIsImZyYW1lXyIsIndpZHRoIiwiaGVpZ2h0IiwiYWN0aXZhdGlvblN0YXRlXyIsImRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfIiwiaW5pdGlhbFNpemVfIiwibWF4UmFkaXVzXyIsImFjdGl2YXRlSGFuZGxlcl8iLCJhY3RpdmF0ZV8iLCJkZWFjdGl2YXRlSGFuZGxlcl8iLCJkZWFjdGl2YXRlXyIsImZvY3VzSGFuZGxlcl8iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZGRDbGFzcyIsIkJHX0ZPQ1VTRUQiLCJibHVySGFuZGxlcl8iLCJyZW1vdmVDbGFzcyIsInJlc2l6ZUhhbmRsZXJfIiwibGF5b3V0IiwidW5ib3VuZGVkQ29vcmRzXyIsImZnU2NhbGVfIiwiYWN0aXZhdGlvblRpbWVyXyIsImZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyIsImFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8iLCJhY3RpdmF0aW9uVGltZXJDYWxsYmFja18iLCJydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8iLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudF8iLCJicm93c2VyU3VwcG9ydHNDc3NWYXJzIiwiaXNTdXBwb3J0ZWRfIiwicmVnaXN0ZXJSb290SGFuZGxlcnNfIiwiUk9PVCIsIlVOQk9VTkRFRCIsImlzVW5ib3VuZGVkIiwibGF5b3V0SW50ZXJuYWxfIiwiZGVyZWdpc3RlclJvb3RIYW5kbGVyc18iLCJkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfIiwicmVtb3ZlQ3NzVmFyc18iLCJmb3JFYWNoIiwicmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwia2V5cyIsImsiLCJpbmRleE9mIiwidXBkYXRlQ3NzVmFyaWFibGUiLCJpc1N1cmZhY2VEaXNhYmxlZCIsImFjdGl2YXRpb25TdGF0ZSIsImlzQWN0aXZhdGVkIiwicHJldmlvdXNBY3RpdmF0aW9uRXZlbnQiLCJpc1NhbWVJbnRlcmFjdGlvbiIsImlzUHJvZ3JhbW1hdGljIiwiYWN0aXZhdGlvbkV2ZW50Iiwid2FzQWN0aXZhdGVkQnlQb2ludGVyIiwiaGFzQWN0aXZhdGVkQ2hpbGQiLCJsZW5ndGgiLCJzb21lIiwiY29udGFpbnNFdmVudFRhcmdldCIsInJlc2V0QWN0aXZhdGlvblN0YXRlXyIsInB1c2giLCJyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsIndhc0VsZW1lbnRNYWRlQWN0aXZlIiwiaXNTdXJmYWNlQWN0aXZlIiwiYW5pbWF0ZUFjdGl2YXRpb25fIiwiVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCIsIlZBUl9GR19UUkFOU0xBVEVfRU5EIiwiRkdfREVBQ1RJVkFUSU9OIiwiRkdfQUNUSVZBVElPTiIsIkRFQUNUSVZBVElPTl9USU1FT1VUX01TIiwidHJhbnNsYXRlU3RhcnQiLCJ0cmFuc2xhdGVFbmQiLCJnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfIiwic3RhcnRQb2ludCIsImVuZFBvaW50Iiwicm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfIiwiY29tcHV0ZUJvdW5kaW5nUmVjdCIsImdldFdpbmRvd1BhZ2VPZmZzZXQiLCJoYXNEZWFjdGl2YXRpb25VWFJ1biIsImFjdGl2YXRpb25IYXNFbmRlZCIsIkZHX0RFQUNUSVZBVElPTl9NUyIsIlRBUF9ERUxBWV9NUyIsInN0YXRlIiwiZXZ0T2JqZWN0IiwiYW5pbWF0ZURlYWN0aXZhdGlvbl8iLCJtYXhEaW0iLCJNYXRoIiwibWF4IiwiZ2V0Qm91bmRlZFJhZGl1cyIsImh5cG90ZW51c2UiLCJzcXJ0IiwicG93IiwiUEFERElORyIsIklOSVRJQUxfT1JJR0lOX1NDQUxFIiwidXBkYXRlTGF5b3V0Q3NzVmFyc18iLCJWQVJfRkdfU0laRSIsIlZBUl9MRUZUIiwiVkFSX1RPUCIsIlZBUl9GR19TQ0FMRSIsInJvdW5kIiwidW5ib3VuZGVkIiwiUmlwcGxlQmFzZSIsInJlZiIsIk1BVENIRVMiLCJfbWF0Y2hlcyIsIkhUTUxFbGVtZW50IiwicHJvdG90eXBlIiwib3B0aW9ucyIsImRpc2FibGVkIiwiJHNldCIsImNsYXNzZXMiLCIkZGVsZXRlIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGVzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsIlJpcHBsZU1peGluIiwicmlwcGxlIiwiaW5pdCIsImRlc3Ryb3kiLCJyZW5kZXIiLCJtZGNCdXR0b25CYXNlIiwicmFpc2VkIiwidW5lbGV2YXRlZCIsInN0cm9rZWQiLCJkZW5zZSIsImNvbXBhY3QiLCJhY2NlbnQiLCJzcmMiLCJzcXVhcmUiLCJmdWxsQmxlZWQiLCJpY29uIiwiTURDQ29tcG9uZW50Iiwicm9vdCIsImZvdW5kYXRpb24iLCJyb290XyIsImluaXRpYWxpemUiLCJmb3VuZGF0aW9uXyIsImdldERlZmF1bHRGb3VuZGF0aW9uIiwiaW5pdGlhbFN5bmNXaXRoRE9NIiwiRXJyb3IiLCJNRENSaXBwbGUiLCJ1bmJvdW5kZWRfIiwic2V0VW5ib3VuZGVkIiwiYWN0aXZhdGUiLCJkZWFjdGl2YXRlIiwiY3JlYXRlQWRhcHRlciIsImRhdGFzZXQiLCJzZXRVbmJvdW5kZWRfIiwiaW5zdGFuY2UiLCJ1dGlsIiwiY2xhc3NMaXN0IiwiYWRkIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsIk1EQ1NlbGVjdGlvbkNvbnRyb2wiLCJNRENDaGVja2JveEFkYXB0ZXIiLCJDQl9QUk9UT19QUk9QUyIsIk1EQ0NoZWNrYm94Rm91bmRhdGlvbiIsImN1cnJlbnRDaGVja1N0YXRlXyIsIlRSQU5TSVRJT05fU1RBVEVfSU5JVCIsImN1cnJlbnRBbmltYXRpb25DbGFzc18iLCJhbmltRW5kTGF0Y2hUaW1lcl8iLCJhbmltRW5kSGFuZGxlcl8iLCJoYW5kbGVBbmltYXRpb25FbmQiLCJjaGFuZ2VIYW5kbGVyXyIsImhhbmRsZUNoYW5nZSIsImRldGVybWluZUNoZWNrU3RhdGVfIiwiZ2V0TmF0aXZlQ29udHJvbF8iLCJVUEdSQURFRCIsInJlZ2lzdGVyQ2hhbmdlSGFuZGxlciIsImluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXyIsImRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyIiwidW5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18iLCJjaGVja2VkIiwiaW5kZXRlcm1pbmF0ZSIsIkRJU0FCTEVEIiwiZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIiLCJBTklNX0VORF9MQVRDSF9NUyIsInRyYW5zaXRpb25DaGVja1N0YXRlXyIsIm5hdGl2ZUNiIiwiY2JQcm90byIsImdldFByb3RvdHlwZU9mIiwiY29udHJvbFN0YXRlIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInZhbGlkRGVzY3JpcHRvciIsIm5hdGl2ZUNiRGVzYyIsImdldCIsInNldCIsImNhbGwiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJnZXROYXRpdmVDb250cm9sIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsImZvcmNlTGF5b3V0IiwiZ2V0VHJhbnNpdGlvbkFuaW1hdGlvbkNsYXNzXyIsImlzQXR0YWNoZWRUb0RPTSIsInJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlciIsIlRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURSIsIlRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCIsIlRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEIiwiQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRCIsIkFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEUiLCJBTklNX0NIRUNLRURfVU5DSEVDS0VEIiwiQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEUiLCJBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCIsIkFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQiLCJpbnB1dFByb3BEZXNjIiwiTURDRm9ybUZpZWxkQWRhcHRlciIsIk1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24iLCJjbGlja0hhbmRsZXJfIiwiaGFuZGxlQ2xpY2tfIiwiYWN0aXZhdGVJbnB1dFJpcHBsZSIsImRlYWN0aXZhdGVJbnB1dFJpcHBsZSIsImV2ZW50VHlwZU1hcCIsImNzc1Byb3BlcnR5TWFwIiwiaGFzUHJvcGVyU2hhcGUiLCJldmVudEZvdW5kSW5NYXBzIiwiZXZlbnRUeXBlIiwiZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZSIsIm1hcCIsInN0eWxlUHJvcGVydHkiLCJub1ByZWZpeCIsIndlYmtpdFByZWZpeCIsImdldEFuaW1hdGlvbk5hbWUiLCJldmVudE5hbWUiLCJ0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXMiLCJnZXRDb3JyZWN0RXZlbnROYW1lIiwiZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSIsImxhYmVsIiwiJHNsb3RzIiwiaGFzTGFiZWwiLCJhbGlnbkVuZCIsInNldENoZWNrZWQiLCJzZXREaXNhYmxlZCIsInNldEluZGV0ZXJtaW5hdGUiLCIkcmVmcyIsImNvbnRyb2wiLCJvZmZzZXRXaWR0aCIsInBhcmVudE5vZGUiLCJmb3JtRmllbGQiLCJpc0luZGV0ZXJtaW5hdGUiLCJpc0NoZWNrZWQiLCJNRENDaGlwQWRhcHRlciIsIk1EQ0NoaXBGb3VuZGF0aW9uIiwiaW50ZXJhY3Rpb25IYW5kbGVyXyIsImhhbmRsZUludGVyYWN0aW9uXyIsImtleUNvZGUiLCJub3RpZnlJbnRlcmFjdGlvbiIsImxlYWRpbmdJY29uIiwibGVhZGluZ0ljb25DbGFzc2VzIiwidHJhaWxpbmdJY29uIiwidHJhaWxpbmdJY29uQ2xhc3NlcyIsIk1EQ0NoaXBTZXRBZGFwdGVyIiwiTURDQ2hpcFNldEZvdW5kYXRpb24iLCJNRENEaWFsb2dGb3VuZGF0aW9uIiwiaXNPcGVuXyIsImNvbXBvbmVudENsaWNrSGFuZGxlcl8iLCJldmVudFRhcmdldEhhc0NsYXNzIiwiQkFDS0RST1AiLCJjYW5jZWwiLCJkaWFsb2dDbGlja0hhbmRsZXJfIiwiaGFuZGxlRGlhbG9nQ2xpY2tfIiwiZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8iLCJ0cmFuc2l0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVUcmFuc2l0aW9uRW5kXyIsImRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIiLCJ1bnRyYXBGb2N1c09uU3VyZmFjZSIsImRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsIkFOSU1BVElORyIsIk9QRU4iLCJlbmFibGVTY3JvbGxfIiwiZGlzYWJsZVNjcm9sbF8iLCJyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIiLCJyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyIiwic2hvdWxkTm90aWZ5Iiwibm90aWZ5QWNjZXB0IiwiY2xvc2UiLCJub3RpZnlDYW5jZWwiLCJBQ0NFUFRfQlROIiwiYWNjZXB0IiwiQ0FOQ0VMX0JUTiIsImlzRGlhbG9nIiwidHJhcEZvY3VzT25TdXJmYWNlIiwibGF5b3V0Rm9vdGVyUmlwcGxlcyIsImFkZEJvZHlDbGFzcyIsIlNDUk9MTF9MT0NLIiwicmVtb3ZlQm9keUNsYXNzIiwibW9kdWxlIiwiZWxlbWVudERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImJhc2ljVGFiYmFibGVzIiwib3JkZXJlZFRhYmJhYmxlcyIsImlzVW5hdmFpbGFibGUiLCJjcmVhdGVJc1VuYXZhaWxhYmxlIiwiY2FuZGlkYXRlU2VsZWN0b3JzIiwiY2FuZGlkYXRlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJqb2luIiwiaW5jbHVkZUNvbnRhaW5lciIsIm1hdGNoZXMiLCJFbGVtZW50IiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJjYW5kaWRhdGVTZWxlY3RvciIsInNsaWNlIiwiYXBwbHkiLCJ1bnNoaWZ0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlSW5kZXgiLCJpIiwibCIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwidGFiSW5kZXgiLCJ0YWdOYW1lIiwidGFiYmFibGVOb2RlcyIsInNvcnQiLCJhIiwiYiIsImluZGV4IiwiaXNPZmZDYWNoZSIsImlzT2ZmIiwibm9kZUNvbXB1dGVkU3R5bGUiLCJkZWZhdWx0VmlldyIsImRpc3BsYXkiLCJ2aXNpYmlsaXR5IiwibGlzdGVuaW5nRm9jdXNUcmFwIiwiZm9jdXNUcmFwIiwidXNlck9wdGlvbnMiLCJmaXJzdFRhYmJhYmxlTm9kZSIsImxhc3RUYWJiYWJsZU5vZGUiLCJub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24iLCJhY3RpdmUiLCJwYXVzZWQiLCJ0YWJFdmVudCIsImNvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJjb25maWciLCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSIsImVzY2FwZURlYWN0aXZhdGVzIiwidHJhcCIsInBhdXNlIiwidW5wYXVzZSIsImFjdGl2YXRlT3B0aW9ucyIsImRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyIsIm9uQWN0aXZhdGUiLCJkZWFjdGl2YXRlT3B0aW9ucyIsImRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zIiwicmV0dXJuRm9jdXMiLCJvbkRlYWN0aXZhdGUiLCJhZGRMaXN0ZW5lcnMiLCJmaXJzdEZvY3VzTm9kZSIsImNoZWNrRm9jdXMiLCJjaGVja0NsaWNrIiwiY2hlY2tQb2ludGVyRG93biIsImNoZWNrS2V5IiwicmVtb3ZlTGlzdGVuZXJzIiwiZ2V0Tm9kZUZvck9wdGlvbiIsIm9wdGlvbk5hbWUiLCJvcHRpb25WYWx1ZSIsImNsaWNrT3V0c2lkZURlYWN0aXZhdGVzIiwicHJldmVudERlZmF1bHQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJibHVyIiwiaXNFc2NhcGVFdmVudCIsImhhbmRsZVRhYiIsImhhc0F0dHJpYnV0ZSIsIk51bWJlciIsImN1cnJlbnRGb2N1c0luZGV4Iiwic2hpZnRLZXkiLCJ0cnlGb2N1cyIsInVwZGF0ZVRhYmJhYmxlTm9kZXMiLCJ0YWJiYWJsZSIsInJlYWRqdXN0Rm9jdXMiLCJmb2N1cyIsInRvTG93ZXJDYXNlIiwic2VsZWN0IiwiY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UiLCJzdXJmYWNlRWwiLCJhY2NlcHRCdXR0b25FbCIsImZvY3VzVHJhcEZhY3RvcnkiLCJjcmVhdGVGb2N1c1RyYXAiLCJyZXF1aXJlZCIsIm1kY0J1dHRvbiIsImRhcmsiLCJzY3JvbGxhYmxlIiwic3VyZmFjZSIsIiRsaXN0ZW5lcnMiLCJub3RpZnkiLCJvcGVuIiwiRk9DVVNBQkxFX0VMRU1FTlRTIiwiTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIiwicm9vdENzc0NsYXNzIiwiYW5pbWF0aW5nQ3NzQ2xhc3MiLCJvcGVuQ3NzQ2xhc3MiLCJyb290Q3NzQ2xhc3NfIiwiYW5pbWF0aW5nQ3NzQ2xhc3NfIiwib3BlbkNzc0NsYXNzXyIsImluZXJ0XyIsImNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyIsImhhbmRsZVRvdWNoU3RhcnRfIiwiY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8iLCJoYW5kbGVUb3VjaE1vdmVfIiwiY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyIsImhhbmRsZVRvdWNoRW5kXyIsImhhc0NsYXNzIiwiaGFzTmVjZXNzYXJ5RG9tIiwiZGV0YWJpbmF0ZV8iLCJyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZXRhYmluYXRlXyIsIm5vdGlmeU9wZW4iLCJub3RpZnlDbG9zZSIsImVsZW1lbnRzIiwiZ2V0Rm9jdXNhYmxlRWxlbWVudHMiLCJzYXZlRWxlbWVudFRhYlN0YXRlIiwibWFrZUVsZW1lbnRVbnRhYmJhYmxlIiwicmVzdG9yZUVsZW1lbnRUYWJTdGF0ZSIsInBvaW50ZXJUeXBlIiwiZGlyZWN0aW9uXyIsImlzUnRsIiwiZHJhd2VyV2lkdGhfIiwiZ2V0RHJhd2VyV2lkdGgiLCJzdGFydFhfIiwidG91Y2hlcyIsImN1cnJlbnRYXyIsInVwZGF0ZVJhZl8iLCJ1cGRhdGVEcmF3ZXJfIiwiYmluZCIsInByZXBhcmVGb3JUb3VjaEVuZF8iLCJhYnMiLCJuZXdQb3NpdGlvbl8iLCJzZXRUcmFuc2xhdGVYIiwiaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyIsIm5ld1BvcyIsIm1pbiIsIk1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIiwiaXNEcmF3ZXIiLCJUQUJfREFUQSIsIlRBQl9EQVRBX0hBTkRMRUQiLCJzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfIiwicmVtYXBFdmVudCIsImdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSIsInRyYW5zZm9ybVByb3BlcnR5TmFtZSIsInN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcyIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIl9yZWZyZXNoIiwiZHJhd2VyIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIk1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24iLCJuZXdPcGFjaXR5IiwiT1BBQ0lUWV9WQVJfTkFNRSIsIm1lZGlhIiwiX3NtYWxsIiwibWF0Y2hNZWRpYSIsIl9sYXJnZSIsInZhbCIsIm1kY0RyYXdlciIsIm1kY1Blcm1hbmVudERyYXdlciIsIm1kY1BlcnNpc3RlbnREcmF3ZXIiLCJtZGNUZW1wb3JhcnlEcmF3ZXIiLCJwZXJtYW5lbnQiLCJwZXJzaXN0ZW50IiwidGVtcG9yYXJ5IiwiZHJhd2VyVHlwZSIsInNtYWxsIiwib3Blbl8iLCJpc1Blcm1hbmVudCIsImlzT3BlbiIsImxhcmdlIiwiaXNSZXNwb25zaXZlIiwidG9nZ2xlT24iLCJzb3VyY2UiLCJ0b2dnbGVPblNvdXJjZSIsIiRvbiIsInRvZ2dsZSIsIm9wZW5PbiIsIm9wZW5PblNvdXJjZSIsImNsb3NlT24iLCJjbG9zZU9uU291cmNlIiwiYWRkTGlzdGVuZXIiLCJyZWZyZXNoTWVkaWEiLCIkbmV4dFRpY2siLCJyZW1vdmVMaXN0ZW5lciIsImlzVGVtcG9yYXJ5IiwiaXNQZXJzaXN0ZW50IiwiYWN0aXZhdGVkIiwic3RhcnRJY29uIiwidGVtcG9yYXJ5Q2xvc2UiLCJtaW5pIiwiYWJzb2x1dGUiLCJmaXhlZCIsIk1EQ0dyaWRMaXN0Rm91bmRhdGlvbiIsImFsaWduQ2VudGVyIiwicmVzaXplRnJhbWVfIiwiYWxpZ25DZW50ZXJfIiwiZ2V0TnVtYmVyT2ZUaWxlcyIsImdyaWRXaWR0aCIsImdldE9mZnNldFdpZHRoIiwiaXRlbVdpZHRoIiwiZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleCIsInRpbGVzV2lkdGgiLCJmbG9vciIsInNldFN0eWxlRm9yVGlsZXNFbGVtZW50IiwibWRjR3JpZCIsIm5hcnJvd0d1dHRlciIsImhlYWRlckNhcHRpb24iLCJyYXRpbyIsImljb25BbGlnblN0YXJ0IiwiaWNvbkFsaWduRW5kIiwid2l0aFN1cHBvcnRUZXh0IiwiaW50ZXJhY3RpdmUiLCJUSUxFX1NFTEVDVE9SIiwicHJvcGVydHkiLCJUSUxFU19TRUxFQ1RPUiIsInNlbGVjdGVkIiwiZW5kSWNvbiIsImFkZFJpcHBsZSIsInJlbW92ZVJpcHBsZSIsImlzSW50ZXJhY3RpdmUiLCJsb2ciLCJNRENJY29uVG9nZ2xlQWRhcHRlciIsInRleHQiLCJNRENJY29uVG9nZ2xlRm91bmRhdGlvbiIsIm9uXyIsImRpc2FibGVkXyIsInNhdmVkVGFiSW5kZXhfIiwidG9nZ2xlT25EYXRhXyIsInRvZ2dsZU9mZkRhdGFfIiwidG9nZ2xlRnJvbUV2dF8iLCJpc0hhbmRsaW5nS2V5ZG93bl8iLCJrZXlkb3duSGFuZGxlcl8iLCJpc1NwYWNlIiwia2V5dXBIYW5kbGVyXyIsInJlZnJlc2hUb2dnbGVEYXRhIiwiZ2V0VGFiSW5kZXgiLCJEQVRBX1RPR0dMRV9PTiIsIkRBVEFfVE9HR0xFX09GRiIsInBhcnNlSnNvbkRhdGFBdHRyXyIsImlzT24iLCJub3RpZnlDaGFuZ2UiLCJBUklBX0xBQkVMIiwiQVJJQV9QUkVTU0VEIiwic2V0QXR0ciIsImNsYXNzVG9SZW1vdmUiLCJjc3NDbGFzcyIsImNvbnRlbnQiLCJzZXRUZXh0IiwiZGF0YUF0dHIiLCJnZXRBdHRyIiwiSlNPTiIsInBhcnNlIiwiaXNEaXNhYmxlZCIsIkFSSUFfRElTQUJMRUQiLCJzZXRUYWJJbmRleCIsInJtQXR0ciIsImtleWJvYXJkS2V5Iiwic3RyaW5naWZ5IiwidG9nZ2xlT2ZmIiwiaWNvbkNsYXNzZXMiLCJpc0tleWJvYXJkQWN0aXZhdGVkIiwiZml4ZWRDb2x1bW5XaWR0aCIsInNwYW5PcHRpb25zIiwibnVtIiwiaXNGaW5pdGUiLCJzcGFuIiwib3JkZXIiLCJwaG9uZSIsInRhYmxldCIsImRlc2t0b3AiLCJhbGlnbiIsIk1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbiIsImRldGVybWluYXRlXyIsIklOREVURVJNSU5BVEVfQ0xBU1MiLCJyZXZlcnNlXyIsIlJFVkVSU0VEX0NMQVNTIiwicHJvZ3Jlc3NfIiwiaXNEZXRlcm1pbmF0ZSIsInNldFNjYWxlXyIsImdldFByaW1hcnlCYXIiLCJnZXRCdWZmZXIiLCJpc1JldmVyc2VkIiwiQ0xPU0VEX0NMQVNTIiwic2NhbGVWYWx1ZSIsInRyYW5zZm9ybVN0eWxlUHJvcGVydHkiLCJzZXRTdHlsZSIsIlByb2dyZXNzUHJvcFR5cGUiLCJzZXRQcm9ncmVzcyIsInByb2dyZXNzIiwic2V0QnVmZmVyIiwiYnVmZmVyIiwic2V0RGV0ZXJtaW5hdGUiLCJzZXRSZXZlcnNlIiwicmV2ZXJzZSIsInByaW1hcnkiLCJtZGNMaXN0IiwiYXZhdGFyTGlzdCIsInR3b0xpbmUiLCJib3JkZXJlZCIsImluc2V0IiwicGFkZGVkIiwiTURDTWVudUFkYXB0ZXIiLCJhdHRyaWJ1dGVOYW1lIiwib3JpZ2luIiwicG9zaXRpb24iLCJhdHRyIiwiQ29ybmVyQml0IiwiQ29ybmVyIiwiUklHSFQiLCJCT1RUT00iLCJGTElQX1JUTCIsIk1EQ01lbnVGb3VuZGF0aW9uIiwiaGFuZGxlUG9zc2libGVTZWxlY3RlZF8iLCJoYW5kbGVLZXlib2FyZERvd25fIiwiaGFuZGxlS2V5Ym9hcmRVcF8iLCJkb2N1bWVudENsaWNrSGFuZGxlcl8iLCJoYW5kbGVEb2N1bWVudENsaWNrXyIsIm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyIsImNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8iLCJzZWxlY3RlZFRyaWdnZXJUaW1lcklkXyIsImFuaW1hdGlvblJlcXVlc3RJZF8iLCJkaW1lbnNpb25zXyIsIml0ZW1IZWlnaHRfIiwiYW5jaG9yQ29ybmVyXyIsIlRPUF9TVEFSVCIsImFuY2hvck1hcmdpbl8iLCJyaWdodCIsImJvdHRvbSIsIm1lYXN1cmVzXyIsInNlbGVjdGVkSW5kZXhfIiwicmVtZW1iZXJTZWxlY3Rpb25fIiwicXVpY2tPcGVuXyIsImtleURvd25XaXRoaW5NZW51XyIsImRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyIiwiY29ybmVyIiwibWFyZ2luIiwicmVtZW1iZXJTZWxlY3Rpb24iLCJzZXRTZWxlY3RlZEluZGV4IiwicXVpY2tPcGVuIiwiZm9jdXNJbmRleCIsImZvY3VzSXRlbUF0SW5kZXgiLCJpc0ZvY3VzZWQiLCJnZXRJbmRleEZvckV2ZW50VGFyZ2V0IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJpc1RhYiIsImlzQXJyb3dVcCIsImlzQXJyb3dEb3duIiwiaXNFbnRlciIsImZvY3VzZWRJdGVtSW5kZXgiLCJnZXRGb2N1c2VkSXRlbUluZGV4IiwibGFzdEl0ZW1JbmRleCIsImdldE51bWJlck9mSXRlbXMiLCJpc0VzY2FwZSIsImdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0IiwiQVJJQV9ESVNBQkxFRF9BVFRSIiwidGFyZ2V0SW5kZXgiLCJub3RpZnlTZWxlY3RlZCIsIlNFTEVDVEVEX1RSSUdHRVJfREVMQVkiLCJhbmNob3JSZWN0IiwiZ2V0QW5jaG9yRGltZW5zaW9ucyIsInZpZXdwb3J0IiwiZ2V0V2luZG93RGltZW5zaW9ucyIsIlRPUF9MRUZUIiwidmlld3BvcnREaXN0YW5jZSIsImFuY2hvckhlaWdodCIsImFuY2hvcldpZHRoIiwibWVudUhlaWdodCIsIm1lbnVXaWR0aCIsImlzQm90dG9tQWxpZ25lZCIsImF2YWlsYWJsZVRvcCIsImF2YWlsYWJsZUJvdHRvbSIsInRvcE92ZXJmbG93IiwiYm90dG9tT3ZlcmZsb3ciLCJpc0ZsaXBSdGwiLCJhdm9pZEhvcml6b250YWxPdmVybGFwIiwiaXNBbGlnbmVkUmlnaHQiLCJhdmFpbGFibGVMZWZ0IiwiYXZhaWxhYmxlUmlnaHQiLCJsZWZ0T3ZlcmZsb3ciLCJyaWdodE92ZXJmbG93IiwiaXNSaWdodEFsaWduZWQiLCJyaWdodE9mZnNldCIsImxlZnRPZmZzZXQiLCJNQVJHSU5fVE9fRURHRSIsImF2b2lkVmVydGljYWxPdmVybGFwIiwiY2FuT3ZlcmxhcFZlcnRpY2FsbHkiLCJtYXhIZWlnaHQiLCJoYXNBbmNob3IiLCJnZXRBdXRvTGF5b3V0TWVhc3VyZW1lbnRzXyIsImdldE9yaWdpbkNvcm5lcl8iLCJtYXhNZW51SGVpZ2h0IiwiZ2V0TWVudU1heEhlaWdodF8iLCJ2ZXJ0aWNhbEFsaWdubWVudCIsImhvcml6b250YWxBbGlnbm1lbnQiLCJob3Jpem9udGFsT2Zmc2V0IiwiZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8iLCJ2ZXJ0aWNhbE9mZnNldCIsImdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0XyIsIkFOQ0hPUl9UT19NRU5VX1dJRFRIX1JBVElPIiwiT0ZGU0VUX1RPX01FTlVfSEVJR0hUX1JBVElPIiwidmVydGljYWxPZmZzZXRQZXJjZW50Iiwib3JpZ2luUGVyY2VudCIsInNldFRyYW5zZm9ybU9yaWdpbiIsInNldFBvc2l0aW9uIiwic2V0TWF4SGVpZ2h0Iiwic2F2ZUZvY3VzIiwiQU5JTUFUSU5HX09QRU4iLCJnZXRJbm5lckRpbWVuc2lvbnMiLCJhdXRvUG9zaXRpb25fIiwiZm9jdXNPbk9wZW5fIiwicmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyIiwiVFJBTlNJVElPTl9PUEVOX0RVUkFUSU9OIiwidGFyZ2V0SXNEaXNhYmxlZCIsIkFOSU1BVElOR19DTE9TRUQiLCJUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OIiwicmVzdG9yZUZvY3VzIiwicHJldlNlbGVjdGVkSW5kZXgiLCJybUF0dHJGb3JPcHRpb25BdEluZGV4Iiwicm1DbGFzc0Zvck9wdGlvbkF0SW5kZXgiLCJTRUxFQ1RFRF9MSVNUX0lURU0iLCJzZXRBdHRyRm9yT3B0aW9uQXRJbmRleCIsImFkZENsYXNzRm9yT3B0aW9uQXRJbmRleCIsIm9wZW5Gcm9tVG9wTGVmdCIsIm9wZW5Gcm9tVG9wUmlnaHQiLCJvcGVuRnJvbUJvdHRvbUxlZnQiLCJvcGVuRnJvbUJvdHRvbVJpZ2h0IiwicmVmcmVzaEl0ZW1zIiwiaXRlbXMiLCJzbG90T2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJfcHJldmlvdXNGb2N1cyIsIm9mZnNldEhlaWdodCIsInBhcmVudEVsZW1lbnQiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJTRUxFQ1RFRF9FVkVOVCIsIkNBTkNFTF9FVkVOVCIsImRpc2Nvbm5lY3QiLCJNRENSYWRpb0FkYXB0ZXIiLCJNRENSYWRpb0ZvdW5kYXRpb24iLCJzZXRWYWx1ZSIsInBpY2tlZCIsImdldFZhbHVlIiwic3luYyIsIk1EQ01lbnUiLCJwcmV2aW91c0ZvY3VzXyIsInNldEFuY2hvckNvcm5lciIsInNldEFuY2hvck1hcmdpbiIsIml0ZW1zQ29udGFpbmVyXyIsIml0ZW1zQ29udGFpbmVyIiwiZW1pdCIsIklURU1TX1NFTEVDVE9SIiwiZ2V0U2VsZWN0ZWRJbmRleCIsInNldFJlbWVtYmVyU2VsZWN0aW9uIiwic2V0UXVpY2tPcGVuIiwiT1BFTkVSX0tFWVMiLCJmb3JUeXBlIiwiTURDU2VsZWN0Rm91bmRhdGlvbiIsImN0eF8iLCJpc0ZvY3VzZWRfIiwiZGlzcGxheUhhbmRsZXJfIiwiaXNNZW51T3BlbiIsImRpc3BsYXlWaWFLZXlib2FyZEhhbmRsZXJfIiwiaGFuZGxlRGlzcGxheVZpYUtleWJvYXJkXyIsInNlbGVjdGlvbkhhbmRsZXJfIiwiZGV0YWlsIiwiY2xvc2VfIiwiY2FuY2VsSGFuZGxlcl8iLCJmbG9hdExhYmVsIiwiY3JlYXRlMmRSZW5kZXJpbmdDb250ZXh0IiwicmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVzaXplIiwiZGVyZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXIiLCJnZXRWYWx1ZUZvck9wdGlvbkF0SW5kZXgiLCJnZXROdW1iZXJPZk9wdGlvbnMiLCJzZWxlY3RlZFRleHRDb250ZW50IiwiZ2V0VGV4dEZvck9wdGlvbkF0SW5kZXgiLCJ0cmltIiwic2V0U2VsZWN0ZWRUZXh0Q29udGVudCIsIm1ha2VVbnRhYmJhYmxlIiwibWFrZVRhYmJhYmxlIiwiZm9udCIsImdldENvbXB1dGVkU3R5bGVWYWx1ZSIsImxldHRlclNwYWNpbmciLCJwYXJzZUZsb2F0IiwicHJpbWFyeUZvbnRGYW1pbHkiLCJmb250U2l6ZSIsIm1heFRleHRMZW5ndGgiLCJzdXJmYWNlUGFkZGluZ1JpZ2h0Iiwic3VyZmFjZVBhZGRpbmdMZWZ0Iiwic2VsZWN0Qm94QWRkZWRQYWRkaW5nIiwidHh0IiwibWVhc3VyZVRleHQiLCJhZGRlZFNwYWNlIiwiY2VpbCIsInNldE1lbnVTdHlsZXNGb3JPcGVuQXRJbmRleF8iLCJhZGRDbGFzc1RvQm90dG9tTGluZSIsIkJPVFRPTV9MSU5FX0FDVElWRSIsIm9wZW5NZW51IiwiZ2V0V2luZG93SW5uZXJIZWlnaHQiLCJzZXRNZW51RWxBdHRyIiwic2V0TWVudUVsU3R5bGUiLCJnZXRNZW51RWxPZmZzZXRIZWlnaHQiLCJpdGVtT2Zmc2V0VG9wIiwiZ2V0T2Zmc2V0VG9wRm9yT3B0aW9uQXRJbmRleCIsInJtTWVudUVsQXR0ciIsImFkanVzdGVkVG9wIiwib3ZlcmZsb3dzVG9wIiwib3ZlcmZsb3dzQm90dG9tIiwicmVtb3ZlQ2xhc3NGcm9tQm90dG9tTGluZSIsIkVWRU5UX1BIQVNFX0FUX1RBUkdFVCIsImV2ZW50UGhhc2UiLCJpc1NwYWNlRG93biIsImlzT3BlbmVyS2V5IiwiTURDU2VsZWN0TGFiZWxBZGFwdGVyIiwiTURDU2VsZWN0TGFiZWxGb3VuZGF0aW9uIiwiTEFCRUxfRkxPQVRfQUJPVkUiLCJib3giLCJtZGNNZW51IiwicmVmcmVzaEluZGV4IiwibWVudSIsImxhYmVsQ2xhc3NlcyIsImxhYmVsRm91bmRhdGlvbiIsInN0eWxlRmxvYXQiLCJib3R0b21MaW5lQ2xhc3NlcyIsImJvdHRvbUxpbmUiLCJwcm9wIiwicHJvcGVydHlOYW1lIiwic3VyZmFjZVN0eWxlcyIsImdldENvbnRleHQiLCJzaG93Iiwib2Zmc2V0VG9wIiwibGFiZWxUeHQiLCJmb3VuZGF0aW9uTGFiZWwiLCJzY3JvbGwiLCJjb3VudCIsInNpemUiLCJyZWZyZXNoU2l6ZSIsIm1heFNpemUiLCJfbW9iaWxlIiwibWRjU2VsZWN0IiwiTURDTmF0aXZlU2VsZWN0IiwiTURDTWVudVNlbGVjdCIsIk1EQ011bHRpU2VsZWN0IiwibW9iaWxlIiwibXVsdGlwbGUiLCJpc05hdGl2ZSIsIm5hdGl2ZSIsIk1EQ05hdGl2ZU9wdGlvbiIsIk1EQ011bHRpT3B0aW9uIiwiTURDTWVudU9wdGlvbiIsIk1EQ1NsaWRlckFkYXB0ZXIiLCJudW1NYXJrZXJzIiwiS0VZX0lEUyIsIk1PVkVfRVZFTlRfTUFQIiwiRE9XTl9FVkVOVFMiLCJVUF9FVkVOVFMiLCJNRENTbGlkZXJGb3VuZGF0aW9uIiwicmVjdF8iLCJOYU4iLCJhY3RpdmVfIiwiaW5UcmFuc2l0XyIsImlzRGlzY3JldGVfIiwiaGFzVHJhY2tNYXJrZXJfIiwiaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8iLCJtaW5fIiwibWF4XyIsInN0ZXBfIiwidmFsdWVfIiwicHJldmVudEZvY3VzU3RhdGVfIiwidXBkYXRlVUlGcmFtZV8iLCJ0aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyIsImludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyIsImhhbmRsZURvd25fIiwiaGFuZGxlS2V5ZG93bl8iLCJoYW5kbGVGb2N1c18iLCJoYW5kbGVCbHVyXyIsIklTX0RJU0NSRVRFIiwiSEFTX1RSQUNLX01BUktFUiIsImV2dE5hbWUiLCJyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyIiwiZ2V0U3RlcCIsImRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsImdldE1pbiIsImdldE1heCIsInN0ZXAiLCJpbmRpdmlzaWJsZSIsInJlbW92ZVRyYWNrTWFya2VycyIsImFwcGVuZFRyYWNrTWFya2VycyIsImxhc3RTdGVwUmF0aW8iLCJmbGV4Iiwic2V0TGFzdFRyYWNrTWFya2Vyc1N0eWxlUHJvcGVydHkiLCJ1cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8iLCJzZXRWYWx1ZV8iLCJBUklBX1ZBTFVFTUFYIiwic2V0dXBUcmFja01hcmtlciIsIkFSSUFfVkFMVUVNSU4iLCJ0b2dnbGVDbGFzc18iLCJpc05hTiIsInNldEluVHJhbnNpdF8iLCJzZXRBY3RpdmVfIiwibW92ZUhhbmRsZXIiLCJoYW5kbGVNb3ZlXyIsInVwSGFuZGxlciIsImhhbmRsZVVwXyIsImRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyIiwic2V0VmFsdWVGcm9tRXZ0XyIsInRhcmdldFRvdWNoZXMiLCJnZXRQYWdlWF8iLCJjb21wdXRlVmFsdWVGcm9tUGFnZVhfIiwieFBvcyIsInBjdENvbXBsZXRlIiwiaXNSVEwiLCJrZXlJZCIsImdldEtleUlkXyIsImdldFZhbHVlRm9yS2V5SWRfIiwiRk9DVVMiLCJrYmRFdnQiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJIT01FIiwiRU5EIiwiUEFHRV9VUCIsIlBBR0VfRE9XTiIsImRlbHRhIiwidmFsdWVOZWVkc1RvQmVGbGlwcGVkIiwiUEFHRV9GQUNUT1IiLCJzaG91bGRGaXJlSW5wdXQiLCJmb3JjZSIsInZhbHVlU2V0VG9Cb3VuZGFyeSIsInF1YW50aXplXyIsIkFSSUFfVkFMVUVOT1ciLCJub3RpZnlJbnB1dCIsInNldE1hcmtlclZhbHVlIiwibnVtU3RlcHMiLCJxdWFudGl6ZWRWYWwiLCJ0cmFuc2xhdGVQeCIsInRyYW5zZm9ybVByb3AiLCJ0cmFuc2l0aW9uZW5kRXZ0TmFtZSIsIm9uVHJhbnNpdGlvbkVuZCIsInNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eSIsInNldFRyYWNrU3R5bGVQcm9wZXJ0eSIsIkFDVElWRSIsImluVHJhbnNpdCIsIklOX1RSQU5TSVQiLCJzaG91bGRCZVByZXNlbnQiLCJkaXNwbGF5TWFya2VycyIsInNldE1pbiIsInNldE1heCIsInNldFN0ZXAiLCJ0aHVtYkNvbnRhaW5lciIsInRodW1iU3R5bGVzIiwidHJhY2tTdHlsZXMiLCJtYXJrZXJWYWx1ZSIsImxhc3RUcmFja01hcmtlcnNTdHlsZXMiLCJoYXNNYXJrZXJzIiwibGF5b3V0T24iLCJsYXlvdXRPblNvdXJjZSIsIk1EQ1NuYWNrYmFyRm91bmRhdGlvbiIsImFjdGlvbldhc0NsaWNrZWRfIiwiZGlzbWlzc09uQWN0aW9uXyIsImZpcnN0Rm9jdXNfIiwicG9pbnRlckRvd25SZWNvZ25pemVkXyIsInNuYWNrYmFySGFzRm9jdXNfIiwic25hY2tiYXJEYXRhXyIsInF1ZXVlXyIsImFjdGlvbkNsaWNrSGFuZGxlcl8iLCJpbnZva2VBY3Rpb25fIiwidmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfIiwidGltZW91dElkXyIsInZpc2liaWxpdHlJc0hpZGRlbiIsImNsZWFudXBfIiwidGltZW91dCIsIk1FU1NBR0VfVElNRU9VVCIsImhhbmRsZVBvc3NpYmxlVGFiS2V5Ym9hcmRGb2N1c18iLCJyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlciIsInNldEFyaWFIaWRkZW4iLCJzZXRBY3Rpb25BcmlhSGlkZGVuIiwiZGVyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlciIsImRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyIiwiZGVyZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyIiwiZGVyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyIiwiZGlzbWlzc09uQWN0aW9uIiwibWVzc2FnZSIsImFjdGlvbkhhbmRsZXIiLCJhY3Rpb25UZXh0IiwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsInJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlciIsInJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJNVUxUSUxJTkUiLCJBQ1RJT05fT05fQk9UVE9NIiwic2V0TWVzc2FnZVRleHQiLCJtdWx0aWxpbmUiLCJhY3Rpb25PbkJvdHRvbSIsInNldEFjdGlvblRleHQiLCJhY3Rpb25IYW5kbGVyXyIsInNldEFjdGlvbkhpZGRlbl8iLCJ1bnNldEFyaWFIaWRkZW4iLCJub3RpZnlTaG93IiwiaGlqYWNrRm9jdXMiLCJzZXRGb2N1c09uQWN0aW9uXyIsInNldEZvY3VzIiwiYWxsb3dEaXNtaXNzYWwiLCJub3RpZnlIaWRlIiwic2hvd05leHRfIiwic2hpZnQiLCJpc0hpZGRlbiIsInVuc2V0QWN0aW9uQXJpYUhpZGRlbiIsImFsaWduU3RhcnQiLCJoaWRkZW4iLCJhY3Rpb25IaWRkZW4iLCJidXR0b24iLCJldmVudFNvdXJjZSIsInNldERpc21pc3NPbkFjdGlvbiIsImRpc21pc3Nlc09uQWN0aW9uIiwiTURDVGFiRm91bmRhdGlvbiIsImNvbXB1dGVkV2lkdGhfIiwiY29tcHV0ZWRMZWZ0XyIsImlzQWN0aXZlXyIsInByZXZlbnREZWZhdWx0T25DbGlja18iLCJpc0FjdGl2ZSIsInByZXZlbnREZWZhdWx0T25DbGljayIsImdldE9mZnNldExlZnQiLCJnZXRDb21wdXRlZFdpZHRoIiwiZ2V0Q29tcHV0ZWRMZWZ0Iiwic2V0QWN0aXZlIiwicHJldmVudHNEZWZhdWx0T25DbGljayIsInNldFByZXZlbnREZWZhdWx0T25DbGljayIsIm1lYXN1cmVTZWxmIiwib2Zmc2V0TGVmdCIsInRhYiIsIk1EQ1RhYkJhckZvdW5kYXRpb24iLCJpc0luZGljYXRvclNob3duXyIsImFjdGl2ZVRhYkluZGV4XyIsImJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQiLCJhY3RpdmVUYWJJbmRleCIsImZpbmRBY3RpdmVUYWJJbmRleF8iLCJ1bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQiLCJmb3JFYWNoVGFiSW5kZXhfIiwibWVhc3VyZVRhYkF0SW5kZXgiLCJsYXlvdXRJbmRpY2F0b3JfIiwiaXNJbmRpY2F0b3JGaXJzdFJlbmRlciIsInNldFN0eWxlRm9ySW5kaWNhdG9yIiwidHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCIsImdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXgiLCJzY2FsZUFtdEZvckFjdGl2ZVRhYldpZHRoIiwiZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXgiLCJ0cmFuc2Zvcm1WYWx1ZSIsImdldE9mZnNldFdpZHRoRm9ySW5kaWNhdG9yIiwiaXNUYWJBY3RpdmVBdEluZGV4IiwiaXRlcmF0b3IiLCJudW1UYWJzIiwiZ2V0TnVtYmVyT2ZUYWJzIiwic2hvdWxkQnJlYWsiLCJwcmV2QWN0aXZlVGFiSW5kZXgiLCJzZXRUYWJBY3RpdmVBdEluZGV4IiwiaW5kaWNhdG9yUHJpbWFyeSIsImluZGljYXRvckFjY2VudCIsInRhYnMiLCJzd2l0Y2hUb1RhYkF0SW5kZXgiLCJvblNlbGVjdCIsImluZGljYXRvclN0eWxlcyIsImluZGljYXRvciIsImlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2siLCJyZXNldFRhYnMiLCJ0YWJFbGVtZW50cyIsIlRBQl9TRUxFQ1RPUiIsIl9fdnVlX18iLCJoYXNUZXh0IiwiaGFzSWNvbiIsImdldEFjdGl2ZVRhYkluZGV4IiwiTURDTGluZVJpcHBsZUFkYXB0ZXIiLCJNRENMaW5lUmlwcGxlRm91bmRhdGlvbiIsImhhbmRsZVRyYW5zaXRpb25FbmQiLCJyZWdpc3RlckV2ZW50SGFuZGxlciIsImRlcmVnaXN0ZXJFdmVudEhhbmRsZXIiLCJMSU5FX1JJUFBMRV9ERUFDVElWQVRJTkciLCJMSU5FX1JJUFBMRV9BQ1RJVkUiLCJ4Q29vcmRpbmF0ZSIsImF0dHJpYnV0ZVN0cmluZyIsImlzRGVhY3RpdmF0aW5nIiwiTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIiLCJNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiIsInNldENvbnRlbnQiLCJIRUxQRVJfVEVYVF9QRVJTSVNURU5UIiwiaXNWYWxpZGF0aW9uIiwiSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0ciLCJyZW1vdmVBdHRyIiwiQVJJQV9ISURERU4iLCJpbnB1dElzVmFsaWQiLCJoZWxwZXJUZXh0SXNQZXJzaXN0ZW50IiwiaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyIsInZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkiLCJST0xFIiwiaGlkZV8iLCJNRENUZXh0RmllbGRJY29uQWRhcHRlciIsIk1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIiwiaGFuZGxlSW50ZXJhY3Rpb24iLCJub3RpZnlJY29uQWN0aW9uIiwiTURDVGV4dEZpZWxkTGFiZWxBZGFwdGVyIiwiTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uIiwiZ2V0V2lkdGgiLCJpc1ZhbGlkIiwiTEFCRUxfU0hBS0UiLCJpc0JhZElucHV0IiwiTURDVGV4dEZpZWxkT3V0bGluZUFkYXB0ZXIiLCJNRENUZXh0RmllbGRPdXRsaW5lRm91bmRhdGlvbiIsImxhYmVsV2lkdGgiLCJyYWRpdXNTdHlsZVZhbHVlIiwiZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlIiwicmFkaXVzIiwiZ2V0SGVpZ2h0IiwiY29ybmVyV2lkdGgiLCJsZWFkaW5nU3Ryb2tlTGVuZ3RoIiwicGFkZGVkTGFiZWxXaWR0aCIsInBhdGhNaWRkbGUiLCJwYXRoIiwic2V0T3V0bGluZVBhdGhBdHRyIiwiTURDVGV4dEZpZWxkQWRhcHRlciIsIk1EQ1RleHRGaWVsZEZvdW5kYXRpb24iLCJmb3VuZGF0aW9uTWFwIiwiaGVscGVyVGV4dF8iLCJoZWxwZXJUZXh0IiwiaWNvbl8iLCJsYWJlbF8iLCJvdXRsaW5lXyIsIm91dGxpbmUiLCJyZWNlaXZlZFVzZXJJbnB1dF8iLCJ1c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nXyIsImlzVmFsaWRfIiwiaW5wdXRGb2N1c0hhbmRsZXJfIiwiYWN0aXZhdGVGb2N1cyIsImlucHV0Qmx1ckhhbmRsZXJfIiwiZGVhY3RpdmF0ZUZvY3VzIiwiaW5wdXRJbnB1dEhhbmRsZXJfIiwiYXV0b0NvbXBsZXRlRm9jdXMiLCJzZXRQb2ludGVyWE9mZnNldF8iLCJ0ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24iLCJpc0JhZElucHV0XyIsInJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIiLCJnZXROYXRpdmVJbnB1dCIsImlzRGVuc2UiLCJERU5TRSIsImxhYmVsU2NhbGUiLCJERU5TRV9MQUJFTF9TQ0FMRSIsIkxBQkVMX1NDQUxFIiwidXBkYXRlU3ZnUGF0aCIsInN0eWxlRm9jdXNlZF8iLCJhY3RpdmF0ZUxpbmVSaXBwbGUiLCJ1cGRhdGVPdXRsaW5lIiwic3R5bGVTaGFrZSIsInNob3dUb1NjcmVlblJlYWRlciIsInRhcmdldENsaWVudFJlY3QiLCJldnRDb29yZHMiLCJjbGllbnRYIiwiY2xpZW50WSIsInNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW4iLCJkZWFjdGl2YXRlTGluZVJpcHBsZSIsImlucHV0IiwiZ2V0TmF0aXZlSW5wdXRfIiwic2hvdWxkUmVtb3ZlTGFiZWxGbG9hdCIsInN0eWxlVmFsaWRpdHlfIiwiaXNOYXRpdmVJbnB1dFZhbGlkXyIsInN0eWxlRGlzYWJsZWRfIiwiaXNSZXF1aXJlZCIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJ2YWxpZCIsIklOVkFMSUQiLCJzZXRWYWxpZGl0eSIsIkZPQ1VTRUQiLCJmdWxsd2lkdGgiLCJoZWxwdGV4dFBlcnNpc3RlbnQiLCJoZWxwdGV4dFZhbGlkYXRpb24iLCJzZXRSZXF1aXJlZCIsInNldFZhbGlkIiwicm9vdENsYXNzZXMiLCJoZWxwZXJUZXh0Rm91bmRhdGlvbiIsInNldFBlcnNpc3RlbnQiLCJzZXRWYWxpZGF0aW9uIiwicmVhZG9ubHkiLCJhdXRvY29tcGxldGUiLCJhdXRvZm9jdXMiLCJoZWxwIiwiX3VpZCIsImhhc091dGxpbmUiLCJib3R0b21MaW5lRm91bmRhdGlvbiIsImJvdHRvbUNsYXNzZXMiLCJoZWxwQ2xhc3NlcyIsImhhc0xlYWRpbmdJY29uIiwiaGFzVHJhaWxpbmdJY29uIiwiaWNvbkZvdW5kYXRpb24iLCJvdXRsaW5lRm91bmRhdGlvbiIsIm91dGxpbmVQYXRoQXR0ciIsImlkbGVPdXRsaW5lRWxlbWVudCIsIm91dGxpbmVJZGxlIiwiTURDVGV4dGZpZWxkRm91bmRhdGlvbiIsInNldFJpcHBsZUNlbnRlciIsInRleHRib3giLCJUSEVNRV9DT0xPUlMiLCJUSEVNRV9TVFlMRVMiLCJjb2xvciIsImJhY2tncm91bmQiLCJNRENUb29sYmFyRm91bmRhdGlvbiIsImNoZWNrUm93SGVpZ2h0XyIsInNjcm9sbEhhbmRsZXJfIiwidXBkYXRlVG9vbGJhclN0eWxlc18iLCJjaGVja1Jvd0hlaWdodEZyYW1lXyIsInNjcm9sbEZyYW1lXyIsImV4ZWN1dGVkTGFzdENoYW5nZV8iLCJjYWxjdWxhdGlvbnNfIiwiZml4ZWRfIiwiZml4ZWRMYXN0cm93XyIsImhhc0ZsZXhpYmxlUm93XyIsInVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfIiwiRklYRUQiLCJGSVhFRF9MQVNUUk9XIiwiVE9PTEJBUl9ST1dfRkxFWElCTEUiLCJGTEVYSUJMRV9ERUZBVUxUX0JFSEFWSU9SIiwiaW5pdEtleVJhdGlvXyIsInNldEtleUhlaWdodHNfIiwicmVnaXN0ZXJTY3JvbGxIYW5kbGVyIiwiZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIiLCJzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudCIsInRvb2xiYXJIZWlnaHQiLCJzY3JvbGxUb3AiLCJmbGV4aWJsZUV4cGFuc2lvbkhlaWdodCIsIm5ld1Rvb2xiYXJSb3dIZWlnaHQiLCJnZXRSb3dIZWlnaHRfIiwidG9vbGJhclJvd0hlaWdodCIsInRvb2xiYXJSYXRpbyIsImZsZXhpYmxlRXhwYW5zaW9uUmF0aW8iLCJtYXhUcmFuc2xhdGVZRGlzdGFuY2UiLCJtYXhUcmFuc2xhdGVZUmF0aW8iLCJzY3JvbGxUaHJlc2hvbGQiLCJzY3JvbGxUaHJlc2hvbGRSYXRpbyIsInVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMiLCJnZXRWaWV3cG9ydFNjcm9sbFkiLCJoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkIiwic2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8iLCJnZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyIsInVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyIsInVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyIsInVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18iLCJmaXJzdFJvd01heFJhdGlvIiwiZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0IiwiZ2V0T2Zmc2V0SGVpZ2h0IiwiYnJlYWtwb2ludCIsIlRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQiLCJnZXRWaWV3cG9ydFdpZHRoIiwiVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVCIsIlRPT0xCQVJfUk9XX0hFSUdIVCIsIkZMRVhJQkxFX01BWCIsIkZMRVhJQkxFX01JTiIsInRyYW5zbGF0ZURpc3RhbmNlIiwiRklYRURfQVRfTEFTVF9ST1ciLCJzZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudCIsInVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfIiwibWF4VGl0bGVTaXplIiwiTUFYX1RJVExFX1NJWkUiLCJtaW5UaXRsZVNpemUiLCJNSU5fVElUTEVfU0laRSIsImN1cnJlbnRUaXRsZVNpemUiLCJzZXRTdHlsZUZvclRpdGxlRWxlbWVudCIsIndhdGVyZmFsbCIsImZpeGVkTGFzdHJvdyIsImZsZXhpYmxlIiwiZmxleGlibGVEZWZhdWx0IiwiRklSU1RfUk9XX1NFTEVDVE9SIiwicm9vdFN0eWxlcyIsIlRJVExFX1NFTEVDVE9SIiwiYWRqdXN0U3R5bGVzIiwic2hyaW5rVG9GaXQiLCJ0eXBvcyIsIm1kY1R5cG9NaXhpbiIsInR5cG8iLCJhZGp1c3RNYXJnaW4iLCIkYXR0cnMiLCJtZGNUeXBvUHJvcE1peGluIiwiZGVmYXVsdFRhZyIsImRlZmF1bHRUeXBvIiwidmFsaWRUeXBvcyIsIm1kY1RleHRTZWN0aW9uIiwibWRjVGV4dCIsIm1kY0Rpc3BsYXkiLCJtZGNIZWFkbGluZSIsIm1kY1RpdGxlIiwibWRjU3ViSGVhZGluZyIsIm1kY0JvZHkiLCJtZGNDYXB0aW9uIiwiVnVlTURDQnV0dG9uIiwiVnVlTURDQ2FyZCIsIlZ1ZU1EQ0NoZWNrYm94IiwiVnVlTURDQ2hpcFNldCIsIlZ1ZU1EQ0RpYWxvZyIsIlZ1ZU1EQ0RyYXdlciIsIlZ1ZU1EQ0VsZXZhdGlvbiIsIlZ1ZU1EQ0ZhYiIsIlZ1ZU1EQ0dyaWRMaXN0IiwiVnVlTURDSWNvbiIsIlZ1ZU1EQ0ljb25Ub2dnbGUiLCJWdWVNRENMYXlvdXRBcHAiLCJWdWVNRENMYXlvdXRHcmlkIiwiVnVlTURDTGluZWFyUHJvZ3Jlc3MiLCJWdWVNRENMaXN0IiwiVnVlTURDTWVudSIsIlZ1ZU1EQ1JhZGlvIiwiVnVlTURDUmlwcGxlIiwiVnVlTURDU2VsZWN0IiwiVnVlTURDU2xpZGVyIiwiVnVlTURDU25hY2tiYXIiLCJWdWVNRENTd2l0Y2giLCJWdWVNRENUYWJzIiwiVnVlTURDVGV4dGZpZWxkIiwiVnVlTURDVGhlbWUiLCJWdWVN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
