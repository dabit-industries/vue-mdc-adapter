/**
* @module vue-mdc-adapter 0.11.2
* @exports VueMDCAdapter
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.31.0"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.VueMDCAdapter = factory());
}(this, (function () { 'use strict';

function autoInit(plugin) {
  // Auto-install
  var _Vue = null;
  if (typeof window !== 'undefined') {
    _Vue = window.Vue;
  } else if (typeof global !== 'undefined') {
    /*global global*/
    _Vue = global.Vue;
  }
  if (_Vue) {
    _Vue.use(plugin);
  }
}

function BasePlugin(components) {
  return {
    version: '0.11.2',
    install: function install(vm) {
      for (var key in components) {
        var component = components[key];
        vm.component(component.name, component);
      }
    },
    components: components
  };
}

var CustomElement = {
  functional: true,
  render: function render(createElement, context) {
    return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
  }
};

var CustomElementMixin = {
  components: {
    CustomElement: CustomElement
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var CustomLink = {
  name: 'custom-link',
  functional: true,
  props: {
    tag: { type: String, default: 'a' },
    link: Object
  },
  render: function render(h, context) {
    var element = void 0;
    var data = _extends({}, context.data);

    if (context.props.link && context.parent.$router) {
      // router-link case
      element = context.parent.$root.$options.components['router-link'];
      data.props = _extends({ tag: context.props.tag }, context.props.link);
      if (data.on.click) {
        data.nativeOn = { click: data.on.click };
      }
    } else {
      // element fallback
      element = context.props.tag;
    }

    return h(element, data, context.children);
  }
};

var CustomLinkMixin = {
  props: {
    to: [String, Object],
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String
  },
  computed: {
    link: function link() {
      return this.to && {
        to: this.to,
        exact: this.exact,
        append: this.append,
        replace: this.replace,
        activeClass: this.activeClass,
        exactActiveClass: this.exactActiveClass
      };
    }
  },
  components: {
    CustomLink: CustomLink
  }
};

/* global CustomEvent */

function emitCustomEvent(el, evtType, evtData) {
  var shouldBubble = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var evt = void 0;
  if (typeof CustomEvent === 'function') {
    evt = new CustomEvent(evtType, {
      detail: evtData,
      bubbles: shouldBubble
    });
  } else {
    evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(evtType, shouldBubble, false, evtData);
  }
  el.dispatchEvent(evt);
}

var CustomButton = {
  name: 'custom-button',
  functional: true,
  props: {
    link: Object
  },
  render: function render(h, context) {
    var element = void 0;
    var data = _extends({}, context.data);

    if (context.props.link && context.parent.$router) {
      // router-link case
      element = context.parent.$root.$options.components['router-link'];
      data.props = _extends({ tag: context.props.tag }, context.props.link);
      data.attrs.role = 'button';
      if (data.on.click) {
        data.nativeOn = { click: data.on.click };
      }
    } else if (data.attrs && data.attrs.href) {
      // href case
      element = 'a';
      data.attrs.role = 'button';
    } else {
      // button fallback
      element = 'button';
    }

    return h(element, data, context.children);
  }
};

var CustomButtonMixin = {
  props: {
    href: String,
    disabled: Boolean,
    to: [String, Object],
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String
  },
  computed: {
    link: function link() {
      return this.to && {
        to: this.to,
        exact: this.exact,
        append: this.append,
        replace: this.replace,
        activeClass: this.activeClass,
        exactActiveClass: this.exactActiveClass
      };
    }
  },
  components: {
    CustomButton: CustomButton
  }
};

function extractIconProp(iconProp) {
  if (typeof iconProp === 'string') {
    return {
      classes: { 'material-icons': true },
      content: iconProp
    };
  } else if (iconProp instanceof Array) {
    return {
      classes: iconProp.reduce(function (result, value) {
        return _extends(result, defineProperty({}, value, true));
      }, {})
    };
  } else if ((typeof iconProp === 'undefined' ? 'undefined' : _typeof(iconProp)) === 'object') {
    return {
      classes: iconProp.className.split(' ').reduce(function (result, value) {
        return _extends(result, defineProperty({}, value, true));
      }, {}),
      content: iconProp.textContent
    };
  }
}

var DispatchEventMixin = {
  props: {
    'event': String,
    'event-target': Object,
    'event-args': Array
  },
  methods: {
    dispatchEvent: function dispatchEvent(evt) {
      this.$emit(evt.type);
      if (this.event) {
        var target = this.eventTarget || this.$root;
        var args = this.eventArgs || [];
        target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
      }
    }
  }
};

var DispatchFocusMixin = {
  data: function data() {
    return { hasFocus: false };
  },

  methods: {
    onMouseDown: function onMouseDown() {
      this._active = true;
    },
    onMouseUp: function onMouseUp() {
      this._active = false;
    },
    onFocusEvent: function onFocusEvent() {
      var _this = this;

      // dispatch async to let time to other focus event to propagate
      setTimeout(function () {
        return _this.dispatchFocusEvent();
      }, 0);
    },
    onBlurEvent: function onBlurEvent() {
      var _this2 = this;

      // dispatch async to let time to other focus event to propagate
      // also filtur blur if mousedown
      this._active || setTimeout(function () {
        return _this2.dispatchFocusEvent();
      }, 0);
    },
    dispatchFocusEvent: function dispatchFocusEvent() {
      var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
      if (hasFocus != this.hasFocus) {
        this.$emit(hasFocus ? 'focus' : 'blur');
        this.hasFocus = hasFocus;
      }
    }
  },
  mounted: function mounted() {
    this.$el.addEventListener('focusin', this.onFocusEvent);
    this.$el.addEventListener('focusout', this.onBlurEvent);
    this.$el.addEventListener('mousedown', this.onMouseDown);
    this.$el.addEventListener('mouseup', this.onMouseUp);
  },
  beforeDestroy: function beforeDestroy() {
    this.$el.removeEventListener('focusin', this.onFocusEvent);
    this.$el.removeEventListener('focusout', this.onBlurEvent);
    this.$el.removeEventListener('mousedown', this.onMouseDown);
    this.$el.removeEventListener('mouseup', this.onMouseUp);
  }
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
var MDCFoundation = function () {
  createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get$$1() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }

    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get$$1() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }

    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get$$1() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }

    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get$$1() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }

    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  createClass(MDCFoundation, [{
    key: "init",
    value: function init() {
      // Subclasses should override this method to perform initialization routines (registering events, etc.)
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    }
  }]);
  return MDCFoundation;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Ripple. Provides an interface for managing
 * - classes
 * - dom
 * - CSS variables
 * - position
 * - dimensions
 * - scroll position
 * - event handlers
 * - unbounded, active and disabled states
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCRippleAdapter = function () {
  function MDCRippleAdapter() {
    classCallCheck(this, MDCRippleAdapter);
  }

  createClass(MDCRippleAdapter, [{
    key: "browserSupportsCssVars",

    /** @return {boolean} */
    value: function browserSupportsCssVars() {}

    /** @return {boolean} */

  }, {
    key: "isUnbounded",
    value: function isUnbounded() {}

    /** @return {boolean} */

  }, {
    key: "isSurfaceActive",
    value: function isSurfaceActive() {}

    /** @return {boolean} */

  }, {
    key: "isSurfaceDisabled",
    value: function isSurfaceDisabled() {}

    /** @param {string} className */

  }, {
    key: "addClass",
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /** @param {!EventTarget} target */

  }, {
    key: "containsEventTarget",
    value: function containsEventTarget(target) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "registerDocumentInteractionHandler",
    value: function registerDocumentInteractionHandler(evtType, handler) {}

    /**
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: "deregisterDocumentInteractionHandler",
    value: function deregisterDocumentInteractionHandler(evtType, handler) {}

    /**
     * @param {!Function} handler
     */

  }, {
    key: "registerResizeHandler",
    value: function registerResizeHandler(handler) {}

    /**
     * @param {!Function} handler
     */

  }, {
    key: "deregisterResizeHandler",
    value: function deregisterResizeHandler(handler) {}

    /**
     * @param {string} varName
     * @param {?number|string} value
     */

  }, {
    key: "updateCssVariable",
    value: function updateCssVariable(varName, value) {}

    /** @return {!ClientRect} */

  }, {
    key: "computeBoundingRect",
    value: function computeBoundingRect() {}

    /** @return {{x: number, y: number}} */

  }, {
    key: "getWindowPageOffset",
    value: function getWindowPageOffset() {}
  }]);
  return MDCRippleAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
};

var strings = {
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
};

var numbers = {
  PADDING: 10,
  INITIAL_ORIGIN_SCALE: 0.6,
  DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
  FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
 * @private {boolean|undefined}
 */
var supportsCssVariables_ = void 0;

/**
 * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
 * @private {boolean|undefined}
 */
var supportsPassive_ = void 0;

/**
 * @param {!Window} windowObj
 * @return {boolean}
 */
function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  var document = windowObj.document;
  var node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node);

  // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  var computedStyle = windowObj.getComputedStyle(node);
  var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
  node.remove();
  return hasPseudoVarBug;
}

/**
 * @param {!Window} windowObj
 * @param {boolean=} forceRefresh
 * @return {boolean|undefined}
 */

function supportsCssVariables(windowObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables_;
  }

  var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
  if (!supportsFunctionPresent) {
    return;
  }

  var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
  // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari
  var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVariables_ = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVariables_ = false;
  }
  return supportsCssVariables_;
}

//
/**
 * Determine whether the current browser supports passive event listeners, and if so, use them.
 * @param {!Window=} globalObj
 * @param {boolean=} forceRefresh
 * @return {boolean|{passive: boolean}}
 */
function applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? { passive: true } : false;
}

/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */
function getMatchesProperty(HTMLElementPrototype) {
  return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
    return p in HTMLElementPrototype;
  }).pop();
}

/**
 * @param {!Event} ev
 * @param {!{x: number, y: number}} pageOffset
 * @param {!ClientRect} clientRect
 * @return {!{x: number, y: number}}
 */
function getNormalizedEventCoords(ev, pageOffset, clientRect) {
  var x = pageOffset.x,
      y = pageOffset.y;

  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;

  var normalizedX = void 0;
  var normalizedY = void 0;
  // Determine touch point relative to the ripple container.
  if (ev.type === 'touchstart') {
    normalizedX = ev.changedTouches[0].pageX - documentX;
    normalizedY = ev.changedTouches[0].pageY - documentY;
  } else {
    normalizedX = ev.pageX - documentX;
    normalizedY = ev.pageY - documentY;
  }

  return { x: normalizedX, y: normalizedY };
}

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Activation events registered on the root element of each instance for activation
var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

// Deactivation events registered on documentElement when a pointer-related down event occurs
var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

// Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
/** @type {!Array<!EventTarget>} */
var activatedTargets = [];

/**
 * @extends {MDCFoundation<!MDCRippleAdapter>}
 */

var MDCRippleFoundation = function (_MDCFoundation) {
  inherits(MDCRippleFoundation, _MDCFoundation);
  createClass(MDCRippleFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings;
    }
  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
        isUnbounded: function isUnbounded() /* boolean */{},
        isSurfaceActive: function isSurfaceActive() /* boolean */{},
        isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
        registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
        computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
        getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
      };
    }
  }]);

  function MDCRippleFoundation(adapter) {
    classCallCheck(this, MDCRippleFoundation);

    /** @private {number} */
    var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

    _this.layoutFrame_ = 0;

    /** @private {!ClientRect} */
    _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

    /** @private {!ActivationStateType} */
    _this.activationState_ = _this.defaultActivationState_();

    /** @private {number} */
    _this.initialSize_ = 0;

    /** @private {number} */
    _this.maxRadius_ = 0;

    /** @private {function(!Event)} */
    _this.activateHandler_ = function (e) {
      return _this.activate_(e);
    };

    /** @private {function(!Event)} */
    _this.deactivateHandler_ = function (e) {
      return _this.deactivate_(e);
    };

    /** @private {function(?Event=)} */
    _this.focusHandler_ = function () {
      return requestAnimationFrame(function () {
        return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    };

    /** @private {function(?Event=)} */
    _this.blurHandler_ = function () {
      return requestAnimationFrame(function () {
        return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
      });
    };

    /** @private {!Function} */
    _this.resizeHandler_ = function () {
      return _this.layout();
    };

    /** @private {!{left: number, top:number}} */
    _this.unboundedCoords_ = {
      left: 0,
      top: 0
    };

    /** @private {number} */
    _this.fgScale_ = 0;

    /** @private {number} */
    _this.activationTimer_ = 0;

    /** @private {number} */
    _this.fgDeactivationRemovalTimer_ = 0;

    /** @private {boolean} */
    _this.activationAnimationHasEnded_ = false;

    /** @private {!Function} */
    _this.activationTimerCallback_ = function () {
      _this.activationAnimationHasEnded_ = true;
      _this.runDeactivationUXLogicIfReady_();
    };

    /** @private {?Event} */
    _this.previousActivationEvent_ = null;
    return _this;
  }

  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   * @return {boolean}
   * @private
   */


  createClass(MDCRippleFoundation, [{
    key: 'isSupported_',
    value: function isSupported_() {
      return this.adapter_.browserSupportsCssVars();
    }

    /**
     * @return {!ActivationStateType}
     */

  }, {
    key: 'defaultActivationState_',
    value: function defaultActivationState_() {
      return {
        isActivated: false,
        hasDeactivationUXRun: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false,
        activationEvent: null,
        isProgrammatic: false
      };
    }
  }, {
    key: 'init',
    value: function init() {
      var _this2 = this;

      if (!this.isSupported_()) {
        return;
      }
      this.registerRootHandlers_();

      var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
          ROOT = _MDCRippleFoundation$.ROOT,
          UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

      requestAnimationFrame(function () {
        _this2.adapter_.addClass(ROOT);
        if (_this2.adapter_.isUnbounded()) {
          _this2.adapter_.addClass(UNBOUNDED);
        }
        _this2.layoutInternal_();
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      if (!this.isSupported_()) {
        return;
      }
      this.deregisterRootHandlers_();
      this.deregisterDeactivationHandlers_();

      var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
          ROOT = _MDCRippleFoundation$2.ROOT,
          UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

      requestAnimationFrame(function () {
        _this3.adapter_.removeClass(ROOT);
        _this3.adapter_.removeClass(UNBOUNDED);
        _this3.removeCssVars_();
      });
    }

    /** @private */

  }, {
    key: 'registerRootHandlers_',
    value: function registerRootHandlers_() {
      var _this4 = this;

      ACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
      });
      this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
      this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      this.adapter_.registerResizeHandler(this.resizeHandler_);
    }

    /**
     * @param {!Event} e
     * @private
     */

  }, {
    key: 'registerDeactivationHandlers_',
    value: function registerDeactivationHandlers_(e) {
      var _this5 = this;

      if (e.type === 'keydown') {
        this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
      } else {
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
        });
      }
    }

    /** @private */

  }, {
    key: 'deregisterRootHandlers_',
    value: function deregisterRootHandlers_() {
      var _this6 = this;

      ACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
      });
      this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
      this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }

    /** @private */

  }, {
    key: 'deregisterDeactivationHandlers_',
    value: function deregisterDeactivationHandlers_() {
      var _this7 = this;

      this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
        _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
      });
    }

    /** @private */

  }, {
    key: 'removeCssVars_',
    value: function removeCssVars_() {
      var _this8 = this;

      var strings$$1 = MDCRippleFoundation.strings;

      Object.keys(strings$$1).forEach(function (k) {
        if (k.indexOf('VAR_') === 0) {
          _this8.adapter_.updateCssVariable(strings$$1[k], null);
        }
      });
    }

    /**
     * @param {?Event} e
     * @private
     */

  }, {
    key: 'activate_',
    value: function activate_(e) {
      var _this9 = this;

      if (this.adapter_.isSurfaceDisabled()) {
        return;
      }

      var activationState = this.activationState_;
      if (activationState.isActivated) {
        return;
      }

      // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
      var previousActivationEvent = this.previousActivationEvent_;
      var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
      if (isSameInteraction) {
        return;
      }

      activationState.isActivated = true;
      activationState.isProgrammatic = e === null;
      activationState.activationEvent = e;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

      var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
        return _this9.adapter_.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        // Immediately reset activation state, while preserving logic that prevents touch follow-on events
        this.resetActivationState_();
        return;
      }

      if (e) {
        activatedTargets.push( /** @type {!EventTarget} */e.target);
        this.registerDeactivationHandlers_(e);
      }

      requestAnimationFrame(function () {
        // This needs to be wrapped in an rAF call b/c web browsers
        // report active states inconsistently when they're called within
        // event handling code:
        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
        activationState.wasElementMadeActive = e && e.type === 'keydown' ? _this9.adapter_.isSurfaceActive() : true;
        if (activationState.wasElementMadeActive) {
          _this9.animateActivation_();
        } else {
          // Reset activation state immediately if element was not made active.
          _this9.activationState_ = _this9.defaultActivationState_();
        }

        // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
        activatedTargets = [];
      });
    }

    /**
     * @param {?Event=} event Optional event containing position information.
     */

  }, {
    key: 'activate',
    value: function activate() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.activate_(event);
    }

    /** @private */

  }, {
    key: 'animateActivation_',
    value: function animateActivation_() {
      var _this10 = this;

      var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
          VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
          VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
      var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
          FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
          FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


      var translateStart = '';
      var translateEnd = '';

      if (!this.adapter_.isUnbounded()) {
        var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
            startPoint = _getFgTranslationCoor.startPoint,
            endPoint = _getFgTranslationCoor.endPoint;

        translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
        translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
      }

      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      // Cancel any ongoing activation/deactivation animations
      clearTimeout(this.activationTimer_);
      clearTimeout(this.fgDeactivationRemovalTimer_);
      this.rmBoundedActivationClasses_();
      this.adapter_.removeClass(FG_DEACTIVATION);

      // Force layout in order to re-trigger the animation.
      this.adapter_.computeBoundingRect();
      this.adapter_.addClass(FG_ACTIVATION);
      this.activationTimer_ = setTimeout(function () {
        return _this10.activationTimerCallback_();
      }, DEACTIVATION_TIMEOUT_MS);
    }

    /**
     * @private
     * @return {{startPoint: PointType, endPoint: PointType}}
     */

  }, {
    key: 'getFgTranslationCoordinates_',
    value: function getFgTranslationCoordinates_() {
      var _activationState_ = this.activationState_,
          activationEvent = _activationState_.activationEvent,
          wasActivatedByPointer = _activationState_.wasActivatedByPointer;


      var startPoint = void 0;
      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords(
        /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame_.width / 2,
          y: this.frame_.height / 2
        };
      }
      // Center the element around the start point.
      startPoint = {
        x: startPoint.x - this.initialSize_ / 2,
        y: startPoint.y - this.initialSize_ / 2
      };

      var endPoint = {
        x: this.frame_.width / 2 - this.initialSize_ / 2,
        y: this.frame_.height / 2 - this.initialSize_ / 2
      };

      return { startPoint: startPoint, endPoint: endPoint };
    }

    /** @private */

  }, {
    key: 'runDeactivationUXLogicIfReady_',
    value: function runDeactivationUXLogicIfReady_() {
      var _this11 = this;

      // This method is called both when a pointing device is released, and when the activation animation ends.
      // The deactivation animation should only run after both of those occur.
      var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
      var _activationState_2 = this.activationState_,
          hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
          isActivated = _activationState_2.isActivated;

      var activationHasEnded = hasDeactivationUXRun || !isActivated;

      if (activationHasEnded && this.activationAnimationHasEnded_) {
        this.rmBoundedActivationClasses_();
        this.adapter_.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer_ = setTimeout(function () {
          _this11.adapter_.removeClass(FG_DEACTIVATION);
        }, numbers.FG_DEACTIVATION_MS);
      }
    }

    /** @private */

  }, {
    key: 'rmBoundedActivationClasses_',
    value: function rmBoundedActivationClasses_() {
      var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

      this.adapter_.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded_ = false;
      this.adapter_.computeBoundingRect();
    }
  }, {
    key: 'resetActivationState_',
    value: function resetActivationState_() {
      var _this12 = this;

      this.previousActivationEvent_ = this.activationState_.activationEvent;
      this.activationState_ = this.defaultActivationState_();
      // Touch devices may fire additional events for the same interaction within a short time.
      // Store the previous event until it's safe to assume that subsequent events are for new interactions.
      setTimeout(function () {
        return _this12.previousActivationEvent_ = null;
      }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
    }

    /**
     * @param {?Event} e
     * @private
     */

  }, {
    key: 'deactivate_',
    value: function deactivate_(e) {
      var _this13 = this;

      var activationState = this.activationState_;
      // This can happen in scenarios such as when you have a keyup event that blurs the element.
      if (!activationState.isActivated) {
        return;
      }

      var state = /** @type {!ActivationStateType} */_extends({}, activationState);

      if (activationState.isProgrammatic) {
        var evtObject = null;
        requestAnimationFrame(function () {
          return _this13.animateDeactivation_(evtObject, state);
        });
        this.resetActivationState_();
      } else {
        this.deregisterDeactivationHandlers_();
        requestAnimationFrame(function () {
          _this13.activationState_.hasDeactivationUXRun = true;
          _this13.animateDeactivation_(e, state);
          _this13.resetActivationState_();
        });
      }
    }

    /**
     * @param {?Event=} event Optional event containing position information.
     */

  }, {
    key: 'deactivate',
    value: function deactivate() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.deactivate_(event);
    }

    /**
     * @param {Event} e
     * @param {!ActivationStateType} options
     * @private
     */

  }, {
    key: 'animateDeactivation_',
    value: function animateDeactivation_(e, _ref) {
      var wasActivatedByPointer = _ref.wasActivatedByPointer,
          wasElementMadeActive = _ref.wasElementMadeActive;

      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady_();
      }
    }
  }, {
    key: 'layout',
    value: function layout() {
      var _this14 = this;

      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }
      this.layoutFrame_ = requestAnimationFrame(function () {
        _this14.layoutInternal_();
        _this14.layoutFrame_ = 0;
      });
    }

    /** @private */

  }, {
    key: 'layoutInternal_',
    value: function layoutInternal_() {
      var _this15 = this;

      this.frame_ = this.adapter_.computeBoundingRect();
      var maxDim = Math.max(this.frame_.height, this.frame_.width);

      // Surface diameter is treated differently for unbounded vs. bounded ripples.
      // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
      // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
      // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
      // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
      // `overflow: hidden`.
      var getBoundedRadius = function getBoundedRadius() {
        var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
        return hypotenuse + MDCRippleFoundation.numbers.PADDING;
      };

      this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

      // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
      this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
      this.fgScale_ = this.maxRadius_ / this.initialSize_;

      this.updateLayoutCssVars_();
    }

    /** @private */

  }, {
    key: 'updateLayoutCssVars_',
    value: function updateLayoutCssVars_() {
      var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
          VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
          VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
          VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
          VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


      this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
      this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

      if (this.adapter_.isUnbounded()) {
        this.unboundedCoords_ = {
          left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
          top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
        };

        this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
        this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
      }
    }

    /** @param {boolean} unbounded */

  }, {
    key: 'setUnbounded',
    value: function setUnbounded(unbounded) {
      var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

      if (unbounded) {
        this.adapter_.addClass(UNBOUNDED);
      } else {
        this.adapter_.removeClass(UNBOUNDED);
      }
    }
  }]);
  return MDCRippleFoundation;
}(MDCFoundation);

var RippleBase = function (_MDCRippleFoundation) {
  inherits(RippleBase, _MDCRippleFoundation);
  createClass(RippleBase, null, [{
    key: 'isSurfaceActive',
    value: function isSurfaceActive(ref) {
      return ref[RippleBase.MATCHES](':active');
    }
  }, {
    key: 'MATCHES',
    get: function get$$1() {
      /* global HTMLElement */
      return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
    }
  }]);

  function RippleBase(vm, options) {
    classCallCheck(this, RippleBase);
    return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
      browserSupportsCssVars: function browserSupportsCssVars() {
        return supportsCssVariables(window);
      },
      isUnbounded: function isUnbounded() {
        return false;
      },
      isSurfaceActive: function isSurfaceActive() {
        return vm.$el[RippleBase.MATCHES](':active');
      },
      isSurfaceDisabled: function isSurfaceDisabled() {
        return vm.disabled;
      },
      addClass: function addClass(className) {
        vm.$set(vm.classes, className, true);
      },
      removeClass: function removeClass(className) {
        vm.$delete(vm.classes, className);
      },

      containsEventTarget: function containsEventTarget(target) {
        return vm.$el.contains(target);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        vm.$el.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        vm.$el.removeEventListener(evt, handler);
      },
      registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
        return document.documentElement.addEventListener(evtType, handler, applyPassive());
      },
      deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
        return document.documentElement.removeEventListener(evtType, handler, applyPassive());
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        return window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        return window.removeEventListener('resize', handler);
      },
      updateCssVariable: function updateCssVariable(varName, value) {
        vm.$set(vm.styles, varName, value);
      },
      computeBoundingRect: function computeBoundingRect() {
        return vm.$el.getBoundingClientRect();
      },
      getWindowPageOffset: function getWindowPageOffset() {
        return { x: window.pageXOffset, y: window.pageYOffset };
      }
    }, options)));
  }

  return RippleBase;
}(MDCRippleFoundation);

var RippleMixin = {
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },
  mounted: function mounted() {
    this.ripple = new RippleBase(this);
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple.destroy();
  }
};

var mdcRipple = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-ripple", attrs: { "tag": _vm.tag, "classes": _vm.classes, "styles": _vm.styles } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-ripple',
  mixins: [CustomElementMixin, RippleMixin],
  props: {
    tag: String
  }
};

var VueMDCRipple = BasePlugin({
  mdcRipple: mdcRipple
});

var mdcButtonBase = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', { ref: "root", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link, "disabled": _vm.disabled }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-button-base',
  mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  }
};

var mdcButton = {
  name: 'mdc-button',
  extends: mdcButtonBase,
  props: {
    raised: Boolean,
    unelevated: Boolean,
    stroked: Boolean,
    dense: Boolean,
    compact: Boolean,
    accent: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-button': true,
        'mdc-button--raised': this.raised,
        'mdc-button--unelevated': this.unelevated,
        'mdc-button--stroked': this.stroked,
        'mdc-button--dense': this.dense,
        'mdc-button--compact': this.compact,
        'mdc-button--accent': this.accent
      }
    };
  },

  watch: {
    raised: function raised() {
      this.$set(this.classes, 'mdc-button--raised', this.raised);
    },
    unelevated: function unelevated() {
      this.$set(this.classes, 'mdc-button--unelevated', this.unelevated);
    },
    stroked: function stroked() {
      this.$set(this.classes, 'mdc-button--stroked', this.stroked);
    },
    dense: function dense() {
      this.$set(this.classes, 'mdc-button--dense', this.dense);
    },
    compact: function compact() {
      this.$set(this.classes, 'mdc-button--compact', this.compact);
    },
    accent: function accent() {
      this.$set(this.classes, 'mdc-button--accent', this.accent);
    }
  }
};

var VueMDCButton = BasePlugin({
  mdcButton: mdcButton
});

var mdcCard = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card", class: { 'mdc-card--stroked': _vm.stroked } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: "mdc-card",
  props: {
    stroked: Boolean
  }
};

var mdcCardPrimaryAction = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-card-primary-action mdc-card__primary-action", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-primary-action',
  mixins: [DispatchEventMixin, CustomLinkMixin, RippleMixin],
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  }
};

var mdcCardMedia = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-media mdc-card__media", class: _vm.classes, style: _vm.styles }, [_vm.$slots.default ? _c('div', { staticClass: "mdc-card__media-content" }, [_vm._t("default")], 2) : _vm._e()]);
  }, staticRenderFns: [],
  name: "mdc-card-media",
  props: {
    src: String,
    'square': Boolean
  },
  computed: {
    styles: function styles() {
      var styles = {
        backgroundImage: 'url(' + this.src + ')'
      };

      return styles;
    },
    classes: function classes() {
      return this.square ? 'mdc-card__media--square' : 'mdc-card__media--16-9';
    }
  }
};

var mdcCardHeader = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-header mdc-card__primary" }, [_vm._t("default", [_vm.title ? _c('h1', { staticClass: "mdc-card__title", class: { 'mdc-card__title--large': _vm.largeTitle } }, [_vm._v(" " + _vm._s(_vm.title) + " ")]) : _vm._e(), _vm._v(" "), _vm.subtitle ? _c('h2', { staticClass: "mdc-card__subtitle" }, [_vm._v(" " + _vm._s(_vm.subtitle) + " ")]) : _vm._e()])], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-header',
  props: {
    'title': String,
    'subtitle': String,
    'large-title': { type: Boolean, default: true }
  }
};

var mdcCardTitle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h1', { staticClass: "mdc-card-title mdc-card__title", class: { 'mdc-card__title--large': _vm.large } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-title',
  props: {
    'large': Boolean
  }
};

var mdcCardSubtitle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h2', { staticClass: "mdc-card-subtitle mdc-card__subtitle" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-subtitle'
};

var mdcCardText = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-text mdc-card__supporting-text" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-text'
};

var mdcCardActions = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-actions mdc-card__actions", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-actions',
  props: {
    fullBleed: Boolean
  },
  computed: {
    classes: function classes() {
      return {
        'mdc-card__actions--full-bleed': this.fullBleed
      };
    }
  }
};

var mdcCardActionButtons = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-buttons mdc-card__action-buttons" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: "mdc-card-action-buttons"
};

var mdcCardActionButton = {
  name: 'mdc-card-action-button',
  extends: mdcButtonBase,
  props: {
    compact: Boolean,
    accent: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-button': true,
        'mdc-card__action': true,
        'mdc-card-action-button': true,
        'mdc-button--compact': this.compact,
        'mdc-button--accent': this.accent
      }
    };
  },

  watch: {
    compact: function compact() {
      this.$set(this.classes, 'mdc-button--compact', this.compact);
    },
    accent: function accent() {
      this.$set(this.classes, 'mdc-button--accent', this.accent);
    }
  }
};

var mdcCardActionIcons = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-icons mdc-card__action-icons" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: "mdc-card-action-icons"
};

var mdcCardActionIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { class: _vm.classes, style: _vm.styles, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-card-action-icon',
  mixins: [DispatchEventMixin],
  props: {
    icon: String
  },
  data: function data() {
    return {
      classes: {
        'mdc-card-action-icon': true,
        'material-icons': !!this.icon,
        'mdc-card__action': true,
        'mdc-card__action--icon': true,
        'mdc-icon-toggle': true
      },
      styles: {}
    };
  },

  watch: {
    icon: function icon() {
      this.$set(this.classes, 'material-icons', !!this.icon);
    }
  },
  mounted: function mounted() {
    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      }
    });
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple.destroy();
  }
};

var VueMDCCard = BasePlugin({
  mdcCard: mdcCard,
  mdcCardPrimaryAction: mdcCardPrimaryAction,
  mdcCardMedia: mdcCardMedia,
  mdcCardHeader: mdcCardHeader,
  mdcCardTitle: mdcCardTitle,
  mdcCardSubtitle: mdcCardSubtitle,
  mdcCardText: mdcCardText,
  mdcCardActions: mdcCardActions,
  mdcCardActionButtons: mdcCardActionButtons,
  mdcCardActionButton: mdcCardActionButton,
  mdcCardActionIcons: mdcCardActionIcons,
  mdcCardActionIcon: mdcCardActionIcon
});

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template F
 */

var MDCComponent = function () {
  createClass(MDCComponent, null, [{
    key: 'attachTo',

    /**
     * @param {!Element} root
     * @return {!MDCComponent}
     */
    value: function attachTo(root) {
      // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
      // returns an instantiated component with its root set to that element. Also note that in the cases of
      // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
      // from getDefaultFoundation().
      return new MDCComponent(root, new MDCFoundation());
    }

    /**
     * @param {!Element} root
     * @param {F=} foundation
     * @param {...?} args
     */

  }]);

  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args);
    // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.
    /** @protected {!F} */
    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  createClass(MDCComponent, [{
    key: 'initialize',
    value: function initialize() /* ...args */{}
    // Subclasses can override this to do any additional setup work that would be considered part of a
    // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
    // initialized. Any additional arguments besides root and foundation will be passed in here.


    /**
     * @return {!F} foundation
     */

  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      // Subclasses must override this method to return a properly configured foundation class for the
      // component.
      throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      // Subclasses should override this method if they need to perform work to synchronize with a host DOM
      // object. An example of this would be a form control wrapper that needs to synchronize its internal state
      // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
      // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      // Subclasses may implement this method to release any resources / deregister any listeners they have
      // attached. An example of this might be deregistering a resize event from the window object.
      this.foundation_.destroy();
    }

    /**
     * Wrapper method to add an event listener to the component's root element. This is most useful when
     * listening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'listen',
    value: function listen(evtType, handler) {
      this.root_.addEventListener(evtType, handler);
    }

    /**
     * Wrapper method to remove an event listener to the component's root element. This is most useful when
     * unlistening for custom events.
     * @param {string} evtType
     * @param {!Function} handler
     */

  }, {
    key: 'unlisten',
    value: function unlisten(evtType, handler) {
      this.root_.removeEventListener(evtType, handler);
    }

    /**
     * Fires a cross-browser-compatible custom event from the component root of the given type,
     * with the given data.
     * @param {string} evtType
     * @param {!Object} evtData
     * @param {boolean=} shouldBubble
     */

  }, {
    key: 'emit',
    value: function emit(evtType, evtData) {
      var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var evt = void 0;
      if (typeof CustomEvent === 'function') {
        evt = new CustomEvent(evtType, {
          detail: evtData,
          bubbles: shouldBubble
        });
      } else {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }

      this.root_.dispatchEvent(evt);
    }
  }]);
  return MDCComponent;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends MDCComponent<!MDCRippleFoundation>
 */

var MDCRipple = function (_MDCComponent) {
  inherits(MDCRipple, _MDCComponent);

  /** @param {...?} args */
  function MDCRipple() {
    var _ref;

    classCallCheck(this, MDCRipple);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @type {boolean} */
    var _this = possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));

    _this.disabled = false;

    /** @private {boolean} */
    _this.unbounded_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @param {{isUnbounded: (boolean|undefined)}=} options
   * @return {!MDCRipple}
   */


  createClass(MDCRipple, [{
    key: 'setUnbounded_',


    /**
     * Closure Compiler throws an access control error when directly accessing a
     * protected or private property inside a getter/setter, like unbounded above.
     * By accessing the protected property inside a method, we solve that problem.
     * That's why this function exists.
     * @private
     */
    value: function setUnbounded_() {
      this.foundation_.setUnbounded(this.unbounded_);
    }
  }, {
    key: 'activate',
    value: function activate() {
      this.foundation_.activate();
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.foundation_.deactivate();
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.foundation_.layout();
    }

    /** @return {!MDCRippleFoundation} */

  }, {
    key: 'getDefaultFoundation',
    value: function getDefaultFoundation() {
      return new MDCRippleFoundation(MDCRipple.createAdapter(this));
    }
  }, {
    key: 'initialSyncWithDOM',
    value: function initialSyncWithDOM() {
      this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
    }
  }, {
    key: 'unbounded',


    /** @return {boolean} */
    get: function get$$1() {
      return this.unbounded_;
    }

    /** @param {boolean} unbounded */
    ,
    set: function set$$1(unbounded) {
      this.unbounded_ = Boolean(unbounded);
      this.setUnbounded_();
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$isUnbounded = _ref2.isUnbounded,
          isUnbounded = _ref2$isUnbounded === undefined ? undefined : _ref2$isUnbounded;

      var ripple = new MDCRipple(root);
      // Only override unbounded behavior if option is explicitly specified
      if (isUnbounded !== undefined) {
        ripple.unbounded = /** @type {boolean} */isUnbounded;
      }
      return ripple;
    }

    /**
     * @param {!RippleCapableSurface} instance
     * @return {!MDCRippleAdapter}
     */

  }, {
    key: 'createAdapter',
    value: function createAdapter(instance) {
      var MATCHES = getMatchesProperty(HTMLElement.prototype);

      return {
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return instance.unbounded;
        },
        isSurfaceActive: function isSurfaceActive() {
          return instance.root_[MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return instance.disabled;
        },
        addClass: function addClass(className) {
          return instance.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return instance.root_.classList.remove(className);
        },
        containsEventTarget: function containsEventTarget(target) {
          return instance.root_.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          return instance.root_.addEventListener(evtType, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          return instance.root_.removeEventListener(evtType, handler, applyPassive());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          return instance.root_.style.setProperty(varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return instance.root_.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      };
    }
  }]);
  return MDCRipple;
}(MDCComponent);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/**
 * @record
 */

var MDCSelectionControl = function () {
  function MDCSelectionControl() {
    classCallCheck(this, MDCSelectionControl);
  }

  createClass(MDCSelectionControl, [{
    key: 'ripple',

    /** @return {?MDCRipple} */
    get: function get$$1() {}
  }]);
  return MDCSelectionControl;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Checkbox. Provides an interface for managing
 * - classes
 * - dom
 * - event handlers
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */

var MDCCheckboxAdapter = function () {
  function MDCCheckboxAdapter() {
    classCallCheck(this, MDCCheckboxAdapter);
  }

  createClass(MDCCheckboxAdapter, [{
    key: 'addClass',

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: 'removeClass',
    value: function removeClass(className) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'registerAnimationEndHandler',
    value: function registerAnimationEndHandler(handler) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'deregisterAnimationEndHandler',
    value: function deregisterAnimationEndHandler(handler) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'registerChangeHandler',
    value: function registerChangeHandler(handler) {}

    /** @param {!EventListener} handler */

  }, {
    key: 'deregisterChangeHandler',
    value: function deregisterChangeHandler(handler) {}

    /** @return {!MDCSelectionControlState} */

  }, {
    key: 'getNativeControl',
    value: function getNativeControl() {}
  }, {
    key: 'forceLayout',
    value: function forceLayout() {}

    /** @return {boolean} */

  }, {
    key: 'isAttachedToDOM',
    value: function isAttachedToDOM() {}
  }]);
  return MDCCheckboxAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const {string} */
var ROOT = 'mdc-checkbox';

/** @enum {string} */
var cssClasses$1 = {
  UPGRADED: 'mdc-checkbox--upgraded',
  CHECKED: 'mdc-checkbox--checked',
  INDETERMINATE: 'mdc-checkbox--indeterminate',
  DISABLED: 'mdc-checkbox--disabled',
  ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
  ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
  ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
  ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
  ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
  ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
};

/** @enum {string} */
var strings$1 = {
  NATIVE_CONTROL_SELECTOR: '.' + ROOT + '__native-control',
  TRANSITION_STATE_INIT: 'init',
  TRANSITION_STATE_CHECKED: 'checked',
  TRANSITION_STATE_UNCHECKED: 'unchecked',
  TRANSITION_STATE_INDETERMINATE: 'indeterminate'
};

/** @enum {number} */
var numbers$1 = {
  ANIM_END_LATCH_MS: 250
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint-enable no-unused-vars */
/** @const {!Array<string>} */
var CB_PROTO_PROPS = ['checked', 'indeterminate'];

/**
 * @extends {MDCFoundation<!MDCCheckboxAdapter>}
 */

var MDCCheckboxFoundation = function (_MDCFoundation) {
  inherits(MDCCheckboxFoundation, _MDCFoundation);
  createClass(MDCCheckboxFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$1;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$1;
    }

    /** @return enum {numbers} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$1;
    }

    /** @return {!MDCCheckboxAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCCheckboxAdapter} */{
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerAnimationEndHandler: function registerAnimationEndHandler() /* handler: EventListener */{},
          deregisterAnimationEndHandler: function deregisterAnimationEndHandler() /* handler: EventListener */{},
          registerChangeHandler: function registerChangeHandler() /* handler: EventListener */{},
          deregisterChangeHandler: function deregisterChangeHandler() /* handler: EventListener */{},
          getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{},
          forceLayout: function forceLayout() {},
          isAttachedToDOM: function isAttachedToDOM() /* boolean */{}
        }
      );
    }
  }]);

  function MDCCheckboxFoundation(adapter) {
    classCallCheck(this, MDCCheckboxFoundation);

    /** @private {string} */
    var _this = possibleConstructorReturn(this, (MDCCheckboxFoundation.__proto__ || Object.getPrototypeOf(MDCCheckboxFoundation)).call(this, _extends(MDCCheckboxFoundation.defaultAdapter, adapter)));

    _this.currentCheckState_ = strings$1.TRANSITION_STATE_INIT;

    /** @private {string} */
    _this.currentAnimationClass_ = '';

    /** @private {number} */
    _this.animEndLatchTimer_ = 0;

    _this.animEndHandler_ = /** @private {!EventListener} */function () {
      return _this.handleAnimationEnd();
    };

    _this.changeHandler_ = /** @private {!EventListener} */function () {
      return _this.handleChange();
    };
    return _this;
  }

  createClass(MDCCheckboxFoundation, [{
    key: 'init',
    value: function init() {
      this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
      this.adapter_.addClass(cssClasses$1.UPGRADED);
      this.adapter_.registerChangeHandler(this.changeHandler_);
      this.installPropertyChangeHooks_();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterChangeHandler(this.changeHandler_);
      this.uninstallPropertyChangeHooks_();
    }

    /** @return {boolean} */

  }, {
    key: 'isChecked',
    value: function isChecked() {
      return this.getNativeControl_().checked;
    }

    /** @param {boolean} checked */

  }, {
    key: 'setChecked',
    value: function setChecked(checked) {
      this.getNativeControl_().checked = checked;
    }

    /** @return {boolean} */

  }, {
    key: 'isIndeterminate',
    value: function isIndeterminate() {
      return this.getNativeControl_().indeterminate;
    }

    /** @param {boolean} indeterminate */

  }, {
    key: 'setIndeterminate',
    value: function setIndeterminate(indeterminate) {
      this.getNativeControl_().indeterminate = indeterminate;
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.getNativeControl_().disabled;
    }

    /** @param {boolean} disabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      this.getNativeControl_().disabled = disabled;
      if (disabled) {
        this.adapter_.addClass(cssClasses$1.DISABLED);
      } else {
        this.adapter_.removeClass(cssClasses$1.DISABLED);
      }
    }

    /** @return {?string} */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.getNativeControl_().value;
    }

    /** @param {?string} value */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.getNativeControl_().value = value;
    }

    /**
     * Handles the animationend event for the checkbox
     */

  }, {
    key: 'handleAnimationEnd',
    value: function handleAnimationEnd() {
      var _this2 = this;

      clearTimeout(this.animEndLatchTimer_);
      this.animEndLatchTimer_ = setTimeout(function () {
        _this2.adapter_.removeClass(_this2.currentAnimationClass_);
        _this2.adapter_.deregisterAnimationEndHandler(_this2.animEndHandler_);
      }, numbers$1.ANIM_END_LATCH_MS);
    }

    /**
     * Handles the change event for the checkbox
     */

  }, {
    key: 'handleChange',
    value: function handleChange() {
      this.transitionCheckState_();
    }

    /** @private */

  }, {
    key: 'installPropertyChangeHooks_',
    value: function installPropertyChangeHooks_() {
      var _this3 = this;

      var nativeCb = this.getNativeControl_();
      var cbProto = Object.getPrototypeOf(nativeCb);

      CB_PROTO_PROPS.forEach(function (controlState) {
        var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
        // We have to check for this descriptor, since some browsers (Safari) don't support its return.
        // See: https://bugs.webkit.org/show_bug.cgi?id=49739
        if (validDescriptor(desc)) {
          var nativeCbDesc = /** @type {!ObjectPropertyDescriptor} */{
            get: desc.get,
            set: function set$$1(state) {
              desc.set.call(nativeCb, state);
              _this3.transitionCheckState_();
            },
            configurable: desc.configurable,
            enumerable: desc.enumerable
          };
          Object.defineProperty(nativeCb, controlState, nativeCbDesc);
        }
      });
    }

    /** @private */

  }, {
    key: 'uninstallPropertyChangeHooks_',
    value: function uninstallPropertyChangeHooks_() {
      var nativeCb = this.getNativeControl_();
      var cbProto = Object.getPrototypeOf(nativeCb);

      CB_PROTO_PROPS.forEach(function (controlState) {
        var desc = /** @type {!ObjectPropertyDescriptor} */Object.getOwnPropertyDescriptor(cbProto, controlState);
        if (validDescriptor(desc)) {
          Object.defineProperty(nativeCb, controlState, desc);
        }
      });
    }

    /** @private */

  }, {
    key: 'transitionCheckState_',
    value: function transitionCheckState_() {
      var nativeCb = this.adapter_.getNativeControl();
      if (!nativeCb) {
        return;
      }
      var oldState = this.currentCheckState_;
      var newState = this.determineCheckState_(nativeCb);
      if (oldState === newState) {
        return;
      }

      // Check to ensure that there isn't a previously existing animation class, in case for example
      // the user interacted with the checkbox before the animation was finished.
      if (this.currentAnimationClass_.length > 0) {
        clearTimeout(this.animEndLatchTimer_);
        this.adapter_.forceLayout();
        this.adapter_.removeClass(this.currentAnimationClass_);
      }

      this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
      this.currentCheckState_ = newState;

      // Check for parentNode so that animations are only run when the element is attached
      // to the DOM.
      if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
        this.adapter_.addClass(this.currentAnimationClass_);
        this.adapter_.registerAnimationEndHandler(this.animEndHandler_);
      }
    }

    /**
     * @param {!MDCSelectionControlState} nativeCb
     * @return {string}
     * @private
     */

  }, {
    key: 'determineCheckState_',
    value: function determineCheckState_(nativeCb) {
      var TRANSITION_STATE_INDETERMINATE = strings$1.TRANSITION_STATE_INDETERMINATE,
          TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
          TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;


      if (nativeCb.indeterminate) {
        return TRANSITION_STATE_INDETERMINATE;
      }
      return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
    }

    /**
     * @param {string} oldState
     * @param {string} newState
     * @return {string}
     */

  }, {
    key: 'getTransitionAnimationClass_',
    value: function getTransitionAnimationClass_(oldState, newState) {
      var TRANSITION_STATE_INIT = strings$1.TRANSITION_STATE_INIT,
          TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
          TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;
      var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
          ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
          ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
          ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
          ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
          ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
          ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;


      switch (oldState) {
        case TRANSITION_STATE_INIT:
          if (newState === TRANSITION_STATE_UNCHECKED) {
            return '';
          }
        // fallthrough
        case TRANSITION_STATE_UNCHECKED:
          return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
        case TRANSITION_STATE_CHECKED:
          return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
        // TRANSITION_STATE_INDETERMINATE
        default:
          return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
      }
    }

    /**
     * @return {!MDCSelectionControlState}
     * @private
     */

  }, {
    key: 'getNativeControl_',
    value: function getNativeControl_() {
      return this.adapter_.getNativeControl() || {
        checked: false,
        indeterminate: false,
        disabled: false,
        value: null
      };
    }
  }]);
  return MDCCheckboxFoundation;
}(MDCFoundation);

/**
 * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
 * @return {boolean}
 */


function validDescriptor(inputPropDesc) {
  return !!inputPropDesc && typeof inputPropDesc.set === 'function';
}

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Form Field. Provides an interface for managing
 * - event handlers
 * - ripple activation
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCFormFieldAdapter = function () {
  function MDCFormFieldAdapter() {
    classCallCheck(this, MDCFormFieldAdapter);
  }

  createClass(MDCFormFieldAdapter, [{
    key: "registerInteractionHandler",

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */
    value: function registerInteractionHandler(type, handler) {}

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}
  }, {
    key: "activateInputRipple",
    value: function activateInputRipple() {}
  }, {
    key: "deactivateInputRipple",
    value: function deactivateInputRipple() {}
  }]);
  return MDCFormFieldAdapter;
}();

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$2 = {
  ROOT: 'mdc-form-field'
};

/** @enum {string} */
var strings$2 = {
  LABEL_SELECTOR: '.mdc-form-field > label'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCFormFieldAdapter>}
 */

var MDCFormFieldFoundation = function (_MDCFoundation) {
  inherits(MDCFormFieldFoundation, _MDCFoundation);
  createClass(MDCFormFieldFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$2;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$2;
    }

    /** @return {!MDCFormFieldAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        activateInputRipple: function activateInputRipple() {},
        deactivateInputRipple: function deactivateInputRipple() {}
      };
    }
  }]);

  function MDCFormFieldFoundation(adapter) {
    classCallCheck(this, MDCFormFieldFoundation);

    /** @private {!EventListener} */
    var _this = possibleConstructorReturn(this, (MDCFormFieldFoundation.__proto__ || Object.getPrototypeOf(MDCFormFieldFoundation)).call(this, _extends(MDCFormFieldFoundation.defaultAdapter, adapter)));

    _this.clickHandler_ = /** @type {!EventListener} */function () {
      return _this.handleClick_();
    };
    return _this;
  }

  createClass(MDCFormFieldFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
    }

    /** @private */

  }, {
    key: 'handleClick_',
    value: function handleClick_() {
      var _this2 = this;

      this.adapter_.activateInputRipple();
      requestAnimationFrame(function () {
        return _this2.adapter_.deactivateInputRipple();
      });
    }
  }]);
  return MDCFormFieldFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @typedef {{
 *   noPrefix: string,
 *   webkitPrefix: string,
 *   styleProperty: string
 * }}
 */
/** @const {Object<string, !VendorPropertyMapType>} */
var eventTypeMap = {
  'animationstart': {
    noPrefix: 'animationstart',
    webkitPrefix: 'webkitAnimationStart',
    styleProperty: 'animation'
  },
  'animationend': {
    noPrefix: 'animationend',
    webkitPrefix: 'webkitAnimationEnd',
    styleProperty: 'animation'
  },
  'animationiteration': {
    noPrefix: 'animationiteration',
    webkitPrefix: 'webkitAnimationIteration',
    styleProperty: 'animation'
  },
  'transitionend': {
    noPrefix: 'transitionend',
    webkitPrefix: 'webkitTransitionEnd',
    styleProperty: 'transition'
  }
};

/** @const {Object<string, !VendorPropertyMapType>} */
var cssPropertyMap = {
  'animation': {
    noPrefix: 'animation',
    webkitPrefix: '-webkit-animation'
  },
  'transform': {
    noPrefix: 'transform',
    webkitPrefix: '-webkit-transform'
  },
  'transition': {
    noPrefix: 'transition',
    webkitPrefix: '-webkit-transition'
  }
};

/**
 * @param {!Object} windowObj
 * @return {boolean}
 */
function hasProperShape(windowObj) {
  return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
}

/**
 * @param {string} eventType
 * @return {boolean}
 */
function eventFoundInMaps(eventType) {
  return eventType in eventTypeMap || eventType in cssPropertyMap;
}

/**
 * @param {string} eventType
 * @param {!Object<string, !VendorPropertyMapType>} map
 * @param {!Element} el
 * @return {string}
 */
function getJavaScriptEventName(eventType, map, el) {
  return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
}

/**
 * Helper function to determine browser prefix for CSS3 animation events
 * and property names.
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getAnimationName(windowObj, eventType) {
  if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
    return eventType;
  }

  var map = /** @type {!Object<string, !VendorPropertyMapType>} */eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
  var el = windowObj['document']['createElement']('div');
  var eventName = '';

  if (map === eventTypeMap) {
    eventName = getJavaScriptEventName(eventType, map, el);
  } else {
    eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  return eventName;
}

// Public functions to access getAnimationName() for JavaScript events or CSS
// property names.

var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getCorrectEventName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}

/**
 * @param {!Object} windowObj
 * @param {string} eventType
 * @return {string}
 */
function getCorrectPropertyName(windowObj, eventType) {
  return getAnimationName(windowObj, eventType);
}

/* global HTMLElement */
var mdcCheckbox = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-checkbox-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-checkbox", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-checkbox__native-control", attrs: { "id": _vm._uid, "type": "checkbox", "name": _vm.name }, domProps: { "value": _vm.value }, on: { "change": _vm.onChange } }), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__background" }, [_c('svg', { staticClass: "mdc-checkbox__checkmark", attrs: { "viewBox": "0 0 24 24" } }, [_c('path', { staticClass: "checkbox__checkmark-path", attrs: { "fill": "none", "stroke": "white", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__mixedmark" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-checkbox',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    'checked': Boolean,
    'indeterminate': Boolean,
    'disabled': Boolean,
    'label': String,
    'align-end': Boolean,
    'value': { type: String, default: function _default() {
        return 'on';
      }
    },
    'name': String
  },
  data: function data() {
    return {
      styles: {},
      classes: {}
    };
  },

  computed: {
    hasLabel: function hasLabel() {
      return this.label || this.$slots.default;
    },
    formFieldClasses: function formFieldClasses() {
      return {
        'mdc-form-field': this.hasLabel,
        'mdc-form-field--align-end': this.hasLabel && this.alignEnd
      };
    }
  },
  watch: {
    'checked': function checked(value) {
      this.foundation.setChecked(value);
    },
    'disabled': function disabled(value) {
      this.foundation.setDisabled(value);
    },
    'indeterminate': function indeterminate(value) {
      this.foundation.setIndeterminate(value);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCCheckboxFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      registerAnimationEndHandler: function registerAnimationEndHandler(handler) {
        return _this.$refs.root.addEventListener(getCorrectEventName(window, 'animationend'), handler);
      },
      deregisterAnimationEndHandler: function deregisterAnimationEndHandler(handler) {
        return _this.$refs.root.removeEventListener(getCorrectEventName(window, 'animationend'), handler);
      },
      registerChangeHandler: function registerChangeHandler(handler) {
        return _this.$refs.control.addEventListener('change', handler);
      },
      deregisterChangeHandler: function deregisterChangeHandler(handler) {
        return _this.$refs.control.removeEventListener('change', handler);
      },
      getNativeControl: function getNativeControl() {
        return _this.$refs.control;
      },
      forceLayout: function forceLayout() {
        return _this.$refs.root.offsetWidth;
      },
      isAttachedToDOM: function isAttachedToDOM() {
        return Boolean(_this.$el.parentNode);
      }
    });

    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      },
      isSurfaceActive: function isSurfaceActive() {
        return RippleBase.isSurfaceActive(_this.$refs.control);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$refs.control.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$refs.control.addEventListener(evt, handler);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this.$refs.root.getBoundingClientRect();
      }
    });

    this.formField = new MDCFormFieldFoundation({
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        _this.$refs.label.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        _this.$refs.label.removeEventListener(type, handler);
      },
      activateInputRipple: function activateInputRipple() {
        _this.ripple && _this.ripple.activate();
      },
      deactivateInputRipple: function deactivateInputRipple() {
        _this.ripple && _this.ripple.deactivate();
      }
    });

    this.foundation.init();
    this.ripple.init();
    this.formField.init();
    this.foundation.setChecked(this.checked);
    this.foundation.setDisabled(this.disabled);
    this.foundation.setIndeterminate(this.indeterminate);
  },
  beforeDestroy: function beforeDestroy() {
    this.formField.destroy();
    this.ripple.destroy();
    this.foundation.destroy();
  },

  methods: {
    onChange: function onChange() {
      this.$emit('update:indeterminate', this.foundation.isIndeterminate());
      this.$emit('change', this.foundation.isChecked());
    }
  }
};

var VueMDCCheckbox = BasePlugin({
  mdcCheckbox: mdcCheckbox
});

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Chip.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Chip into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCChipAdapter = function () {
  function MDCChipAdapter() {
    classCallCheck(this, MDCChipAdapter);
  }

  createClass(MDCChipAdapter, [{
    key: "registerInteractionHandler",

    /**
     * Registers an event listener on the root element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */
    value: function registerInteractionHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the root element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}

    /**
     * Emits a custom "MDCChip:interaction" event denoting the chip has been
     * interacted with (typically on click or keydown).
     */

  }, {
    key: "notifyInteraction",
    value: function notifyInteraction() {}
  }]);
  return MDCChipAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$3 = {
  INTERACTION_EVENT: 'MDCChip:interaction'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCChipAdapter>}
 * @final
 */

var MDCChipFoundation = function (_MDCFoundation) {
  inherits(MDCChipFoundation, _MDCFoundation);
  createClass(MDCChipFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$3;
    }

    /**
     * {@see MDCChipAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCChipAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCChipAdapter} */{
          registerInteractionHandler: function registerInteractionHandler() {},
          deregisterInteractionHandler: function deregisterInteractionHandler() {},
          notifyInteraction: function notifyInteraction() {}
        }
      );
    }

    /**
     * @param {!MDCChipAdapter} adapter
     */

  }]);

  function MDCChipFoundation(adapter) {
    classCallCheck(this, MDCChipFoundation);

    /** @private {function(!Event): undefined} */
    var _this = possibleConstructorReturn(this, (MDCChipFoundation.__proto__ || Object.getPrototypeOf(MDCChipFoundation)).call(this, _extends(MDCChipFoundation.defaultAdapter, adapter)));

    _this.interactionHandler_ = function (evt) {
      return _this.handleInteraction_(evt);
    };
    return _this;
  }

  createClass(MDCChipFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
      });
    }

    /**
     * Handles an interaction event on the root element.
     * @param {!Event} evt
     */

  }, {
    key: 'handleInteraction_',
    value: function handleInteraction_(evt) {
      if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
        this.adapter_.notifyInteraction();
      }
    }
  }]);
  return MDCChipFoundation;
}(MDCFoundation);

var mdcChip = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-chip", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "0" } }, [_vm.haveleadingIcon ? _c('i', { staticClass: "mdc-chip__icon mdc-chip__icon--leading", class: _vm.leadingClasses }, [_vm._v(_vm._s(_vm.leadingIcon))]) : _vm._e(), _vm._v(" "), _c('div', { attrs: { "classes": "mdc-chip__text" } }, [_vm._t("default")], 2), _vm._v(" "), _vm.havetrailingIcon ? _c('i', { staticClass: "mdc-chip__icon mdc-chip__icon--trailing", class: _vm.trailingClasses, attrs: { "tabindex": "0", "role": "button" } }, [_vm._v(_vm._s(_vm.trailingIcon))]) : _vm._e()]);
  }, staticRenderFns: [],
  name: "mdc-chip",
  mixins: [CustomLinkMixin, DispatchEventMixin],
  props: {
    leadingIcon: [String],
    trailingIcon: [String],
    leadingIconClasses: [Object],
    trailingIconClasses: [Object]
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  methods: {},
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCChipFoundation({
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$el.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$el.removeEventListener(type, handler);
      },
      notifyInteraction: function notifyInteraction() {
        _this.dispatchEvent({ type: 'click' });
      }
    });

    this.foundation.init();

    this.ripple = new RippleBase(this);
    this.ripple.init();
  },

  computed: {
    haveleadingIcon: function haveleadingIcon() {
      return !!this.leadingIcon || this.leadingIconClasses;
    },
    havetrailingIcon: function havetrailingIcon() {
      return !!this.trailingIcon || this.trailingIconClasses;
    },
    leadingClasses: function leadingClasses() {
      return _extends({}, {
        "material-icons": !!this.leadingIcon
      }, this.leadingIconClasses);
    },
    trailingClasses: function trailingClasses() {
      return _extends({}, {
        "material-icons": !!this.trailingIcon
      }, this.trailingIconClasses);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple.destroy();
    this.foundation.destroy();
  }
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Chip Set.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Chip Set into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCChipSetAdapter = function () {
  function MDCChipSetAdapter() {
    classCallCheck(this, MDCChipSetAdapter);
  }

  createClass(MDCChipSetAdapter, [{
    key: "hasClass",

    /**
     * Returns true if the root element contains the given class name.
     * @param {string} className
     */
    value: function hasClass(className) {}
  }]);
  return MDCChipSetAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$4 = {
  CHIP_SELECTOR: '.mdc-chip'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCChipSetAdapter>}
 * @final
 */

var MDCChipSetFoundation = function (_MDCFoundation) {
  inherits(MDCChipSetFoundation, _MDCFoundation);
  createClass(MDCChipSetFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$4;
    }

    /**
     * {@see MDCChipSetAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCChipSetAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCChipSetAdapter} */{
          hasClass: function hasClass() {}
        }
      );
    }

    /**
     * @param {!MDCChipSetAdapter} adapter
     */

  }]);

  function MDCChipSetFoundation(adapter) {
    classCallCheck(this, MDCChipSetFoundation);
    return possibleConstructorReturn(this, (MDCChipSetFoundation.__proto__ || Object.getPrototypeOf(MDCChipSetFoundation)).call(this, _extends(MDCChipSetFoundation.defaultAdapter, adapter)));
  }

  return MDCChipSetFoundation;
}(MDCFoundation);

var mdcChipSet = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-chip-set", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-chip-set',
  props: {},
  data: function data() {
    return {
      classes: {}
    };
  },

  methods: {},
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCChipSetFoundation({
      hasClass: function hasClass(className) {
        return _this.$refs.root.classList.contains(className);
      }
    });

    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCChipSet = BasePlugin({
  mdcChip: mdcChip,
  mdcChipSet: mdcChipSet
});

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$3 = {
  ROOT: 'mdc-dialog',
  OPEN: 'mdc-dialog--open',
  ANIMATING: 'mdc-dialog--animating',
  BACKDROP: 'mdc-dialog__backdrop',
  SCROLL_LOCK: 'mdc-dialog-scroll-lock',
  ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
  CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
};

var strings$5 = {
  OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
  DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
  ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
  ACCEPT_EVENT: 'MDCDialog:accept',
  CANCEL_EVENT: 'MDCDialog:cancel'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCDialogFoundation = function (_MDCFoundation) {
  inherits(MDCDialogFoundation, _MDCFoundation);
  createClass(MDCDialogFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$3;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$5;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        eventTargetHasClass: function eventTargetHasClass() {
          return (/* target: EventTarget, className: string */ /* boolean */false
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
        registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        notifyAccept: function notifyAccept() {},
        notifyCancel: function notifyCancel() {},
        trapFocusOnSurface: function trapFocusOnSurface() {},
        untrapFocusOnSurface: function untrapFocusOnSurface() {},
        isDialog: function isDialog() {
          return (/* el: Element */ /* boolean */false
          );
        },
        layoutFooterRipples: function layoutFooterRipples() {}
      };
    }
  }]);

  function MDCDialogFoundation(adapter) {
    classCallCheck(this, MDCDialogFoundation);

    var _this = possibleConstructorReturn(this, (MDCDialogFoundation.__proto__ || Object.getPrototypeOf(MDCDialogFoundation)).call(this, _extends(MDCDialogFoundation.defaultAdapter, adapter)));

    _this.isOpen_ = false;
    _this.componentClickHandler_ = function (evt) {
      if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$3.BACKDROP)) {
        _this.cancel(true);
      }
    };
    _this.dialogClickHandler_ = function (evt) {
      return _this.handleDialogClick_(evt);
    };
    _this.documentKeydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        _this.cancel(true);
      }
    };
    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd_(evt);
    };
    return _this;
  }

  createClass(MDCDialogFoundation, [{
    key: 'destroy',
    value: function destroy() {
      // Ensure that dialog is cleaned up when destroyed
      if (this.isOpen_) {
        this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.untrapFocusOnSurface();
        this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
        this.enableScroll_();
      }
    }
  }, {
    key: 'open',
    value: function open() {
      this.isOpen_ = true;
      this.disableScroll_();
      this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
      this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
      this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
    }
  }, {
    key: 'close',
    value: function close() {
      this.isOpen_ = false;
      this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
      this.adapter_.untrapFocusOnSurface();
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
    }
  }, {
    key: 'isOpen',
    value: function isOpen() {
      return this.isOpen_;
    }
  }, {
    key: 'accept',
    value: function accept(shouldNotify) {
      if (shouldNotify) {
        this.adapter_.notifyAccept();
      }

      this.close();
    }
  }, {
    key: 'cancel',
    value: function cancel(shouldNotify) {
      if (shouldNotify) {
        this.adapter_.notifyCancel();
      }

      this.close();
    }
  }, {
    key: 'handleDialogClick_',
    value: function handleDialogClick_(evt) {
      var target = evt.target;

      if (this.adapter_.eventTargetHasClass(target, cssClasses$3.ACCEPT_BTN)) {
        this.accept(true);
      } else if (this.adapter_.eventTargetHasClass(target, cssClasses$3.CANCEL_BTN)) {
        this.cancel(true);
      }
    }
  }, {
    key: 'handleTransitionEnd_',
    value: function handleTransitionEnd_(evt) {
      if (this.adapter_.isDialog(evt.target)) {
        this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
        if (this.isOpen_) {
          this.adapter_.trapFocusOnSurface();
          this.adapter_.layoutFooterRipples();
        } else {
          this.enableScroll_();
        }
      }
    }
  }, {
    key: 'disableScroll_',
    value: function disableScroll_() {
      this.adapter_.addBodyClass(cssClasses$3.SCROLL_LOCK);
    }
  }, {
    key: 'enableScroll_',
    value: function enableScroll_() {
      this.adapter_.removeBodyClass(cssClasses$3.SCROLL_LOCK);
    }
  }]);
  return MDCDialogFoundation;
}(MDCFoundation);

var tabbable = function (el, options) {
  options = options || {};

  var elementDocument = el.ownerDocument || el;
  var basicTabbables = [];
  var orderedTabbables = [];

  // A node is "available" if
  // - it's computed style
  var isUnavailable = createIsUnavailable(elementDocument);

  var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];

  var candidates = el.querySelectorAll(candidateSelectors.join(','));

  if (options.includeContainer) {
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    if (candidateSelectors.some(function (candidateSelector) {
      return matches.call(el, candidateSelector);
    })) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var candidate, candidateIndex;
  for (var i = 0, l = candidates.length; i < l; i++) {
    candidate = candidates[i];
    candidateIndex = parseInt(candidate.getAttribute('tabindex'), 10) || candidate.tabIndex;

    if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
      continue;
    }

    if (candidateIndex === 0) {
      basicTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        index: i,
        tabIndex: candidateIndex,
        node: candidate
      });
    }
  }

  var tabbableNodes = orderedTabbables.sort(function (a, b) {
    return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
  }).map(function (a) {
    return a.node;
  });

  Array.prototype.push.apply(tabbableNodes, basicTabbables);

  return tabbableNodes;
};

function createIsUnavailable(elementDocument) {
  // Node cache must be refreshed on every check, in case
  // the content of the element has changed
  var isOffCache = [];

  // "off" means `display: none;`, as opposed to "hidden",
  // which means `visibility: hidden;`. getComputedStyle
  // accurately reflects visiblity in context but not
  // "off" state, so we need to recursively check parents.

  function isOff(node, nodeComputedStyle) {
    if (node === elementDocument.documentElement) return false;

    // Find the cached node (Array.prototype.find not available in IE9)
    for (var i = 0, length = isOffCache.length; i < length; i++) {
      if (isOffCache[i][0] === node) return isOffCache[i][1];
    }

    nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = isOff(node.parentNode);
    }

    isOffCache.push([node, result]);

    return result;
  }

  return function isUnavailable(node) {
    if (node === elementDocument.documentElement) return false;

    var computedStyle = elementDocument.defaultView.getComputedStyle(node);

    if (isOff(node, computedStyle)) return true;

    return computedStyle.visibility === 'hidden';
  };
}

var listeningFocusTrap = null;

function focusTrap(element, userOptions) {
  var tabbableNodes = [];
  var firstTabbableNode = null;
  var lastTabbableNode = null;
  var nodeFocusedBeforeActivation = null;
  var active = false;
  var paused = false;
  var tabEvent = null;

  var container = typeof element === 'string' ? document.querySelector(element) : element;

  var config = userOptions || {};
  config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
  config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };

  return trap;

  function activate(activateOptions) {
    if (active) return;

    var defaultedActivateOptions = {
      onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
    };

    active = true;
    paused = false;
    nodeFocusedBeforeActivation = document.activeElement;

    if (defaultedActivateOptions.onActivate) {
      defaultedActivateOptions.onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!active) return;

    var defaultedDeactivateOptions = {
      returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
      onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
    };

    removeListeners();

    if (defaultedDeactivateOptions.onDeactivate) {
      defaultedDeactivateOptions.onDeactivate();
    }

    if (defaultedDeactivateOptions.returnFocus) {
      setTimeout(function () {
        tryFocus(nodeFocusedBeforeActivation);
      }, 0);
    }

    active = false;
    paused = false;
    return this;
  }

  function pause() {
    if (paused || !active) return;
    paused = true;
    removeListeners();
  }

  function unpause() {
    if (!paused || !active) return;
    paused = false;
    addListeners();
  }

  function addListeners() {
    if (!active) return;

    // There can be only one listening focus trap at a time
    if (listeningFocusTrap) {
      listeningFocusTrap.pause();
    }
    listeningFocusTrap = trap;

    updateTabbableNodes();
    tryFocus(firstFocusNode());
    document.addEventListener('focus', checkFocus, true);
    document.addEventListener('click', checkClick, true);
    document.addEventListener('mousedown', checkPointerDown, true);
    document.addEventListener('touchstart', checkPointerDown, true);
    document.addEventListener('keydown', checkKey, true);

    return trap;
  }

  function removeListeners() {
    if (!active || listeningFocusTrap !== trap) return;

    document.removeEventListener('focus', checkFocus, true);
    document.removeEventListener('click', checkClick, true);
    document.removeEventListener('mousedown', checkPointerDown, true);
    document.removeEventListener('touchstart', checkPointerDown, true);
    document.removeEventListener('keydown', checkKey, true);

    listeningFocusTrap = null;

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = document.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function firstFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(document.activeElement)) {
      node = document.activeElement;
    } else {
      node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error('You can\'t have a focus-trap without at least one focusable element');
    }

    return node;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event
  function checkPointerDown(e) {
    if (config.clickOutsideDeactivates && !container.contains(e.target)) {
      deactivate({ returnFocus: false });
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function checkFocus(e) {
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
    // Checking for a blur method here resolves a Firefox issue (#15)
    if (typeof e.target.blur === 'function') e.target.blur();

    if (tabEvent) {
      readjustFocus(tabEvent);
    }
  }

  function checkKey(e) {
    if (e.key === 'Tab' || e.keyCode === 9) {
      handleTab(e);
    }

    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      deactivate();
    }
  }

  function handleTab(e) {
    updateTabbableNodes();

    if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
      return tabEvent = e;
    }

    e.preventDefault();
    var currentFocusIndex = tabbableNodes.indexOf(e.target);

    if (e.shiftKey) {
      if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
        return tryFocus(lastTabbableNode);
      }
      return tryFocus(tabbableNodes[currentFocusIndex - 1]);
    }

    if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

    tryFocus(tabbableNodes[currentFocusIndex + 1]);
  }

  function updateTabbableNodes() {
    tabbableNodes = tabbable(container);
    firstTabbableNode = tabbableNodes[0];
    lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
  }

  function readjustFocus(e) {
    if (e.shiftKey) return tryFocus(lastTabbableNode);

    tryFocus(firstTabbableNode);
  }
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function tryFocus(node) {
  if (!node || !node.focus) return;
  if (node === document.activeElement) return;

  node.focus();
  if (node.tagName.toLowerCase() === 'input') {
    node.select();
  }
}

var focusTrap_1 = focusTrap;

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
  var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focusTrap_1;

  return focusTrapFactory(surfaceEl, {
    initialFocus: acceptButtonEl,
    clickOutsideDeactivates: true
  });
}

var mdcDialog = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { ref: "root", staticClass: "mdc-dialog", class: _vm.classes, style: _vm.styles, attrs: { "role": "alertdialog", "aria-labelledby": 'label' + _vm._uid, "aria-describedby": 'desc' + _vm._uid } }, [_c('div', { ref: "surface", staticClass: "mdc-dialog__surface", class: _vm.surfaceClasses }, [_c('header', { staticClass: "mdc-dialog__header" }, [_c('h2', { staticClass: "mdc-dialog__header__title", attrs: { "id": 'label' + _vm._uid } }, [_vm._v(" " + _vm._s(_vm.title) + " ")])]), _vm._v(" "), _c('section', { staticClass: "mdc-dialog__body", class: _vm.bodyClasses, attrs: { "id": 'desc' + _vm._uid } }, [_vm._t("default")], 2), _vm._v(" "), _c('footer', { staticClass: "mdc-dialog__footer" }, [_vm.cancel ? _c('mdcButton', { ref: "cancel", staticClass: "mdc-dialog__footer__button", class: { 'mdc-dialog__action': _vm.accent }, on: { "click": _vm.onCancel } }, [_vm._v(_vm._s(_vm.cancel))]) : _vm._e(), _vm._v(" "), _c('mdcButton', { ref: "accept", staticClass: "mdc-dialog__footer__button", class: { 'mdc-dialog__action': _vm.accent }, attrs: { "disabled": _vm.acceptDisabled }, on: { "click": _vm.onAccept } }, [_vm._v(_vm._s(_vm.accept))])], 1)]), _vm._v(" "), _c('div', { staticClass: "mdc-dialog__backdrop" })]);
  }, staticRenderFns: [],
  name: 'mdc-dialog',
  props: {
    title: { type: String, required: true },
    accept: { type: String, default: 'Ok' },
    acceptDisabled: Boolean,
    cancel: { type: String, default: 'Cancel' },
    accent: Boolean,
    scrollable: Boolean
  },
  components: {
    mdcButton: mdcButton
  },
  data: function data() {
    return {
      classes: {
        'mdc-theme--dark': this.dark
      },
      styles: {},
      surfaceClasses: {},
      bodyClasses: {
        'mdc-dialog__body--scrollable': this.scrollable
      }
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.focusTrap = createFocusTrapInstance(this.$refs.surface, this.$refs.accept);

    this.foundation = new MDCDialogFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      },
      eventTargetHasClass: function eventTargetHasClass(target, className) {
        return target.classList.contains(className);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        return _this.$refs.root.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        return _this.$refs.root.removeEventListener(evt, handler);
      },
      registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /*evt, handler*/{
        // VMA_HACK: handle button clicks ourselves
        // this.$refs.surface.addEventListener(evt, handler)
      },
      deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /*evt, handler*/{
        // VMA_HACK: handle button clicks ourselves
        // this.$refs.surface.removeEventListener(evt, handler)
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        return document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        return document.removeEventListener('keydown', handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        return _this.$refs.surface.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        return _this.$refs.surface.removeEventListener('transitionend', handler);
      },
      notifyAccept: function notifyAccept() {
        return _this.$emit('accept');
      },
      notifyCancel: function notifyCancel() {
        return _this.$emit('cancel');
      },
      trapFocusOnSurface: function trapFocusOnSurface() {
        return _this.focusTrap.activate();
      },
      untrapFocusOnSurface: function untrapFocusOnSurface() {
        return _this.focusTrap.deactivate();
      },
      isDialog: function isDialog(el) {
        return _this.$refs.surface === el;
      },
      layoutFooterRipples: function layoutFooterRipples() {
        _this.$refs.accept.ripple.layout();
        _this.cancel && _this.$refs.cancel.ripple.layout();
      }
    });

    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  },

  methods: {
    onCancel: function onCancel() {
      this.foundation.cancel(true);
    },
    onAccept: function onAccept() {
      var _this2 = this;

      if (this.$listeners['validate']) {
        this.$emit('validate', {
          accept: function accept() {
            var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            return _this2.foundation.accept(notify);
          }
        });
      } else {
        this.foundation.accept(true);
      }
    },
    show: function show() {
      this.foundation.open();
    },
    close: function close() {
      this.foundation.close();
    }
  }
};

var VueMDCDialog = BasePlugin({
  mdcDialog: mdcDialog
});

var mdcPermanentDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography" }, [_c('nav', { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-permanent-drawer',
  props: {
    'toolbar-spacer': Boolean
  }
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
  inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
  createClass(MDCSlidableDrawerFoundation, null, [{
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        hasClass: function hasClass() /* className: string */{},
        hasNecessaryDom: function hasNecessaryDom() {
          return (/* boolean */false
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
        setTranslateX: function setTranslateX() /* value: number | null */{},
        getFocusableElements: function getFocusableElements() /* NodeList */{},
        saveElementTabState: function saveElementTabState() /* el: Element */{},
        restoreElementTabState: function restoreElementTabState() /* el: Element */{},
        makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
        notifyOpen: function notifyOpen() {},
        notifyClose: function notifyClose() {},
        isRtl: function isRtl() {
          return (/* boolean */false
          );
        },
        getDrawerWidth: function getDrawerWidth() {
          return (/* number */0
          );
        }
      };
    }
  }]);

  function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
    classCallCheck(this, MDCSlidableDrawerFoundation);

    var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

    _this.rootCssClass_ = rootCssClass;
    _this.animatingCssClass_ = animatingCssClass;
    _this.openCssClass_ = openCssClass;

    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd_(evt);
    };

    _this.inert_ = false;

    _this.componentTouchStartHandler_ = function (evt) {
      return _this.handleTouchStart_(evt);
    };
    _this.componentTouchMoveHandler_ = function (evt) {
      return _this.handleTouchMove_(evt);
    };
    _this.componentTouchEndHandler_ = function (evt) {
      return _this.handleTouchEnd_(evt);
    };
    _this.documentKeydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        _this.close();
      }
    };
    return _this;
  }

  createClass(MDCSlidableDrawerFoundation, [{
    key: 'init',
    value: function init() {
      var ROOT = this.rootCssClass_;
      var OPEN = this.openCssClass_;

      if (!this.adapter_.hasClass(ROOT)) {
        throw new Error(ROOT + ' class required in root element.');
      }

      if (!this.adapter_.hasNecessaryDom()) {
        throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
      }

      if (this.adapter_.hasClass(OPEN)) {
        this.isOpen_ = true;
      } else {
        this.detabinate_();
        this.isOpen_ = false;
      }

      this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
      this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
      this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
      this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
      this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
      // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
    }
  }, {
    key: 'open',
    value: function open() {
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.addClass(this.animatingCssClass_);
      this.adapter_.addClass(this.openCssClass_);
      this.retabinate_();
      // Debounce multiple calls
      if (!this.isOpen_) {
        this.adapter_.notifyOpen();
      }
      this.isOpen_ = true;
    }
  }, {
    key: 'close',
    value: function close() {
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.addClass(this.animatingCssClass_);
      this.adapter_.removeClass(this.openCssClass_);
      this.detabinate_();
      // Debounce multiple calls
      if (this.isOpen_) {
        this.adapter_.notifyClose();
      }
      this.isOpen_ = false;
    }
  }, {
    key: 'isOpen',
    value: function isOpen() {
      return this.isOpen_;
    }

    /**
     *  Render all children of the drawer inert when it's closed.
     */

  }, {
    key: 'detabinate_',
    value: function detabinate_() {
      if (this.inert_) {
        return;
      }

      var elements = this.adapter_.getFocusableElements();
      if (elements) {
        for (var i = 0; i < elements.length; i++) {
          this.adapter_.saveElementTabState(elements[i]);
          this.adapter_.makeElementUntabbable(elements[i]);
        }
      }

      this.inert_ = true;
    }

    /**
     *  Make all children of the drawer tabbable again when it's open.
     */

  }, {
    key: 'retabinate_',
    value: function retabinate_() {
      if (!this.inert_) {
        return;
      }

      var elements = this.adapter_.getFocusableElements();
      if (elements) {
        for (var i = 0; i < elements.length; i++) {
          this.adapter_.restoreElementTabState(elements[i]);
        }
      }

      this.inert_ = false;
    }
  }, {
    key: 'handleTouchStart_',
    value: function handleTouchStart_(evt) {
      if (!this.adapter_.hasClass(this.openCssClass_)) {
        return;
      }
      if (evt.pointerType && evt.pointerType !== 'touch') {
        return;
      }

      this.direction_ = this.adapter_.isRtl() ? -1 : 1;
      this.drawerWidth_ = this.adapter_.getDrawerWidth();
      this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      this.currentX_ = this.startX_;

      this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
    }
  }, {
    key: 'handleTouchMove_',
    value: function handleTouchMove_(evt) {
      if (evt.pointerType && evt.pointerType !== 'touch') {
        return;
      }

      this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
    }
  }, {
    key: 'handleTouchEnd_',
    value: function handleTouchEnd_(evt) {
      if (evt.pointerType && evt.pointerType !== 'touch') {
        return;
      }

      this.prepareForTouchEnd_();

      // Did the user close the drawer by more than 50%?
      if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
        this.close();
      } else {
        // Triggering an open here means we'll get a nice animation back to the fully open state.
        this.open();
      }
    }
  }, {
    key: 'prepareForTouchEnd_',
    value: function prepareForTouchEnd_() {
      cancelAnimationFrame(this.updateRaf_);
      this.adapter_.setTranslateX(null);
    }
  }, {
    key: 'updateDrawer_',
    value: function updateDrawer_() {
      this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      this.adapter_.setTranslateX(this.newPosition_);
    }
  }, {
    key: 'isRootTransitioningEventTarget_',
    value: function isRootTransitioningEventTarget_() {
      // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
      // if the event target is the root event target currently transitioning.
      return false;
    }
  }, {
    key: 'handleTransitionEnd_',
    value: function handleTransitionEnd_(evt) {
      if (this.isRootTransitioningEventTarget_(evt.target)) {
        this.adapter_.removeClass(this.animatingCssClass_);
        this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
      }
    }
  }, {
    key: 'newPosition_',
    get: function get$$1() {
      var newPos = null;

      if (this.direction_ === 1) {
        newPos = Math.min(0, this.currentX_ - this.startX_);
      } else {
        newPos = Math.max(0, this.currentX_ - this.startX_);
      }

      return newPos;
    }
  }]);
  return MDCSlidableDrawerFoundation;
}(MDCFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$4 = {
  ROOT: 'mdc-drawer--persistent',
  OPEN: 'mdc-drawer--open',
  ANIMATING: 'mdc-drawer--animating'
};

var strings$6 = {
  DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
  FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCPersistentDrawer:open',
  CLOSE_EVENT: 'MDCPersistentDrawer:close'
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
  inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
  createClass(MDCPersistentDrawerFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$4;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$6;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
        isDrawer: function isDrawer() {
          return false;
        }
      });
    }
  }]);

  function MDCPersistentDrawerFoundation(adapter) {
    classCallCheck(this, MDCPersistentDrawerFoundation);
    return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
  }

  createClass(MDCPersistentDrawerFoundation, [{
    key: 'isRootTransitioningEventTarget_',
    value: function isRootTransitioningEventTarget_(el) {
      return this.adapter_.isDrawer(el);
    }
  }]);
  return MDCPersistentDrawerFoundation;
}(MDCSlidableDrawerFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TAB_DATA = 'data-mdc-tabindex';
var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

var storedTransformPropertyName_ = void 0;
var supportsPassive_$1 = void 0;

// Remap touch events to pointer events, if the browser doesn't support touch events.
function remapEvent(eventName) {
  var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

  if (!('ontouchstart' in globalObj.document)) {
    switch (eventName) {
      case 'touchstart':
        return 'pointerdown';
      case 'touchmove':
        return 'pointermove';
      case 'touchend':
        return 'pointerup';
      default:
        return eventName;
    }
  }

  return eventName;
}

// Choose the correct transform property to use on the current browser.
function getTransformPropertyName() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (storedTransformPropertyName_ === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
    storedTransformPropertyName_ = transformPropertyName;
  }

  return storedTransformPropertyName_;
}

// Determine whether the current browser supports CSS properties.
function supportsCssCustomProperties() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

  if ('CSS' in globalObj) {
    return globalObj.CSS.supports('(--color: red)');
  }
  return false;
}

// Determine whether the current browser supports passive event listeners, and if so, use them.
function applyPassive$1() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_$1 === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_$1 = isSupported;
  }

  return supportsPassive_$1 ? { passive: true } : false;
}

// Save the tab state for an element.
function saveElementTabState(el) {
  if (el.hasAttribute('tabindex')) {
    el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
  }
  el.setAttribute(TAB_DATA_HANDLED, true);
}

// Restore the tab state for an element, if it was saved.
function restoreElementTabState(el) {
  // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
  if (el.hasAttribute(TAB_DATA_HANDLED)) {
    if (el.hasAttribute(TAB_DATA)) {
      el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
      el.removeAttribute(TAB_DATA);
    } else {
      el.removeAttribute('tabindex');
    }
    el.removeAttribute(TAB_DATA_HANDLED);
  }
}

var mdcPersistentDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-persistent-drawer',
  model: {
    prop: 'open',
    event: 'change'
  },
  props: {
    'toolbar-spacer': Boolean,
    'open': Boolean
  },
  data: function data() {
    return {
      classes: {}
    };
  },

  watch: {
    open: function open() {
      this._refresh();
    }
  },
  methods: {
    _refresh: function _refresh() {
      if (this.open) {
        this.foundation && this.foundation.open();
      } else {
        this.foundation && this.foundation.close();
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


    this.foundation = new MDCPersistentDrawerFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.classes, className);
      },
      hasClass: function hasClass(className) {
        return _this.$el.classList.contains(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return !!_this.$refs.drawer;
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
      },
      deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        _this.$refs.drawer.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        _this.$refs.drawer.removeEventListener('transitionend', handler);
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        document.removeEventListener('keydown', handler);
      },
      getDrawerWidth: function getDrawerWidth() {
        return _this.$refs.drawer.offsetWidth;
      },
      setTranslateX: function setTranslateX(value) {
        _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
      },
      getFocusableElements: function getFocusableElements() {
        return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
      },
      saveElementTabState: function saveElementTabState$$1(el) {
        saveElementTabState(el);
      },
      restoreElementTabState: function restoreElementTabState$$1(el) {
        restoreElementTabState(el);
      },
      makeElementUntabbable: function makeElementUntabbable(el) {
        el.setAttribute('tabindex', -1);
      },
      notifyOpen: function notifyOpen() {
        _this.$emit('change', true);
        _this.$emit('open');
      },
      notifyClose: function notifyClose() {
        _this.$emit('change', false);
        _this.$emit('close');
      },
      isRtl: function isRtl() {
        /* global getComputedStyle */
        return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
      },
      isDrawer: function isDrawer(el) {
        return el === _this.$refs.drawer;
      }
    });
    this.foundation && this.foundation.init();
    this._refresh();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation && this.foundation.destroy();
    this.foundation = null;
  }
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$5 = {
  ROOT: 'mdc-drawer--temporary',
  OPEN: 'mdc-drawer--open',
  ANIMATING: 'mdc-drawer--animating',
  SCROLL_LOCK: 'mdc-drawer-scroll-lock'
};

var strings$7 = {
  DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
  OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
  FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCTemporaryDrawer:open',
  CLOSE_EVENT: 'MDCTemporaryDrawer:close'
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
  inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
  createClass(MDCTemporaryDrawerFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$5;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$7;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        isDrawer: function isDrawer() {
          return false;
        },
        updateCssVariable: function updateCssVariable() /* value: string */{},
        eventTargetHasClass: function eventTargetHasClass() {
          return (/* target: EventTarget, className: string */ /* boolean */false
          );
        }
      });
    }
  }]);

  function MDCTemporaryDrawerFoundation(adapter) {
    classCallCheck(this, MDCTemporaryDrawerFoundation);

    var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

    _this.componentClickHandler_ = function (evt) {
      if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$5.ROOT)) {
        _this.close(true);
      }
    };
    return _this;
  }

  createClass(MDCTemporaryDrawerFoundation, [{
    key: 'init',
    value: function init() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

      // Make browser aware of custom property being used in this element.
      // Workaround for certain types of hard-to-reproduce heisenbugs.
      this.adapter_.updateCssVariable(0);
      this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

      this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
      this.enableScroll_();
    }
  }, {
    key: 'open',
    value: function open() {
      this.disableScroll_();
      // Make sure custom property values are cleared before starting.
      this.adapter_.updateCssVariable('');

      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
    }
  }, {
    key: 'close',
    value: function close() {
      // Make sure custom property values are cleared before making any changes.
      this.adapter_.updateCssVariable('');

      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
    }
  }, {
    key: 'prepareForTouchEnd_',
    value: function prepareForTouchEnd_() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

      this.adapter_.updateCssVariable('');
    }
  }, {
    key: 'updateDrawer_',
    value: function updateDrawer_() {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

      var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
      this.adapter_.updateCssVariable(newOpacity);
    }
  }, {
    key: 'isRootTransitioningEventTarget_',
    value: function isRootTransitioningEventTarget_(el) {
      return this.adapter_.isDrawer(el);
    }
  }, {
    key: 'handleTransitionEnd_',
    value: function handleTransitionEnd_(evt) {
      get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
      if (!this.isOpen_) {
        this.enableScroll_();
      }
    }
  }, {
    key: 'disableScroll_',
    value: function disableScroll_() {
      this.adapter_.addBodyClass(cssClasses$5.SCROLL_LOCK);
    }
  }, {
    key: 'enableScroll_',
    value: function enableScroll_() {
      this.adapter_.removeBodyClass(cssClasses$5.SCROLL_LOCK);
    }
  }]);
  return MDCTemporaryDrawerFoundation;
}(MDCSlidableDrawerFoundation);

var mdcTemporaryDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-temporary-drawer',
  model: {
    prop: 'open',
    event: 'change'
  },
  props: {
    'open': Boolean,
    'toolbar-spacer': Boolean
  },
  data: function data() {
    return {
      classes: {}
    };
  },

  watch: {
    open: function open() {
      this._refresh();
    }
  },
  methods: {
    _refresh: function _refresh() {
      if (this.open) {
        this.foundation && this.foundation.open();
      } else {
        this.foundation && this.foundation.close();
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
        FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
        OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


    this.foundation = new MDCTemporaryDrawerFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.classes, className);
      },
      hasClass: function hasClass(className) {
        return _this.$el.classList.contains(className);
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      },
      eventTargetHasClass: function eventTargetHasClass(target, className) {
        return target.classList.contains(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return !!_this.$refs.drawer;
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$1());
      },
      registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
      },
      deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
        _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        _this.$refs.drawer.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        _this.$refs.drawer.removeEventListener('transitionend', handler);
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        document.removeEventListener('keydown', handler);
      },
      getDrawerWidth: function getDrawerWidth() {
        return _this.$refs.drawer.offsetWidth;
      },
      setTranslateX: function setTranslateX(value) {
        _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
      },
      updateCssVariable: function updateCssVariable(value) {
        if (supportsCssCustomProperties()) {
          _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
        }
      },
      getFocusableElements: function getFocusableElements() {
        return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
      },
      saveElementTabState: function saveElementTabState$$1(el) {
        saveElementTabState(el);
      },
      restoreElementTabState: function restoreElementTabState$$1(el) {
        restoreElementTabState(el);
      },
      makeElementUntabbable: function makeElementUntabbable(el) {
        el.setAttribute('tabindex', -1);
      },
      notifyOpen: function notifyOpen() {
        _this.$emit('change', true);
        _this.$emit('open');
      },
      notifyClose: function notifyClose() {
        _this.$emit('change', false);
        _this.$emit('close');
      },
      isRtl: function isRtl() {
        /* global getComputedStyle */
        return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
      },
      isDrawer: function isDrawer(el) {
        return el === _this.$refs.drawer;
      }
    });
    this.foundation && this.foundation.init();
    this._refresh();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation && this.foundation.destroy();
    this.foundation = null;
  }
};

var media = new (function () {
  function _class() {
    classCallCheck(this, _class);
  }

  createClass(_class, [{
    key: 'small',
    get: function get$$1() {
      return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
    }
  }, {
    key: 'large',
    get: function get$$1() {
      return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
    }
  }]);
  return _class;
}())();

var mdcDrawer = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { ref: "drawer", tag: "component", staticClass: "mdc-drawer", attrs: { "toolbar-spacer": _vm.toolbarSpacer }, on: { "change": function change($event) {
          _vm.$root.$emit('mdc:layout');
        }, "open": function open($event) {
          _vm.$emit('open');
        }, "close": function close($event) {
          _vm.$emit('close');
        } }, model: { value: _vm.open_, callback: function callback($$v) {
          _vm.open_ = $$v;
        }, expression: "open_" } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer',
  props: {
    permanent: Boolean,
    persistent: Boolean,
    temporary: Boolean,
    drawerType: {
      type: String,
      validator: function validator(val) {
        return val in ['temporary', 'persistent', 'permanent'];
      }
    },
    toolbarSpacer: Boolean,
    toggleOn: String,
    toggleOnSource: { type: Object, required: false },
    openOn: String,
    openOnSource: { type: Object, required: false },
    closeOn: String,
    closeOnSource: { type: Object, required: false }
  },
  provide: function provide() {
    return { mdcDrawer: this };
  },
  data: function data() {
    return {
      small: false,
      large: false,
      open_: false
    };
  },

  components: {
    'mdc-permanent-drawer': mdcPermanentDrawer,
    'mdc-persistent-drawer': mdcPersistentDrawer,
    'mdc-temporary-drawer': mdcTemporaryDrawer
  },
  computed: {
    type: function type() {
      if (this.permanent) {
        return 'mdc-permanent-drawer';
      } else if (this.persistent) {
        return 'mdc-persistent-drawer';
      } else if (this.temporary) {
        return 'mdc-temporary-drawer';
      } else {
        switch (this.drawerType) {
          case 'permanent':
            return 'mdc-permanent-drawer';
          case 'persistent':
            return 'mdc-persistent-drawer';
          case 'temporary':
            return 'mdc-temporary-drawer';
          default:
            return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
        }
      }
    },
    isPermanent: function isPermanent() {
      return this.permanent || this.type === 'mdc-permanent-drawer';
    },
    isPersistent: function isPersistent() {
      return this.persistent || this.type === 'mdc-persistent-drawer';
    },
    isTemporary: function isTemporary() {
      return this.temporary || this.type === 'mdc-temporary-drawer';
    },
    isResponsive: function isResponsive() {
      return !(this.permanent || this.persistent || this.temporary || this.drawerType);
    }
  },
  methods: {
    open: function open() {
      this.open_ = true;
    },
    close: function close() {
      this.isPermanent || (this.open_ = false);
    },
    toggle: function toggle() {
      this.isPermanent || (this.isOpen() ? this.close() : this.open());
    },
    isOpen: function isOpen() {
      return this.isPermanent || this.open_;
    },
    refreshMedia: function refreshMedia() {
      this.small = media.small.matches;
      this.large = media.large.matches;
      if (this.isResponsive) {
        if (this.large) {
          this.open();
        } else {
          this.close();
        }
      }
    }
  },
  created: function created() {
    if (window && window.matchMedia) {
      this.small = media.small.matches;
      this.large = media.large.matches;
    }
  },
  mounted: function mounted() {
    var _this = this;

    if (this.toggleOn) {
      var source = this.toggleOnSource || this.$root;
      source.$on(this.toggleOn, function () {
        return _this.toggle();
      });
    }
    if (this.openOn) {
      var _source = this.openOnSource || this.$root;
      _source.$on(this.openOn, function () {
        return _this.open();
      });
    }
    if (this.closeOn) {
      var _source2 = this.closeOnSource || this.$root;
      _source2.$on(this.closeOn, function () {
        return _this.close();
      });
    }
    media.small.addListener(this.refreshMedia);
    media.large.addListener(this.refreshMedia);
    this.$nextTick(function () {
      return _this.refreshMedia();
    });
  },
  beforeDestroy: function beforeDestroy() {
    media.small.removeListener(this.refreshMedia);
    media.large.removeListener(this.refreshMedia);
  }
};

var mdcDrawerLayout = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer-layout'
};

var mdcDrawerHeader = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.show ? _c('header', { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c('div', { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
  }, staticRenderFns: [],
  name: 'mdc-drawer-header',
  props: {
    'permanent': Boolean,
    'persistent': Boolean,
    'temporary': Boolean
  },
  inject: ['mdcDrawer'],
  computed: {
    show: function show() {
      if (this.temporary || this.persistent || this.permanent) {
        return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
      } else {
        return true;
      }
    }
  }
};

var mdcDrawerList = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer-list',
  props: {
    'dense': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-list--dense': this.dense
      }
    };
  }
};

var mdcDrawerItem = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-drawer-item mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.onClick } }, [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c('i', { staticClass: "material-icons", attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-drawer-item',
  inject: ['mdcDrawer'],
  mixins: [DispatchEventMixin, CustomLinkMixin],
  props: {
    startIcon: String,
    temporaryClose: {
      type: Boolean,
      default: true
    },
    activated: Boolean,
    exactActiveClass: {
      type: String,
      default: 'mdc-list-item--activated'
    }
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    itemClasses: function itemClasses() {
      return {
        'mdc-list-item--activated': this.activated
      };
    },
    hasStartDetail: function hasStartDetail() {
      return this.startIcon || this.$slots['start-detail'];
    }
  },
  methods: {
    onClick: function onClick(evt) {
      this.mdcDrawer.isTemporary && this.temporaryClose && this.mdcDrawer.close();
      this.dispatchEvent(evt);
    }
  },
  mounted: function mounted() {
    this.ripple = new RippleBase(this);
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.ripple && this.ripple.destroy();
    this.ripple = null;
  }
};

var mdcDrawerDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-divider" });
  }, staticRenderFns: [],
  name: 'mdc-drawer-divider'
};

var VueMDCDrawer = BasePlugin({
  mdcDrawer: mdcDrawer,
  mdcDrawerLayout: mdcDrawerLayout,
  mdcDrawerHeader: mdcDrawerHeader,
  mdcDrawerList: mdcDrawerList,
  mdcDrawerItem: mdcDrawerItem,
  mdcDrawerDivider: mdcDrawerDivider
});

var mdcElevation = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-elevation" });
  }, staticRenderFns: [],
  name: 'mdc-elevation',
  props: {}
};

var VueMDCElevation = BasePlugin({
  mdcElevation: mdcElevation
});

var mdcFAB = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', { staticClass: "mdc-fab", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [_c('span', { staticClass: "mdc-fab__icon" }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-fab',
  mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
  props: {
    icon: String,
    mini: Boolean,
    absolute: Boolean,
    fixed: Boolean
  },
  data: function data() {
    return {
      classes: {
        'material-icons': this.icon,
        'mdc-fab--mini': this.mini,
        'mdc-fab--absolute': this.absolute,
        'mdc-fab--fixed': this.fixed
      },
      styles: {}
    };
  },

  watch: {
    icon: function icon() {
      this.$set(this.classes, 'material-icons', this.icon);
    },
    mini: function mini() {
      this.$set(this.classes, 'mdc-fab--mini', this.mini);
    }
  }
};

var VueMDCFab = BasePlugin({
  mdcFAB: mdcFAB
});

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var strings$8 = {
  TILES_SELECTOR: '.mdc-grid-list__tiles',
  TILE_SELECTOR: '.mdc-grid-tile'
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCGridListFoundation = function (_MDCFoundation) {
  inherits(MDCGridListFoundation, _MDCFoundation);
  createClass(MDCGridListFoundation, null, [{
    key: 'strings',
    get: function get$$1() {
      return strings$8;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        getOffsetWidth: function getOffsetWidth() {
          return (/* number */0
          );
        },
        getNumberOfTiles: function getNumberOfTiles() {
          return (/* number */0
          );
        },
        getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
          return (/* index: number */ /* number */0
          );
        },
        setStyleForTilesElement: function setStyleForTilesElement() /* property: string, value: string */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{}
      };
    }
  }]);

  function MDCGridListFoundation(adapter) {
    classCallCheck(this, MDCGridListFoundation);

    var _this = possibleConstructorReturn(this, (MDCGridListFoundation.__proto__ || Object.getPrototypeOf(MDCGridListFoundation)).call(this, _extends(MDCGridListFoundation.defaultAdapter, adapter)));

    _this.resizeHandler_ = function () {
      return _this.alignCenter();
    };
    _this.resizeFrame_ = 0;
    return _this;
  }

  createClass(MDCGridListFoundation, [{
    key: 'init',
    value: function init() {
      this.alignCenter();
      this.adapter_.registerResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'alignCenter',
    value: function alignCenter() {
      var _this2 = this;

      if (this.resizeFrame_ !== 0) {
        cancelAnimationFrame(this.resizeFrame_);
      }
      this.resizeFrame_ = requestAnimationFrame(function () {
        _this2.alignCenter_();
        _this2.resizeFrame_ = 0;
      });
    }
  }, {
    key: 'alignCenter_',
    value: function alignCenter_() {
      if (this.adapter_.getNumberOfTiles() == 0) {
        return;
      }
      var gridWidth = this.adapter_.getOffsetWidth();
      var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
      var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
      this.adapter_.setStyleForTilesElement('width', tilesWidth + 'px');
    }
  }]);
  return MDCGridListFoundation;
}(MDCFoundation);

var mdcGridList = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-grid-list" }, [_c('ul', { staticClass: "mdc-grid-list__tiles", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-grid-list',
  props: {
    'width': [String, Number],
    'ratio': String,
    'narrow-gutter': Boolean,
    'header-caption': Boolean,
    'icon-align-start': Boolean,
    'icon-align-end': Boolean,
    'with-support-text': Boolean,
    'interactive': Boolean
  },
  provide: function provide() {
    return { mdcGrid: this };
  },

  computed: {
    classes: function classes() {
      var classes = {};

      classes['mdc-grid-list--tile-gutter-1'] = this.narrowGutter;
      classes['mdc-grid-list--header-caption'] = this.headerCaption;
      classes['mdc-grid-list--tile-aspect-' + this.ratio] = this.ratio;
      classes['mdc-grid-list--with-icon-align-start'] = this.iconAlignStart;
      classes['mdc-grid-list--with-icon-align-end'] = this.iconAlignEnd;
      classes['mdc-grid-list--twoline-caption'] = this.withSupportText;
      classes['mdc-grid-list--non-interactive'] = !this.interactive;

      return classes;
    },
    styles: function styles() {
      var defaultWidth = 200;
      return {
        '--mdc-grid-list-tile-width': (this.width || defaultWidth) + 'px'
      };
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCGridListFoundation({
      getOffsetWidth: function getOffsetWidth() {
        return _this.$el.offsetWidth;
      },
      getNumberOfTiles: function getNumberOfTiles() {
        return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
      },
      getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
        return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
      },
      setStyleForTilesElement: function setStyleForTilesElement(property, value) {
        _this.$el.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        window.removeEventListener('resize', handler);
      }
    });
    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var mdcGridTile = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-grid-tile", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined }, on: { "click": _vm.onClick } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.cover ? _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('div', { staticClass: "mdc-grid-tile__primary-content", style: { backgroundImage: 'url(' + _vm.src + ')' } })]) : _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('img', { staticClass: "mdc-grid-tile__primary-content", attrs: { "src": _vm.src } })]), _vm._v(" "), _vm.title || _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__secondary" }, [_vm.icon ? _c('i', { staticClass: "mdc-grid-tile__icon material-icons" }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), _vm.title ? _c('span', { staticClass: "mdc-grid-tile__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._v(" "), _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__support-text" }, [_vm._v(_vm._s(_vm.supportText))]) : _vm._e()]) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-grid-tile',
  inject: ['mdcGrid'],
  mixins: [DispatchEventMixin],
  props: {
    'src': String,
    'cover': Boolean,
    'icon': String,
    'title': String,
    'support-text': String,
    'selected': Boolean,
    'activated': Boolean
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    itemClasses: function itemClasses() {
      return {
        'mdc-grid-tile--selected': this.selected,
        'mdc-grid-tile--activated': this.activated
      };
    },
    isInteractive: function isInteractive() {
      return this.mdcGrid && this.mdcGrid.interactive;
    },
    hasStartDetail: function hasStartDetail() {
      return this.startIcon || this.$slots['start-detail'];
    },
    hasEndDetail: function hasEndDetail() {
      return this.endIcon || this.$slots['end-detail'];
    }
  },
  watch: {
    isInteractive: function isInteractive(value) {
      if (value) {
        this.addRipple();
      } else {
        this.removeRipple();
      }
    }
  },
  methods: {
    onClick: function onClick(evt) {
      this.dispatchEvent(evt);
    },
    addRipple: function addRipple() {
      if (!this.ripple) {
        var ripple = new RippleBase(this);
        ripple.init();
        this.ripple = ripple;
      }
    },
    removeRipple: function removeRipple() {
      if (this.ripple) {
        var ripple = this.ripple;
        this.ripple = null;
        ripple.destroy();
      }
    }
  },
  mounted: function mounted() {
    this.isInteractive && this.addRipple();
    /* eslint-disable no-console */
    console.log(this);
    console.log(this.$el.getBoundingClientRect());
    console.log(this.ripple);
    /* eslint-enable no-console */
  },
  beforeDestroy: function beforeDestroy() {
    this.removeRipple();
  }
};

var VueMDCGridList = BasePlugin({
  mdcGridList: mdcGridList,
  mdcGridTile: mdcGridTile
});

var mdcIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon mdc-icon--material", class: { 'material-icons': !!_vm.icon } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-icon',
  props: {
    icon: String
  }
};

var VueMDCIcon = BasePlugin({
  mdcIcon: mdcIcon
});

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Icon Toggle. Provides an interface for managing
 * - classes
 * - dom
 * - inner text
 * - event handlers
 * - event dispatch
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */

var MDCIconToggleAdapter = function () {
  function MDCIconToggleAdapter() {
    classCallCheck(this, MDCIconToggleAdapter);
  }

  createClass(MDCIconToggleAdapter, [{
    key: "addClass",

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(type, handler) {}

    /**
     * @param {string} type
     * @param {!EventListener} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}

    /** @param {string} text */

  }, {
    key: "setText",
    value: function setText(text) {}

    /** @return {number} */

  }, {
    key: "getTabIndex",
    value: function getTabIndex() {}

    /** @param {number} tabIndex */

  }, {
    key: "setTabIndex",
    value: function setTabIndex(tabIndex) {}

    /**
     * @param {string} name
     * @return {string}
     */

  }, {
    key: "getAttr",
    value: function getAttr(name) {}

    /**
     * @param {string} name
     * @param {string} value
     */

  }, {
    key: "setAttr",
    value: function setAttr(name, value) {}

    /** @param {string} name */

  }, {
    key: "rmAttr",
    value: function rmAttr(name) {}

    /** @param {!IconToggleEvent} evtData */

  }, {
    key: "notifyChange",
    value: function notifyChange(evtData) {}
  }]);
  return MDCIconToggleAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$6 = {
  ROOT: 'mdc-icon-toggle',
  DISABLED: 'mdc-icon-toggle--disabled'
};

/** @enum {string} */
var strings$9 = {
  DATA_TOGGLE_ON: 'data-toggle-on',
  DATA_TOGGLE_OFF: 'data-toggle-off',
  ARIA_PRESSED: 'aria-pressed',
  ARIA_DISABLED: 'aria-disabled',
  ARIA_LABEL: 'aria-label',
  CHANGE_EVENT: 'MDCIconToggle:change'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/**
 * @extends {MDCFoundation<!MDCIconToggleAdapter>}
 */

var MDCIconToggleFoundation = function (_MDCFoundation) {
  inherits(MDCIconToggleFoundation, _MDCFoundation);
  createClass(MDCIconToggleFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$6;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$9;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        setText: function setText() /* text: string */{},
        getTabIndex: function getTabIndex() {
          return (/* number */0
          );
        },
        setTabIndex: function setTabIndex() /* tabIndex: number */{},
        getAttr: function getAttr() {
          return (/* name: string */ /* string */''
          );
        },
        setAttr: function setAttr() /* name: string, value: string */{},
        rmAttr: function rmAttr() /* name: string */{},
        notifyChange: function notifyChange() /* evtData: IconToggleEvent */{}
      };
    }
  }]);

  function MDCIconToggleFoundation(adapter) {
    classCallCheck(this, MDCIconToggleFoundation);

    /** @private {boolean} */
    var _this = possibleConstructorReturn(this, (MDCIconToggleFoundation.__proto__ || Object.getPrototypeOf(MDCIconToggleFoundation)).call(this, _extends(MDCIconToggleFoundation.defaultAdapter, adapter)));

    _this.on_ = false;

    /** @private {boolean} */
    _this.disabled_ = false;

    /** @private {number} */
    _this.savedTabIndex_ = -1;

    /** @private {?IconToggleState} */
    _this.toggleOnData_ = null;

    /** @private {?IconToggleState} */
    _this.toggleOffData_ = null;

    _this.clickHandler_ = /** @private {!EventListener} */function () {
      return _this.toggleFromEvt_();
    };

    /** @private {boolean} */
    _this.isHandlingKeydown_ = false;

    _this.keydownHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
      if (isSpace(evt)) {
        _this.isHandlingKeydown_ = true;
        return evt.preventDefault();
      }
    };

    _this.keyupHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
      if (isSpace(evt)) {
        _this.isHandlingKeydown_ = false;
        _this.toggleFromEvt_();
      }
    };
    return _this;
  }

  createClass(MDCIconToggleFoundation, [{
    key: 'init',
    value: function init() {
      this.refreshToggleData();
      this.savedTabIndex_ = this.adapter_.getTabIndex();
      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
    }
  }, {
    key: 'refreshToggleData',
    value: function refreshToggleData() {
      var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
          DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
          DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;

      this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
      this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
    }

    /** @private */

  }, {
    key: 'toggleFromEvt_',
    value: function toggleFromEvt_() {
      this.toggle();
      var isOn = this.on_;

      this.adapter_.notifyChange( /** @type {!IconToggleEvent} */{ isOn: isOn });
    }

    /** @return {boolean} */

  }, {
    key: 'isOn',
    value: function isOn() {
      return this.on_;
    }

    /** @param {boolean=} isOn */

  }, {
    key: 'toggle',
    value: function toggle() {
      var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;

      this.on_ = isOn;

      var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
          ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
          ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;


      if (this.on_) {
        this.adapter_.setAttr(ARIA_PRESSED, 'true');
      } else {
        this.adapter_.setAttr(ARIA_PRESSED, 'false');
      }

      var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
          classToRemove = _ref.cssClass;

      if (classToRemove) {
        this.adapter_.removeClass(classToRemove);
      }

      var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
          content = _ref2.content,
          label = _ref2.label,
          cssClass = _ref2.cssClass;

      if (cssClass) {
        this.adapter_.addClass(cssClass);
      }
      if (content) {
        this.adapter_.setText(content);
      }
      if (label) {
        this.adapter_.setAttr(ARIA_LABEL, label);
      }
    }

    /**
     * @param {string} dataAttr
     * @return {!IconToggleState}
     */

  }, {
    key: 'parseJsonDataAttr_',
    value: function parseJsonDataAttr_(dataAttr) {
      var val = this.adapter_.getAttr(dataAttr);
      if (!val) {
        return {};
      }
      return (/** @type {!IconToggleState} */JSON.parse(val)
      );
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.disabled_;
    }

    /** @param {boolean} isDisabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(isDisabled) {
      this.disabled_ = isDisabled;

      var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
      var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;


      if (this.disabled_) {
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.setTabIndex(-1);
        this.adapter_.setAttr(ARIA_DISABLED, 'true');
        this.adapter_.addClass(DISABLED);
      } else {
        this.adapter_.setTabIndex(this.savedTabIndex_);
        this.adapter_.rmAttr(ARIA_DISABLED);
        this.adapter_.removeClass(DISABLED);
      }
    }

    /** @return {boolean} */

  }, {
    key: 'isKeyboardActivated',
    value: function isKeyboardActivated() {
      return this.isHandlingKeydown_;
    }
  }]);
  return MDCIconToggleFoundation;
}(MDCFoundation);

/**
 * @param {!KeyboardKey} keyboardKey
 * @return {boolean}
 */
function isSpace(keyboardKey) {
  return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
}

var mdcIConToggle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon-toggle", class: _vm.classes, style: _vm.styles, attrs: { "role": "button", "aria-pressed": "false", "tabindex": _vm.tabIndex, "data-toggle-on": _vm.toggleOnData, "data-toggle-off": _vm.toggleOffData } }, [_c('i', { class: _vm.iconClasses, attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.text))])]);
  }, staticRenderFns: [],
  name: 'mdc-icon-toggle',
  props: {
    toggleOn: [String, Object],
    toggleOff: [String, Object],
    value: Boolean,
    disabled: Boolean,
    accent: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-icon-toggle--accent': this.accent
      },
      styles: {},
      iconClasses: {},
      tabIndex: 0,
      text: ''
    };
  },

  watch: {
    value: function value(_value) {
      this.foundation && this.foundation.toggle(_value);
    },
    disabled: function disabled(_disabled) {
      this.foundation && this.foundation.setDisabled(_disabled);
    },
    toggleOnData: function toggleOnData() {
      this.foundation && this.foundation.refreshToggleData();
    },
    toggleOffData: function toggleOffData() {
      this.foundation && this.foundation.refreshToggleData();
    },
    accent: function accent(value) {
      this.$set(this.classes, 'mdc-icon-toggle--secondary', value);
    }
  },
  computed: {
    toggleOnData: function toggleOnData() {
      var toggle = this.toggleOn;
      return toggle && JSON.stringify(typeof toggle === 'string' ? {
        content: toggle,
        cssClass: 'material-icons'
      } : {
        content: toggle.icon || toggle.content,
        label: toggle.label,
        cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
      });
    },
    toggleOffData: function toggleOffData() {
      var toggle = this.toggleOff;
      return toggle && JSON.stringify(typeof toggle === 'string' ? {
        content: toggle,
        cssClass: 'material-icons'
      } : {
        content: toggle.icon || toggle.content,
        label: toggle.label,
        cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
      });
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCIconToggleFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.iconClasses, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.iconClasses, className);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        return _this.$el.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        return _this.$el.removeEventListener(evt, handler);
      },
      setText: function setText(text) {
        _this.text = text;
      },
      getTabIndex: function getTabIndex() {
        return _this.tabIndex;
      },
      setTabIndex: function setTabIndex(tabIndex) {
        _this.tabIndex = tabIndex;
      },
      getAttr: function getAttr(name, value) {
        return _this.$el.getAttribute(name, value);
      },
      setAttr: function setAttr(name, value) {
        _this.$el.setAttribute(name, value);
      },
      rmAttr: function rmAttr(name) {
        _this.$el.removeAttribute(name);
      },
      notifyChange: function notifyChange(evtData) {
        _this.$emit('input', evtData.isOn);
      }
    });
    this.foundation.init();
    this.foundation.toggle(this.value);
    this.foundation.setDisabled(this.disabled);

    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      },
      isSurfaceActive: function isSurfaceActive() {
        return _this.foundation.isKeyboardActivated();
      }
    });
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
    this.ripple.destroy();
  }
};

var VueMDCIconToggle = BasePlugin({
  mdcIConToggle: mdcIConToggle
});

var mdcLayoutApp = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-app" }, [_c('div', { staticClass: "mdc-layout-app--toolbar-wrapper" }, [_vm._t("toolbar")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--main-container" }, [_c('div', { staticClass: "mdc-layout-app--drawer-wrapper" }, [_vm._t("drawer")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--content-wrapper" }, [_vm._t("default")], 2)])]);
  }, staticRenderFns: [],
  name: 'mdc-layout-app'
};

var VueMDCLayoutApp = BasePlugin({
  mdcLayoutApp: mdcLayoutApp
});

var mdcLayoutGrid = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-grid", class: _vm.classes }, [_c('div', { staticClass: "mdc-layout-grid__inner" }, [_vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-layout-grid',
  props: {
    'fixed-column-width': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-layout-grid--fixed-column-width': this.fixedColumnWidth
      }
    };
  }
};

var spanOptions = {
  type: [String, Number],
  default: null,
  validator: function validator(value) {
    var num = Number(value);
    return isFinite(num) && num <= 12 && num > 0;
  }
};

var mdcLayoutCell = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-cell mdc-layout-grid__cell", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-layout-cell',
  props: {
    span: spanOptions,
    order: spanOptions,
    phone: spanOptions,
    tablet: spanOptions,
    desktop: spanOptions,
    align: {
      type: String,
      validator: function validator(value) {
        return ['top', 'bottom', 'middle'].indexOf(value) !== -1;
      }
    }
  },
  computed: {
    classes: function classes() {
      var classes = [];

      if (this.span) {
        classes.push("mdc-layout-grid__cell--span-" + this.span);
      }

      if (this.order) {
        classes.push("mdc-layout-grid__cell--order-" + this.order);
      }

      if (this.phone) {
        classes.push("mdc-layout-grid__cell--span-" + this.phone + "-phone");
      }

      if (this.tablet) {
        classes.push("mdc-layout-grid__cell--span-" + this.tablet + "-tablet");
      }

      if (this.desktop) {
        classes.push("mdc-layout-grid__cell--span-" + this.desktop + "-desktop");
      }

      if (this.align) {
        classes.push("mdc-layout-grid__cell--align-" + this.align);
      }

      return classes;
    }
  }
};

var mdcLayoutInnerGrid = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-inner-grid mdc-layout-grid__inner" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-layout-inner-grid'
};

var VueMDCLayoutGrid = BasePlugin({
  mdcLayoutGrid: mdcLayoutGrid,
  mdcLayoutCell: mdcLayoutCell,
  mdcLayoutInnerGrid: mdcLayoutInnerGrid
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$7 = {
  CLOSED_CLASS: 'mdc-linear-progress--closed',
  INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
  REVERSED_CLASS: 'mdc-linear-progress--reversed'
};

var strings$10 = {
  PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
  BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCLinearProgressFoundation = function (_MDCFoundation) {
  inherits(MDCLinearProgressFoundation, _MDCFoundation);
  createClass(MDCLinearProgressFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$7;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$10;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        getPrimaryBar: function getPrimaryBar() /* el: Element */{},
        getBuffer: function getBuffer() /* el: Element */{},
        hasClass: function hasClass() {
          return (/* className: string */false
          );
        },
        removeClass: function removeClass() /* className: string */{},
        setStyle: function setStyle() /* el: Element, styleProperty: string, value: string */{}
      };
    }
  }]);

  function MDCLinearProgressFoundation(adapter) {
    classCallCheck(this, MDCLinearProgressFoundation);
    return possibleConstructorReturn(this, (MDCLinearProgressFoundation.__proto__ || Object.getPrototypeOf(MDCLinearProgressFoundation)).call(this, _extends(MDCLinearProgressFoundation.defaultAdapter, adapter)));
  }

  createClass(MDCLinearProgressFoundation, [{
    key: 'init',
    value: function init() {
      this.determinate_ = !this.adapter_.hasClass(cssClasses$7.INDETERMINATE_CLASS);
      this.reverse_ = this.adapter_.hasClass(cssClasses$7.REVERSED_CLASS);
      this.progress_ = 0;
    }
  }, {
    key: 'setDeterminate',
    value: function setDeterminate(isDeterminate) {
      this.determinate_ = isDeterminate;
      if (this.determinate_) {
        this.adapter_.removeClass(cssClasses$7.INDETERMINATE_CLASS);
        this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
      } else {
        this.adapter_.addClass(cssClasses$7.INDETERMINATE_CLASS);
        this.setScale_(this.adapter_.getPrimaryBar(), 1);
        this.setScale_(this.adapter_.getBuffer(), 1);
      }
    }
  }, {
    key: 'setProgress',
    value: function setProgress(value) {
      this.progress_ = value;
      if (this.determinate_) {
        this.setScale_(this.adapter_.getPrimaryBar(), value);
      }
    }
  }, {
    key: 'setBuffer',
    value: function setBuffer(value) {
      if (this.determinate_) {
        this.setScale_(this.adapter_.getBuffer(), value);
      }
    }
  }, {
    key: 'setReverse',
    value: function setReverse(isReversed) {
      this.reverse_ = isReversed;
      if (this.reverse_) {
        this.adapter_.addClass(cssClasses$7.REVERSED_CLASS);
      } else {
        this.adapter_.removeClass(cssClasses$7.REVERSED_CLASS);
      }
    }
  }, {
    key: 'open',
    value: function open() {
      this.adapter_.removeClass(cssClasses$7.CLOSED_CLASS);
    }
  }, {
    key: 'close',
    value: function close() {
      this.adapter_.addClass(cssClasses$7.CLOSED_CLASS);
    }
  }, {
    key: 'setScale_',
    value: function setScale_(el, scaleValue) {
      var _this2 = this;

      var value = 'scaleX(' + scaleValue + ')';
      transformStyleProperties.forEach(function (transformStyleProperty) {
        _this2.adapter_.setStyle(el, transformStyleProperty, value);
      });
    }
  }]);
  return MDCLinearProgressFoundation;
}(MDCFoundation);

var ProgressPropType = {
  type: [Number, String],
  validator: function validator(value) {
    return Number(value) >= 0 && Number(value) <= 1;
  }
};

var mdcLinearProgress = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress", class: _vm.classes, style: _vm.styles, attrs: { "role": "progressbar" } }, [_c('div', { staticClass: "mdc-linear-progress__buffering-dots" }), _vm._v(" "), _c('div', { ref: "buffer", staticClass: "mdc-linear-progress__buffer" }), _vm._v(" "), _c('div', { ref: "primary", staticClass: "mdc-linear-progress__bar mdc-linear-progress__primary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]), _vm._v(" "), _vm._m(0)]);
  }, staticRenderFns: [function () {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress__bar mdc-linear-progress__secondary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]);
  }],
  name: 'mdc-linear-progress',
  props: {
    'open': { type: Boolean, default: true },
    'indeterminate': Boolean,
    'reverse': Boolean,
    'accent': Boolean,
    'progress': ProgressPropType,
    'buffer': ProgressPropType
  },
  data: function data() {
    return {
      classes: { 'mdc-linear-progress--accent': this.accent },
      styles: {}
    };
  },

  watch: {
    open: function open() {
      if (this.open) {
        this.foundation.open();
      } else {
        this.foundation.close();
      }
    },
    progress: function progress() {
      this.foundation.setProgress(Number(this.progress));
    },
    buffer: function buffer() {
      this.foundation.setBuffer(Number(this.buffer));
    },
    indeterminate: function indeterminate() {
      this.foundation.setDeterminate(!this.indeterminate);
    },
    reverse: function reverse() {
      this.foundation.setReverse(this.reverse);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCLinearProgressFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.classes, className, true);
      },
      getPrimaryBar: function getPrimaryBar() /* el: Element */{
        return _this.$refs.primary;
      },
      getBuffer: function getBuffer() /* el: Element */{
        return _this.$refs.buffer;
      },
      hasClass: function hasClass(className) {
        _this.$el.classList.contains(className);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.classes, className);
      },
      setStyle: function setStyle(el, styleProperty, value) {
        el.style[styleProperty] = value;
      }
    });
    this.foundation.init();

    this.foundation.setReverse(this.reverse);
    this.foundation.setProgress(Number(this.progress));
    this.foundation.setBuffer(Number(this.buffer));
    this.foundation.setDeterminate(!this.indeterminate);
    if (this.open) {
      this.foundation.open();
    } else {
      this.foundation.close();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCLinearProgress = BasePlugin({
  mdcLinearProgress: mdcLinearProgress
});

var mdcList = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('ul', { staticClass: "mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-list',
  props: {
    dense: Boolean,
    avatarList: Boolean,
    twoLine: Boolean,
    bordered: Boolean,
    interactive: Boolean
  },
  provide: function provide() {
    return { mdcList: this };
  },

  computed: {
    classes: function classes() {
      return {
        'mdc-list--dense': this.dense,
        'mdc-list--avatar-list': this.avatarList,
        'mdc-list--two-line': this.twoLine,
        'mdc-list--bordered': this.bordered,
        'mdc-list--non-interactive': !this.interactive
      };
    }
  }
};

var mdcListItem = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail")], 2) : _vm._e(), _vm._v(" "), _vm.hasSecondary ? _c('span', { staticClass: "mdc-list-item__text" }, [_vm._t("default"), _vm._v(" "), _c('span', { staticClass: "mdc-list-item__secondary-text" }, [_vm._t("secondary")], 2)], 2) : _vm._t("default"), _vm._v(" "), _vm.hasEndDetail ? _c('span', { staticClass: "mdc-list-item__meta" }, [_vm._t("end-detail")], 2) : _vm._e()], 2);
  }, staticRenderFns: [],
  name: 'mdc-list-item',
  inject: ['mdcList'],
  props: {
    selected: Boolean,
    activated: Boolean
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    itemClasses: function itemClasses() {
      return {
        'mdc-list-item--selected': this.selected,
        'mdc-list-item--activated': this.activated
      };
    },
    isInteractive: function isInteractive() {
      return this.mdcList && this.mdcList.interactive;
    },
    hasSecondary: function hasSecondary() {
      return this.$slots['secondary'] && this.mdcList && this.mdcList.twoLine;
    },
    hasEndDetail: function hasEndDetail() {
      return !!this.$slots['end-detail'];
    },
    hasStartDetail: function hasStartDetail() {
      return !!this.$slots['start-detail'];
    }
  },
  watch: {
    isInteractive: function isInteractive(value) {
      if (value) {
        this.addRipple();
      } else {
        this.removeRipple();
      }
    }
  },
  mounted: function mounted() {
    this.isInteractive && this.addRipple();
  },
  beforeDestroy: function beforeDestroy() {
    this.removeRipple();
  },

  methods: {
    addRipple: function addRipple() {
      if (!this.ripple) {
        var ripple = new RippleBase(this);
        ripple.init();
        this.ripple = ripple;
      }
    },
    removeRipple: function removeRipple() {
      if (this.ripple) {
        var ripple = this.ripple;
        this.ripple = null;
        ripple.destroy();
      }
    }
  }

};

var mdcListDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-list-divider", class: _vm.classes, attrs: { "role": "separator" } });
  }, staticRenderFns: [],
  name: 'mdc-list-divider',
  props: {
    inset: Boolean,
    padded: Boolean
  },
  computed: {
    classes: function classes() {
      return {
        'mdc-list-divider--inset': this.inset,
        'mdc-list-divider--padded': this.padded
      };
    }
  }
};

var mdcListGroup = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-list-group" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-list-group'
};

var mdcListGroupHeader = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h3', { staticClass: "mdc-list-group-header mdc-list-group__subheader" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-list-group-header'
};

var mdcListGroupDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-group-divider mdc-list-divider" });
  }, staticRenderFns: [],
  name: 'mdc-list-group-divider'
};

var VueMDCList = BasePlugin({
  mdcList: mdcList,
  mdcListItem: mdcListItem,
  mdcListDivider: mdcListDivider,
  mdcListGroup: mdcListGroup,
  mdcListGroupHeader: mdcListGroupHeader,
  mdcListGroupDivider: mdcListGroupDivider
});

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Menu. Provides an interface for managing
 * - classes
 * - dom
 * - focus
 * - position
 * - dimensions
 * - event handlers
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */
var MDCMenuAdapter = function () {
  function MDCMenuAdapter() {
    classCallCheck(this, MDCMenuAdapter);
  }

  createClass(MDCMenuAdapter, [{
    key: "addClass",

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /** @return {boolean} */

  }, {
    key: "hasNecessaryDom",
    value: function hasNecessaryDom() {}

    /**
     * @param {EventTarget} target
     * @param {string} attributeName
     * @return {string}
     */

  }, {
    key: "getAttributeForEventTarget",
    value: function getAttributeForEventTarget(target, attributeName) {}

    /** @return {{ width: number, height: number }} */

  }, {
    key: "getInnerDimensions",
    value: function getInnerDimensions() {}

    /** @return {boolean} */

  }, {
    key: "hasAnchor",
    value: function hasAnchor() {}

    /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

  }, {
    key: "getAnchorDimensions",
    value: function getAnchorDimensions() {}

    /** @return {{ width: number, height: number }} */

  }, {
    key: "getWindowDimensions",
    value: function getWindowDimensions() {}

    /** @return {number} */

  }, {
    key: "getNumberOfItems",
    value: function getNumberOfItems() {}

    /**
     * @param {string} type
     * @param {function(!Event)} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(type, handler) {}

    /**
     * @param {string} type
     * @param {function(!Event)} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}

    /** @param {function(!Event)} handler */

  }, {
    key: "registerBodyClickHandler",
    value: function registerBodyClickHandler(handler) {}

    /** @param {function(!Event)} handler */

  }, {
    key: "deregisterBodyClickHandler",
    value: function deregisterBodyClickHandler(handler) {}

    /**
     * @param {EventTarget} target
     * @return {number}
     */

  }, {
    key: "getIndexForEventTarget",
    value: function getIndexForEventTarget(target) {}

    /** @param {{index: number}} evtData */

  }, {
    key: "notifySelected",
    value: function notifySelected(evtData) {}
  }, {
    key: "notifyCancel",
    value: function notifyCancel() {}
  }, {
    key: "saveFocus",
    value: function saveFocus() {}
  }, {
    key: "restoreFocus",
    value: function restoreFocus() {}

    /** @return {boolean} */

  }, {
    key: "isFocused",
    value: function isFocused() {}
  }, {
    key: "focus",
    value: function focus() {}

    /** @return {number} */

  }, {
    key: "getFocusedItemIndex",
    value: function getFocusedItemIndex() /* number */{}

    /** @param {number} index */

  }, {
    key: "focusItemAtIndex",
    value: function focusItemAtIndex(index) {}

    /** @return {boolean} */

  }, {
    key: "isRtl",
    value: function isRtl() {}

    /** @param {string} origin */

  }, {
    key: "setTransformOrigin",
    value: function setTransformOrigin(origin) {}

    /** @param {{
    *   top: (string|undefined),
    *   right: (string|undefined),
    *   bottom: (string|undefined),
    *   left: (string|undefined)
    * }} position */

  }, {
    key: "setPosition",
    value: function setPosition(position) {}

    /** @param {string} height */

  }, {
    key: "setMaxHeight",
    value: function setMaxHeight(height) {}

    /**
     * @param {number} index
     * @param {string} attr
     * @param {string} value
     */

  }, {
    key: "setAttrForOptionAtIndex",
    value: function setAttrForOptionAtIndex(index, attr, value) {}

    /**
     * @param {number} index
     * @param {string} attr
     */

  }, {
    key: "rmAttrForOptionAtIndex",
    value: function rmAttrForOptionAtIndex(index, attr) {}

    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "addClassForOptionAtIndex",
    value: function addClassForOptionAtIndex(index, className) {}

    /**
     * @param {number} index
     * @param {string} className
     */

  }, {
    key: "rmClassForOptionAtIndex",
    value: function rmClassForOptionAtIndex(index, className) {}
  }]);
  return MDCMenuAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$8 = {
  ROOT: 'mdc-menu',
  OPEN: 'mdc-menu--open',
  ANIMATING_OPEN: 'mdc-menu--animating-open',
  ANIMATING_CLOSED: 'mdc-menu--animating-closed',
  SELECTED_LIST_ITEM: 'mdc-list-item--selected'
};

/** @enum {string} */
var strings$11 = {
  ITEMS_SELECTOR: '.mdc-menu__items',
  SELECTED_EVENT: 'MDCMenu:selected',
  CANCEL_EVENT: 'MDCMenu:cancel',
  ARIA_DISABLED_ATTR: 'aria-disabled'
};

/** @enum {number} */
var numbers$2 = {
  // Amount of time to wait before triggering a selected event on the menu. Note that this time
  // will most likely be bumped up once interactive lists are supported to allow for the ripple to
  // animate before closing the menu
  SELECTED_TRIGGER_DELAY: 50,
  // Total duration of menu open animation.
  TRANSITION_OPEN_DURATION: 120,
  // Total duration of menu close animation.
  TRANSITION_CLOSE_DURATION: 75,
  // Margin left to the edge of the viewport when menu is at maximum possible height.
  MARGIN_TO_EDGE: 32,
  // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
  ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
  // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
  OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
};

/**
 * Enum for bits in the {@see Corner) bitmap.
 * @enum {number}
 */
var CornerBit = {
  BOTTOM: 1,
  CENTER: 2,
  RIGHT: 4,
  FLIP_RTL: 8
};

/**
 * Enum for representing an element corner for positioning the menu.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 *
 * @enum {number}
 */
var Corner = {
  TOP_LEFT: 0,
  TOP_RIGHT: CornerBit.RIGHT,
  BOTTOM_LEFT: CornerBit.BOTTOM,
  BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
  TOP_START: CornerBit.FLIP_RTL,
  TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
  BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
  BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @typedef {{
 *   top: number,
 *   right: number,
 *   bottom: number,
 *   left: number
 * }}
 */
/* eslint-enable no-unused-vars */

/**
 * @extends {MDCFoundation<!MDCMenuAdapter>}
 */

var MDCMenuFoundation = function (_MDCFoundation) {
  inherits(MDCMenuFoundation, _MDCFoundation);
  createClass(MDCMenuFoundation, null, [{
    key: 'cssClasses',

    /** @return enum{cssClasses} */
    get: function get$$1() {
      return cssClasses$8;
    }

    /** @return enum{strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$11;
    }

    /** @return enum{numbers} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$2;
    }

    /** @return enum{number} */

  }, {
    key: 'Corner',
    get: function get$$1() {
      return Corner;
    }

    /**
     * {@see MDCMenuAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCMenuAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCMenuAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {
            return false;
          },
          hasNecessaryDom: function hasNecessaryDom() {
            return false;
          },
          getAttributeForEventTarget: function getAttributeForEventTarget() {},
          getInnerDimensions: function getInnerDimensions() {
            return {};
          },
          hasAnchor: function hasAnchor() {
            return false;
          },
          getAnchorDimensions: function getAnchorDimensions() {
            return {};
          },
          getWindowDimensions: function getWindowDimensions() {
            return {};
          },
          getNumberOfItems: function getNumberOfItems() {
            return 0;
          },
          registerInteractionHandler: function registerInteractionHandler() {},
          deregisterInteractionHandler: function deregisterInteractionHandler() {},
          registerBodyClickHandler: function registerBodyClickHandler() {},
          deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
          getIndexForEventTarget: function getIndexForEventTarget() {
            return 0;
          },
          notifySelected: function notifySelected() {},
          notifyCancel: function notifyCancel() {},
          saveFocus: function saveFocus() {},
          restoreFocus: function restoreFocus() {},
          isFocused: function isFocused() {
            return false;
          },
          focus: function focus() {},
          getFocusedItemIndex: function getFocusedItemIndex() {
            return -1;
          },
          focusItemAtIndex: function focusItemAtIndex() {},
          isRtl: function isRtl() {
            return false;
          },
          setTransformOrigin: function setTransformOrigin() {},
          setPosition: function setPosition() {},
          setMaxHeight: function setMaxHeight() {},
          setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
          rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
          addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
          rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
        }
      );
    }

    /** @param {!MDCMenuAdapter} adapter */

  }]);

  function MDCMenuFoundation(adapter) {
    classCallCheck(this, MDCMenuFoundation);

    /** @private {function(!Event)} */
    var _this = possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, _extends(MDCMenuFoundation.defaultAdapter, adapter)));

    _this.clickHandler_ = function (evt) {
      return _this.handlePossibleSelected_(evt);
    };
    /** @private {function(!Event)} */
    _this.keydownHandler_ = function (evt) {
      return _this.handleKeyboardDown_(evt);
    };
    /** @private {function(!Event)} */
    _this.keyupHandler_ = function (evt) {
      return _this.handleKeyboardUp_(evt);
    };
    /** @private {function(!Event)} */
    _this.documentClickHandler_ = function (evt) {
      return _this.handleDocumentClick_(evt);
    };
    /** @private {boolean} */
    _this.isOpen_ = false;
    /** @private {number} */
    _this.openAnimationEndTimerId_ = 0;
    /** @private {number} */
    _this.closeAnimationEndTimerId_ = 0;
    /** @private {number} */
    _this.selectedTriggerTimerId_ = 0;
    /** @private {number} */
    _this.animationRequestId_ = 0;
    /** @private {!{ width: number, height: number }} */
    _this.dimensions_;
    /** @private {number} */
    _this.itemHeight_;
    /** @private {Corner} */
    _this.anchorCorner_ = Corner.TOP_START;
    /** @private {AnchorMargin} */
    _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
    /** @private {?AutoLayoutMeasurements} */
    _this.measures_ = null;
    /** @private {number} */
    _this.selectedIndex_ = -1;
    /** @private {boolean} */
    _this.rememberSelection_ = false;
    /** @private {boolean} */
    _this.quickOpen_ = false;

    // A keyup event on the menu needs to have a corresponding keydown
    // event on the menu. If the user opens the menu with a keydown event on a
    // button, the menu will only get the key up event causing buggy behavior with selected elements.
    /** @private {boolean} */
    _this.keyDownWithinMenu_ = false;
    return _this;
  }

  createClass(MDCMenuFoundation, [{
    key: 'init',
    value: function init() {
      var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
          ROOT = _MDCMenuFoundation$cs.ROOT,
          OPEN = _MDCMenuFoundation$cs.OPEN;


      if (!this.adapter_.hasClass(ROOT)) {
        throw new Error(ROOT + ' class required in root element.');
      }

      if (!this.adapter_.hasNecessaryDom()) {
        throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
      }

      if (this.adapter_.hasClass(OPEN)) {
        this.isOpen_ = true;
      }

      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      clearTimeout(this.selectedTriggerTimerId_);
      clearTimeout(this.openAnimationEndTimerId_);
      clearTimeout(this.closeAnimationEndTimerId_);
      // Cancel any currently running animations.
      cancelAnimationFrame(this.animationRequestId_);
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
    }

    /**
     * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
     */

  }, {
    key: 'setAnchorCorner',
    value: function setAnchorCorner(corner) {
      this.anchorCorner_ = corner;
    }

    /**
     * @param {!AnchorMargin} margin 4-plet of margins from anchor.
     */

  }, {
    key: 'setAnchorMargin',
    value: function setAnchorMargin(margin) {
      this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
      this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
      this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
      this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
    }

    /** @param {boolean} rememberSelection */

  }, {
    key: 'setRememberSelection',
    value: function setRememberSelection(rememberSelection) {
      this.rememberSelection_ = rememberSelection;
      this.setSelectedIndex(-1);
    }

    /** @param {boolean} quickOpen */

  }, {
    key: 'setQuickOpen',
    value: function setQuickOpen(quickOpen) {
      this.quickOpen_ = quickOpen;
    }

    /**
     * @param {?number} focusIndex
     * @private
     */

  }, {
    key: 'focusOnOpen_',
    value: function focusOnOpen_(focusIndex) {
      if (focusIndex === null) {
        // If this instance of MDCMenu remembers selections, and the user has
        // made a selection, then focus the last selected item
        if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
          this.adapter_.focusItemAtIndex(this.selectedIndex_);
          return;
        }

        this.adapter_.focus();
        // If that doesn't work, focus first item instead.
        if (!this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(0);
        }
      } else {
        this.adapter_.focusItemAtIndex(focusIndex);
      }
    }

    /**
     * Handle clicks and cancel the menu if not a child list-item
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handleDocumentClick_',
    value: function handleDocumentClick_(evt) {
      var el = evt.target;

      while (el && el !== document.documentElement) {
        if (this.adapter_.getIndexForEventTarget(el) !== -1) {
          return;
        }
        el = el.parentNode;
      }

      this.adapter_.notifyCancel();
      this.close(evt);
    }
  }, {
    key: 'handleKeyboardDown_',


    /**
     * Handle keys that we want to repeat on hold (tab and arrows).
     * @param {!Event} evt
     * @return {boolean}
     * @private
     */
    value: function handleKeyboardDown_(evt) {
      // Do nothing if Alt, Ctrl or Meta are pressed.
      if (evt.altKey || evt.ctrlKey || evt.metaKey) {
        return true;
      }

      var keyCode = evt.keyCode,
          key = evt.key,
          shiftKey = evt.shiftKey;

      var isTab = key === 'Tab' || keyCode === 9;
      var isArrowUp = key === 'ArrowUp' || keyCode === 38;
      var isArrowDown = key === 'ArrowDown' || keyCode === 40;
      var isSpace = key === 'Space' || keyCode === 32;
      var isEnter = key === 'Enter' || keyCode === 13;
      // The menu needs to know if the keydown event was triggered on the menu
      this.keyDownWithinMenu_ = isEnter || isSpace;

      var focusedItemIndex = this.adapter_.getFocusedItemIndex();
      var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

      if (shiftKey && isTab && focusedItemIndex === 0) {
        this.adapter_.focusItemAtIndex(lastItemIndex);
        evt.preventDefault();
        return false;
      }

      if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
        this.adapter_.focusItemAtIndex(0);
        evt.preventDefault();
        return false;
      }

      // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling
      if (isArrowUp || isArrowDown || isSpace) {
        evt.preventDefault();
      }

      if (isArrowUp) {
        if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(lastItemIndex);
        } else {
          this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
        }
      } else if (isArrowDown) {
        if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
          this.adapter_.focusItemAtIndex(0);
        } else {
          this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
        }
      }

      return true;
    }

    /**
     * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
     * @param {!Event} evt
     * @return {boolean}
     * @private
     */

  }, {
    key: 'handleKeyboardUp_',
    value: function handleKeyboardUp_(evt) {
      // Do nothing if Alt, Ctrl or Meta are pressed.
      if (evt.altKey || evt.ctrlKey || evt.metaKey) {
        return true;
      }

      var keyCode = evt.keyCode,
          key = evt.key;

      var isEnter = key === 'Enter' || keyCode === 13;
      var isSpace = key === 'Space' || keyCode === 32;
      var isEscape = key === 'Escape' || keyCode === 27;

      if (isEnter || isSpace) {
        // If the keydown event didn't occur on the menu, then it should
        // disregard the possible selected event.
        if (this.keyDownWithinMenu_) {
          this.handlePossibleSelected_(evt);
        }
        this.keyDownWithinMenu_ = false;
      }

      if (isEscape) {
        this.adapter_.notifyCancel();
        this.close();
      }

      return true;
    }

    /**
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handlePossibleSelected_',
    value: function handlePossibleSelected_(evt) {
      var _this2 = this;

      if (this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true') {
        return;
      }
      var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);
      if (targetIndex < 0) {
        return;
      }
      // Debounce multiple selections
      if (this.selectedTriggerTimerId_) {
        return;
      }
      this.selectedTriggerTimerId_ = setTimeout(function () {
        _this2.selectedTriggerTimerId_ = 0;
        _this2.close();
        if (_this2.rememberSelection_) {
          _this2.setSelectedIndex(targetIndex);
        }
        _this2.adapter_.notifySelected({ index: targetIndex });
      }, numbers$2.SELECTED_TRIGGER_DELAY);
    }

    /**
     * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
     */

  }, {
    key: 'getAutoLayoutMeasurements_',
    value: function getAutoLayoutMeasurements_() {
      var anchorRect = this.adapter_.getAnchorDimensions();
      var viewport = this.adapter_.getWindowDimensions();

      return {
        viewport: viewport,
        viewportDistance: {
          top: anchorRect.top,
          right: viewport.width - anchorRect.right,
          left: anchorRect.left,
          bottom: viewport.height - anchorRect.bottom
        },
        anchorHeight: anchorRect.height,
        anchorWidth: anchorRect.width,
        menuHeight: this.dimensions_.height,
        menuWidth: this.dimensions_.width
      };
    }

    /**
     * Computes the corner of the anchor from which to animate and position the menu.
     * @return {Corner}
     * @private
     */

  }, {
    key: 'getOriginCorner_',
    value: function getOriginCorner_() {
      // Defaults: open from the top left.
      var corner = Corner.TOP_LEFT;

      var _measures_ = this.measures_,
          viewportDistance = _measures_.viewportDistance,
          anchorHeight = _measures_.anchorHeight,
          anchorWidth = _measures_.anchorWidth,
          menuHeight = _measures_.menuHeight,
          menuWidth = _measures_.menuWidth;

      var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
      var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
      var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;

      var topOverflow = menuHeight - availableTop;
      var bottomOverflow = menuHeight - availableBottom;
      if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
        corner |= CornerBit.BOTTOM;
      }

      var isRtl = this.adapter_.isRtl();
      var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
      var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
      var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
      var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
      var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;

      var leftOverflow = menuWidth - availableLeft;
      var rightOverflow = menuWidth - availableRight;

      if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
        corner |= CornerBit.RIGHT;
      }

      return corner;
    }

    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
     * @private
     */

  }, {
    key: 'getHorizontalOriginOffset_',
    value: function getHorizontalOriginOffset_(corner) {
      var anchorWidth = this.measures_.anchorWidth;

      var isRightAligned = Boolean(corner & CornerBit.RIGHT);
      var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
      var x = 0;
      if (isRightAligned) {
        var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
        x = rightOffset;
      } else {
        var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
        x = leftOffset;
      }
      return x;
    }

    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
     * @private
     */

  }, {
    key: 'getVerticalOriginOffset_',
    value: function getVerticalOriginOffset_(corner) {
      var _measures_2 = this.measures_,
          viewport = _measures_2.viewport,
          viewportDistance = _measures_2.viewportDistance,
          anchorHeight = _measures_2.anchorHeight,
          menuHeight = _measures_2.menuHeight;

      var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
      var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;

      var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
      var canOverlapVertically = !avoidVerticalOverlap;
      var y = 0;

      if (isBottomAligned) {
        y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
        // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
        // anchor corner. Bottom margin is ignored in such cases.
        if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
          y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
        }
      } else {
        y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
        // adjust for when menu can overlap anchor, but too tall to be aligned to top
        // anchor corners. Top margin is ignored in that case.
        if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
          y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
        }
      }
      return y;
    }

    /**
     * @param {Corner} corner Origin corner of the menu.
     * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
     * @private
     */

  }, {
    key: 'getMenuMaxHeight_',
    value: function getMenuMaxHeight_(corner) {
      var maxHeight = 0;
      var viewportDistance = this.measures_.viewportDistance;

      var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);

      // When maximum height is not specified, it is handled from css.
      if (this.anchorCorner_ & CornerBit.BOTTOM) {
        if (isBottomAligned) {
          maxHeight = viewportDistance.top + this.anchorMargin_.top;
        } else {
          maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
        }
      }

      return maxHeight;
    }

    /** @private */

  }, {
    key: 'autoPosition_',
    value: function autoPosition_() {
      var _position;

      if (!this.adapter_.hasAnchor()) {
        return;
      }

      // Compute measurements for autoposition methods reuse.
      this.measures_ = this.getAutoLayoutMeasurements_();

      var corner = this.getOriginCorner_();
      var maxMenuHeight = this.getMenuMaxHeight_(corner);
      var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
      var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
      var horizontalOffset = this.getHorizontalOriginOffset_(corner);
      var verticalOffset = this.getVerticalOriginOffset_(corner);
      var position = (_position = {}, defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
      var _measures_3 = this.measures_,
          anchorWidth = _measures_3.anchorWidth,
          menuHeight = _measures_3.menuHeight,
          menuWidth = _measures_3.menuWidth;
      // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

      if (anchorWidth / menuWidth > numbers$2.ANCHOR_TO_MENU_WIDTH_RATIO) {
        horizontalAlignment = 'center';
      }

      // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
      // scale animation is "anchored" on the anchor.
      if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers$2.OFFSET_TO_MENU_HEIGHT_RATIO) {
        var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
        var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
        verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
      }

      this.adapter_.setTransformOrigin(horizontalAlignment + ' ' + verticalAlignment);
      this.adapter_.setPosition(position);
      this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');

      // Clear measures after positioning is complete.
      this.measures_ = null;
    }

    /**
     * Open the menu.
     * @param {{focusIndex: ?number}=} options
     */

  }, {
    key: 'open',
    value: function open() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$focusIndex = _ref.focusIndex,
          focusIndex = _ref$focusIndex === undefined ? null : _ref$focusIndex;

      this.adapter_.saveFocus();

      if (!this.quickOpen_) {
        this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
      }

      this.animationRequestId_ = requestAnimationFrame(function () {
        _this3.dimensions_ = _this3.adapter_.getInnerDimensions();
        _this3.autoPosition_();
        _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);
        _this3.focusOnOpen_(focusIndex);
        _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);
        if (!_this3.quickOpen_) {
          _this3.openAnimationEndTimerId_ = setTimeout(function () {
            _this3.openAnimationEndTimerId_ = 0;
            _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
          }, numbers$2.TRANSITION_OPEN_DURATION);
        }
      });
      this.isOpen_ = true;
    }

    /**
     * Closes the menu.
     * @param {Event=} evt
     */

  }, {
    key: 'close',
    value: function close() {
      var _this4 = this;

      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings$11.ARIA_DISABLED_ATTR) === 'true' : false;

      if (targetIsDisabled) {
        return;
      }

      this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

      if (!this.quickOpen_) {
        this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
      }

      requestAnimationFrame(function () {
        _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);
        if (!_this4.quickOpen_) {
          _this4.closeAnimationEndTimerId_ = setTimeout(function () {
            _this4.closeAnimationEndTimerId_ = 0;
            _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
          }, numbers$2.TRANSITION_CLOSE_DURATION);
        }
      });
      this.isOpen_ = false;
      this.adapter_.restoreFocus();
    }

    /** @return {boolean} */

  }, {
    key: 'isOpen',
    value: function isOpen() {
      return this.isOpen_;
    }

    /** @return {number} */

  }, {
    key: 'getSelectedIndex',
    value: function getSelectedIndex() {
      return this.selectedIndex_;
    }

    /**
     * @param {number} index Index of the item to set as selected.
     */

  }, {
    key: 'setSelectedIndex',
    value: function setSelectedIndex(index) {
      if (index === this.selectedIndex_) {
        return;
      }

      var prevSelectedIndex = this.selectedIndex_;
      if (prevSelectedIndex >= 0) {
        this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
        this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses$8.SELECTED_LIST_ITEM);
      }

      this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;
      if (this.selectedIndex_ >= 0) {
        this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
        this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses$8.SELECTED_LIST_ITEM);
      }
    }
  }]);
  return MDCMenuFoundation;
}(MDCFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @type {string|undefined} */
var storedTransformPropertyName_$1 = void 0;

/**
 * Returns the name of the correct transform property to use on the current browser.
 * @param {!Window} globalObj
 * @param {boolean=} forceRefresh
 * @return {string}
 */
function getTransformPropertyName$1(globalObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
    storedTransformPropertyName_$1 = transformPropertyName;
  }

  return storedTransformPropertyName_$1;
}

var mdcMenu = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-menu mdc-simple-menu", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "-1" } }, [_c('ul', { ref: "items", staticClass: "mdc-simple-menu__items mdc-list", attrs: { "role": "menu", "aria-hidden": "true" } }, [_vm._t("default")], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-menu',
  props: {
    'open-from-top-left': Boolean,
    'open-from-top-right': Boolean,
    'open-from-bottom-left': Boolean,
    'open-from-bottom-right': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-simple-menu--open-from-top-left': this.openFromTopLeft,
        'mdc-simple-menu--open-from-top-right': this.openFromTopRight,
        'mdc-simple-menu--open-from-bottom-left': this.openFromBottomLeft,
        'mdc-simple-menu--open-from-bottom-right': this.openFromBottomRight
      },
      styles: {},
      items: []
    };
  },

  methods: {
    show: function show(options) {
      this.foundation.open(options);
    },
    hide: function hide() {
      this.foundation.close();
    },
    isOpen: function isOpen() {
      return this.foundation ? this.foundation.isOpen() : false;
    }
  },
  mounted: function mounted() {
    var _this = this;

    var refreshItems = function refreshItems() {
      _this.items = [].slice.call(_this.$refs.items.querySelectorAll('.mdc-list-item[role]'));
      _this.$emit('update');
    };
    this.slotObserver = new MutationObserver(function () {
      return refreshItems();
    });
    this.slotObserver.observe(this.$el, { childList: true, subtree: true });

    this._previousFocus = undefined;

    this.foundation = new MDCMenuFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      hasClass: function hasClass(className) {
        return _this.$refs.root.classList.contains(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return Boolean(_this.$refs.items);
      },
      getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
        return target.getAttribute(attributeName);
      },
      getInnerDimensions: function getInnerDimensions() {
        return {
          width: _this.$refs.items.offsetWidth,
          height: _this.$refs.items.offsetHeight
        };
      },
      hasAnchor: function hasAnchor() {
        return _this.$refs.root.parentElement && _this.$refs.root.parentElement.classList.contains('mdc-menu-anchor');
      },
      getAnchorDimensions: function getAnchorDimensions() {
        return _this.$refs.root.parentElement.getBoundingClientRect();
      },
      getWindowDimensions: function getWindowDimensions() {
        return {
          width: window.innerWidth,
          height: window.innerHeight
        };
      },
      getNumberOfItems: function getNumberOfItems() {
        return _this.items.length;
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$refs.root.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$refs.root.removeEventListener(type, handler);
      },
      registerBodyClickHandler: function registerBodyClickHandler(handler) {
        return document.body.addEventListener('click', handler);
      },
      deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
        return document.body.removeEventListener('click', handler);
      },
      getIndexForEventTarget: function getIndexForEventTarget(target) {
        return _this.items.indexOf(target);
      },
      notifySelected: function notifySelected(evtData) {
        var evt = {
          index: evtData.index,
          item: _this.items[evtData.index]
        };
        _this.$emit('select', evt);
        emitCustomEvent(_this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, evt);
      },
      notifyCancel: function notifyCancel() {
        _this.$emit('cancel');
        emitCustomEvent(_this.$el, MDCMenuFoundation.strings.CANCEL_EVENT, {});
      },
      saveFocus: function saveFocus() {
        _this._previousFocus = document.activeElement;
      },
      restoreFocus: function restoreFocus() {
        if (_this._previousFocus) {
          _this._previousFocus.focus();
        }
      },
      isFocused: function isFocused() {
        return document.activeElement === _this.$refs.root;
      },
      focus: function focus() {
        return _this.$refs.root.focus();
      },
      getFocusedItemIndex: function getFocusedItemIndex() {
        return _this.items.indexOf(document.activeElement);
      },
      focusItemAtIndex: function focusItemAtIndex(index) {
        return _this.items[index].focus();
      },
      isRtl: function isRtl() {
        return getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
      },
      setTransformOrigin: function setTransformOrigin(origin) {
        _this.$set(_this.styles, getTransformPropertyName$1(window) + '-origin', origin);
      },
      setPosition: function setPosition(position) {
        _this.$set(_this.styles, 'left', position.left);
        _this.$set(_this.styles, 'right', position.right);
        _this.$set(_this.styles, 'top', position.top);
        _this.$set(_this.styles, 'bottom', position.bottom);
      },
      setMaxHeight: function setMaxHeight(height) {
        _this.$set(_this.styles, 'max-height', height);
      },
      setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
        _this.items[index].setAttribute(attr, value);
      },
      rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
        _this.items[index].removeAttribute(attr);
      },
      addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
        _this.items[index].classList.add(className);
      },
      rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
        _this.items[index].classList.remove(className);
      }
    });

    refreshItems();
    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this._previousFocus = null;
    this.slotObserver.disconnect();
    this.foundation.destroy();
  }
};

var mdcMenuItem = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-item mdc-list-item", attrs: { "role": "menuitem", "tabindex": _vm.disabled ? '-1' : '0', "aria-disabled": _vm.disabled } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-menu-item',
  props: {
    disabled: Boolean
  }
};

var mdcMenuDivider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-divider mdc-list-divider", attrs: { "role": "separator" } });
  }, staticRenderFns: [],
  name: 'mdc-menu-divider'
};

var mdcMenuAnchor = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-menu-anchor" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-menu-anchor'
};

var VueMDCMenu = BasePlugin({
  mdcMenu: mdcMenu,
  mdcMenuItem: mdcMenuItem,
  mdcMenuDivider: mdcMenuDivider,
  mdcMenuAnchor: mdcMenuAnchor
});

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Radio. Provides an interface for managing
 * - classes
 * - dom
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
 *
 * @record
 */

var MDCRadioAdapter = function () {
  function MDCRadioAdapter() {
    classCallCheck(this, MDCRadioAdapter);
  }

  createClass(MDCRadioAdapter, [{
    key: 'addClass',

    /** @param {string} className */
    value: function addClass(className) {}

    /** @param {string} className */

  }, {
    key: 'removeClass',
    value: function removeClass(className) {}

    /** @return {!MDCSelectionControlState} */

  }, {
    key: 'getNativeControl',
    value: function getNativeControl() {}
  }]);
  return MDCRadioAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$12 = {
  NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
};

/** @enum {string} */
var cssClasses$9 = {
  ROOT: 'mdc-radio',
  DISABLED: 'mdc-radio--disabled'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint-enable no-unused-vars */
/**
 * @extends {MDCFoundation<!MDCRadioAdapter>}
 */

var MDCRadioFoundation = function (_MDCFoundation) {
  inherits(MDCRadioFoundation, _MDCFoundation);

  function MDCRadioFoundation() {
    classCallCheck(this, MDCRadioFoundation);
    return possibleConstructorReturn(this, (MDCRadioFoundation.__proto__ || Object.getPrototypeOf(MDCRadioFoundation)).apply(this, arguments));
  }

  createClass(MDCRadioFoundation, [{
    key: 'isChecked',


    /** @return {boolean} */
    value: function isChecked() {
      return this.getNativeControl_().checked;
    }

    /** @param {boolean} checked */

  }, {
    key: 'setChecked',
    value: function setChecked(checked) {
      this.getNativeControl_().checked = checked;
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.getNativeControl_().disabled;
    }

    /** @param {boolean} disabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;

      this.getNativeControl_().disabled = disabled;
      if (disabled) {
        this.adapter_.addClass(DISABLED);
      } else {
        this.adapter_.removeClass(DISABLED);
      }
    }

    /** @return {?string} */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.getNativeControl_().value;
    }

    /** @param {?string} value */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.getNativeControl_().value = value;
    }

    /**
     * @return {!MDCSelectionControlState}
     * @private
     */

  }, {
    key: 'getNativeControl_',
    value: function getNativeControl_() {
      return this.adapter_.getNativeControl() || {
        checked: false,
        disabled: false,
        value: null
      };
    }
  }], [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$9;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$12;
    }

    /** @return {!MDCRadioAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCRadioAdapter} */{
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{}
        }
      );
    }
  }]);
  return MDCRadioFoundation;
}(MDCFoundation);

var mdcRadio = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-radio-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-radio", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-radio__native-control", attrs: { "type": "radio", "id": _vm._uid, "name": _vm.name }, on: { "change": _vm.sync } }), _vm._v(" "), _c('div', { ref: "label", staticClass: "mdc-radio__background" }, [_c('div', { staticClass: "mdc-radio__outer-circle" }), _vm._v(" "), _c('div', { staticClass: "mdc-radio__inner-circle" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  }, staticRenderFns: [],
  name: 'mdc-radio',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'picked',
    event: 'change'
  },
  props: {
    'name': { type: String, required: true },
    'value': String,
    'picked': String,
    'checked': Boolean,
    'label': String,
    'align-end': Boolean,
    'disabled': Boolean
  },
  data: function data() {
    return {
      classes: {},
      styles: {},
      formFieldClasses: {
        'mdc-form-field': this.label,
        'mdc-form-field--align-end': this.label && this.alignEnd
      }
    };
  },
  mounted: function mounted() {
    var _this = this;

    // add foundation
    this.foundation = new MDCRadioFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      getNativeControl: function getNativeControl() {
        return _this.$refs.control;
      }
    });

    // add ripple
    this.ripple = new RippleBase(this, {
      isUnbounded: function isUnbounded() {
        return true;
      },
      isSurfaceActive: function isSurfaceActive() {
        return false;
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        _this.$refs.control.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        _this.$refs.control.removeEventListener(evt, handler);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this.$refs.root.getBoundingClientRect();
      }
    });

    this.formField = new MDCFormFieldFoundation({
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        _this.$refs.label.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        _this.$refs.label.removeEventListener(type, handler);
      },
      activateInputRipple: function activateInputRipple() {
        _this.ripple && _this.ripple.activate();
      },
      deactivateInputRipple: function deactivateInputRipple() {
        _this.ripple && _this.ripple.deactivate();
      }
    });

    this.foundation.init();
    this.ripple.init();
    this.formField.init();

    this.foundation.setValue(this.value ? this.value : this.label);
    this.foundation.setDisabled(this.disabled);
    this.foundation.setChecked(this.checked || this.picked == this.foundation.getValue());

    // refresh model
    this.checked && this.sync();
  },
  beforeDestroy: function beforeDestroy() {
    this.formField.destroy();
    this.ripple.destroy();
    this.foundation.destroy();
  },

  watch: {
    disabled: function disabled(value) {
      this.foundation.setDisabled(value);
    }
  },
  methods: {
    isChecked: function isChecked() {
      return this.foundation.isChecked();
    },
    sync: function sync() {
      this.$emit('change', this.foundation.getValue());
    }
  }
};

var VueMDCRadio = BasePlugin({
  mdcRadio: mdcRadio
});

var MDCNativeSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('select', { directives: [{ name: "model", rawName: "v-model", value: _vm.selected, expression: "selected" }], ref: "root", staticClass: "mdc-select mdc-native-select", attrs: { "disabled": _vm.disabled }, on: { "change": [function ($event) {
          var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
            return o.selected;
          }).map(function (o) {
            var val = "_value" in o ? o._value : o.value;return val;
          });_vm.selected = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
        }, _vm.onChange] } }, [_vm.label ? _c('option', { attrs: { "disabled": "disabled", "value": "" } }, [_vm._v(_vm._s(_vm.label))]) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-native-select',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: [String, Array],
    disabled: Boolean,
    label: String
  },
  data: function data() {
    return {
      selected: this.value
    };
  },

  methods: {
    onChange: function onChange() {
      this.$emit('change', this.selected);
    }
  }
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var cssClasses$10 = {
  BOTTOM_LINE: 'mdc-select__bottom-line',
  BOTTOM_LINE_ACTIVE: 'mdc-select__bottom-line--active',
  BOX: 'mdc-select--box',
  DISABLED: 'mdc-select--disabled',
  OPEN: 'mdc-select--open',
  ROOT: 'mdc-select',
  SCROLL_LOCK: 'mdc-select-scroll-lock'
};

var strings$13 = {
  CHANGE_EVENT: 'MDCSelect:change',
  BOTTOM_LINE_SELECTOR: '.mdc-select__bottom-line',
  LABEL_SELECTOR: '.mdc-select__label',
  MENU_SELECTOR: '.mdc-select__menu',
  SURFACE_SELECTOR: '.mdc-select__surface',
  SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends MDCComponent<!MDCMenuFoundation>
 */

var MDCMenu = function (_MDCComponent) {
  inherits(MDCMenu, _MDCComponent);

  /** @param {...?} args */
  function MDCMenu() {
    var _ref;

    classCallCheck(this, MDCMenu);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @private {!Element} */
    var _this = possibleConstructorReturn(this, (_ref = MDCMenu.__proto__ || Object.getPrototypeOf(MDCMenu)).call.apply(_ref, [this].concat(args)));

    _this.previousFocus_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @return {!MDCMenu}
   */


  createClass(MDCMenu, [{
    key: 'show',


    /** @param {{focusIndex: ?number}=} options */
    value: function show() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$focusIndex = _ref2.focusIndex,
          focusIndex = _ref2$focusIndex === undefined ? null : _ref2$focusIndex;

      this.foundation_.open({ focusIndex: focusIndex });
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.foundation_.close();
    }

    /**
     * @param {Corner} corner Default anchor corner alignment of top-left
     *     menu corner.
     */

  }, {
    key: 'setAnchorCorner',
    value: function setAnchorCorner(corner) {
      this.foundation_.setAnchorCorner(corner);
    }

    /**
     * @param {AnchorMargin} margin
     */

  }, {
    key: 'setAnchorMargin',
    value: function setAnchorMargin(margin) {
      this.foundation_.setAnchorMargin(margin);
    }

    /**
     * Return the item container element inside the component.
     * @return {?Element}
     */

  }, {
    key: 'getOptionByIndex',


    /**
     * Return the item within the menu that is selected.
     * @param {number} index
     * @return {?Element}
     */
    value: function getOptionByIndex(index) {
      var items = this.items;

      if (index < items.length) {
        return this.items[index];
      } else {
        return null;
      }
    }

    /** @param {number} index */

  }, {
    key: 'getDefaultFoundation',


    /** @return {!MDCMenuFoundation} */
    value: function getDefaultFoundation() {
      var _this2 = this;

      return new MDCMenuFoundation({
        addClass: function addClass(className) {
          return _this2.root_.classList.add(className);
        },
        removeClass: function removeClass(className) {
          return _this2.root_.classList.remove(className);
        },
        hasClass: function hasClass(className) {
          return _this2.root_.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return Boolean(_this2.itemsContainer_);
        },
        getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
          return target.getAttribute(attributeName);
        },
        getInnerDimensions: function getInnerDimensions() {
          var itemsContainer = _this2.itemsContainer_;

          return { width: itemsContainer.offsetWidth, height: itemsContainer.offsetHeight };
        },
        hasAnchor: function hasAnchor() {
          return _this2.root_.parentElement && _this2.root_.parentElement.classList.contains('mdc-menu-anchor');
        },
        getAnchorDimensions: function getAnchorDimensions() {
          return _this2.root_.parentElement.getBoundingClientRect();
        },
        getWindowDimensions: function getWindowDimensions() {
          return { width: window.innerWidth, height: window.innerHeight };
        },
        getNumberOfItems: function getNumberOfItems() {
          return _this2.items.length;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this2.root_.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this2.root_.removeEventListener(type, handler);
        },
        registerBodyClickHandler: function registerBodyClickHandler(handler) {
          return document.body.addEventListener('click', handler);
        },
        deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
          return document.body.removeEventListener('click', handler);
        },
        getIndexForEventTarget: function getIndexForEventTarget(target) {
          return _this2.items.indexOf(target);
        },
        notifySelected: function notifySelected(evtData) {
          return _this2.emit(MDCMenuFoundation.strings.SELECTED_EVENT, {
            index: evtData.index,
            item: _this2.items[evtData.index]
          });
        },
        notifyCancel: function notifyCancel() {
          return _this2.emit(MDCMenuFoundation.strings.CANCEL_EVENT, {});
        },
        saveFocus: function saveFocus() {
          _this2.previousFocus_ = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          if (_this2.previousFocus_) {
            _this2.previousFocus_.focus();
          }
        },
        isFocused: function isFocused() {
          return document.activeElement === _this2.root_;
        },
        focus: function focus() {
          return _this2.root_.focus();
        },
        getFocusedItemIndex: function getFocusedItemIndex() {
          return _this2.items.indexOf(document.activeElement);
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          return _this2.items[index].focus();
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this2.root_.style[getTransformPropertyName$1(window) + '-origin'] = origin;
        },
        setPosition: function setPosition(position) {
          _this2.root_.style.left = 'left' in position ? position.left : null;
          _this2.root_.style.right = 'right' in position ? position.right : null;
          _this2.root_.style.top = 'top' in position ? position.top : null;
          _this2.root_.style.bottom = 'bottom' in position ? position.bottom : null;
        },
        setMaxHeight: function setMaxHeight(height) {
          _this2.root_.style.maxHeight = height;
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          return _this2.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          return _this2.items[index].removeAttribute(attr);
        },
        addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
          return _this2.items[index].classList.add(className);
        },
        rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
          return _this2.items[index].classList.remove(className);
        }
      });
    }
  }, {
    key: 'open',


    /** @return {boolean} */
    get: function get$$1() {
      return this.foundation_.isOpen();
    }

    /** @param {boolean} value */
    ,
    set: function set$$1(value) {
      if (value) {
        this.foundation_.open();
      } else {
        this.foundation_.close();
      }
    }
  }, {
    key: 'itemsContainer_',
    get: function get$$1() {
      return this.root_.querySelector(MDCMenuFoundation.strings.ITEMS_SELECTOR);
    }

    /**
     * Return the items within the menu. Note that this only contains the set of elements within
     * the items container that are proper list items, and not supplemental / presentational DOM
     * elements.
     * @return {!Array<!Element>}
     */

  }, {
    key: 'items',
    get: function get$$1() {
      var itemsContainer = this.itemsContainer_;

      return [].slice.call(itemsContainer.querySelectorAll('.mdc-list-item[role]'));
    }
  }, {
    key: 'selectedItemIndex',
    set: function set$$1(index) {
      this.foundation_.setSelectedIndex(index);
    }

    /** @return {number} */
    ,
    get: function get$$1() {
      return this.foundation_.getSelectedIndex();
    }

    /** @param {!boolean} rememberSelection */

  }, {
    key: 'rememberSelection',
    set: function set$$1(rememberSelection) {
      this.foundation_.setRememberSelection(rememberSelection);
    }

    /** @param {boolean} quickOpen */

  }, {
    key: 'quickOpen',
    set: function set$$1(quickOpen) {
      this.foundation_.setQuickOpen(quickOpen);
    }
  }], [{
    key: 'attachTo',
    value: function attachTo(root) {
      return new MDCMenu(root);
    }
  }]);
  return MDCMenu;
}(MDCComponent);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var OPENER_KEYS = [{ key: 'ArrowUp', keyCode: 38, forType: 'keydown' }, { key: 'ArrowDown', keyCode: 40, forType: 'keydown' }, { key: 'Space', keyCode: 32, forType: 'keyup' }];

var MDCSelectFoundation = function (_MDCFoundation) {
  inherits(MDCSelectFoundation, _MDCFoundation);
  createClass(MDCSelectFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$10;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$13;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        floatLabel: function floatLabel() /* value: boolean */{},
        addClassToBottomLine: function addClassToBottomLine() /* className: string */{},
        removeClassFromBottomLine: function removeClassFromBottomLine() /* className: string */{},
        setBottomLineAttr: function setBottomLineAttr() /* attr: string, value: string */{},
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        setAttr: function setAttr() /* attr: string, value: string */{},
        rmAttr: function rmAttr() /* attr: string */{},
        computeBoundingRect: function computeBoundingRect() {
          return (/* {left: number, top: number} */{ left: 0, top: 0 }
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        focus: function focus() {},
        makeTabbable: function makeTabbable() {},
        makeUntabbable: function makeUntabbable() {},
        getComputedStyleValue: function getComputedStyleValue() {
          return (/* propertyName: string */ /* string */''
          );
        },
        setStyle: function setStyle() /* propertyName: string, value: string */{},
        create2dRenderingContext: function create2dRenderingContext() {
          return (/* {font: string, measureText: (string) => {width: number}} */{
              font: '',
              measureText: function measureText() {
                return { width: 0 };
              }
            }
          );
        },
        setMenuElStyle: function setMenuElStyle() /* propertyName: string, value: string */{},
        setMenuElAttr: function setMenuElAttr() /* attr: string, value: string */{},
        rmMenuElAttr: function rmMenuElAttr() /* attr: string */{},
        getMenuElOffsetHeight: function getMenuElOffsetHeight() {
          return (/* number */0
          );
        },
        openMenu: function openMenu() /* focusIndex: number */{},
        isMenuOpen: function isMenuOpen() {
          return (/* boolean */false
          );
        },
        setSelectedTextContent: function setSelectedTextContent() /* textContent: string */{},
        getNumberOfOptions: function getNumberOfOptions() {
          return (/* number */0
          );
        },
        getTextForOptionAtIndex: function getTextForOptionAtIndex() {
          return (/* index: number */ /* string */''
          );
        },
        getValueForOptionAtIndex: function getValueForOptionAtIndex() {
          return (/* index: number */ /* string */''
          );
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex() /* index: number, attr: string, value: string */{},
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() /* index: number, attr: string */{},
        getOffsetTopForOptionAtIndex: function getOffsetTopForOptionAtIndex() {
          return (/* index: number */ /* number */0
          );
        },
        registerMenuInteractionHandler: function registerMenuInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterMenuInteractionHandler: function deregisterMenuInteractionHandler() /* type: string, handler: EventListener */{},
        notifyChange: function notifyChange() {},
        getWindowInnerHeight: function getWindowInnerHeight() {
          return (/* number */0
          );
        }
      };
    }
  }]);

  function MDCSelectFoundation(adapter) {
    classCallCheck(this, MDCSelectFoundation);

    var _this = possibleConstructorReturn(this, (MDCSelectFoundation.__proto__ || Object.getPrototypeOf(MDCSelectFoundation)).call(this, _extends(MDCSelectFoundation.defaultAdapter, adapter)));

    _this.ctx_ = null;
    _this.selectedIndex_ = -1;
    _this.disabled_ = false;
    _this.isFocused_ = false;

    /** @private {number} */
    _this.animationRequestId_ = 0;

    _this.displayHandler_ = function (evt) {
      evt.preventDefault();
      if (!_this.adapter_.isMenuOpen()) {
        _this.open_();
      }
    };
    _this.displayViaKeyboardHandler_ = function (evt) {
      return _this.handleDisplayViaKeyboard_(evt);
    };
    _this.selectionHandler_ = function (_ref) {
      var detail = _ref.detail;
      var index = detail.index;


      if (index !== _this.selectedIndex_) {
        _this.setSelectedIndex(index);
        _this.adapter_.notifyChange();
      }
      _this.close_();
    };
    _this.cancelHandler_ = function () {
      _this.close_();
      if (_this.selectedIndex_ === -1) {
        _this.adapter_.floatLabel(false);
      }
    };
    return _this;
  }

  createClass(MDCSelectFoundation, [{
    key: 'init',
    value: function init() {
      this.ctx_ = this.adapter_.create2dRenderingContext();
      this.adapter_.registerInteractionHandler('click', this.displayHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.displayViaKeyboardHandler_);
      this.adapter_.registerInteractionHandler('keyup', this.displayViaKeyboardHandler_);
      this.adapter_.registerMenuInteractionHandler(MDCMenuFoundation.strings.SELECTED_EVENT, this.selectionHandler_);
      this.adapter_.registerMenuInteractionHandler(MDCMenuFoundation.strings.CANCEL_EVENT, this.cancelHandler_);
      this.resize();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      // Drop reference to context object to prevent potential leaks
      this.ctx_ = null;
      cancelAnimationFrame(this.animationRequestId_);
      this.adapter_.deregisterInteractionHandler('click', this.displayHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.displayViaKeyboardHandler_);
      this.adapter_.deregisterInteractionHandler('keyup', this.displayViaKeyboardHandler_);
      this.adapter_.deregisterMenuInteractionHandler(MDCMenuFoundation.strings.SELECTED_EVENT, this.selectionHandler_);
      this.adapter_.deregisterMenuInteractionHandler(MDCMenuFoundation.strings.CANCEL_EVENT, this.cancelHandler_);
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.selectedIndex_ >= 0 ? this.adapter_.getValueForOptionAtIndex(this.selectedIndex_) : '';
    }
  }, {
    key: 'getSelectedIndex',
    value: function getSelectedIndex() {
      return this.selectedIndex_;
    }
  }, {
    key: 'setSelectedIndex',
    value: function setSelectedIndex(index) {
      var prevSelectedIndex = this.selectedIndex_;
      if (prevSelectedIndex >= 0) {
        this.adapter_.rmAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected');
      }

      this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfOptions() ? index : -1;
      var selectedTextContent = '';
      if (this.selectedIndex_ >= 0) {
        selectedTextContent = this.adapter_.getTextForOptionAtIndex(this.selectedIndex_).trim();
        this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
      }
      this.adapter_.setSelectedTextContent(selectedTextContent);
    }
  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.disabled_;
    }
  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      var DISABLED = MDCSelectFoundation.cssClasses.DISABLED;

      this.disabled_ = disabled;
      if (this.disabled_) {
        this.adapter_.addClass(DISABLED);
        this.adapter_.setAttr('aria-disabled', 'true');
        this.adapter_.makeUntabbable();
      } else {
        this.adapter_.removeClass(DISABLED);
        this.adapter_.rmAttr('aria-disabled');
        this.adapter_.makeTabbable();
      }
    }
  }, {
    key: 'resize',
    value: function resize() {
      var font = this.adapter_.getComputedStyleValue('font');
      var letterSpacing = parseFloat(this.adapter_.getComputedStyleValue('letter-spacing'));

      if (font) {
        this.ctx_.font = font;
      } else {
        var primaryFontFamily = this.adapter_.getComputedStyleValue('font-family').split(',')[0];
        var fontSize = this.adapter_.getComputedStyleValue('font-size');
        this.ctx_.font = fontSize + ' ' + primaryFontFamily;
      }

      var maxTextLength = 0;

      for (var i = 0, l = this.adapter_.getNumberOfOptions(); i < l; i++) {
        var surfacePaddingRight = parseInt(this.adapter_.getComputedStyleValue('padding-right'), 10);
        var surfacePaddingLeft = parseInt(this.adapter_.getComputedStyleValue('padding-left'), 10);
        var selectBoxAddedPadding = surfacePaddingRight + surfacePaddingLeft;
        var txt = this.adapter_.getTextForOptionAtIndex(i).trim();

        var _ctx_$measureText = this.ctx_.measureText(txt),
            width = _ctx_$measureText.width;

        var addedSpace = letterSpacing * txt.length;

        maxTextLength = Math.max(maxTextLength, Math.ceil(width + addedSpace + selectBoxAddedPadding));
      }

      this.adapter_.setStyle('width', maxTextLength + 'px');
    }
  }, {
    key: 'open_',
    value: function open_() {
      var _this2 = this;

      this.disableScroll_();
      var OPEN = MDCSelectFoundation.cssClasses.OPEN;

      var focusIndex = this.selectedIndex_ < 0 ? 0 : this.selectedIndex_;

      this.setMenuStylesForOpenAtIndex_(focusIndex);
      this.adapter_.floatLabel(true);
      this.adapter_.addClassToBottomLine(cssClasses$10.BOTTOM_LINE_ACTIVE);
      this.adapter_.addClass(OPEN);
      this.animationRequestId_ = requestAnimationFrame(function () {
        _this2.adapter_.openMenu(focusIndex);
        _this2.isFocused_ = true;
      });
    }
  }, {
    key: 'setMenuStylesForOpenAtIndex_',
    value: function setMenuStylesForOpenAtIndex_(index) {
      var innerHeight = this.adapter_.getWindowInnerHeight();

      var _adapter_$computeBoun = this.adapter_.computeBoundingRect(),
          left = _adapter_$computeBoun.left,
          top = _adapter_$computeBoun.top;

      this.adapter_.setMenuElAttr('aria-hidden', 'true');
      this.adapter_.setMenuElStyle('display', 'block');
      var menuHeight = this.adapter_.getMenuElOffsetHeight();
      var itemOffsetTop = this.adapter_.getOffsetTopForOptionAtIndex(index);
      this.adapter_.setMenuElStyle('display', '');
      this.adapter_.rmMenuElAttr('aria-hidden');

      var adjustedTop = top - itemOffsetTop;
      var overflowsTop = adjustedTop < 0;
      var overflowsBottom = adjustedTop + menuHeight > innerHeight;
      if (overflowsTop) {
        adjustedTop = 0;
      } else if (overflowsBottom) {
        adjustedTop = Math.max(0, innerHeight - menuHeight);
      }

      this.adapter_.setMenuElStyle('left', left + 'px');
      this.adapter_.setMenuElStyle('top', adjustedTop + 'px');
      this.adapter_.setMenuElStyle('transform-origin', 'center ' + itemOffsetTop + 'px');
    }
  }, {
    key: 'close_',
    value: function close_() {
      var OPEN = MDCSelectFoundation.cssClasses.OPEN;

      this.adapter_.removeClass(OPEN);
      this.adapter_.removeClassFromBottomLine(cssClasses$10.BOTTOM_LINE_ACTIVE);
      this.adapter_.focus();
      this.enableScroll_();
    }
  }, {
    key: 'handleDisplayViaKeyboard_',
    value: function handleDisplayViaKeyboard_(evt) {
      // We use a hard-coded 2 instead of Event.AT_TARGET to avoid having to reference a browser
      // global.
      var EVENT_PHASE_AT_TARGET = 2;
      if (evt.eventPhase !== EVENT_PHASE_AT_TARGET) {
        return;
      }

      // Prevent pressing space down from scrolling the page
      var isSpaceDown = evt.type === 'keydown' && (evt.key === 'Space' || evt.keyCode === 32);
      if (isSpaceDown) {
        evt.preventDefault();
      }

      var isOpenerKey = OPENER_KEYS.some(function (_ref2) {
        var key = _ref2.key,
            keyCode = _ref2.keyCode,
            forType = _ref2.forType;

        return evt.type === forType && (evt.key === key || evt.keyCode === keyCode);
      });

      if (isOpenerKey) {
        this.displayHandler_(evt);
      }
    }
  }, {
    key: 'disableScroll_',
    value: function disableScroll_() {
      this.adapter_.addBodyClass(cssClasses$10.SCROLL_LOCK);
    }
  }, {
    key: 'enableScroll_',
    value: function enableScroll_() {
      this.adapter_.removeBodyClass(cssClasses$10.SCROLL_LOCK);
    }
  }]);
  return MDCSelectFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Select Label.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Select label into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCSelectLabelAdapter = function () {
  function MDCSelectLabelAdapter() {
    classCallCheck(this, MDCSelectLabelAdapter);
  }

  createClass(MDCSelectLabelAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the label element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the label element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}
  }]);
  return MDCSelectLabelAdapter;
}();

var cssClasses$11 = {
  LABEL_FLOAT_ABOVE: 'mdc-select__label--float-above'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCSelectLabelAdapter>}
 * @final
 */

var MDCSelectLabelFoundation = function (_MDCFoundation) {
  inherits(MDCSelectLabelFoundation, _MDCFoundation);
  createClass(MDCSelectLabelFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$11;
    }

    /**
     * {@see MDCSelectLabelAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCSelectLabelAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCSelectLabelAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          getWidth: function getWidth() {}
        }
      );
    }

    /**
     * @param {!MDCSelectLabelAdapter} adapter
     */

  }]);

  function MDCSelectLabelFoundation(adapter) {
    classCallCheck(this, MDCSelectLabelFoundation);
    return possibleConstructorReturn(this, (MDCSelectLabelFoundation.__proto__ || Object.getPrototypeOf(MDCSelectLabelFoundation)).call(this, _extends(MDCSelectLabelFoundation.defaultAdapter, adapter)));
  }

  /**
   * Styles the label to float or defloat as necessary.
   * @param {string} value The value of the input.
   * @param {boolean} isFocused Whether the input is focused.
   * @param {boolean} isBadInput The input's `validity.badInput` value.
   */


  createClass(MDCSelectLabelFoundation, [{
    key: 'styleFloat',
    value: function styleFloat(value) {
      var LABEL_FLOAT_ABOVE = MDCSelectLabelFoundation.cssClasses.LABEL_FLOAT_ABOVE;

      if (!!value) {
        this.adapter_.addClass(LABEL_FLOAT_ABOVE);
      } else {
        this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
      }
    }
  }]);
  return MDCSelectLabelFoundation;
}(MDCFoundation);

var MDCMenuSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-select mdc-menu-select", class: _vm.classes, attrs: { "role": "listbox" } }, [_c('div', { ref: "surface", staticClass: "mdc-select__surface", style: _vm.surfaceStyles, attrs: { "tabindex": _vm.tabIndex } }, [_c('div', { ref: "label", staticClass: "mdc-select__label", class: _vm.labelClasses }, [_vm._v(_vm._s(_vm.label))]), _vm._v(" "), _c('div', { ref: "selectedContent", staticClass: "mdc-select__selected-text" }, [_vm._v(_vm._s(_vm.selectedTextContent))]), _vm._v(" "), _c('div', { ref: "bottomLine", staticClass: "mdc-select__bottom-line", class: _vm.bottomLineClasses })]), _vm._v(" "), _c('mdc-menu', { ref: "menu", staticClass: "mdc-select__menu", on: { "update": _vm.refreshIndex } }, [_vm._t("default")], 2)], 1);
  }, staticRenderFns: [],
  name: 'mdc-menu-select',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    multiple: Boolean,
    value: [String, Array],
    disabled: Boolean,
    label: String,
    box: Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-select--box': this.box
      },
      labelClasses: {},
      bottomLineClasses: {},
      surfaceStyles: {},
      tabIndex: 0,
      selectedTextContent: ''
    };
  },

  components: {
    'mdc-menu': mdcMenu
  },
  watch: {
    disabled: function disabled(value) {
      this.foundation && this.foundation.setDisabled(value);
    },
    value: function value() {
      this.refreshIndex();
    },
    box: function box() {
      this.$set(this.classes, 'mdc-select--box', this.box);
    }
  },
  methods: {
    refreshIndex: function refreshIndex() {
      if (this.foundation) {
        var options = this.$refs.menu.items;
        for (var i = 0; i < options.length; i++) {
          var optionValue = options[i].getAttribute('data-value') || options[i].textContent.trim();
          if (this.value == optionValue) {
            this.foundation.setSelectedIndex(i);
            //TODO: MDCFIX force float above if value is valid
            this.$set(this.labelClasses, 'mdc-select__label--float-above', true);
            return;
          }
        }
        //TODO: MDCFIX force float above if value is valid
        this.foundation.setSelectedIndex(-1);
        this.$set(this.labelClasses, 'mdc-select__label--float-above', false);
        this.$emit('change', this.foundation.getValue()); // TODO: MDCFIX
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.labelFoundation = new MDCSelectLabelFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.labelClasses, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.labelClasses, className);
      }
    });

    this.foundation = new MDCSelectFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      floatLabel: function floatLabel(value) {
        _this.labelFoundation.styleFloat(value);
      },
      addClassToBottomLine: function addClassToBottomLine(className) {
        return _this.$set(_this.bottomLineClasses, className, true);
      },
      removeClassFromBottomLine: function removeClassFromBottomLine(className) {
        return _this.$delete(_this.bottomLineClasses, className);
      },
      setBottomLineAttr: function setBottomLineAttr(attr, value) {
        return _this.$refs.bottomLine.setAttribute(attr, value);
      },
      setAttr: function setAttr(attr, value) {
        return _this.$el.setAttribute(attr, value);
      },
      rmAttr: function rmAttr(attr, value) {
        return _this.$el.removeAttribute(attr, value);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this.$refs.surface.getBoundingClientRect();
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$refs.surface.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$refs.surface.removeEventListener(type, handler);
      },
      focus: function focus() {
        return _this.$refs.surface.focus();
      },
      makeTabbable: function makeTabbable() {
        _this.tabIndex = 0;
      },
      makeUntabbable: function makeUntabbable() {
        _this.tabIndex = -1;
      },
      getComputedStyleValue: function getComputedStyleValue(prop) {
        return window.getComputedStyle(_this.$refs.surface).getPropertyValue(prop);
      },
      setStyle: function setStyle(propertyName, value) {
        return _this.$set(_this.surfaceStyles, propertyName, value);
      },
      create2dRenderingContext: function create2dRenderingContext() {
        return document.createElement('canvas').getContext('2d');
      },
      setMenuElStyle: function setMenuElStyle(propertyName, value) {
        return _this.$refs.menu.$el.style[propertyName] = value;
      },
      setMenuElAttr: function setMenuElAttr(attr, value) {
        return _this.$refs.menu.$el.setAttribute(attr, value);
      },
      rmMenuElAttr: function rmMenuElAttr(attr) {
        return _this.$refs.menu.$el.removeAttribute(attr);
      },
      getMenuElOffsetHeight: function getMenuElOffsetHeight() {
        return _this.$refs.menu.$el.offsetHeight;
      },
      openMenu: function openMenu(focusIndex) {
        return _this.$refs.menu.show({ focusIndex: focusIndex });
      },
      isMenuOpen: function isMenuOpen() {
        return _this.$refs.menu.isOpen();
      },
      setSelectedTextContent: function setSelectedTextContent(selectedTextContent) {
        _this.selectedTextContent = selectedTextContent;
      },
      getNumberOfOptions: function getNumberOfOptions() {
        return _this.$refs.menu.items.length;
      },
      getTextForOptionAtIndex: function getTextForOptionAtIndex(index) {
        return _this.$refs.menu.items[index].textContent.trim();
      },
      getValueForOptionAtIndex: function getValueForOptionAtIndex(index) {
        return _this.$refs.menu.items[index].getAttribute('data-value') || _this.$refs.menu.items[index].textContent.trim();
      },
      setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
        return _this.$refs.menu.items[index].setAttribute(attr, value);
      },
      rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
        return _this.$refs.menu.items[index].removeAttribute(attr);
      },
      getOffsetTopForOptionAtIndex: function getOffsetTopForOptionAtIndex(index) {
        return _this.$refs.menu.items[index].offsetTop;
      },
      registerMenuInteractionHandler: function registerMenuInteractionHandler(type, handler) {
        return _this.$refs.menu.$el.addEventListener(type, handler);
      },
      deregisterMenuInteractionHandler: function deregisterMenuInteractionHandler(type, handler) {
        return _this.$refs.menu.$el.removeEventListener(type, handler);
      },
      notifyChange: function notifyChange() {
        _this.$emit('change', _this.foundation.getValue());
      },
      getWindowInnerHeight: function getWindowInnerHeight() {
        return window.innerHeight;
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      }
    });

    //TODO: MDCFIX
    var foundation = this.foundation;
    foundation.resize = function () {

      var font = foundation.adapter_.getComputedStyleValue('font');
      var letterSpacing = parseFloat(foundation.adapter_.getComputedStyleValue('letter-spacing'));

      if (font) {
        foundation.ctx_.font = font;
      } else {
        var primaryFontFamily = foundation.adapter_.getComputedStyleValue('font-family').split(',')[0];
        var fontSize = foundation.adapter_.getComputedStyleValue('font-size');
        foundation.ctx_.font = fontSize + ' ' + primaryFontFamily;
      }

      var maxTextLength = 0;

      var surfacePaddingRight = parseInt(foundation.adapter_.getComputedStyleValue('padding-right'), 10);
      var surfacePaddingLeft = parseInt(foundation.adapter_.getComputedStyleValue('padding-left'), 10);
      var selectBoxAddedPadding = surfacePaddingRight + surfacePaddingLeft;

      for (var i = 0, l = foundation.adapter_.getNumberOfOptions(); i < l; i++) {
        var txt = foundation.adapter_.getTextForOptionAtIndex(i).trim();

        var _foundation$ctx_$meas = foundation.ctx_.measureText(txt),
            _width = _foundation$ctx_$meas.width;

        var _addedSpace = letterSpacing * txt.length;

        maxTextLength = Math.max(maxTextLength, Math.ceil(_width + _addedSpace + selectBoxAddedPadding));
      }

      var labelTxt = _this.label;

      var _foundation$ctx_$meas2 = foundation.ctx_.measureText(labelTxt),
          width = _foundation$ctx_$meas2.width;

      var addedSpace = letterSpacing * labelTxt.length;

      maxTextLength = Math.max(maxTextLength, Math.ceil(width + addedSpace + selectBoxAddedPadding));

      foundation.adapter_.setStyle('width', maxTextLength + 'px');
    };
    /// 
    this.labelFoundation.init();
    this.foundation.init();
    this.foundation.setDisabled(this.disabled);
    this.refreshIndex();
    if (this.value !== this.foundation.getValue()) {
      this.$emit('change', this.foundation.getValue());
    }
  },
  beforeDestroy: function beforeDestroy() {
    var foundation = this.foundation;
    this.foundation = null;
    foundation.destroy();

    var foundationLabel = this.foundationLabel;
    this.foundationLabel = null;
    foundationLabel.destroy();
  }
};

var MDCMultiSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('select', { directives: [{ name: "model", rawName: "v-model", value: _vm.selected, expression: "selected" }], ref: "root", staticClass: "mdc-select mdc-multi-select mdc-list", style: _vm.styles, attrs: { "multiple": _vm.multiple, "disabled": _vm.disabled }, on: { "change": [function ($event) {
          var $$selectedVal = Array.prototype.filter.call($event.target.options, function (o) {
            return o.selected;
          }).map(function (o) {
            var val = "_value" in o ? o._value : o.value;return val;
          });_vm.selected = $event.target.multiple ? $$selectedVal : $$selectedVal[0];
        }, _vm.onChange] } }, [_vm.label ? _c('optgroup', { ref: "optgroup", staticClass: "mdc-list-group", attrs: { "label": _vm.label } }, [_vm._t("default")], 2) : _vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-multi-select',
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    multiple: Boolean,
    value: [String, Array],
    disabled: Boolean,
    label: String,
    maxSize: {
      type: [String, Number],
      default: 4
    }
  },
  data: function data() {
    return {
      selected: this.value,
      size: undefined,
      count: undefined
    };
  },

  computed: {
    styles: function styles() {
      var scroll = this.count > this.size;
      var size = 48 * this.size + (scroll ? 0 : 16);

      var styles = {
        'height': size + 'px',
        'overflow-y': scroll ? 'scroll' : 'hidden'
      };
      if (!scroll) {
        styles['background-image'] = 'unset';
      }
      return styles;
    }
  },
  methods: {
    onChange: function onChange() {
      this.$emit('change', this.selected);
    }
  },
  mounted: function mounted() {
    var _this = this;

    var refreshSize = function refreshSize() {
      var count = _this.$refs.root.querySelectorAll('option, optgroup').length;
      _this.count = count;
      var max = Number(_this.maxSize);
      if (_this.label) {
        max += 1;
      }
      _this.size = Math.min(count, max);
    };

    this.slotObserver = new MutationObserver(function () {
      return refreshSize();
    });
    this.slotObserver.observe(this.$el, { childList: true, subtree: true });

    refreshSize();
  },
  beforeDestroy: function beforeDestroy() {
    this.slotObserver.disconnect();
  }
};

var media$1 = new (function () {
  function _class() {
    classCallCheck(this, _class);
  }

  createClass(_class, [{
    key: 'mobile',
    get: function get$$1() {
      return this._mobile || (this._mobile = window.matchMedia('(max-width: 600px) and (pointer: coarse)'));
    }
  }]);
  return _class;
}())();

var mdcSelect = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, _vm._b({ tag: "component", attrs: { "multiple": _vm.multiple, "label": _vm.label, "value": _vm.value }, on: { "change": _vm.onChange } }, 'component', _vm.$attrs, false), [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-select',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    multiple: Boolean,
    value: [String, Array],
    label: String,
    native: Boolean
  },
  provide: function provide() {
    return { mdcSelect: this };
  },

  components: {
    'mdc-native-select': MDCNativeSelect,
    'mdc-menu-select': MDCMenuSelect,
    'mdc-multi-select': MDCMultiSelect
  },
  data: function data() {
    return {
      mobile: window ? media$1.mobile.matches : true
    };
  },

  computed: {
    type: function type() {
      return this.multiple ? 'mdc-multi-select' : this.menu ? 'mdc-menu-select' : this.isNative ? 'mdc-native-select' : 'mdc-menu-select';
    },
    isNative: function isNative() {
      return this.native || this.multiple || this.mobile;
    }
  },
  methods: {
    onChange: function onChange(value) {
      this.$emit('change', value);
    },
    refreshMedia: function refreshMedia() {
      this.mobile = media$1.mobile.matches;
    }
  },
  beforeMount: function beforeMount() {
    media$1.mobile.addListener(this.refreshMedia);
    this.refreshMedia();
  },
  beforeDestroy: function beforeDestroy() {
    media$1.mobile.removeListener(this.refreshMedia);
  }
};

var MDCNativeOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.hasValue ? _c('option', { staticClass: "mdc-option mdc-native-option", attrs: { "disabled": _vm.disabled }, domProps: { "value": _vm.value } }, [_vm._t("default")], 2) : _c('option', { staticClass: "mdc-option mdc-native-option", attrs: { "disabled": _vm.disabled } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-native-option',
  props: {
    value: String,
    disabled: Boolean
  },
  computed: {
    hasValue: function hasValue() {
      return !(typeof this.value === 'undefined');
    }
  }
};

var MDCMenuOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-option mdc-menu-option mdc-list-item", attrs: { "role": "option", "tabindex": _vm.disabled ? -1 : 0, "aria-disabled": _vm.disabled, "data-value": _vm.value } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-menu-option',
  props: {
    value: String,
    disabled: Boolean
  }
};

var MDCMultiOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.hasValue ? _c('option', { staticClass: "mdc-option mdc-multi-option mdc-list-item", attrs: { "disabled": _vm.disabled }, domProps: { "value": _vm.value } }, [_vm._t("default")], 2) : _c('option', { staticClass: "mdc-option mdc-multi-option mdc-list-item", attrs: { "disabled": _vm.disabled } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-multi-option',
  props: {
    value: String,
    disabled: Boolean
  },
  computed: {
    hasValue: function hasValue() {
      return !(typeof this.value === 'undefined');
    }
  }
};

var mdcOption = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { tag: "component", attrs: { "disabled": _vm.disabled, "value": _vm.value } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-option',
  props: {
    value: String,
    disabled: Boolean
  },
  inject: ['mdcSelect'],
  components: {
    'mdc-native-option': MDCNativeOption,
    'mdc-multi-option': MDCMultiOption,
    'mdc-menu-option': MDCMenuOption
  },
  computed: {
    isNative: function isNative() {
      return this.mdcSelect.isNative;
    },
    multiple: function multiple() {
      return this.mdcSelect.multiple;
    },
    type: function type() {
      return this.multiple ? 'mdc-multi-option' : this.isNative ? 'mdc-native-option' : 'mdc-menu-option';
    }
  }
};

var VueMDCSelect = BasePlugin({
  mdcSelect: mdcSelect,
  mdcOption: mdcOption
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$12 = {
  ACTIVE: 'mdc-slider--active',
  DISABLED: 'mdc-slider--disabled',
  DISCRETE: 'mdc-slider--discrete',
  FOCUS: 'mdc-slider--focus',
  IN_TRANSIT: 'mdc-slider--in-transit',
  IS_DISCRETE: 'mdc-slider--discrete',
  HAS_TRACK_MARKER: 'mdc-slider--display-markers'
};

/** @enum {string} */
var strings$14 = {
  TRACK_SELECTOR: '.mdc-slider__track',
  TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
  LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
  THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
  PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
  ARIA_VALUEMIN: 'aria-valuemin',
  ARIA_VALUEMAX: 'aria-valuemax',
  ARIA_VALUENOW: 'aria-valuenow',
  ARIA_DISABLED: 'aria-disabled',
  STEP_DATA_ATTR: 'data-step',
  CHANGE_EVENT: 'MDCSlider:change',
  INPUT_EVENT: 'MDCSlider:input'
};

/** @enum {number} */
var numbers$3 = {
  PAGE_FACTOR: 4
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */

/**
 * Adapter for MDC Slider.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Slider into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCSliderAdapter = function () {
  function MDCSliderAdapter() {
    classCallCheck(this, MDCSliderAdapter);
  }

  createClass(MDCSliderAdapter, [{
    key: "hasClass",

    /**
     * Returns true if className exists for the slider Element
     * @param {string} className
     * @return {boolean}
     */
    value: function hasClass(className) {}

    /**
     * Adds a class to the slider Element
     * @param {string} className
     */

  }, {
    key: "addClass",
    value: function addClass(className) {}

    /**
     * Removes a class from the slider Element
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns a string if attribute name exists on the slider Element,
     * otherwise returns null
     * @param {string} name
     * @return {?string}
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(name) {}

    /**
     * Sets attribute name on slider Element to value
     * @param {string} name
     * @param {string} value
     */

  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {}

    /**
     * Removes attribute name from slider Element
     * @param {string} name
     */

  }, {
    key: "removeAttribute",
    value: function removeAttribute(name) {}

    /**
     * Returns the bounding client rect for the slider Element
     * @return {?ClientRect}
     */

  }, {
    key: "computeBoundingRect",
    value: function computeBoundingRect() {}

    /**
     * Returns the tab index of the slider Element
     * @return {number}
     */

  }, {
    key: "getTabIndex",
    value: function getTabIndex() {}

    /**
     * Registers an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(type, handler) {}

    /**
     * Registers an event handler on the thumb container element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerThumbContainerInteractionHandler",
    value: function registerThumbContainerInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the thumb container element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterThumbContainerInteractionHandler",
    value: function deregisterThumbContainerInteractionHandler(type, handler) {}

    /**
     * Registers an event handler on the body for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerBodyInteractionHandler",
    value: function registerBodyInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the body for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterBodyInteractionHandler",
    value: function deregisterBodyInteractionHandler(type, handler) {}

    /**
     * Registers an event handler for the window resize event
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerResizeHandler",
    value: function registerResizeHandler(handler) {}

    /**
     * Deregisters an event handler for the window resize event
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterResizeHandler",
    value: function deregisterResizeHandler(handler) {}

    /**
     * Emits a custom event MDCSlider:input from the root
     */

  }, {
    key: "notifyInput",
    value: function notifyInput() {}

    /**
     * Emits a custom event MDCSlider:change from the root
     */

  }, {
    key: "notifyChange",
    value: function notifyChange() {}

    /**
     * Sets a style property of the thumb container element to the passed value
     * @param {string} propertyName
     * @param {string} value
     */

  }, {
    key: "setThumbContainerStyleProperty",
    value: function setThumbContainerStyleProperty(propertyName, value) {}

    /**
     * Sets a style property of the track element to the passed value
     * @param {string} propertyName
     * @param {string} value
     */

  }, {
    key: "setTrackStyleProperty",
    value: function setTrackStyleProperty(propertyName, value) {}

    /**
     * Sets the inner text of the pin marker to the passed value
     * @param {number} value
     */

  }, {
    key: "setMarkerValue",
    value: function setMarkerValue(value) {}

    /**
     * Appends the passed number of track markers to the track mark container element
     * @param {number} numMarkers
     */

  }, {
    key: "appendTrackMarkers",
    value: function appendTrackMarkers(numMarkers) {}

    /**
     * Removes all track markers fromt he track mark container element
     */

  }, {
    key: "removeTrackMarkers",
    value: function removeTrackMarkers() {}

    /**
     * Sets a style property of the last track marker to the passed value
     * @param {string} propertyName
     * @param {string} value
     */

  }, {
    key: "setLastTrackMarkersStyleProperty",
    value: function setLastTrackMarkersStyleProperty(propertyName, value) {}

    /**
     * Returns true if the root element is RTL, otherwise false
     * @return {boolean}
     */

  }, {
    key: "isRTL",
    value: function isRTL() {}
  }]);
  return MDCSliderAdapter;
}();

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var KEY_IDS = {
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  HOME: 'Home',
  END: 'End',
  PAGE_UP: 'PageUp',
  PAGE_DOWN: 'PageDown'
};

/** @enum {string} */
var MOVE_EVENT_MAP = {
  'mousedown': 'mousemove',
  'touchstart': 'touchmove',
  'pointerdown': 'pointermove'
};

var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];

/**
 * @extends {MDCFoundation<!MDCSliderAdapter>}
 */

var MDCSliderFoundation = function (_MDCFoundation) {
  inherits(MDCSliderFoundation, _MDCFoundation);
  createClass(MDCSliderFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {cssClasses} */
    get: function get$$1() {
      return cssClasses$12;
    }

    /** @return enum {strings} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$14;
    }

    /** @return enum {numbers} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$3;
    }

    /** @return {!MDCSliderAdapter} */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCSliderAdapter} */{
          hasClass: function hasClass() {
            return (/* className: string */ /* boolean */false
            );
          },
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          getAttribute: function getAttribute() {
            return (/* name: string */ /* string|null */null
            );
          },
          setAttribute: function setAttribute() /* name: string, value: string */{},
          removeAttribute: function removeAttribute() /* name: string */{},
          computeBoundingRect: function computeBoundingRect() {
            return (/* ClientRect */{
                top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0
              }
            );
          },
          getTabIndex: function getTabIndex() {
            return (/* number */0
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
          registerBodyInteractionHandler: function registerBodyInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() /* type: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          notifyInput: function notifyInput() {},
          notifyChange: function notifyChange() {},
          setThumbContainerStyleProperty: function setThumbContainerStyleProperty() /* propertyName: string, value: string */{},
          setTrackStyleProperty: function setTrackStyleProperty() /* propertyName: string, value: string */{},
          setMarkerValue: function setMarkerValue() /* value: number */{},
          appendTrackMarkers: function appendTrackMarkers() /* numMarkers: number */{},
          removeTrackMarkers: function removeTrackMarkers() {},
          setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty() /* propertyName: string, value: string */{},
          isRTL: function isRTL() {
            return (/* boolean */false
            );
          }
        }
      );
    }

    /**
     * Creates a new instance of MDCSliderFoundation
     * @param {?MDCSliderAdapter} adapter
     */

  }]);

  function MDCSliderFoundation(adapter) {
    classCallCheck(this, MDCSliderFoundation);

    /** @private {?ClientRect} */
    var _this = possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));

    _this.rect_ = null;
    // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
    // because those could be valid tabindices set by the client code.
    _this.savedTabIndex_ = NaN;
    _this.active_ = false;
    _this.inTransit_ = false;
    _this.isDiscrete_ = false;
    _this.hasTrackMarker_ = false;
    _this.handlingThumbTargetEvt_ = false;
    _this.min_ = 0;
    _this.max_ = 100;
    _this.step_ = 0;
    _this.value_ = 0;
    _this.disabled_ = false;
    _this.preventFocusState_ = false;
    _this.updateUIFrame_ = 0;
    _this.thumbContainerPointerHandler_ = function () {
      _this.handlingThumbTargetEvt_ = true;
    };
    _this.interactionStartHandler_ = function (evt) {
      return _this.handleDown_(evt);
    };
    _this.keydownHandler_ = function (evt) {
      return _this.handleKeydown_(evt);
    };
    _this.focusHandler_ = function () {
      return _this.handleFocus_();
    };
    _this.blurHandler_ = function () {
      return _this.handleBlur_();
    };
    _this.resizeHandler_ = function () {
      return _this.layout();
    };
    return _this;
  }

  createClass(MDCSliderFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this.isDiscrete_ = this.adapter_.hasClass(cssClasses$12.IS_DISCRETE);
      this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$12.HAS_TRACK_MARKER);
      DOWN_EVENTS.forEach(function (evtName) {
        return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
      });
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
      this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      DOWN_EVENTS.forEach(function (evtName) {
        _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
      });
      this.adapter_.registerResizeHandler(this.resizeHandler_);
      this.layout();
      // At last step, provide a reasonable default value to discrete slider
      if (this.isDiscrete_ && this.getStep() == 0) {
        this.step_ = 1;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      DOWN_EVENTS.forEach(function (evtName) {
        _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
      });
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
      this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
      DOWN_EVENTS.forEach(function (evtName) {
        _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
      });
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'setupTrackMarker',
    value: function setupTrackMarker() {
      if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
        var min = this.getMin();
        var max = this.getMax();
        var step = this.getStep();
        var numMarkers = (max - min) / step;

        // In case distance between max & min is indivisible to step,
        // we place the secondary to last marker proportionally at where thumb
        // could reach and place the last marker at max value
        var indivisible = Math.ceil(numMarkers) !== numMarkers;
        if (indivisible) {
          numMarkers = Math.ceil(numMarkers);
        }

        this.adapter_.removeTrackMarkers();
        this.adapter_.appendTrackMarkers(numMarkers);

        if (indivisible) {
          var lastStepRatio = (max - numMarkers * step) / step + 1;
          var flex = getCorrectPropertyName(window, 'flex');
          this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
        }
      }
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.rect_ = this.adapter_.computeBoundingRect();
      this.updateUIForCurrentValue_();
    }

    /** @return {number} */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.value_;
    }

    /** @param {number} value */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.setValue_(value, false);
    }

    /** @return {number} */

  }, {
    key: 'getMax',
    value: function getMax() {
      return this.max_;
    }

    /** @param {number} max */

  }, {
    key: 'setMax',
    value: function setMax(max) {
      if (max < this.min_) {
        throw new Error('Cannot set max to be less than the slider\'s minimum value');
      }
      this.max_ = max;
      this.setValue_(this.value_, false, true);
      this.adapter_.setAttribute(strings$14.ARIA_VALUEMAX, String(this.max_));
      this.setupTrackMarker();
    }

    /** @return {number} */

  }, {
    key: 'getMin',
    value: function getMin() {
      return this.min_;
    }

    /** @param {number} min */

  }, {
    key: 'setMin',
    value: function setMin(min) {
      if (min > this.max_) {
        throw new Error('Cannot set min to be greater than the slider\'s maximum value');
      }
      this.min_ = min;
      this.setValue_(this.value_, false, true);
      this.adapter_.setAttribute(strings$14.ARIA_VALUEMIN, String(this.min_));
      this.setupTrackMarker();
    }

    /** @return {number} */

  }, {
    key: 'getStep',
    value: function getStep() {
      return this.step_;
    }

    /** @param {number} step */

  }, {
    key: 'setStep',
    value: function setStep(step) {
      if (step < 0) {
        throw new Error('Step cannot be set to a negative number');
      }
      if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
        step = 1;
      }
      this.step_ = step;
      this.setValue_(this.value_, false, true);
      this.setupTrackMarker();
    }

    /** @return {boolean} */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.disabled_;
    }

    /** @param {boolean} disabled */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      this.disabled_ = disabled;
      this.toggleClass_(cssClasses$12.DISABLED, this.disabled_);
      if (this.disabled_) {
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.setAttribute(strings$14.ARIA_DISABLED, 'true');
        this.adapter_.removeAttribute('tabindex');
      } else {
        this.adapter_.removeAttribute(strings$14.ARIA_DISABLED);
        if (!isNaN(this.savedTabIndex_)) {
          this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
        }
      }
    }

    /**
     * Called when the user starts interacting with the slider
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handleDown_',
    value: function handleDown_(evt) {
      var _this4 = this;

      if (this.disabled_) {
        return;
      }

      this.preventFocusState_ = true;
      this.setInTransit_(!this.handlingThumbTargetEvt_);
      this.handlingThumbTargetEvt_ = false;
      this.setActive_(true);

      var moveHandler = function moveHandler(evt) {
        _this4.handleMove_(evt);
      };

      // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
      // do not always fire these consistently in pairs.
      // (See https://github.com/material-components/material-components-web/issues/1192)
      var upHandler = function upHandler() {
        _this4.handleUp_();
        _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
        });
      };

      this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
      UP_EVENTS.forEach(function (evtName) {
        return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
      });
      this.setValueFromEvt_(evt);
    }

    /**
     * Called when the user moves the slider
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'handleMove_',
    value: function handleMove_(evt) {
      evt.preventDefault();
      this.setValueFromEvt_(evt);
    }

    /**
     * Called when the user's interaction with the slider ends
     * @private
     */

  }, {
    key: 'handleUp_',
    value: function handleUp_() {
      this.setActive_(false);
      this.adapter_.notifyChange();
    }

    /**
     * Returns the pageX of the event
     * @param {!Event} evt
     * @return {number}
     * @private
     */

  }, {
    key: 'getPageX_',
    value: function getPageX_(evt) {
      if (evt.targetTouches && evt.targetTouches.length > 0) {
        return evt.targetTouches[0].pageX;
      }
      return evt.pageX;
    }

    /**
     * Sets the slider value from an event
     * @param {!Event} evt
     * @private
     */

  }, {
    key: 'setValueFromEvt_',
    value: function setValueFromEvt_(evt) {
      var pageX = this.getPageX_(evt);
      var value = this.computeValueFromPageX_(pageX);
      this.setValue_(value, true);
    }

    /**
     * Computes the new value from the pageX position
     * @param {number} pageX
     * @return {number}
     */

  }, {
    key: 'computeValueFromPageX_',
    value: function computeValueFromPageX_(pageX) {
      var max = this.max_,
          min = this.min_;

      var xPos = pageX - this.rect_.left;
      var pctComplete = xPos / this.rect_.width;
      if (this.adapter_.isRTL()) {
        pctComplete = 1 - pctComplete;
      }
      // Fit the percentage complete between the range [min,max]
      // by remapping from [0, 1] to [min, min+(max-min)].
      return min + pctComplete * (max - min);
    }

    /**
     * Handles keydown events
     * @param {!Event} evt
     */

  }, {
    key: 'handleKeydown_',
    value: function handleKeydown_(evt) {
      var keyId = this.getKeyId_(evt);
      var value = this.getValueForKeyId_(keyId);
      if (isNaN(value)) {
        return;
      }

      // Prevent page from scrolling due to key presses that would normally scroll the page
      evt.preventDefault();
      this.adapter_.addClass(cssClasses$12.FOCUS);
      this.setValue_(value, true);
      this.adapter_.notifyChange();
    }

    /**
     * Returns the computed name of the event
     * @param {!Event} kbdEvt
     * @return {string}
     */

  }, {
    key: 'getKeyId_',
    value: function getKeyId_(kbdEvt) {
      if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
        return KEY_IDS.ARROW_LEFT;
      }
      if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
        return KEY_IDS.ARROW_RIGHT;
      }
      if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
        return KEY_IDS.ARROW_UP;
      }
      if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
        return KEY_IDS.ARROW_DOWN;
      }
      if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
        return KEY_IDS.HOME;
      }
      if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
        return KEY_IDS.END;
      }
      if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
        return KEY_IDS.PAGE_UP;
      }
      if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
        return KEY_IDS.PAGE_DOWN;
      }

      return '';
    }

    /**
     * Computes the value given a keyboard key ID
     * @param {string} keyId
     * @return {number}
     */

  }, {
    key: 'getValueForKeyId_',
    value: function getValueForKeyId_(keyId) {
      var max = this.max_,
          min = this.min_,
          step = this.step_;

      var delta = step || (max - min) / 100;
      var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
      if (valueNeedsToBeFlipped) {
        delta = -delta;
      }

      switch (keyId) {
        case KEY_IDS.ARROW_LEFT:
        case KEY_IDS.ARROW_DOWN:
          return this.value_ - delta;
        case KEY_IDS.ARROW_RIGHT:
        case KEY_IDS.ARROW_UP:
          return this.value_ + delta;
        case KEY_IDS.HOME:
          return this.min_;
        case KEY_IDS.END:
          return this.max_;
        case KEY_IDS.PAGE_UP:
          return this.value_ + delta * numbers$3.PAGE_FACTOR;
        case KEY_IDS.PAGE_DOWN:
          return this.value_ - delta * numbers$3.PAGE_FACTOR;
        default:
          return NaN;
      }
    }
  }, {
    key: 'handleFocus_',
    value: function handleFocus_() {
      if (this.preventFocusState_) {
        return;
      }
      this.adapter_.addClass(cssClasses$12.FOCUS);
    }
  }, {
    key: 'handleBlur_',
    value: function handleBlur_() {
      this.preventFocusState_ = false;
      this.adapter_.removeClass(cssClasses$12.FOCUS);
    }

    /**
     * Sets the value of the slider
     * @param {number} value
     * @param {boolean} shouldFireInput
     * @param {boolean=} force
     */

  }, {
    key: 'setValue_',
    value: function setValue_(value, shouldFireInput) {
      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (value === this.value_ && !force) {
        return;
      }

      var min = this.min_,
          max = this.max_;

      var valueSetToBoundary = value === min || value === max;
      if (this.step_ && !valueSetToBoundary) {
        value = this.quantize_(value);
      }
      if (value < min) {
        value = min;
      } else if (value > max) {
        value = max;
      }
      this.value_ = value;
      this.adapter_.setAttribute(strings$14.ARIA_VALUENOW, String(this.value_));
      this.updateUIForCurrentValue_();

      if (shouldFireInput) {
        this.adapter_.notifyInput();
        if (this.isDiscrete_) {
          this.adapter_.setMarkerValue(value);
        }
      }
    }

    /**
     * Calculates the quantized value
     * @param {number} value
     * @return {number}
     */

  }, {
    key: 'quantize_',
    value: function quantize_(value) {
      var numSteps = Math.round(value / this.step_);
      var quantizedVal = numSteps * this.step_;
      return quantizedVal;
    }
  }, {
    key: 'updateUIForCurrentValue_',
    value: function updateUIForCurrentValue_() {
      var _this5 = this;

      var max = this.max_,
          min = this.min_,
          value = this.value_;

      var pctComplete = (value - min) / (max - min);
      var translatePx = pctComplete * this.rect_.width;
      if (this.adapter_.isRTL()) {
        translatePx = this.rect_.width - translatePx;
      }

      var transformProp = getCorrectPropertyName(window, 'transform');
      var transitionendEvtName = getCorrectEventName(window, 'transitionend');

      if (this.inTransit_) {
        var onTransitionEnd = function onTransitionEnd() {
          _this5.setInTransit_(false);
          _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        };
        this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
      }

      this.updateUIFrame_ = requestAnimationFrame(function () {
        // NOTE(traviskaufman): It would be nice to use calc() here,
        // but IE cannot handle calcs in transforms correctly.
        // See: https://goo.gl/NC2itk
        // Also note that the -50% offset is used to center the slider thumb.
        _this5.adapter_.setThumbContainerStyleProperty(transformProp, 'translateX(' + translatePx + 'px) translateX(-50%)');
        _this5.adapter_.setTrackStyleProperty(transformProp, 'scaleX(' + pctComplete + ')');
      });
    }

    /**
     * Toggles the active state of the slider
     * @param {boolean} active
     */

  }, {
    key: 'setActive_',
    value: function setActive_(active) {
      this.active_ = active;
      this.toggleClass_(cssClasses$12.ACTIVE, this.active_);
    }

    /**
     * Toggles the inTransit state of the slider
     * @param {boolean} inTransit
     */

  }, {
    key: 'setInTransit_',
    value: function setInTransit_(inTransit) {
      this.inTransit_ = inTransit;
      this.toggleClass_(cssClasses$12.IN_TRANSIT, this.inTransit_);
    }

    /**
     * Conditionally adds or removes a class based on shouldBePresent
     * @param {string} className
     * @param {boolean} shouldBePresent
     */

  }, {
    key: 'toggleClass_',
    value: function toggleClass_(className, shouldBePresent) {
      if (shouldBePresent) {
        this.adapter_.addClass(className);
      } else {
        this.adapter_.removeClass(className);
      }
    }
  }]);
  return MDCSliderFoundation;
}(MDCFoundation);

var mdcSlider = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-slider", class: _vm.classes, attrs: { "tabindex": "0", "role": "slider" } }, [_c('div', { staticClass: "mdc-slider__track-container" }, [_c('div', { staticClass: "mdc-slider__track", style: _vm.trackStyles }), _vm._v(" "), _vm.hasMarkers ? _c('div', { staticClass: "mdc-slider__track-marker-container" }, _vm._l(_vm.numMarkers, function (markerNum) {
      return _c('div', { key: markerNum, staticClass: "mdc-slider__track-marker", style: markerNum == _vm.numMarkers ? _vm.lastTrackMarkersStyles : {} });
    })) : _vm._e()]), _vm._v(" "), _c('div', { ref: "thumbContainer", staticClass: "mdc-slider__thumb-container", style: _vm.thumbStyles }, [_vm.isDiscrete ? _c('div', { staticClass: "mdc-slider__pin" }, [_c('span', { staticClass: "mdc-slider__pin-value-marker" }, [_vm._v(_vm._s(_vm.markerValue))])]) : _vm._e(), _vm._v(" "), _c('svg', { staticClass: "mdc-slider__thumb", attrs: { "width": "21", "height": "21" } }, [_c('circle', { attrs: { "cx": "10.5", "cy": "10.5", "r": "7.875" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-slider__focus-ring" })])]);
  }, staticRenderFns: [],
  name: 'mdc-slider',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: [Number, String],
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String], default: 0 },
    displayMarkers: Boolean,
    disabled: Boolean,
    layoutOn: String,
    layoutOnSource: { type: Object, required: false }
  },
  data: function data() {
    return {
      classes: {
        'mdc-slider--discrete': !!this.step,
        'mdc-slider--display-markers': this.displayMarkers
      },
      trackStyles: {},
      lastTrackMarkersStyles: {},
      thumbStyles: {},
      markerValue: '',
      numMarkers: 0
    };
  },

  computed: {
    isDiscrete: function isDiscrete() {
      return !!this.step;
    },
    hasMarkers: function hasMarkers() {
      return !!this.step && this.displayMarkers && this.numMarkers;
    }
  },
  watch: {
    value: function value() {
      if (this.foundation.getValue() !== Number(this.value)) {
        this.foundation.setValue(this.value);
      }
    },
    min: function min() {
      this.foundation.setMin(Number(this.min));
    },
    max: function max() {
      this.foundation.setMax(Number(this.max));
    },
    step: function step() {
      this.foundation.setStep(Number(this.step));
    },
    disabled: function disabled() {
      this.foundation.setDisabled(this.disabled);
    }
  },
  methods: {
    layout: function layout() {
      var _this = this;

      this.$nextTick(function () {
        _this.foundation && _this.foundation.layout();
      });
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.foundation = new MDCSliderFoundation({
      hasClass: function hasClass(className) {
        return _this2.$el.classList.contains(className);
      },
      addClass: function addClass(className) {
        _this2.$set(_this2.classes, className, true);
      },
      removeClass: function removeClass(className) {
        _this2.$delete(_this2.classes, className, true);
      },
      getAttribute: function getAttribute(name) {
        return _this2.$el.getAttribute(name);
      },
      setAttribute: function setAttribute(name, value) {
        return _this2.$el.setAttribute(name, value);
      },
      removeAttribute: function removeAttribute(name) {
        return _this2.$el.removeAttribute(name);
      },
      computeBoundingRect: function computeBoundingRect() {
        return _this2.$el.getBoundingClientRect();
      },
      getTabIndex: function getTabIndex() {
        return _this2.$el.tabIndex;
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        _this2.$el.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        _this2.$el.removeEventListener(type, handler);
      },
      registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
        _this2.$refs.thumbContainer.addEventListener(type, handler);
      },
      deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
        _this2.$refs.thumbContainer.removeEventListener(type, handler);
      },
      registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
        document.body.addEventListener(type, handler);
      },
      deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
        document.body.removeEventListener(type, handler);
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        window.removeEventListener('resize', handler);
      },
      notifyInput: function notifyInput() {
        _this2.$emit('input', _this2.foundation.getValue());
      },
      notifyChange: function notifyChange() {
        _this2.$emit('change', _this2.foundation.getValue());
      },
      setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
        _this2.$set(_this2.thumbStyles, propertyName, value);
      },
      setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
        _this2.$set(_this2.trackStyles, propertyName, value);
      },
      setMarkerValue: function setMarkerValue(value) {
        _this2.markerValue = value;
      },
      appendTrackMarkers: function appendTrackMarkers(numMarkers) {
        _this2.numMarkers = numMarkers;
      },
      removeTrackMarkers: function removeTrackMarkers() {
        _this2.numMarkers = 0;
      },
      setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
        _this2.$set(_this2.lastTrackMarkersStyles, propertyName, value);
      },
      isRTL: function isRTL() {
        return false;
      }
    });

    this.foundation.init();
    this.foundation.setDisabled(this.disabled);
    this.foundation.setMin(Number(this.min));
    this.foundation.setMax(Number(this.max));
    this.foundation.setStep(Number(this.step));
    this.foundation.setValue(Number(this.value));
    if (this.hasMarkers) {
      this.foundation.setupTrackMarker();
    }

    this.$root.$on('mdc:layout', this.layout);

    if (this.layoutOn) {
      var source = this.layoutOnSource || this.$root;
      source.$on(this.layoutOn, this.layout);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCSlider = BasePlugin({
  mdcSlider: mdcSlider
});

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var cssClasses$13 = {
  ROOT: 'mdc-snackbar',
  TEXT: 'mdc-snackbar__text',
  ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
  ACTION_BUTTON: 'mdc-snackbar__action-button',
  ACTIVE: 'mdc-snackbar--active',
  MULTILINE: 'mdc-snackbar--multiline',
  ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
};

var strings$15 = {
  TEXT_SELECTOR: '.mdc-snackbar__text',
  ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
  ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
  SHOW_EVENT: 'MDCSnackbar:show',
  HIDE_EVENT: 'MDCSnackbar:hide'
};

var numbers$4 = {
  MESSAGE_TIMEOUT: 2750
};

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCSnackbarFoundation = function (_MDCFoundation) {
  inherits(MDCSnackbarFoundation, _MDCFoundation);
  createClass(MDCSnackbarFoundation, [{
    key: 'active',
    get: function get$$1() {
      return this.active_;
    }
  }], [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$13;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$15;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        setAriaHidden: function setAriaHidden() {},
        unsetAriaHidden: function unsetAriaHidden() {},
        setActionAriaHidden: function setActionAriaHidden() {},
        unsetActionAriaHidden: function unsetActionAriaHidden() {},
        setActionText: function setActionText() /* actionText: string */{},
        setMessageText: function setMessageText() /* message: string */{},
        setFocus: function setFocus() {},
        visibilityIsHidden: function visibilityIsHidden() {
          return (/* boolean */false
          );
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler() /* handler: EventListener */{},
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler() /* handler: EventListener */{},
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler() /* handler: EventListener */{},
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler() /* handler: EventListener */{},
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerActionClickHandler: function registerActionClickHandler() /* handler: EventListener */{},
        deregisterActionClickHandler: function deregisterActionClickHandler() /* handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        notifyShow: function notifyShow() {},
        notifyHide: function notifyHide() {}
      };
    }
  }]);

  function MDCSnackbarFoundation(adapter) {
    classCallCheck(this, MDCSnackbarFoundation);

    var _this = possibleConstructorReturn(this, (MDCSnackbarFoundation.__proto__ || Object.getPrototypeOf(MDCSnackbarFoundation)).call(this, _extends(MDCSnackbarFoundation.defaultAdapter, adapter)));

    _this.active_ = false;
    _this.actionWasClicked_ = false;
    _this.dismissOnAction_ = true;
    _this.firstFocus_ = true;
    _this.pointerDownRecognized_ = false;
    _this.snackbarHasFocus_ = false;
    _this.snackbarData_ = null;
    _this.queue_ = [];
    _this.actionClickHandler_ = function () {
      _this.actionWasClicked_ = true;
      _this.invokeAction_();
    };
    _this.visibilitychangeHandler_ = function () {
      clearTimeout(_this.timeoutId_);
      _this.snackbarHasFocus_ = true;

      if (!_this.adapter_.visibilityIsHidden()) {
        setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
      }
    };
    _this.interactionHandler_ = function (evt) {
      if (evt.type == 'touchstart' || evt.type == 'mousedown') {
        _this.pointerDownRecognized_ = true;
      }
      _this.handlePossibleTabKeyboardFocus_(evt);

      if (evt.type == 'focus') {
        _this.pointerDownRecognized_ = false;
      }
    };
    _this.blurHandler_ = function () {
      clearTimeout(_this.timeoutId_);
      _this.snackbarHasFocus_ = false;
      _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
    };
    return _this;
  }

  createClass(MDCSnackbarFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerActionClickHandler(this.actionClickHandler_);
      this.adapter_.setAriaHidden();
      this.adapter_.setActionAriaHidden();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
      this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
      this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
      ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
        _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
      });
    }
  }, {
    key: 'dismissesOnAction',
    value: function dismissesOnAction() {
      return this.dismissOnAction_;
    }
  }, {
    key: 'setDismissOnAction',
    value: function setDismissOnAction(dismissOnAction) {
      this.dismissOnAction_ = !!dismissOnAction;
    }
  }, {
    key: 'show',
    value: function show(data) {
      var _this3 = this;

      if (!data) {
        throw new Error('Please provide a data object with at least a message to display.');
      }
      if (!data.message) {
        throw new Error('Please provide a message to be displayed.');
      }
      if (data.actionHandler && !data.actionText) {
        throw new Error('Please provide action text with the handler.');
      }
      if (this.active) {
        this.queue_.push(data);
        return;
      }
      clearTimeout(this.timeoutId_);
      this.snackbarData_ = data;
      this.firstFocus_ = true;
      this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
      this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
      ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
        _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
      });

      var ACTIVE = cssClasses$13.ACTIVE,
          MULTILINE = cssClasses$13.MULTILINE,
          ACTION_ON_BOTTOM = cssClasses$13.ACTION_ON_BOTTOM;


      this.adapter_.setMessageText(this.snackbarData_.message);

      if (this.snackbarData_.multiline) {
        this.adapter_.addClass(MULTILINE);
        if (this.snackbarData_.actionOnBottom) {
          this.adapter_.addClass(ACTION_ON_BOTTOM);
        }
      }

      if (this.snackbarData_.actionHandler) {
        this.adapter_.setActionText(this.snackbarData_.actionText);
        this.actionHandler_ = this.snackbarData_.actionHandler;
        this.setActionHidden_(false);
      } else {
        this.setActionHidden_(true);
        this.actionHandler_ = null;
        this.adapter_.setActionText(null);
      }

      this.active_ = true;
      this.adapter_.addClass(ACTIVE);
      this.adapter_.unsetAriaHidden();
      this.adapter_.notifyShow();

      this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers$4.MESSAGE_TIMEOUT);
    }
  }, {
    key: 'handlePossibleTabKeyboardFocus_',
    value: function handlePossibleTabKeyboardFocus_() {
      var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

      if (hijackFocus) {
        this.setFocusOnAction_();
      }

      this.firstFocus_ = false;
    }
  }, {
    key: 'setFocusOnAction_',
    value: function setFocusOnAction_() {
      this.adapter_.setFocus();
      this.snackbarHasFocus_ = true;
      this.firstFocus_ = false;
    }
  }, {
    key: 'invokeAction_',
    value: function invokeAction_() {
      try {
        if (!this.actionHandler_) {
          return;
        }

        this.actionHandler_();
      } finally {
        if (this.dismissOnAction_) {
          this.cleanup_();
        }
      }
    }
  }, {
    key: 'cleanup_',
    value: function cleanup_() {
      var _this4 = this;

      var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

      if (allowDismissal) {
        var ACTIVE = cssClasses$13.ACTIVE,
            MULTILINE = cssClasses$13.MULTILINE,
            ACTION_ON_BOTTOM = cssClasses$13.ACTION_ON_BOTTOM;


        this.adapter_.removeClass(ACTIVE);

        var handler = function handler() {
          clearTimeout(_this4.timeoutId_);
          _this4.adapter_.deregisterTransitionEndHandler(handler);
          _this4.adapter_.removeClass(MULTILINE);
          _this4.adapter_.removeClass(ACTION_ON_BOTTOM);
          _this4.setActionHidden_(true);
          _this4.adapter_.setAriaHidden();
          _this4.active_ = false;
          _this4.snackbarHasFocus_ = false;
          _this4.adapter_.notifyHide();
          _this4.showNext_();
        };

        this.adapter_.registerTransitionEndHandler(handler);
      }
    }
  }, {
    key: 'showNext_',
    value: function showNext_() {
      if (!this.queue_.length) {
        return;
      }
      this.show(this.queue_.shift());
    }
  }, {
    key: 'setActionHidden_',
    value: function setActionHidden_(isHidden) {
      if (isHidden) {
        this.adapter_.setActionAriaHidden();
      } else {
        this.adapter_.unsetActionAriaHidden();
      }
    }
  }]);
  return MDCSnackbarFoundation;
}(MDCFoundation);

var mdcSnackbar = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-snackbar", class: _vm.classes, attrs: { "aria-live": "assertive", "aria-atomic": "true", "aria-hidden": _vm.hidden } }, [_c('div', { staticClass: "mdc-snackbar__text" }, [_vm._v(_vm._s(_vm.message))]), _vm._v(" "), _c('div', { staticClass: "mdc-snackbar__action-wrapper" }, [_c('button', { ref: "button", staticClass: "mdc-snackbar__action-button", attrs: { "type": "button", "aria-hidden": _vm.actionHidden } }, [_vm._v(_vm._s(_vm.actionText))])])]);
  }, staticRenderFns: [],
  name: 'mdc-snackbar',
  props: {
    'align-start': Boolean,
    'event': {
      type: String,
      required: false,
      default: function _default() {
        return 'show-snackbar';
      }
    },
    'event-source': {
      type: Object,
      required: false,
      default: function _default() {
        return this.$root;
      }
    },
    'dismisses-on-action': { type: Boolean, default: true }
  },
  data: function data() {
    return {
      classes: {
        'mdc-snackbar--align-start': this.alignStart
      },
      message: '',
      actionText: '',
      hidden: false,
      actionHidden: false
    };
  },

  methods: {
    show: function show(data) {
      this.foundation.show(data);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCSnackbarFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      setAriaHidden: function setAriaHidden() {
        return _this.hidden = true;
      },
      unsetAriaHidden: function unsetAriaHidden() {
        return _this.hidden = false;
      },
      setActionAriaHidden: function setActionAriaHidden() {
        return _this.actionHidden = true;
      },
      unsetActionAriaHidden: function unsetActionAriaHidden() {
        return _this.actionHidden = false;
      },
      setActionText: function setActionText(text) {
        _this.actionText = text;
      },
      setMessageText: function setMessageText(text) {
        _this.message = text;
      },
      setFocus: function setFocus() {
        return _this.$refs.button.focus();
      },
      visibilityIsHidden: function visibilityIsHidden() {
        return document.hidden;
      },
      registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
        return _this.$refs.button.addEventListener('blur', handler, true);
      },
      deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
        return _this.$refs.button.removeEventListener('blur', handler, true);
      },
      registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
        return document.addEventListener('visibilitychange', handler);
      },
      deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
        return document.removeEventListener('visibilitychange', handler);
      },
      registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
        return document.body.addEventListener(evt, handler, true);
      },
      deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
        return document.body.removeEventListener(evt, handler, true);
      },
      registerActionClickHandler: function registerActionClickHandler(handler) {
        return _this.$refs.button.addEventListener('click', handler);
      },
      deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
        return _this.$refs.button.removeEventListener('click', handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        _this.$refs.root.addEventListener(getCorrectEventName(window, 'transitionend'), handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        _this.$refs.root.removeEventListener(getCorrectEventName(window, 'transitionend'), handler);
      },
      notifyShow: function notifyShow() {
        return _this.$emit('show');
      },
      notifyHide: function notifyHide() {
        return _this.$emit('hide');
      }
    });
    this.foundation.init();
    if (this.event) {
      this.eventSource.$on(this.event, function (data) {
        _this.foundation.show(data);
      });
    }
    this.foundation.setDismissOnAction(this.dismissesOnAction);
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var VueMDCSnackbar = BasePlugin({
  mdcSnackbar: mdcSnackbar
});

var mdcSwitch = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch-wrapper", class: { 'mdc-form-field': this.hasLabel, 'mdc-form-field--align-end': this.hasLabel && this.alignEnd } }, [_c('div', { staticClass: "mdc-switch", class: { 'mdc-switch--disabled': _vm.disabled } }, [_c('input', { ref: "control", staticClass: "mdc-switch__native-control", attrs: { "type": "checkbox", "name": _vm.name, "id": _vm._uid, "disabled": _vm.disabled }, domProps: { "checked": _vm.checked }, on: { "change": _vm.onChanged } }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _vm.hasLabel ? _c('label', { staticClass: "mdc-switch-label", attrs: { "for": _vm._uid } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
  }, staticRenderFns: [function () {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch__background" }, [_c('div', { staticClass: "mdc-switch__knob" })]);
  }],
  name: 'mdc-switch',
  mixins: [DispatchFocusMixin],
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    'checked': Boolean,
    'label': String,
    'alignEnd': Boolean,
    'disabled': Boolean,
    'value': { type: String, default: function _default() {
        return 'on';
      }
    },
    'name': String
  },
  computed: {
    hasLabel: function hasLabel() {
      return this.label || this.$slots.default;
    }
  },
  methods: {
    onChanged: function onChanged(event) {
      this.$emit('change', event.target.checked);
    }
  }
};

var VueMDCSwitch = BasePlugin({
  mdcSwitch: mdcSwitch
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$14 = {
  ACTIVE: 'mdc-tab--active'
};

var strings$16 = {
  SELECTED_EVENT: 'MDCTab:selected'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCTabFoundation = function (_MDCFoundation) {
  inherits(MDCTabFoundation, _MDCFoundation);
  createClass(MDCTabFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$14;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$16;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
        getOffsetWidth: function getOffsetWidth() {
          return (/* number */0
          );
        },
        getOffsetLeft: function getOffsetLeft() {
          return (/* number */0
          );
        },
        notifySelected: function notifySelected() {}
      };
    }
  }]);

  function MDCTabFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, MDCTabFoundation);

    var _this = possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, _extends(MDCTabFoundation.defaultAdapter, adapter)));

    _this.computedWidth_ = 0;
    _this.computedLeft_ = 0;
    _this.isActive_ = false;
    _this.preventDefaultOnClick_ = false;

    _this.clickHandler_ = function (evt) {
      if (_this.preventDefaultOnClick_) {
        evt.preventDefault();
      }
      _this.adapter_.notifySelected();
    };

    _this.keydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
        _this.adapter_.notifySelected();
      }
    };
    return _this;
  }

  createClass(MDCTabFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
    }
  }, {
    key: 'getComputedWidth',
    value: function getComputedWidth() {
      return this.computedWidth_;
    }
  }, {
    key: 'getComputedLeft',
    value: function getComputedLeft() {
      return this.computedLeft_;
    }
  }, {
    key: 'isActive',
    value: function isActive() {
      return this.isActive_;
    }
  }, {
    key: 'setActive',
    value: function setActive(isActive) {
      this.isActive_ = isActive;
      if (this.isActive_) {
        this.adapter_.addClass(cssClasses$14.ACTIVE);
      } else {
        this.adapter_.removeClass(cssClasses$14.ACTIVE);
      }
    }
  }, {
    key: 'preventsDefaultOnClick',
    value: function preventsDefaultOnClick() {
      return this.preventDefaultOnClick_;
    }
  }, {
    key: 'setPreventDefaultOnClick',
    value: function setPreventDefaultOnClick(preventDefaultOnClick) {
      this.preventDefaultOnClick_ = preventDefaultOnClick;
    }
  }, {
    key: 'measureSelf',
    value: function measureSelf() {
      this.computedWidth_ = this.adapter_.getOffsetWidth();
      this.computedLeft_ = this.adapter_.getOffsetLeft();
    }
  }]);
  return MDCTabFoundation;
}(MDCFoundation);

var mdcTab = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', { staticClass: "mdc-tab", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link }, on: { "click": _vm.dispatchEvent } }, [!!_vm.hasIcon ? _c('i', { ref: "icon", staticClass: "mdc-tab__icon", class: _vm.hasIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("icon", [_vm._v(_vm._s(_vm.hasIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasText ? _c('span', { class: { 'mdc-tab__icon-text': !!_vm.hasIcon } }, [_vm._t("default")], 2) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-tab',
  mixins: [CustomLinkMixin, DispatchEventMixin],
  props: {
    active: Boolean,
    icon: [String, Array, Object]
  },
  data: function data() {
    return {
      classes: {},
      styles: {}
    };
  },

  computed: {
    hasIcon: function hasIcon() {
      if (this.icon || this.$slots.icon) {
        this.icon ? extractIconProp(this.icon) : {};
      }
      return false;
    },
    hasText: function hasText() {
      return !!this.$slots.default;
    }
  },
  methods: {
    getComputedWidth: function getComputedWidth() {
      return this.foundation.getComputedWidth();
    },
    getComputedLeft: function getComputedLeft() {
      return this.foundation.getComputedLeft();
    },
    isActive: function isActive() {
      return this.foundation.isActive();
    },
    setActive: function setActive(isActive) {
      this.foundation.setActive(isActive);
    },
    isDefaultPreventedOnClick: function isDefaultPreventedOnClick() {
      return this.foundation.preventsDefaultOnClick();
    },
    setPreventDefaultOnClick: function setPreventDefaultOnClick(preventDefaultOnClick) {
      this.foundation.setPreventDefaultOnClick(preventDefaultOnClick);
    },
    measureSelf: function measureSelf() {
      this.foundation.measureSelf();
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCTabFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      registerInteractionHandler: function registerInteractionHandler(type, handler) {
        return _this.$el.addEventListener(type, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
        return _this.$el.removeEventListener(type, handler);
      },
      getOffsetWidth: function getOffsetWidth() {
        return _this.$el.offsetWidth;
      },
      getOffsetLeft: function getOffsetLeft() {
        return _this.$el.offsetLeft;
      },
      notifySelected: function notifySelected() {
        emitCustomEvent(_this.$el, MDCTabFoundation.strings.SELECTED_EVENT, { tab: _this }, true);
      }
    });
    this.foundation.init();
    this.setActive(this.active);
    this.ripple = new RippleBase(this);
    this.ripple.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
    this.ripple.destroy();
  }
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$15 = {
  UPGRADED: 'mdc-tab-bar-upgraded'
};

var strings$17 = {
  TAB_SELECTOR: '.mdc-tab',
  INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
  CHANGE_EVENT: 'MDCTabBar:change'
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MDCTabBarFoundation = function (_MDCFoundation) {
  inherits(MDCTabBarFoundation, _MDCFoundation);
  createClass(MDCTabBarFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$15;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$17;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
        unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        getOffsetWidth: function getOffsetWidth() {
          return (/* number */0
          );
        },
        setStyleForIndicator: function setStyleForIndicator() /* propertyName: string, value: string */{},
        getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
          return (/* number */0
          );
        },
        notifyChange: function notifyChange() /* evtData: {activeTabIndex: number} */{},
        getNumberOfTabs: function getNumberOfTabs() {
          return (/* number */0
          );
        },
        isTabActiveAtIndex: function isTabActiveAtIndex() {
          return (/* index: number */ /* boolean */false
          );
        },
        setTabActiveAtIndex: function setTabActiveAtIndex() /* index: number, isActive: true */{},
        isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
          return (/* index: number */ /* boolean */false
          );
        },
        setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex() /* index: number, preventDefaultOnClick: boolean */{},
        measureTabAtIndex: function measureTabAtIndex() /* index: number */{},
        getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
          return (/* index: number */ /* number */0
          );
        },
        getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
          return (/* index: number */ /* number */0
          );
        }
      };
    }
  }]);

  function MDCTabBarFoundation(adapter) {
    classCallCheck(this, MDCTabBarFoundation);

    var _this = possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, _extends(MDCTabBarFoundation.defaultAdapter, adapter)));

    _this.isIndicatorShown_ = false;
    _this.computedWidth_ = 0;
    _this.computedLeft_ = 0;
    _this.activeTabIndex_ = 0;
    _this.layoutFrame_ = 0;
    _this.resizeHandler_ = function () {
      return _this.layout();
    };
    return _this;
  }

  createClass(MDCTabBarFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.addClass(cssClasses$15.UPGRADED);
      this.adapter_.bindOnMDCTabSelectedEvent();
      this.adapter_.registerResizeHandler(this.resizeHandler_);
      var activeTabIndex = this.findActiveTabIndex_();
      if (activeTabIndex >= 0) {
        this.activeTabIndex_ = activeTabIndex;
      }
      this.layout();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.removeClass(cssClasses$15.UPGRADED);
      this.adapter_.unbindOnMDCTabSelectedEvent();
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  }, {
    key: 'layoutInternal_',
    value: function layoutInternal_() {
      var _this2 = this;

      this.forEachTabIndex_(function (index) {
        return _this2.adapter_.measureTabAtIndex(index);
      });
      this.computedWidth_ = this.adapter_.getOffsetWidth();
      this.layoutIndicator_();
    }
  }, {
    key: 'layoutIndicator_',
    value: function layoutIndicator_() {
      var isIndicatorFirstRender = !this.isIndicatorShown_;

      // Ensure that indicator appears in the right position immediately for correct first render.
      if (isIndicatorFirstRender) {
        this.adapter_.setStyleForIndicator('transition', 'none');
      }

      var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
      var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();

      var transformValue = 'translateX(' + translateAmtForActiveTabLeft + 'px) scale(' + scaleAmtForActiveTabWidth + ', 1)';
      this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

      if (isIndicatorFirstRender) {
        // Force layout so that transform styles to take effect.
        this.adapter_.getOffsetWidthForIndicator();
        this.adapter_.setStyleForIndicator('transition', '');
        this.adapter_.setStyleForIndicator('visibility', 'visible');
        this.isIndicatorShown_ = true;
      }
    }
  }, {
    key: 'findActiveTabIndex_',
    value: function findActiveTabIndex_() {
      var _this3 = this;

      var activeTabIndex = -1;
      this.forEachTabIndex_(function (index) {
        if (_this3.adapter_.isTabActiveAtIndex(index)) {
          activeTabIndex = index;
          return true;
        }
      });
      return activeTabIndex;
    }
  }, {
    key: 'forEachTabIndex_',
    value: function forEachTabIndex_(iterator) {
      var numTabs = this.adapter_.getNumberOfTabs();
      for (var index = 0; index < numTabs; index++) {
        var shouldBreak = iterator(index);
        if (shouldBreak) {
          break;
        }
      }
    }
  }, {
    key: 'layout',
    value: function layout() {
      var _this4 = this;

      if (this.layoutFrame_) {
        cancelAnimationFrame(this.layoutFrame_);
      }

      this.layoutFrame_ = requestAnimationFrame(function () {
        _this4.layoutInternal_();
        _this4.layoutFrame_ = 0;
      });
    }
  }, {
    key: 'switchToTabAtIndex',
    value: function switchToTabAtIndex(index, shouldNotify) {
      var _this5 = this;

      if (index === this.activeTabIndex_) {
        return;
      }

      if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
        throw new Error('Out of bounds index specified for tab: ' + index);
      }

      var prevActiveTabIndex = this.activeTabIndex_;
      this.activeTabIndex_ = index;
      requestAnimationFrame(function () {
        if (prevActiveTabIndex >= 0) {
          _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
        }
        _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);
        _this5.layoutIndicator_();
        if (shouldNotify) {
          _this5.adapter_.notifyChange({ activeTabIndex: _this5.activeTabIndex_ });
        }
      });
    }
  }, {
    key: 'getActiveTabIndex',
    value: function getActiveTabIndex() {
      return this.findActiveTabIndex_();
    }
  }]);
  return MDCTabBarFoundation;
}(MDCFoundation);

var mdcTabBar = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-tab-bar", class: _vm.classes }, [_vm._t("default"), _vm._v(" "), _c('span', { ref: "indicator", staticClass: "mdc-tab-bar__indicator", style: _vm.indicatorStyles })], 2);
  }, staticRenderFns: [],
  name: 'mdc-tab-bar',
  props: {
    'indicator-primary': Boolean,
    'indicator-accent': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-tab-bar--indicator-primary': this.indicatorPrimary,
        'mdc-tab-bar--indicator-accent': this.indicatorAccent
      },
      indicatorStyles: {},
      tabs: []
    };
  },

  methods: {
    onSelect: function onSelect(_ref) {
      var detail = _ref.detail;
      var tab = detail.tab;

      var index = this.tabs.indexOf(tab);
      if (index < 0) {
        throw new Error('mdc-tab-bar internal error: index not found');
      }
      this.foundation.switchToTabAtIndex(index, true);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCTabBarFoundation({
      addClass: function addClass(className) {
        return _this.$set(_this.classes, className, true);
      },
      removeClass: function removeClass(className) {
        return _this.$delete(_this.classes, className);
      },
      bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
        _this.$el.addEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
      },
      unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
        return _this.$el.removeEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        return window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        return window.removeEventListener('resize', handler);
      },
      getOffsetWidth: function getOffsetWidth() {
        return _this.$el.offsetWidth;
      },
      setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
        return _this.$set(_this.indicatorStyles, propertyName, value);
      },
      getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
        return _this.$refs.indicator.offsetWidth;
      },
      notifyChange: function notifyChange(evtData) {
        _this.$emit('change', evtData.activeTabIndex);
      },
      getNumberOfTabs: function getNumberOfTabs() {
        return _this.tabs.length;
      },
      isTabActiveAtIndex: function isTabActiveAtIndex(index) {
        return _this.tabs[index].isActive();
      },
      setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
        _this.tabs[index].setActive(isActive);
      },
      isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
        return _this.tabs[index].isDefaultPreventedOnClick();
      },
      setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
        _this.tabs[index].setPreventDefaultOnClick(preventDefaultOnClick);
      },
      measureTabAtIndex: function measureTabAtIndex(index) {
        return _this.tabs[index].measureSelf();
      },
      getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
        return _this.tabs[index].getComputedWidth();
      },
      getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
        return _this.tabs[index].getComputedLeft();
      }
    });

    var resetTabs = function resetTabs() {
      var tabElements = [].slice.call(_this.$el.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
      _this.tabs = tabElements.map(function (el) {
        return el.__vue__;
      });

      var hasText = void 0,
          hasIcon = void 0;
      var tabs = _this.tabs;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tab = _step.value;

          if (tab.hasText) {
            hasText = true;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = tabs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _tab = _step2.value;

          if (_tab.hasIcon) {
            hasIcon = true;
            break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (hasText && hasIcon) {
        _this.$set(_this.classes, 'mdc-tab-bar--icons-with-text', true);
      } else if (hasIcon) {
        _this.$set(_this.classes, 'mdc-tab-bar--icon-tab-bar', true);
      }

      if (_this.foundation) {
        var activeTabIndex = _this.foundation.getActiveTabIndex();
        if (activeTabIndex >= 0) {
          _this.foundation.switchToTabAtIndex(activeTabIndex, true);
        } else {
          _this.foundation.switchToTabAtIndex(0, true);
        }
        _this.foundation.layout();
      }
    };

    resetTabs();

    this.slotObserver = new MutationObserver(function () {
      return resetTabs();
    });
    this.slotObserver.observe(this.$el, { childList: true, subtree: true });

    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.slotObserver.disconnect();
    this.foundation.destroy();
  }
};

var VueMDCTabs = BasePlugin({
  mdcTab: mdcTab,
  mdcTabBar: mdcTabBar
});

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC TextField Line Ripple.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the line ripple into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCLineRippleAdapter = function () {
  function MDCLineRippleAdapter() {
    classCallCheck(this, MDCLineRippleAdapter);
  }

  createClass(MDCLineRippleAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the line ripple element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the line ripple element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /**
     * Sets an attribute with a given value on the line ripple element.
     * @param {string} attr
     * @param {string} value
     */

  }, {
    key: "setAttr",
    value: function setAttr(attr, value) {}

    /**
     * Registers an event listener on the line ripple element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerEventHandler",
    value: function registerEventHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the line ripple element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterEventHandler",
    value: function deregisterEventHandler(evtType, handler) {}
  }]);
  return MDCLineRippleAdapter;
}();

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$16 = {
  LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
  LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCLineRippleAdapter>}
 * @final
 */

var MDCLineRippleFoundation = function (_MDCFoundation) {
  inherits(MDCLineRippleFoundation, _MDCFoundation);
  createClass(MDCLineRippleFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$16;
    }

    /**
     * {@see MDCLineRippleAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCLineRippleAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCLineRippleAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          setAttr: function setAttr() {},
          registerEventHandler: function registerEventHandler() {},
          deregisterEventHandler: function deregisterEventHandler() {}
        }
      );
    }

    /**
     * @param {!MDCLineRippleAdapter=} adapter
     */

  }]);

  function MDCLineRippleFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /** @type {!MDCLineRippleAdapter} */{};
    classCallCheck(this, MDCLineRippleFoundation);

    /** @private {function(!Event): undefined} */
    var _this = possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));

    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd(evt);
    };
    return _this;
  }

  createClass(MDCLineRippleFoundation, [{
    key: 'init',
    value: function init() {
      this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
    }

    /**
     * Activates the line ripple
     */

  }, {
    key: 'activate',
    value: function activate() {
      this.adapter_.removeClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);
      this.adapter_.addClass(cssClasses$16.LINE_RIPPLE_ACTIVE);
    }

    /**
     * Sets the center of the ripple animation to the given X coordinate.
     * @param {!number} xCoordinate
     */

  }, {
    key: 'setRippleCenter',
    value: function setRippleCenter(xCoordinate) {
      var attributeString = 'transform-origin: ' + xCoordinate + 'px center';

      this.adapter_.setAttr('style', attributeString);
    }

    /**
     * Deactivates the line ripple
     */

  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.adapter_.addClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);
    }

    /**
     * Handles a transition end event
     * @param {!Event} evt
     */

  }, {
    key: 'handleTransitionEnd',
    value: function handleTransitionEnd(evt) {
      // Wait for the line ripple to be either transparent or opaque
      // before emitting the animation end event
      var isDeactivating = this.adapter_.hasClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);

      if (evt.propertyName === 'opacity') {
        if (isDeactivating) {
          this.adapter_.removeClass(cssClasses$16.LINE_RIPPLE_ACTIVE);
          this.adapter_.removeClass(cssClasses$16.LINE_RIPPLE_DEACTIVATING);
        }
      }
    }
  }]);
  return MDCLineRippleFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Helper Text.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the TextField helper text into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldHelperTextAdapter = function () {
  function MDCTextFieldHelperTextAdapter() {
    classCallCheck(this, MDCTextFieldHelperTextAdapter);
  }

  createClass(MDCTextFieldHelperTextAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the helper text element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the helper text element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns whether or not the helper text element contains the given class.
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: "hasClass",
    value: function hasClass(className) {}

    /**
     * Sets an attribute with a given value on the helper text element.
     * @param {string} attr
     * @param {string} value
     */

  }, {
    key: "setAttr",
    value: function setAttr(attr, value) {}

    /**
     * Removes an attribute from the helper text element.
     * @param {string} attr
     */

  }, {
    key: "removeAttr",
    value: function removeAttr(attr) {}

    /**
     * Sets the text content for the helper text element.
     * @param {string} content
     */

  }, {
    key: "setContent",
    value: function setContent(content) {}
  }]);
  return MDCTextFieldHelperTextAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$18 = {
  ARIA_HIDDEN: 'aria-hidden',
  ROLE: 'role'
};

/** @enum {string} */
var cssClasses$17 = {
  HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
  HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
 * @final
 */

var MDCTextFieldHelperTextFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);
  createClass(MDCTextFieldHelperTextFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$17;
    }

    /** @return enum {string} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$18;
    }

    /**
     * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldHelperTextAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldHelperTextAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          setAttr: function setAttr() {},
          removeAttr: function removeAttr() {},
          setContent: function setContent() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldHelperTextAdapter} adapter
     */

  }]);

  function MDCTextFieldHelperTextFoundation(adapter) {
    classCallCheck(this, MDCTextFieldHelperTextFoundation);
    return possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
  }

  /**
   * Sets the content of the helper text field.
   * @param {string} content
   */


  createClass(MDCTextFieldHelperTextFoundation, [{
    key: 'setContent',
    value: function setContent(content) {
      this.adapter_.setContent(content);
    }

    /** @param {boolean} isPersistent Sets the persistency of the helper text. */

  }, {
    key: 'setPersistent',
    value: function setPersistent(isPersistent) {
      if (isPersistent) {
        this.adapter_.addClass(cssClasses$17.HELPER_TEXT_PERSISTENT);
      } else {
        this.adapter_.removeClass(cssClasses$17.HELPER_TEXT_PERSISTENT);
      }
    }

    /**
     * @param {boolean} isValidation True to make the helper text act as an
     *   error validation message.
     */

  }, {
    key: 'setValidation',
    value: function setValidation(isValidation) {
      if (isValidation) {
        this.adapter_.addClass(cssClasses$17.HELPER_TEXT_VALIDATION_MSG);
      } else {
        this.adapter_.removeClass(cssClasses$17.HELPER_TEXT_VALIDATION_MSG);
      }
    }

    /** Makes the helper text visible to the screen reader. */

  }, {
    key: 'showToScreenReader',
    value: function showToScreenReader() {
      this.adapter_.removeAttr(strings$18.ARIA_HIDDEN);
    }

    /**
     * Sets the validity of the helper text based on the input validity.
     * @param {boolean} inputIsValid
     */

  }, {
    key: 'setValidity',
    value: function setValidity(inputIsValid) {
      var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$17.HELPER_TEXT_PERSISTENT);
      var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$17.HELPER_TEXT_VALIDATION_MSG);
      var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

      if (validationMsgNeedsDisplay) {
        this.adapter_.setAttr(strings$18.ROLE, 'alert');
      } else {
        this.adapter_.removeAttr(strings$18.ROLE);
      }

      if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
        this.hide_();
      }
    }

    /**
     * Hides the help text from screen readers.
     * @private
     */

  }, {
    key: 'hide_',
    value: function hide_() {
      this.adapter_.setAttr(strings$18.ARIA_HIDDEN, 'true');
    }
  }]);
  return MDCTextFieldHelperTextFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Icon.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the text field icon into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldIconAdapter = function () {
  function MDCTextFieldIconAdapter() {
    classCallCheck(this, MDCTextFieldIconAdapter);
  }

  createClass(MDCTextFieldIconAdapter, [{
    key: "setAttr",

    /**
     * Sets an attribute on the icon element.
     * @param {string} attr
     * @param {string} value
     */
    value: function setAttr(attr, value) {}

    /**
     * Registers an event listener on the icon element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "registerInteractionHandler",
    value: function registerInteractionHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the icon element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: "deregisterInteractionHandler",
    value: function deregisterInteractionHandler(evtType, handler) {}

    /**
     * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
     */

  }, {
    key: "notifyIconAction",
    value: function notifyIconAction() {}
  }]);
  return MDCTextFieldIconAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$19 = {
  ICON_EVENT: 'MDCTextField:icon'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
 * @final
 */

var MDCTextFieldIconFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldIconFoundation, _MDCFoundation);
  createClass(MDCTextFieldIconFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$19;
    }

    /**
     * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldIconAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldIconAdapter} */{
          setAttr: function setAttr() {},
          registerInteractionHandler: function registerInteractionHandler() {},
          deregisterInteractionHandler: function deregisterInteractionHandler() {},
          notifyIconAction: function notifyIconAction() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldIconAdapter} adapter
     */

  }]);

  function MDCTextFieldIconFoundation(adapter) {
    classCallCheck(this, MDCTextFieldIconFoundation);

    /** @private {function(!Event): undefined} */
    var _this = possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));

    _this.interactionHandler_ = function (evt) {
      return _this.handleInteraction(evt);
    };
    return _this;
  }

  createClass(MDCTextFieldIconFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      ['click', 'keydown'].forEach(function (evtType) {
        _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
      });
    }

    /**
     * Sets the content of the helper text field.
     * @param {boolean} disabled
     */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      if (disabled) {
        this.adapter_.setAttr('tabindex', '-1');
      } else {
        this.adapter_.setAttr('tabindex', '0');
      }
    }

    /**
     * Handles an interaction event
     * @param {!Event} evt
     */

  }, {
    key: 'handleInteraction',
    value: function handleInteraction(evt) {
      if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
        this.adapter_.notifyIconAction();
      }
    }
  }]);
  return MDCTextFieldIconFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Label.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Text Field label into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldLabelAdapter = function () {
  function MDCTextFieldLabelAdapter() {
    classCallCheck(this, MDCTextFieldLabelAdapter);
  }

  createClass(MDCTextFieldLabelAdapter, [{
    key: "addClass",

    /**
     * Adds a class to the label element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the label element.
     * @param {string} className
     */

  }, {
    key: "removeClass",
    value: function removeClass(className) {}

    /**
     * Returns the width of the label element.
     * @return {number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {}
  }]);
  return MDCTextFieldLabelAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var cssClasses$18 = {
  LABEL_FLOAT_ABOVE: 'mdc-text-field__label--float-above',
  LABEL_SHAKE: 'mdc-text-field__label--shake'
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldLabelAdapter>}
 * @final
 */

var MDCTextFieldLabelFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldLabelFoundation, _MDCFoundation);
  createClass(MDCTextFieldLabelFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$18;
    }

    /**
     * {@see MDCTextFieldLabelAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldLabelAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldLabelAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          getWidth: function getWidth() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldLabelAdapter} adapter
     */

  }]);

  function MDCTextFieldLabelFoundation(adapter) {
    classCallCheck(this, MDCTextFieldLabelFoundation);
    return possibleConstructorReturn(this, (MDCTextFieldLabelFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldLabelFoundation)).call(this, _extends(MDCTextFieldLabelFoundation.defaultAdapter, adapter)));
  }

  /**
   * Returns the width of the label element.
   * @return {number}
   */


  createClass(MDCTextFieldLabelFoundation, [{
    key: 'getWidth',
    value: function getWidth() {
      return this.adapter_.getWidth();
    }

    /**
     * Styles the label to produce the label shake for errors.
     * @param {boolean} isValid Whether the input's value is valid (passes all
     *     validity checks).
     * @param {boolean} isFocused Whether the input is focused.
     */

  }, {
    key: 'styleShake',
    value: function styleShake(isValid, isFocused) {
      var LABEL_SHAKE = MDCTextFieldLabelFoundation.cssClasses.LABEL_SHAKE;

      if (isValid || isFocused) {
        this.adapter_.removeClass(LABEL_SHAKE);
      } else {
        this.adapter_.addClass(LABEL_SHAKE);
      }
    }

    /**
     * Styles the label to float or defloat as necessary.
     * @param {string} value The value of the input.
     * @param {boolean} isFocused Whether the input is focused.
     * @param {boolean} isBadInput The input's `validity.badInput` value.
     */

  }, {
    key: 'styleFloat',
    value: function styleFloat(value, isFocused, isBadInput) {
      var _MDCTextFieldLabelFou = MDCTextFieldLabelFoundation.cssClasses,
          LABEL_FLOAT_ABOVE = _MDCTextFieldLabelFou.LABEL_FLOAT_ABOVE,
          LABEL_SHAKE = _MDCTextFieldLabelFou.LABEL_SHAKE;

      if (!!value || isFocused) {
        this.adapter_.addClass(LABEL_FLOAT_ABOVE);
      } else if (!isBadInput) {
        this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }
  }]);
  return MDCTextFieldLabelFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Text Field Outline.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Text Field outline into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */
var MDCTextFieldOutlineAdapter = function () {
  function MDCTextFieldOutlineAdapter() {
    classCallCheck(this, MDCTextFieldOutlineAdapter);
  }

  createClass(MDCTextFieldOutlineAdapter, [{
    key: "getWidth",

    /**
     * Returns the width of the root element.
     * @return {number}
     */
    value: function getWidth() {}

    /**
     * Returns the height of the root element.
     * @return {number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {}

    /**
     * Sets the "d" attribute of the outline element's SVG path.
     * @param {string} value
     */

  }, {
    key: "setOutlinePathAttr",
    value: function setOutlinePathAttr(value) {}

    /**
     * Returns the idle outline element's computed style value of the given css property `propertyName`.
     * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
     * @param {string} propertyName
     * @return {string}
     */

  }, {
    key: "getIdleOutlineStyleValue",
    value: function getIdleOutlineStyleValue(propertyName) {}
  }]);
  return MDCTextFieldOutlineAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$20 = {
  PATH_SELECTOR: '.mdc-text-field__outline-path',
  IDLE_OUTLINE_SELECTOR: '.mdc-text-field__idle-outline'
};

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @extends {MDCFoundation<!MDCTextFieldOutlineAdapter>}
 * @final
 */

var MDCTextFieldOutlineFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldOutlineFoundation, _MDCFoundation);
  createClass(MDCTextFieldOutlineFoundation, null, [{
    key: 'strings',

    /** @return enum {string} */
    get: function get$$1() {
      return strings$20;
    }

    /**
     * {@see MDCTextFieldOutlineAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldOutlineAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldOutlineAdapter} */{
          getWidth: function getWidth() {},
          getHeight: function getHeight() {},
          setOutlinePathAttr: function setOutlinePathAttr() {},
          getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldOutlineAdapter} adapter
     */

  }]);

  function MDCTextFieldOutlineFoundation(adapter) {
    classCallCheck(this, MDCTextFieldOutlineFoundation);
    return possibleConstructorReturn(this, (MDCTextFieldOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldOutlineFoundation)).call(this, _extends(MDCTextFieldOutlineFoundation.defaultAdapter, adapter)));
  }

  /**
   * Updates the SVG path of the focus outline element based on the given width of the
   * label element and the RTL context.
   * @param {number} labelWidth
   * @param {boolean=} isRtl
   */


  createClass(MDCTextFieldOutlineFoundation, [{
    key: 'updateSvgPath',
    value: function updateSvgPath(labelWidth) {
      var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
      var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
      var radius = parseFloat(radiusStyleValue);
      var width = this.adapter_.getWidth();
      var height = this.adapter_.getHeight();
      var cornerWidth = radius + 1.2;
      var leadingStrokeLength = Math.abs(11 - cornerWidth);
      var paddedLabelWidth = labelWidth + 8;

      // The right, bottom, and left sides of the outline follow the same SVG path.
      var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;

      var path = void 0;
      if (!isRtl) {
        path = 'M' + (cornerWidth + leadingStrokeLength + paddedLabelWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedLabelWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
      } else {
        path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedLabelWidth - leadingStrokeLength);
      }

      this.adapter_.setOutlinePathAttr(path);
    }
  }]);
  return MDCTextFieldOutlineFoundation;
}(MDCFoundation);

/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/**
 * Adapter for MDC Text Field.
 *
 * Defines the shape of the adapter expected by the foundation. Implement this
 * adapter to integrate the Text Field into your framework. See
 * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
 * for more information.
 *
 * @record
 */

var MDCTextFieldAdapter = function () {
  function MDCTextFieldAdapter() {
    classCallCheck(this, MDCTextFieldAdapter);
  }

  createClass(MDCTextFieldAdapter, [{
    key: 'addClass',

    /**
     * Adds a class to the root Element.
     * @param {string} className
     */
    value: function addClass(className) {}

    /**
     * Removes a class from the root Element.
     * @param {string} className
     */

  }, {
    key: 'removeClass',
    value: function removeClass(className) {}

    /**
     * Returns true if the root element contains the given class name.
     * @param {string} className
     * @return {boolean}
     */

  }, {
    key: 'hasClass',
    value: function hasClass(className) {}

    /**
     * Registers an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'registerTextFieldInteractionHandler',
    value: function registerTextFieldInteractionHandler(type, handler) {}

    /**
     * Deregisters an event handler on the root element for a given event.
     * @param {string} type
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'deregisterTextFieldInteractionHandler',
    value: function deregisterTextFieldInteractionHandler(type, handler) {}

    /**
     * Registers an event listener on the native input element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'registerInputInteractionHandler',
    value: function registerInputInteractionHandler(evtType, handler) {}

    /**
     * Deregisters an event listener on the native input element for a given event.
     * @param {string} evtType
     * @param {function(!Event): undefined} handler
     */

  }, {
    key: 'deregisterInputInteractionHandler',
    value: function deregisterInputInteractionHandler(evtType, handler) {}

    /**
     * Returns an object representing the native text input element, with a
     * similar API shape. The object returned should include the value, disabled
     * and badInput properties, as well as the checkValidity() function. We never
     * alter the value within our code, however we do update the disabled
     * property, so if you choose to duck-type the return value for this method
     * in your implementation it's important to keep this in mind. Also note that
     * this method can return null, which the foundation will handle gracefully.
     * @return {?Element|?NativeInputType}
     */

  }, {
    key: 'getNativeInput',
    value: function getNativeInput() {}

    /**
     * Returns true if the textfield is focused.
     * We achieve this via `document.activeElement === this.root_`.
     * @return {boolean}
     */

  }, {
    key: 'isFocused',
    value: function isFocused() {}

    /**
     * Returns true if the direction of the root element is set to RTL.
     * @return {boolean}
     */

  }, {
    key: 'isRtl',
    value: function isRtl() {}

    /**
     * Activates the line ripple.
     */

  }, {
    key: 'activateLineRipple',
    value: function activateLineRipple() {}

    /**
     * Deactivates the line ripple.
     */

  }, {
    key: 'deactivateLineRipple',
    value: function deactivateLineRipple() {}

    /**
     * Sets the transform origin of the line ripple.
     * @param {number} normalizedX
     */

  }, {
    key: 'setLineRippleTransformOrigin',
    value: function setLineRippleTransformOrigin(normalizedX) {}
  }]);
  return MDCTextFieldAdapter;
}();

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
var strings$21 = {
  ARIA_CONTROLS: 'aria-controls',
  INPUT_SELECTOR: '.mdc-text-field__input',
  LABEL_SELECTOR: '.mdc-text-field__label',
  ICON_SELECTOR: '.mdc-text-field__icon',
  OUTLINE_SELECTOR: '.mdc-text-field__outline',
  BOTTOM_LINE_SELECTOR: '.mdc-line-ripple'
};

/** @enum {string} */
var cssClasses$19 = {
  ROOT: 'mdc-text-field',
  UPGRADED: 'mdc-text-field--upgraded',
  DISABLED: 'mdc-text-field--disabled',
  DENSE: 'mdc-text-field--dense',
  FOCUSED: 'mdc-text-field--focused',
  INVALID: 'mdc-text-field--invalid',
  BOX: 'mdc-text-field--box',
  OUTLINED: 'mdc-text-field--outlined'
};

/** @enum {number} */
var numbers$5 = {
  LABEL_SCALE: 0.75,
  DENSE_LABEL_SCALE: 0.923
};

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
/* eslint-enable no-unused-vars */
/**
 * @extends {MDCFoundation<!MDCTextFieldAdapter>}
 * @final
 */

var MDCTextFieldFoundation = function (_MDCFoundation) {
  inherits(MDCTextFieldFoundation, _MDCFoundation);
  createClass(MDCTextFieldFoundation, null, [{
    key: 'cssClasses',

    /** @return enum {string} */
    get: function get$$1() {
      return cssClasses$19;
    }

    /** @return enum {string} */

  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$21;
    }

    /** @return enum {string} */

  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$5;
    }

    /**
     * {@see MDCTextFieldAdapter} for typing information on parameters and return
     * types.
     * @return {!MDCTextFieldAdapter}
     */

  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return (/** @type {!MDCTextFieldAdapter} */{
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
          deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
          registerInputInteractionHandler: function registerInputInteractionHandler() {},
          deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
          getNativeInput: function getNativeInput() {},
          isFocused: function isFocused() {},
          isRtl: function isRtl() {},
          activateLineRipple: function activateLineRipple() {},
          deactivateLineRipple: function deactivateLineRipple() {},
          setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {}
        }
      );
    }

    /**
     * @param {!MDCTextFieldAdapter} adapter
     * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
     */

  }]);

  function MDCTextFieldFoundation(adapter) {
    var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {!FoundationMapType} */{};
    classCallCheck(this, MDCTextFieldFoundation);

    /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
    var _this = possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));

    _this.helperText_ = foundationMap.helperText;
    /** @type {!MDCTextFieldIconFoundation|undefined} */
    _this.icon_ = foundationMap.icon;
    /** @type {!MDCTextFieldLabelFoundation|undefined} */
    _this.label_ = foundationMap.label;
    /** @type {!MDCTextFieldOutlineFoundation|undefined} */
    _this.outline_ = foundationMap.outline;

    /** @private {boolean} */
    _this.isFocused_ = false;
    /** @private {boolean} */
    _this.receivedUserInput_ = false;
    /** @private {boolean} */
    _this.useCustomValidityChecking_ = false;
    /** @private {boolean} */
    _this.isValid_ = true;
    /** @private {function(): undefined} */
    _this.inputFocusHandler_ = function () {
      return _this.activateFocus();
    };
    /** @private {function(): undefined} */
    _this.inputBlurHandler_ = function () {
      return _this.deactivateFocus();
    };
    /** @private {function(): undefined} */
    _this.inputInputHandler_ = function () {
      return _this.autoCompleteFocus();
    };
    /** @private {function(!Event): undefined} */
    _this.setPointerXOffset_ = function (evt) {
      return _this.setTransformOrigin(evt);
    };
    /** @private {function(!Event): undefined} */
    _this.textFieldInteractionHandler_ = function () {
      return _this.handleTextFieldInteraction();
    };
    return _this;
  }

  createClass(MDCTextFieldFoundation, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
      // Ensure label does not collide with any pre-filled value.
      if (this.label_ && this.getValue()) {
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }

      if (this.adapter_.isFocused()) {
        this.inputFocusHandler_();
      }

      this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
      this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
      this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
      ['mousedown', 'touchstart'].forEach(function (evtType) {
        _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
      });
      ['click', 'keydown'].forEach(function (evtType) {
        _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this3 = this;

      this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
      this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
      this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
      this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
      ['mousedown', 'touchstart'].forEach(function (evtType) {
        _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
      });
      ['click', 'keydown'].forEach(function (evtType) {
        _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
      });
    }

    /**
     * Handles user interactions with the Text Field.
     */

  }, {
    key: 'handleTextFieldInteraction',
    value: function handleTextFieldInteraction() {
      if (this.adapter_.getNativeInput().disabled) {
        return;
      }
      this.receivedUserInput_ = true;
    }

    /**
     * Updates the focus outline for outlined text fields.
     */

  }, {
    key: 'updateOutline',
    value: function updateOutline() {
      if (!this.outline_ || !this.label_) {
        return;
      }

      var isDense = this.adapter_.hasClass(cssClasses$19.DENSE);
      var labelScale = isDense ? numbers$5.DENSE_LABEL_SCALE : numbers$5.LABEL_SCALE;
      var labelWidth = this.label_.getWidth() * labelScale;
      var isRtl = this.adapter_.isRtl();
      this.outline_.updateSvgPath(labelWidth, isRtl);
    }

    /**
     * Activates the text field focus state.
     */

  }, {
    key: 'activateFocus',
    value: function activateFocus() {
      this.isFocused_ = true;
      this.styleFocused_(this.isFocused_);
      this.adapter_.activateLineRipple();
      if (this.outline_) {
        this.updateOutline();
      }
      if (this.label_) {
        this.label_.styleShake(this.isValid(), this.isFocused_);
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }
      if (this.helperText_) {
        this.helperText_.showToScreenReader();
      }
    }

    /**
     * Sets the line ripple's transform origin, so that the line ripple activate
     * animation will animate out from the user's click location.
     * @param {!Event} evt
     */

  }, {
    key: 'setTransformOrigin',
    value: function setTransformOrigin(evt) {
      var targetClientRect = evt.target.getBoundingClientRect();
      var evtCoords = { x: evt.clientX, y: evt.clientY };
      var normalizedX = evtCoords.x - targetClientRect.left;
      this.adapter_.setLineRippleTransformOrigin(normalizedX);
    }

    /**
     * Activates the Text Field's focus state in cases when the input value
     * changes without user input (e.g. programatically).
     */

  }, {
    key: 'autoCompleteFocus',
    value: function autoCompleteFocus() {
      if (!this.receivedUserInput_) {
        this.activateFocus();
      }
    }

    /**
     * Deactivates the Text Field's focus state.
     */

  }, {
    key: 'deactivateFocus',
    value: function deactivateFocus() {
      this.isFocused_ = false;
      this.adapter_.deactivateLineRipple();
      var input = this.getNativeInput_();
      var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
      var isValid = this.isValid();
      this.styleValidity_(isValid);
      this.styleFocused_(this.isFocused_);
      if (this.label_) {
        this.label_.styleShake(this.isValid(), this.isFocused_);
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }
      if (shouldRemoveLabelFloat) {
        this.receivedUserInput_ = false;
      }
    }

    /**
     * @return {string} The value of the input Element.
     */

  }, {
    key: 'getValue',
    value: function getValue() {
      return this.getNativeInput_().value;
    }

    /**
     * @param {string} value The value to set on the input Element.
     */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.getNativeInput_().value = value;
      var isValid = this.isValid();
      this.styleValidity_(isValid);
      if (this.label_) {
        this.label_.styleShake(isValid, this.isFocused_);
        this.label_.styleFloat(this.getValue(), this.isFocused_, this.isBadInput_());
      }
    }

    /**
     * @return {boolean} If a custom validity is set, returns that value.
     *     Otherwise, returns the result of native validity checks.
     */

  }, {
    key: 'isValid',
    value: function isValid() {
      return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
    }

    /**
     * @param {boolean} isValid Sets the validity state of the Text Field.
     */

  }, {
    key: 'setValid',
    value: function setValid(isValid) {
      this.useCustomValidityChecking_ = true;
      this.isValid_ = isValid;
      // Retrieve from the getter to ensure correct logic is applied.
      isValid = this.isValid();
      this.styleValidity_(isValid);
      if (this.label_) {
        this.label_.styleShake(isValid, this.isFocused_);
      }
    }

    /**
     * @return {boolean} True if the Text Field is disabled.
     */

  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this.getNativeInput_().disabled;
    }

    /**
     * @param {boolean} disabled Sets the text-field disabled or enabled.
     */

  }, {
    key: 'setDisabled',
    value: function setDisabled(disabled) {
      this.getNativeInput_().disabled = disabled;
      this.styleDisabled_(disabled);
    }

    /**
     * @return {boolean} True if the Text Field is required.
     */

  }, {
    key: 'isRequired',
    value: function isRequired() {
      return this.getNativeInput_().required;
    }

    /**
     * @param {boolean} isRequired Sets the text-field required or not.
     */

  }, {
    key: 'setRequired',
    value: function setRequired(isRequired) {
      this.getNativeInput_().required = isRequired;
      // Addition of the asterisk is automatic based on CSS, but validity checking
      // needs to be manually run.
      this.styleValidity_(this.isValid());
    }

    /**
     * @param {string} content Sets the content of the helper text.
     */

  }, {
    key: 'setHelperTextContent',
    value: function setHelperTextContent(content) {
      if (this.helperText_) {
        this.helperText_.setContent(content);
      }
    }

    /**
     * @return {boolean} True if the Text Field input fails in converting the
     *     user-supplied value.
     * @private
     */

  }, {
    key: 'isBadInput_',
    value: function isBadInput_() {
      return this.getNativeInput_().validity.badInput;
    }

    /**
     * @return {boolean} The result of native validity checking
     *     (ValidityState.valid).
     */

  }, {
    key: 'isNativeInputValid_',
    value: function isNativeInputValid_() {
      return this.getNativeInput_().validity.valid;
    }

    /**
     * Styles the component based on the validity state.
     * @param {boolean} isValid
     * @private
     */

  }, {
    key: 'styleValidity_',
    value: function styleValidity_(isValid) {
      var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

      if (isValid) {
        this.adapter_.removeClass(INVALID);
      } else {
        this.adapter_.addClass(INVALID);
      }
      if (this.helperText_) {
        this.helperText_.setValidity(isValid);
      }
    }

    /**
     * Styles the component based on the focused state.
     * @param {boolean} isFocused
     * @private
     */

  }, {
    key: 'styleFocused_',
    value: function styleFocused_(isFocused) {
      var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

      if (isFocused) {
        this.adapter_.addClass(FOCUSED);
      } else {
        this.adapter_.removeClass(FOCUSED);
      }
    }

    /**
     * Styles the component based on the disabled state.
     * @param {boolean} isDisabled
     * @private
     */

  }, {
    key: 'styleDisabled_',
    value: function styleDisabled_(isDisabled) {
      var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
          DISABLED = _MDCTextFieldFoundati.DISABLED,
          INVALID = _MDCTextFieldFoundati.INVALID;

      if (isDisabled) {
        this.adapter_.addClass(DISABLED);
        this.adapter_.removeClass(INVALID);
      } else {
        this.adapter_.removeClass(DISABLED);
      }
      if (this.icon_) {
        this.icon_.setDisabled(isDisabled);
      }
    }

    /**
     * @return {!Element|!NativeInputType} The native text input from the
     * host environment, or a dummy if none exists.
     * @private
     */

  }, {
    key: 'getNativeInput_',
    value: function getNativeInput_() {
      return this.adapter_.getNativeInput() ||
      /** @type {!NativeInputType} */{
        value: '',
        disabled: false,
        validity: {
          badInput: false,
          valid: true
        }
      };
    }
  }]);
  return MDCTextFieldFoundation;
}(MDCFoundation);

var mdcTextField = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-textfield-wrapper", style: { width: _vm.fullwidth ? '100%' : undefined } }, [_c('div', { ref: "root", class: _vm.rootClasses }, [!!_vm.hasLeadingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasLeadingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("leading-icon", [_vm._v(_vm._s(_vm.hasLeadingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.multiline ? _c('textarea', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls, "rows": _vm.rows, "cols": _vm.cols }, on: { "input": function input($event) {
          _vm.updateValue($event.target.value);
        } } }, 'textarea', _vm.inputAttrs, false), _vm.$listeners)) : _c('input', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "type": _vm.type, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls }, on: { "input": function input($event) {
          _vm.updateValue($event.target.value);
        } } }, 'input', _vm.inputAttrs, false), _vm.$listeners)), _vm._v(" "), _vm.hasLabel ? _c('label', { ref: "label", class: _vm.labelClassesUpgraded, attrs: { "for": _vm._uid } }, [_vm._v(" " + _vm._s(_vm.label) + " ")]) : _vm._e(), _vm._v(" "), !!_vm.hasTrailingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasTrailingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("trailing-icon", [_vm._v(_vm._s(_vm.hasTrailingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outline", staticClass: "mdc-text-field__outline" }, [_c('svg', [_c('path', { staticClass: "mdc-text-field__outline-path", attrs: { "d": _vm.outlinePathAttr } })])]) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outlineIdle", staticClass: "mdc-text-field__idle-outline" }) : _vm._e(), _vm._v(" "), _vm.hasBottomLine ? _c('div', { ref: "bottom", class: _vm.bottomClasses }) : _vm._e()]), _vm._v(" "), _vm.helptext ? _c('p', { ref: "help", class: _vm.helpClasses, attrs: { "id": 'help-' + _vm._uid, "aria-hidden": "true" } }, [_vm._v(" " + _vm._s(_vm.helptext) + " ")]) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-textfield',
  mixins: [CustomElementMixin, DispatchFocusMixin],
  model: {
    prop: 'value',
    event: 'model'
  },
  props: {
    value: String,
    type: {
      type: String,
      default: 'text',
      validator: function validator(value) {
        return ['text', 'email', 'search', 'password', 'tel', 'url'].indexOf(value) !== -1;
      }
    },
    dense: Boolean,
    label: String,
    helptext: String,
    helptextPersistent: Boolean,
    helptextValidation: Boolean,
    box: Boolean,
    outline: Boolean,
    disabled: Boolean,
    required: Boolean,
    valid: { type: Boolean, default: undefined },
    fullwidth: Boolean,
    multiline: Boolean,
    leadingIcon: [String, Array, Object],
    trailingIcon: [String, Array, Object],
    size: { type: [Number, String], default: 20 },
    minlength: { type: [Number, String], default: undefined },
    maxlength: { type: [Number, String], default: undefined },
    rows: { type: [Number, String], default: 8 },
    cols: { type: [Number, String], default: 40 },

    // other input props  
    name: String,
    readonly: Boolean,
    autocomplete: Boolean,
    autofocus: Boolean
  },
  data: function data() {
    return {
      text: this.value,
      rootClasses: {
        'mdc-textfield': true,
        'mdc-text-field': true,
        'mdc-text-field--upgraded': true,
        'mdc-text-field--disabled': this.disabled,
        'mdc-text-field--dense': this.dense,
        'mdc-text-field--fullwidth': this.fullwidth,
        'mdc-text-field--textarea': this.multiline,
        'mdc-text-field--box': !this.fullwidth && this.box,
        'mdc-text-field--outlined': !this.fullwidth && this.outline
      },
      inputClasses: {
        'mdc-text-field__input': true
      },
      labelClasses: {
        'mdc-text-field__label': true
      },
      bottomClasses: {
        'mdc-line-ripple': true
      },
      helpClasses: {
        'mdc-text-field-helper-text': true,
        'mdc-text-field-helper-text--persistent': this.helptextPersistent,
        'mdc-text-field-helper-text--validation-msg': this.helptextValidation
      },
      outlinePathAttr: undefined
    };
  },
  watch: {
    disabled: function disabled() {
      this.foundation && this.foundation.setDisabled(this.disabled);
    },
    required: function required() {
      this.foundation && this.foundation.setRequired(this.disabled);
    },
    valid: function valid() {
      if (typeof this.valid !== "undefined") {
        this.foundation && this.foundation.setValid(this.valid);
      }
    },
    dense: function dense() {
      this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
    },
    helptextPersistent: function helptextPersistent() {
      this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
    },
    helptextValidation: function helptextValidation() {
      this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
    },
    value: function value(_value) {
      if (this.foundation) {
        if (_value !== this.foundation.getValue()) {
          this.foundation.setValue(_value);
        }
      }
    }
  },
  methods: {
    updateValue: function updateValue(value) {
      this.$emit('model', value);
    },
    focus: function focus() {
      this.$refs.input && this.$refs.input.focus();
    },
    blur: function blur() {
      this.$refs.input && this.$refs.input.blur();
    }
  },
  computed: {
    inputAttrs: function inputAttrs() {
      var name = this.name,
          readonly = this.readonly,
          autocomplete = this.autocomplete,
          autofocus = this.autofocus;

      return { name: name, readonly: readonly, autocomplete: autocomplete, autofocus: autofocus };
    },
    inputPlaceHolder: function inputPlaceHolder() {
      return this.fullwidth ? this.label : undefined;
    },
    inputAriaControls: function inputAriaControls() {
      return this.help ? 'help-' + this._uid : undefined;
    },
    hasLabel: function hasLabel() {
      return !this.fullwidth && this.label;
    },
    hasOutline: function hasOutline() {
      return !this.fullwidth && this.outline;
    },
    hasBottomLine: function hasBottomLine() {
      return !this.hasOutline && !this.multiline;
    },
    hasLeadingIcon: function hasLeadingIcon() {
      if ((this.leadingIcon || this.$slots['leading-icon']) && !(this.trailingIcon || this.$slots['trailing-icon'])) {
        return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
      }
      return false;
    },
    hasTrailingIcon: function hasTrailingIcon() {
      if (this.trailingIcon || this.$slots['trailing-icon']) {
        return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
      }
      return false;
    },
    labelClassesUpgraded: function labelClassesUpgraded() {
      return _extends(this.labelClasses, {
        'mdc-text-field__label--float-above': this.value
      });
    }
  },
  mounted: function mounted() {
    var _this = this;

    if (this.$refs.bottom) {
      this.bottomLineFoundation = new MDCLineRippleFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.bottomClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.bottomClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.bottomClasses.classList.contains(className);
        },
        setAttr: function setAttr(name, value) {
          _this.$refs.bottom.setAttribute(name, value);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          _this.$refs.bottom.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          _this.$refs.bottom.removeEventListener(evtType, handler);
        }
      });
      this.bottomLineFoundation.init();
    }

    if (this.$refs.help) {
      this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.helpClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.helpClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.help.classList.contains(className);
        },
        setAttr: function setAttr(name, value) {
          _this.$refs.help.setAttribute(name, value);
        },
        removeAttr: function removeAttr(name) {
          _this.$refs.help.removeAttribute(name);
        },
        setContent: function setContent() /*content*/{
          // help text get's updated from {{helptext}}
          // this.$refs.help.textContent = content;
        }
      });
      this.helperTextFoundation.init();
    }

    if (this.$refs.icon) {
      if (this.hasLeadingIcon) {
        this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
      } else if (this.hasTrailingIcon) {
        this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
      }

      this.iconFoundation = new MDCTextFieldIconFoundation({
        setAttr: function setAttr(attr, value) {
          return _this.$refs.icon.setAttribute(attr, value);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$refs.icon.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$refs.icon.removeEventListener(evtType, handler);
        },
        notifyIconAction: function notifyIconAction() {
          return _this.$emit('icon-action');
        }
      });
      this.iconFoundation.init();
    }

    if (this.$refs.label) {
      this.labelFoundation = new MDCTextFieldLabelFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.labelClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.labelClasses, className);
        },
        getWidth: function getWidth() {
          return _this.$refs.label.offsetWidth;
        }
      });
      this.labelFoundation.init();
    }

    if (this.$refs.outline) {
      this.outlineFoundation = new MDCTextFieldOutlineFoundation({
        getWidth: function getWidth() {
          return _this.$refs.outline.offsetWidth;
        },
        getHeight: function getHeight() {
          return _this.$refs.outline.offsetHeight;
        },
        setOutlinePathAttr: function setOutlinePathAttr(value) {
          _this.outlinePathAttr = value;
        },
        getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
          var idleOutlineElement = _this.$refs.outlineIdle;
          if (idleOutlineElement) {
            return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
          }
        }
      });
      this.outlineFoundation.init();
    }

    this.foundation = new MDCTextFieldFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.rootClasses, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.rootClasses, className);
      },
      hasClass: function hasClass(className) {
        _this.$refs.root.classList.contains(className);
      },
      registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
        _this.$refs.root.addEventListener(evtType, handler);
      },
      deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
        _this.$refs.root.removeEventListener(evtType, handler);
      },
      isFocused: function isFocused() {
        return document.activeElement === _this.$refs.input;
      },
      isRtl: function isRtl() {
        return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
      },
      deactivateLineRipple: function deactivateLineRipple() {
        if (_this.bottom) {
          _this.bottom.deactivate();
        }
      },
      activateLineRipple: function activateLineRipple() {
        if (_this.bottom) {
          _this.bottom.activate();
        }
      },
      setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
        if (_this.bottom) {
          _this.bottom.setRippleCenter(normalizedX);
        }
      },
      registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
        _this.$refs.input.addEventListener(evtType, handler);
      },
      deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
        _this.$refs.input.removeEventListener(evtType, handler);
      },
      getNativeInput: function getNativeInput() {
        return _this.$refs.input;
      }

    }, {
      bottomLine: this.bottomLineFoundation,
      helperText: this.helperTextFoundation,
      icon: this.iconFoundation,
      label: this.labelFoundation,
      outline: this.outlineFoundation
    });

    this.foundation.init();
    this.foundation.setValue(this.value);
    this.foundation.setDisabled(this.disabled);
    this.foundation.setRequired(this.required);
    if (typeof this.valid !== "undefined") {
      this.foundation.setValid(this.valid);
    }

    if (this.textbox) {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation && this.foundation.destroy();
    this.bottomLineFoundation && this.bottomLineFoundation.destroy();
    this.helperTextFoundation && this.helperTextFoundation.destroy();
    this.iconFoundation && this.iconFoundation.destroy();
    this.labelFoundation && this.labelFoundation.destroy();
    this.outlineFoundation && this.outlineFoundation.destroy();
    this.ripple && this.ripple.destroy();
  }
};

var VueMDCTextfield = BasePlugin({
  mdcTextField: mdcTextField
});

var THEME_COLORS = ['primary', 'secondary', 'background', 'primary-light', 'secondary-light', 'secondary-dark', 'primary-dark'];

var THEME_STYLES = ['text-primary', 'text-secondary', 'text-hint', 'text-icon', 'text-disabled'];

var mdcTheme = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-theme", class: _vm.classes, attrs: { "tag": _vm.tag } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-theme',
  components: {
    CustomElement: CustomElement
  },
  props: {
    tag: { type: String, default: 'div' },
    color: String,
    background: String
  },
  computed: {
    classes: function classes() {
      var classes = {};

      if (this.color && THEME_COLORS.indexOf(this.color) !== -1) {
        classes['mdc-theme--' + this.color] = true;
      }

      if (this.background && THEME_COLORS.indexOf(this.background) !== -1) {
        classes['mdc-theme--' + this.background + '-bg'] = true;

        if (this.color && THEME_STYLES.indexOf(this.color) !== -1) {
          classes['mdc-theme--' + this.color + '-on-' + this.background] = true;
        }
      }
      return classes;
    }
  }
};

var VueMDCTheme = BasePlugin({
  mdcTheme: mdcTheme
});

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses$20 = {
  FIXED: 'mdc-toolbar--fixed',
  FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
  FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
  TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
  FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
  FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
  FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
};

var strings$22 = {
  TITLE_SELECTOR: '.mdc-toolbar__title',
  FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
  CHANGE_EVENT: 'MDCToolbar:change'
};

var numbers$6 = {
  MAX_TITLE_SIZE: 2.125,
  MIN_TITLE_SIZE: 1.25,
  TOOLBAR_ROW_HEIGHT: 64,
  TOOLBAR_ROW_MOBILE_HEIGHT: 56,
  TOOLBAR_MOBILE_BREAKPOINT: 600
};

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MDCToolbarFoundation = function (_MDCFoundation) {
  inherits(MDCToolbarFoundation, _MDCFoundation);
  createClass(MDCToolbarFoundation, null, [{
    key: 'cssClasses',
    get: function get$$1() {
      return cssClasses$20;
    }
  }, {
    key: 'strings',
    get: function get$$1() {
      return strings$22;
    }
  }, {
    key: 'numbers',
    get: function get$$1() {
      return numbers$6;
    }
  }, {
    key: 'defaultAdapter',
    get: function get$$1() {
      return {
        hasClass: function hasClass() {
          return (/* className: string */ /* boolean */false
          );
        },
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
        deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        getViewportWidth: function getViewportWidth() {
          return (/* number */0
          );
        },
        getViewportScrollY: function getViewportScrollY() {
          return (/* number */0
          );
        },
        getOffsetHeight: function getOffsetHeight() {
          return (/* number */0
          );
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          return (/* number */0
          );
        },
        notifyChange: function notifyChange() /* evtData: {flexibleExpansionRatio: number} */{},
        setStyle: function setStyle() /* property: string, value: string */{},
        setStyleForTitleElement: function setStyleForTitleElement() /* property: string, value: string */{},
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement() /* property: string, value: string */{},
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement() /* property: string, value: string */{}
      };
    }
  }]);

  function MDCToolbarFoundation(adapter) {
    classCallCheck(this, MDCToolbarFoundation);

    var _this = possibleConstructorReturn(this, (MDCToolbarFoundation.__proto__ || Object.getPrototypeOf(MDCToolbarFoundation)).call(this, _extends(MDCToolbarFoundation.defaultAdapter, adapter)));

    _this.resizeHandler_ = function () {
      return _this.checkRowHeight_();
    };
    _this.scrollHandler_ = function () {
      return _this.updateToolbarStyles_();
    };
    _this.checkRowHeightFrame_ = 0;
    _this.scrollFrame_ = 0;
    _this.executedLastChange_ = false;

    _this.calculations_ = {
      toolbarRowHeight: 0,
      // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
      toolbarRatio: 0, // The ratio of toolbar height to row height
      flexibleExpansionRatio: 0, // The ratio of flexible space height to row height
      maxTranslateYRatio: 0, // The ratio of max toolbar move up distance to row height
      scrollThresholdRatio: 0, // The ratio of max scrollTop that we should listen to to row height
      // Derived Heights based on the above key ratios.
      toolbarHeight: 0,
      flexibleExpansionHeight: 0, // Flexible row minus toolbar height (derived)
      maxTranslateYDistance: 0, // When toolbar only fix last row (derived)
      scrollThreshold: 0
    };
    // Toolbar fixed behavior
    // If toolbar is fixed
    _this.fixed_ = false;
    // If fixed is targeted only at the last row
    _this.fixedLastrow_ = false;
    // Toolbar flexible behavior
    // If the first row is flexible
    _this.hasFlexibleRow_ = false;
    // If use the default behavior
    _this.useFlexDefaultBehavior_ = false;
    return _this;
  }

  createClass(MDCToolbarFoundation, [{
    key: 'init',
    value: function init() {
      this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
      this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
      this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);
      if (this.hasFlexibleRow_) {
        this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
      }
      this.initKeyRatio_();
      this.setKeyHeights_();
      this.adapter_.registerResizeHandler(this.resizeHandler_);
      this.adapter_.registerScrollHandler(this.scrollHandler_);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      this.adapter_.deregisterScrollHandler(this.scrollHandler_);
    }
  }, {
    key: 'updateAdjustElementStyles',
    value: function updateAdjustElementStyles() {
      if (this.fixed_) {
        this.adapter_.setStyleForFixedAdjustElement('margin-top', this.calculations_.toolbarHeight + 'px');
      }
    }
  }, {
    key: 'getFlexibleExpansionRatio_',
    value: function getFlexibleExpansionRatio_(scrollTop) {
      // To prevent division by zero when there is no flexibleExpansionHeight
      var delta = 0.0001;
      return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
    }
  }, {
    key: 'checkRowHeight_',
    value: function checkRowHeight_() {
      var _this2 = this;

      cancelAnimationFrame(this.checkRowHeightFrame_);
      this.checkRowHeightFrame_ = requestAnimationFrame(function () {
        return _this2.setKeyHeights_();
      });
    }
  }, {
    key: 'setKeyHeights_',
    value: function setKeyHeights_() {
      var newToolbarRowHeight = this.getRowHeight_();
      if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
        this.calculations_.toolbarRowHeight = newToolbarRowHeight;
        this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
        this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
        this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
        this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
        this.updateAdjustElementStyles();
        this.updateToolbarStyles_();
      }
    }
  }, {
    key: 'updateToolbarStyles_',
    value: function updateToolbarStyles_() {
      var _this3 = this;

      cancelAnimationFrame(this.scrollFrame_);
      this.scrollFrame_ = requestAnimationFrame(function () {
        var scrollTop = _this3.adapter_.getViewportScrollY();
        var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

        if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
          return;
        }

        var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

        _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);
        if (_this3.fixedLastrow_) {
          _this3.updateToolbarFixedState_(scrollTop);
        }
        if (_this3.hasFlexibleRow_) {
          _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
        }
        _this3.executedLastChange_ = hasScrolledOutOfThreshold;
        _this3.adapter_.notifyChange({ flexibleExpansionRatio: flexibleExpansionRatio });
      });
    }
  }, {
    key: 'scrolledOutOfThreshold_',
    value: function scrolledOutOfThreshold_(scrollTop) {
      return scrollTop > this.calculations_.scrollThreshold;
    }
  }, {
    key: 'initKeyRatio_',
    value: function initKeyRatio_() {
      var toolbarRowHeight = this.getRowHeight_();
      var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
      this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
      this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
      this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
      this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
    }
  }, {
    key: 'getRowHeight_',
    value: function getRowHeight_() {
      var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
      return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
    }
  }, {
    key: 'updateToolbarFlexibleState_',
    value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
      this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
      this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
      if (flexibleExpansionRatio === 1) {
        this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
      } else if (flexibleExpansionRatio === 0) {
        this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
      }
    }
  }, {
    key: 'updateToolbarFixedState_',
    value: function updateToolbarFixedState_(scrollTop) {
      var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
      this.adapter_.setStyle('transform', 'translateY(' + -translateDistance + 'px)');

      if (translateDistance === this.calculations_.maxTranslateYDistance) {
        this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
      } else {
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
      }
    }
  }, {
    key: 'updateFlexibleRowElementStyles_',
    value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
      if (this.fixed_) {
        var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
        this.adapter_.setStyleForFlexibleRowElement('height', height + this.calculations_.toolbarRowHeight + 'px');
      }
      if (this.useFlexDefaultBehavior_) {
        this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
      }
    }
  }, {
    key: 'updateElementStylesDefaultBehavior_',
    value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
      var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
      var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
      var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;

      this.adapter_.setStyleForTitleElement('font-size', currentTitleSize + 'rem');
    }
  }]);
  return MDCToolbarFoundation;
}(MDCFoundation);

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var supportsPassive_$2 = void 0;

// Determine whether the current browser supports passive event listeners, and if so, use them.
function applyPassive$2() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_$2 === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_$2 = isSupported;
  }

  return supportsPassive_$2 ? { passive: true } : false;
}

var mdcToolbar = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', { staticClass: "mdc-toolbar-wrapper" }, [_c('div', { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, [_vm._t("default")], 2), _vm._v(" "), _vm.fixed || _vm.waterfall || _vm.fixedLastrow ? _c('div', { ref: "fixed-adjust", staticClass: "mdc-toolbar-fixed-adjust", style: _vm.adjustStyles }) : _vm._e()]);
  }, staticRenderFns: [],
  name: 'mdc-toolbar',
  props: {
    'fixed': Boolean,
    'waterfall': Boolean,
    'fixed-lastrow': Boolean,
    'flexible': Boolean,
    'flexible-default': { type: Boolean, default: true }
  },
  data: function data() {
    return {
      rootClasses: {
        'mdc-toolbar': true,
        'mdc-toolbar--fixed': this.fixed || this.waterfall || this.fixedLastrow,
        'mdc-toolbar--waterfall': this.waterfall,
        'mdc-toolbar--fixed-lastrow-only': this.fixedLastrow,
        'mdc-toolbar--flexible': this.flexible,
        'mdc-toolbar--flexible-default-behavior': this.flexible && this.flexibleDefault
      },
      rootStyles: {},
      adjustStyles: {
        // to avoid top margin collapse with :after el
        // 0.1 px should be rounded to 0px
        // TODO: find a better trick
        // height: '0.1px'
      },
      foundation: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.foundation = new MDCToolbarFoundation({
      addClass: function addClass(className) {
        _this.$set(_this.rootClasses, className, true);
      },
      removeClass: function removeClass(className) {
        _this.$delete(_this.rootClasses, className);
      },
      hasClass: function hasClass(className) {
        return _this.$refs.root.classList.contains(className);
      },
      registerScrollHandler: function registerScrollHandler(handler) {
        window.addEventListener('scroll', handler, applyPassive$2());
      },
      deregisterScrollHandler: function deregisterScrollHandler(handler) {
        window.removeEventListener('scroll', handler, applyPassive$2());
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        window.removeEventListener('resize', handler);
      },
      getViewportWidth: function getViewportWidth() {
        return window.innerWidth;
      },
      getViewportScrollY: function getViewportScrollY() {
        return window.pageYOffset;
      },
      getOffsetHeight: function getOffsetHeight() {
        return _this.$refs.root.offsetHeight;
      },
      getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
        var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
        return el ? el.offsetHeight : undefined;
      },
      notifyChange: function notifyChange(evtData) {
        _this.$emit('change', evtData);
      },
      setStyle: function setStyle(property, value) {
        _this.$set(_this.rootStyles, property, value);
      },
      setStyleForTitleElement: function setStyleForTitleElement(property, value) {
        var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);
        if (el) el.style.setProperty(property, value);
      },
      setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
        var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
        if (el) el.style.setProperty(property, value);
      },
      setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
        _this.$set(_this.adjustStyles, property, value);
      }
    });
    this.foundation.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.foundation.destroy();
  }
};

var mdcToolbarRow = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-toolbar-row mdc-toolbar__row" }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-row'
};

var mdcToolbarSection = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-toolbar-section mdc-toolbar__section", class: _vm.classes }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-section',
  props: {
    'align-start': Boolean,
    'align-end': Boolean,
    'shrink-to-fit': Boolean
  },
  data: function data() {
    return {
      classes: {
        'mdc-toolbar__section--align-start': this.alignStart,
        'mdc-toolbar__section--align-end': this.alignEnd,
        'mdc-toolbar__section--shrink-to-fit': this.shrinkToFit
      }
    };
  }
};

var mdcToolbarMenuIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-menu-icon mdc-toolbar__menu-icon", class: { 'material-icons': !!_vm.icon }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-menu-icon',
  mixins: [DispatchEventMixin],
  props: {
    icon: { type: String, 'default': "menu" }
  }
};

var mdcToolbarTitle = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-title mdc-toolbar__title", on: { "click": _vm.dispatchEvent } }, [_vm._t("default")], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-title',
  mixins: [DispatchEventMixin]
};

var mdcToolbarIcon = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', { staticClass: "mdc-toolbar-icon mdc-toolbar__icon", class: { 'material-icons': !!_vm.icon }, on: { "click": _vm.dispatchEvent } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
  }, staticRenderFns: [],
  name: 'mdc-toolbar-icon',
  mixins: [DispatchEventMixin],
  props: {
    icon: String
  }
};

var VueMDCToolbar = BasePlugin({
  mdcToolbar: mdcToolbar,
  mdcToolbarRow: mdcToolbarRow,
  mdcToolbarSection: mdcToolbarSection,
  mdcToolbarMenuIcon: mdcToolbarMenuIcon,
  mdcToolbarTitle: mdcToolbarTitle,
  mdcToolbarIcon: mdcToolbarIcon
});

var typos = ['display4', 'display3', 'display2', 'display1', 'headline', 'title', 'subheading1', 'subheading2', 'body1', 'body2', 'caption', 'button'];

var mdcTypoMixin = function mdcTypoMixin(name) {
  return {
    render: function render(createElement) {
      var _class;

      return createElement(this.tag, {
        'class': (_class = {
          'mdc-typo': true
        }, defineProperty(_class, name, true), defineProperty(_class, 'mdc-typography--' + this.typo, true), defineProperty(_class, 'mdc-typography--adjust-margin', this.adjustMargin), _class),
        'attrs': this.$attrs,
        'on': this.$listeners
      }, this.$slots.default);
    }
  };
};

function mdcTypoPropMixin(defaultTag, defaultTypo, validTypos) {
  return {
    props: {
      'tag': {
        type: String,
        default: defaultTag
      },
      'typo': {
        type: String,
        default: defaultTypo,
        validator: function validator(value) {
          return validTypos.indexOf(value) !== -1;
        }
      },
      'adjust-margin': {
        type: Boolean,
        default: false
      }
    }
  };
}

var mdcTextSection = {
  name: 'mdc-text-section',
  props: {
    'tag': {
      type: String,
      default: 'section'
    }
  },
  render: function render(createElement) {
    return createElement(this.tag, {
      'class': {
        'mdc-typography': true,
        'mdc-text-section': true
      },
      'attrs': this.$attrs,
      'on': this.$listeners
    }, this.$slots.default);
  }
};

var mdcText = {
  name: 'mdc-text',
  mixins: [mdcTypoMixin('mdc-text'), mdcTypoPropMixin('p', 'body1', typos)]
};

var mdcDisplay = {
  name: 'mdc-display',
  mixins: [mdcTypoMixin('mdc-display'), mdcTypoPropMixin('h1', 'display1', ['display4', 'display3', 'display2', 'display1'])]
};

var mdcHeadline = {
  name: 'mdc-headline',
  mixins: [mdcTypoMixin('mdc-headline'), mdcTypoPropMixin('h2', 'headline', ['headline'])]
};

var mdcTitle = {
  name: 'mdc-title',
  mixins: [mdcTypoMixin('mdc-title'), mdcTypoPropMixin('h3', 'title', ['title'])]
};

var mdcSubHeading = {
  name: 'mdc-subheading',
  mixins: [mdcTypoMixin('mdc-subheading'), mdcTypoPropMixin('h4', 'subheading2', ['subheading1', 'subheading2'])]
};

var mdcBody = {
  name: 'mdc-body',
  mixins: [mdcTypoMixin('mdc-body'), mdcTypoPropMixin('p', 'body1', ['body1', 'body2'])]
};

var mdcCaption = {
  name: 'mdc-caption',
  mixins: [mdcTypoMixin('mdc-caption'), mdcTypoPropMixin('span', 'caption', ['caption'])]
};

var VueMDCTypography = BasePlugin({
  mdcTextSection: mdcTextSection,
  mdcText: mdcText,
  mdcBody: mdcBody,
  mdcCaption: mdcCaption,
  mdcDisplay: mdcDisplay,
  mdcHeadline: mdcHeadline,
  mdcSubHeading: mdcSubHeading,
  mdcTitle: mdcTitle
});

//
// vue PlugIn
//
var plugin = {
  version: '0.11.2',
  install: function install(vm) {
    vm.use(VueMDCButton);
    vm.use(VueMDCCard);
    vm.use(VueMDCCheckbox);
    vm.use(VueMDCChipSet);
    vm.use(VueMDCDialog);
    vm.use(VueMDCDrawer);
    vm.use(VueMDCElevation);
    vm.use(VueMDCFab);
    vm.use(VueMDCGridList);
    vm.use(VueMDCIcon);
    vm.use(VueMDCIconToggle);
    vm.use(VueMDCLayoutApp);
    vm.use(VueMDCLayoutGrid);
    vm.use(VueMDCLinearProgress);
    vm.use(VueMDCList);
    vm.use(VueMDCMenu);
    vm.use(VueMDCRadio);
    vm.use(VueMDCRipple);
    vm.use(VueMDCSelect);
    vm.use(VueMDCSlider);
    vm.use(VueMDCSnackbar);
    vm.use(VueMDCSwitch);
    vm.use(VueMDCTabs);
    vm.use(VueMDCTextfield);
    vm.use(VueMDCTheme);
    vm.use(VueMDCToolbar);
    vm.use(VueMDCTypography);
  }
};

autoInit(plugin);

return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1kYy1hZGFwdGVyLmpzIiwic291cmNlcyI6WyIuLi9jb21wb25lbnRzL2Jhc2UvYXV0by1pbml0LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Jhc2UtcGx1Z2luLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1lbGVtZW50LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1saW5rLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1ldmVudC5qcyIsIi4uL2NvbXBvbmVudHMvYmFzZS9jdXN0b20tYnV0dG9uLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1pY29uLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Rpc3BhdGNoLWV2ZW50LW1peGluLmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2Rpc3BhdGNoLWZvY3VzLW1peGluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLWJhc2UuanMiLCIuLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9idXR0b24vbWRjLWJ1dHRvbi1iYXNlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvYnV0dG9uL21kYy1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9idXR0b24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1tZWRpYS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtaGVhZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC10aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtc3VidGl0bGUudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXRleHQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24taWNvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L21kYy1jaGVja2JveC52dWUiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2NoaXBzL21kYy1jaGlwLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9jaGlwcy9tZGMtY2hpcC1zZXQudnVlIiwiLi4vY29tcG9uZW50cy9jaGlwcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL3V0aWwuanMiLCIuLi9jb21wb25lbnRzL2RpYWxvZy9tZGMtZGlhbG9nLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZGlhbG9nL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcm1hbmVudC1kcmF3ZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXBlcnNpc3RlbnQtZHJhd2VyLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy10ZW1wb3JhcnktZHJhd2VyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1sYXlvdXQudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2VsZXZhdGlvbi9tZGMtZWxldmF0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZWxldmF0aW9uL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9mYWIvbWRjLWZhYi52dWUiLCIuLi9jb21wb25lbnRzL2ZhYi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZ3JpZC1saXN0L2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2dyaWQtbGlzdC9tZGMtZ3JpZC1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvZ3JpZC1saXN0L21kYy1ncmlkLXRpbGUudnVlIiwiLi4vY29tcG9uZW50cy9ncmlkLWxpc3QvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2ljb24vbWRjLWljb24udnVlIiwiLi4vY29tcG9uZW50cy9pY29uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL21kYy1pY29uLXRvZ2dsZS52dWUiLCIuLi9jb21wb25lbnRzL2ljb24tdG9nZ2xlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtYXBwL21kYy1sYXlvdXQtYXBwLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWFwcC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1jZWxsLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvbWRjLWxheW91dC1pbm5lci1ncmlkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWdyaWQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmVhci1wcm9ncmVzcy9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9saW5lYXItcHJvZ3Jlc3MvbWRjLWxpbmVhci1wcm9ncmVzcy52dWUiLCIuLi9jb21wb25lbnRzL2xpbmVhci1wcm9ncmVzcy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtaXRlbS52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWdyb3VwLWhlYWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAtZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS1hbmNob3IudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yYWRpby9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3JhZGlvL21kYy1yYWRpby52dWUiLCIuLi9jb21wb25lbnRzL3JhZGlvL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW5hdGl2ZS1zZWxlY3QudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2xhYmVsL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9sYWJlbC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9sYWJlbC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW1lbnUtc2VsZWN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1tdWx0aS1zZWxlY3QudnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLXNlbGVjdC52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtbmF0aXZlLW9wdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtbWVudS1vcHRpb24udnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLW11bHRpLW9wdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtb3B0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NsaWRlci9tZGMtc2xpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2xpZGVyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbmFja2Jhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NuYWNrYmFyL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NuYWNrYmFyL21kYy1zbmFja2Jhci52dWUiLCIuLi9jb21wb25lbnRzL3NuYWNrYmFyL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9zd2l0Y2gvbWRjLXN3aXRjaC52dWUiLCIuLi9jb21wb25lbnRzL3N3aXRjaC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFicy90YWIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90YWJzL21kYy10YWIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi1iYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi1iYXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdGFicy9tZGMtdGFiLWJhci52dWUiLCIuLi9jb21wb25lbnRzL3RhYnMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9sYWJlbC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvbGFiZWwvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvbGFiZWwvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL291dGxpbmUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL291dGxpbmUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvb3V0bGluZS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RleHRmaWVsZC9tZGMtdGV4dGZpZWxkLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGV4dGZpZWxkL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy90aGVtZS9tZGMtdGhlbWUudnVlIiwiLi4vY29tcG9uZW50cy90aGVtZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9vbGJhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9vbGJhci91dGlsLmpzIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci1yb3cudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLXNlY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLW1lbnUtaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItdGl0bGUudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLWljb24udnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L21kYy10eXBvZ3JhcGh5LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGF1dG9Jbml0IChwbHVnaW4pIHtcbiAgLy8gQXV0by1pbnN0YWxsXG4gIGxldCBfVnVlID0gbnVsbFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfVnVlID0gd2luZG93LlZ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLypnbG9iYWwgZ2xvYmFsKi9cbiAgICBfVnVlID0gZ2xvYmFsLlZ1ZVxuICB9XG4gIGlmIChfVnVlKSB7XG4gICAgX1Z1ZS51c2UocGx1Z2luKVxuICB9XG59XG4gICIsImV4cG9ydCBmdW5jdGlvbiBCYXNlUGx1Z2luIChjb21wb25lbnRzKSB7IFxuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdfX1ZFUlNJT05fXycsXG4gICAgaW5zdGFsbDogKHZtKSA9PiB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1trZXldXG4gICAgICAgICAgdm0uY29tcG9uZW50KGNvbXBvbmVudC5uYW1lLGNvbXBvbmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHNcbiAgfSBcbn1cblxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlciAoY3JlYXRlRWxlbWVudCwgY29udGV4dCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgY29udGV4dC5wcm9wcy5pcyB8fCBjb250ZXh0LnByb3BzLnRhZyB8fCAnZGl2JywgXG4gICAgICBjb250ZXh0LmRhdGEsXG4gICAgICBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21FbGVtZW50TWl4aW4gPSB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21FbGVtZW50XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBDdXN0b21MaW5rID0ge1xuICBuYW1lOiAnY3VzdG9tLWxpbmsnLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHRhZzogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdhJyB9LFxuICAgIGxpbmsgOiBPYmplY3QsXG4gIH0sXG4gIHJlbmRlciAoaCwgY29udGV4dCkge1xuICAgIGxldCBlbGVtZW50IFxuICAgIGxldCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5kYXRhKVxuXG4gICAgaWYgKGNvbnRleHQucHJvcHMubGluayAmJiBjb250ZXh0LnBhcmVudC4kcm91dGVyKSB7XG4gICAgICAvLyByb3V0ZXItbGluayBjYXNlXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wYXJlbnQuJHJvb3QuJG9wdGlvbnMuY29tcG9uZW50c1sncm91dGVyLWxpbmsnXSBcbiAgICAgIGRhdGEucHJvcHMgPSBPYmplY3QuYXNzaWduKHt0YWc6IGNvbnRleHQucHJvcHMudGFnfSwgY29udGV4dC5wcm9wcy5saW5rKVxuICAgICAgaWYgKGRhdGEub24uY2xpY2spIHtcbiAgICAgICAgZGF0YS5uYXRpdmVPbiA9IHtjbGljazogZGF0YS5vbi5jbGljayB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVsZW1lbnQgZmFsbGJhY2tcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnByb3BzLnRhZyBcbiAgICB9IFxuXG4gICAgcmV0dXJuIGgoZWxlbWVudCwgZGF0YSwgY29udGV4dC5jaGlsZHJlbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tTGlua01peGluID0ge1xuICBwcm9wczoge1xuICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGxpbmsgKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG8gJiYge1xuICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgIGFwcGVuZDogdGhpcy5hcHBlbmQsXG4gICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcbiAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgIGV4YWN0QWN0aXZlQ2xhc3M6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcyxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHMgOiB7IFxuICAgIEN1c3RvbUxpbmsgXG4gIH1cbn0iLCIvKiBnbG9iYWwgQ3VzdG9tRXZlbnQgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRDdXN0b21FdmVudCAoZWwsIGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gIGxldCBldnRcbiAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICBidWJibGVzOiBzaG91bGRCdWJibGVcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKVxuICB9XG4gIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KVxufVxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUJ1dHRvbiA9IHtcbiAgbmFtZTogJ2N1c3RvbS1idXR0b24nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGxpbmsgOiBPYmplY3QsXG4gIH0sXG4gIHJlbmRlciAoaCwgY29udGV4dCkge1xuICAgIGxldCBlbGVtZW50IFxuICAgIGxldCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5kYXRhKVxuXG4gICAgaWYgKGNvbnRleHQucHJvcHMubGluayAmJiBjb250ZXh0LnBhcmVudC4kcm91dGVyKSB7XG4gICAgICAvLyByb3V0ZXItbGluayBjYXNlXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wYXJlbnQuJHJvb3QuJG9wdGlvbnMuY29tcG9uZW50c1sncm91dGVyLWxpbmsnXSBcbiAgICAgIGRhdGEucHJvcHMgPSBPYmplY3QuYXNzaWduKHt0YWc6IGNvbnRleHQucHJvcHMudGFnfSwgY29udGV4dC5wcm9wcy5saW5rKVxuICAgICAgZGF0YS5hdHRycy5yb2xlID0gJ2J1dHRvbidcbiAgICAgIGlmIChkYXRhLm9uLmNsaWNrKSB7XG4gICAgICAgIGRhdGEubmF0aXZlT24gPSB7Y2xpY2s6IGRhdGEub24uY2xpY2sgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLmhyZWYpIHtcbiAgICAgIC8vIGhyZWYgY2FzZVxuICAgICAgZWxlbWVudCA9ICdhJyBcbiAgICAgIGRhdGEuYXR0cnMucm9sZSA9ICdidXR0b24nXG4gICAgfSAgZWxzZSB7XG4gICAgICAvLyBidXR0b24gZmFsbGJhY2tcbiAgICAgIGVsZW1lbnQgPSAnYnV0dG9uJ1xuICAgIH0gXG5cbiAgICByZXR1cm4gaChlbGVtZW50LCBkYXRhLCBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21CdXR0b25NaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgdG86IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGluayAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50byAmJiB7XG4gICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICBleGFjdDogdGhpcy5leGFjdCxcbiAgICAgICAgYXBwZW5kOiB0aGlzLmFwcGVuZCxcbiAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgICBhY3RpdmVDbGFzczogdGhpcy5hY3RpdmVDbGFzcyxcbiAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzLFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50cyA6IHsgXG4gICAgQ3VzdG9tQnV0dG9uIFxuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdEljb25Qcm9wIChpY29uUHJvcCkge1xuICAgIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc2VzOiB7ICdtYXRlcmlhbC1pY29ucycgOiB0cnVlfSxcbiAgICAgICAgY29udGVudDogaWNvblByb3AgXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGljb25Qcm9wIGluc3RhbmNlb2YgQXJyYXkpe1xuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIGNsYXNzZXM6IGljb25Qcm9wLnJlZHVjZShcbiAgICAgICAgICAocmVzdWx0LCB2YWx1ZSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQse1t2YWx1ZV06dHJ1ZX0pLFxuICAgICAgICAgIHt9KSxcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaWNvblByb3AgPT09ICdvYmplY3QnKXtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBjbGFzc2VzOiBpY29uUHJvcC5jbGFzc05hbWUuc3BsaXQoJyAnKS5yZWR1Y2UoXG4gICAgICAgICAgKHJlc3VsdCwgdmFsdWUpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LHtbdmFsdWVdOnRydWV9KSxcbiAgICAgICAgICB7fSksXG4gICAgICAgIGNvbnRlbnQ6IGljb25Qcm9wLnRleHRDb250ZW50IFxuICAgICAgfVxuICAgIH1cbiAgfVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRXZlbnRNaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICAnZXZlbnQnOiBTdHJpbmcsXG4gICAgJ2V2ZW50LXRhcmdldCc6IE9iamVjdCxcbiAgICAnZXZlbnQtYXJncyc6IEFycmF5LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZGlzcGF0Y2hFdmVudCAoZXZ0KSB7XG4gICAgICB0aGlzLiRlbWl0KGV2dC50eXBlKVxuICAgICAgaWYgKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZXZlbnRUYXJnZXQgfHwgdGhpcy4kcm9vdFxuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZXZlbnRBcmdzIHx8IFtdXG4gICAgICAgIHRhcmdldC4kZW1pdCh0aGlzLmV2ZW50LCAuLi5hcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRm9jdXNNaXhpbiA9IHtcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuICB7aGFzRm9jdXM6IGZhbHNlfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlXG4gICAgfSxcbiAgICBvbk1vdXNlVXAgKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2VcbiAgICB9LFxuICAgIG9uRm9jdXNFdmVudCAoKSB7XG4gICAgICAvLyBkaXNwYXRjaCBhc3luYyB0byBsZXQgdGltZSB0byBvdGhlciBmb2N1cyBldmVudCB0byBwcm9wYWdhdGVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwwKVxuICAgIH0sXG4gICAgb25CbHVyRXZlbnQgKCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICAvLyBhbHNvIGZpbHR1ciBibHVyIGlmIG1vdXNlZG93blxuICAgICAgdGhpcy5fYWN0aXZlIHx8IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwwKVxuICAgIH0sXG4gICAgZGlzcGF0Y2hGb2N1c0V2ZW50KCkge1xuICAgICAgbGV0IGhhc0ZvY3VzID0gdGhpcy4kZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgdGhpcy4kZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICBpZiAoaGFzRm9jdXMgIT0gdGhpcy5oYXNGb2N1cykge1xuICAgICAgICB0aGlzLiRlbWl0KGhhc0ZvY3VzID8gJ2ZvY3VzJyA6ICdibHVyJylcbiAgICAgICAgdGhpcy5oYXNGb2N1cyA9IGhhc0ZvY3VzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBSaXBwbGUuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gQ1NTIHZhcmlhYmxlc1xuICogLSBwb3NpdGlvblxuICogLSBkaW1lbnNpb25zXG4gKiAtIHNjcm9sbCBwb3NpdGlvblxuICogLSBldmVudCBoYW5kbGVyc1xuICogLSB1bmJvdW5kZWQsIGFjdGl2ZSBhbmQgZGlzYWJsZWQgc3RhdGVzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENSaXBwbGVBZGFwdGVyIHtcbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1VuYm91bmRlZCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzU3VyZmFjZUFjdGl2ZSgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzU3VyZmFjZURpc2FibGVkKCkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudFRhcmdldH0gdGFyZ2V0ICovXG4gIGNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFyTmFtZVxuICAgKiBAcGFyYW0gez9udW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgdXBkYXRlQ3NzVmFyaWFibGUodmFyTmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqIEByZXR1cm4geyFDbGllbnRSZWN0fSAqL1xuICBjb21wdXRlQm91bmRpbmdSZWN0KCkge31cblxuICAvKiogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gKi9cbiAgZ2V0V2luZG93UGFnZU9mZnNldCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JpcHBsZUFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgLy8gUmlwcGxlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHRoZSBcInJvb3RcIiBjb21wb25lbnQgaXMgcmVhbGx5IGEgXCJtaXhpblwiIG9mIHNvcnRzLFxuICAvLyBnaXZlbiB0aGF0IGl0J3MgYW4gJ3VwZ3JhZGUnIHRvIGFuIGV4aXN0aW5nIGNvbXBvbmVudC4gVGhhdCBiZWluZyBzYWlkIGl0IGlzIHRoZSByb290XG4gIC8vIENTUyBjbGFzcyB0aGF0IGFsbCBvdGhlciBDU1MgY2xhc3NlcyBkZXJpdmUgZnJvbS5cbiAgUk9PVDogJ21kYy1yaXBwbGUtdXBncmFkZWQnLFxuICBVTkJPVU5ERUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS11bmJvdW5kZWQnLFxuICBCR19GT0NVU0VEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tYmFja2dyb3VuZC1mb2N1c2VkJyxcbiAgRkdfQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtYWN0aXZhdGlvbicsXG4gIEZHX0RFQUNUSVZBVElPTjogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWZvcmVncm91bmQtZGVhY3RpdmF0aW9uJyxcbn07XG5cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFZBUl9MRUZUOiAnLS1tZGMtcmlwcGxlLWxlZnQnLFxuICBWQVJfVE9QOiAnLS1tZGMtcmlwcGxlLXRvcCcsXG4gIFZBUl9GR19TSVpFOiAnLS1tZGMtcmlwcGxlLWZnLXNpemUnLFxuICBWQVJfRkdfU0NBTEU6ICctLW1kYy1yaXBwbGUtZmctc2NhbGUnLFxuICBWQVJfRkdfVFJBTlNMQVRFX1NUQVJUOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1zdGFydCcsXG4gIFZBUl9GR19UUkFOU0xBVEVfRU5EOiAnLS1tZGMtcmlwcGxlLWZnLXRyYW5zbGF0ZS1lbmQnLFxufTtcblxuY29uc3QgbnVtYmVycyA9IHtcbiAgUEFERElORzogMTAsXG4gIElOSVRJQUxfT1JJR0lOX1NDQUxFOiAwLjYsXG4gIERFQUNUSVZBVElPTl9USU1FT1VUX01TOiAyMjUsIC8vIENvcnJlc3BvbmRzIHRvICRtZGMtcmlwcGxlLXRyYW5zbGF0ZS1kdXJhdGlvbiAoaS5lLiBhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgRkdfREVBQ1RJVkFUSU9OX01TOiAxNTAsIC8vIENvcnJlc3BvbmRzIHRvICRtZGMtcmlwcGxlLWZhZGUtb3V0LWR1cmF0aW9uIChpLmUuIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXG4gIFRBUF9ERUxBWV9NUzogMzAwLCAvLyBEZWxheSBiZXR3ZWVuIHRvdWNoIGFuZCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIG9uIHRvdWNoIGRldmljZXNcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBTdG9yZXMgcmVzdWx0IGZyb20gc3VwcG9ydHNDc3NWYXJpYWJsZXMgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IENTUyBjdXN0b20gdmFyaWFibGUgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcblxuLyoqXG4gKiBTdG9yZXMgcmVzdWx0IGZyb20gYXBwbHlQYXNzaXZlIHRvIGF2b2lkIHJlZHVuZGFudCBwcm9jZXNzaW5nIHRvIGRldGVjdCBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIHN1cHBvcnQuXG4gKiBAcHJpdmF0ZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmxldCBzdXBwb3J0c1Bhc3NpdmVfO1xuXG4vKipcbiAqIEBwYXJhbSB7IVdpbmRvd30gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBkZXRlY3RFZGdlUHNldWRvVmFyQnVnKHdpbmRvd09iaikge1xuICAvLyBEZXRlY3QgdmVyc2lvbnMgb2YgRWRnZSB3aXRoIGJ1Z2d5IHZhcigpIHN1cHBvcnRcbiAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMTQ5NTQ0OC9cbiAgY29uc3QgZG9jdW1lbnQgPSB3aW5kb3dPYmouZG9jdW1lbnQ7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbm9kZS5jbGFzc05hbWUgPSAnbWRjLXJpcHBsZS1zdXJmYWNlLS10ZXN0LWVkZ2UtdmFyLWJ1Zyc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7XG5cbiAgLy8gVGhlIGJ1ZyBleGlzdHMgaWYgOjpiZWZvcmUgc3R5bGUgZW5kcyB1cCBwcm9wYWdhdGluZyB0byB0aGUgcGFyZW50IGVsZW1lbnQuXG4gIC8vIEFkZGl0aW9uYWxseSwgZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIG51bGwgaW4gaWZyYW1lcyB3aXRoIGRpc3BsYXk6IFwibm9uZVwiIGluIEZpcmVmb3gsXG4gIC8vIGJ1dCBGaXJlZm94IGlzIGtub3duIHRvIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzIGNvcnJlY3RseS5cbiAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvd09iai5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICBjb25zdCBoYXNQc2V1ZG9WYXJCdWcgPSBjb21wdXRlZFN0eWxlICE9PSBudWxsICYmIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wU3R5bGUgPT09ICdzb2xpZCc7XG4gIG5vZGUucmVtb3ZlKCk7XG4gIHJldHVybiBoYXNQc2V1ZG9WYXJCdWc7XG59XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlUmVmcmVzaFxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93T2JqLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9PT0gJ2Jvb2xlYW4nICYmICFmb3JjZVJlZnJlc2gpIHtcbiAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXNfID0gIWRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xufVxuXG4vL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IEhUTUxFbGVtZW50UHJvdG90eXBlXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlKSB7XG4gIHJldHVybiBbXG4gICAgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdtYXRjaGVzJyxcbiAgXS5maWx0ZXIoKHApID0+IHAgaW4gSFRNTEVsZW1lbnRQcm90b3R5cGUpLnBvcCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUV2ZW50fSBldlxuICogQHBhcmFtIHshe3g6IG51bWJlciwgeTogbnVtYmVyfX0gcGFnZU9mZnNldFxuICogQHBhcmFtIHshQ2xpZW50UmVjdH0gY2xpZW50UmVjdFxuICogQHJldHVybiB7IXt4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gKi9cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyhldiwgcGFnZU9mZnNldCwgY2xpZW50UmVjdCkge1xuICBjb25zdCB7eCwgeX0gPSBwYWdlT2Zmc2V0O1xuICBjb25zdCBkb2N1bWVudFggPSB4ICsgY2xpZW50UmVjdC5sZWZ0O1xuICBjb25zdCBkb2N1bWVudFkgPSB5ICsgY2xpZW50UmVjdC50b3A7XG5cbiAgbGV0IG5vcm1hbGl6ZWRYO1xuICBsZXQgbm9ybWFsaXplZFk7XG4gIC8vIERldGVybWluZSB0b3VjaCBwb2ludCByZWxhdGl2ZSB0byB0aGUgcmlwcGxlIGNvbnRhaW5lci5cbiAgaWYgKGV2LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgIG5vcm1hbGl6ZWRYID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfSBlbHNlIHtcbiAgICBub3JtYWxpemVkWCA9IGV2LnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYucGFnZVkgLSBkb2N1bWVudFk7XG4gIH1cblxuICByZXR1cm4ge3g6IG5vcm1hbGl6ZWRYLCB5OiBub3JtYWxpemVkWX07XG59XG5cbmV4cG9ydCB7c3VwcG9ydHNDc3NWYXJpYWJsZXMsIGFwcGx5UGFzc2l2ZSwgZ2V0TWF0Y2hlc1Byb3BlcnR5LCBnZXROb3JtYWxpemVkRXZlbnRDb29yZHN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1JpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtnZXROb3JtYWxpemVkRXZlbnRDb29yZHN9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGlzQWN0aXZhdGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgYWN0aXZhdGlvbkV2ZW50OiBFdmVudCxcbiAqICAgaXNQcm9ncmFtbWF0aWM6IChib29sZWFufHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBBY3RpdmF0aW9uU3RhdGVUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICBhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBkZWFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGZvY3VzOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGJsdXI6IChzdHJpbmd8dW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVySW5mb1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGFjdGl2YXRlOiBmdW5jdGlvbighRXZlbnQpLFxuICogICBkZWFjdGl2YXRlOiBmdW5jdGlvbighRXZlbnQpLFxuICogICBmb2N1czogZnVuY3Rpb24oKSxcbiAqICAgYmx1cjogZnVuY3Rpb24oKVxuICogfX1cbiAqL1xubGV0IExpc3RlbmVyc1R5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIHg6IG51bWJlcixcbiAqICAgeTogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgUG9pbnRUeXBlO1xuXG4vLyBBY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIHRoZSByb290IGVsZW1lbnQgb2YgZWFjaCBpbnN0YW5jZSBmb3IgYWN0aXZhdGlvblxuY29uc3QgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93biddO1xuXG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbmNvbnN0IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gWyd0b3VjaGVuZCcsICdwb2ludGVydXAnLCAnbW91c2V1cCddO1xuXG4vLyBUcmFja3MgYWN0aXZhdGlvbnMgdGhhdCBoYXZlIG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGZyYW1lLCB0byBhdm9pZCBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG4vKiogQHR5cGUgeyFBcnJheTwhRXZlbnRUYXJnZXQ+fSAqL1xubGV0IGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmlwcGxlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gLyogYm9vbGVhbiAtIGNhY2hlZCAqLyB7fSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKC8qIHRhcmdldDogIUV2ZW50VGFyZ2V0ICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyB7fSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IC8qIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gKi8ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUNsaWVudFJlY3R9ICovXG4gICAgdGhpcy5mcmFtZV8gPSAvKiogQHR5cGUgeyFDbGllbnRSZWN0fSAqLyAoe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5hY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5kZWFjdGl2YXRlXyhlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgKCkgPT4gdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRClcbiAgICApO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQ9KX0gKi9cbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICgpID0+IHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpXG4gICAgKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshe2xlZnQ6IG51bWJlciwgdG9wOm51bWJlcn19ICovXG4gICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ1NjYWxlXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHs/RXZlbnR9ICovXG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHdlIGFyZSBub3QgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudFxuICAgKiB1bnRpbCB0aGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0aGUgZm91bmRhdGlvbiByZXF1ZXN0cyBpdC4gVGhpcyBwcmV2ZW50cyBzY2VuYXJpb3Mgd2hlcmVcbiAgICogY2xpZW50LXNpZGUgZmVhdHVyZS1kZXRlY3Rpb24gbWF5IGhhcHBlbiB0b28gZWFybHksIHN1Y2ggYXMgd2hlbiBjb21wb25lbnRzIGFyZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG4gICAqIGFuZCB0aGVuIGluaXRpYWxpemVkIGF0IG1vdW50IHRpbWUgb24gdGhlIGNsaWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzU3VwcG9ydGVkXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5icm93c2VyU3VwcG9ydHNDc3NWYXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9XG4gICAqL1xuICBkZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IGZhbHNlLFxuICAgICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiBmYWxzZSxcbiAgICAgIHdhc0VsZW1lbnRNYWRlQWN0aXZlOiBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb25FdmVudDogbnVsbCxcbiAgICAgIGlzUHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpc3RlclJvb3RIYW5kbGVyc18oKTtcblxuICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFJPT1QpO1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpO1xuICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuXG4gICAgY29uc3Qge1JPT1QsIFVOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoUk9PVCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgICB0aGlzLnJlbW92ZUNzc1ZhcnNfKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW1vdmVDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7c3RyaW5nc30gPSBNRENSaXBwbGVGb3VuZGF0aW9uO1xuICAgIE9iamVjdC5rZXlzKHN0cmluZ3MpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChrLmluZGV4T2YoJ1ZBUl8nKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKHN0cmluZ3Nba10sIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY3RpdmF0ZV8oZSkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZURpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIHJlYWN0aW5nIHRvIGZvbGxvdy1vbiBldmVudHMgZmlyZWQgYnkgdG91Y2ggZGV2aWNlIGFmdGVyIGFuIGFscmVhZHktcHJvY2Vzc2VkIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjb25zdCBwcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfO1xuICAgIGNvbnN0IGlzU2FtZUludGVyYWN0aW9uID0gcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgJiYgZSAmJiBwcmV2aW91c0FjdGl2YXRpb25FdmVudC50eXBlICE9PSBlLnR5cGU7XG4gICAgaWYgKGlzU2FtZUludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBlID09PSBudWxsO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5hY3RpdmF0aW9uRXZlbnQgPSBlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPyBmYWxzZSA6IChcbiAgICAgIGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAncG9pbnRlcmRvd24nXG4gICAgKTtcblxuICAgIGNvbnN0IGhhc0FjdGl2YXRlZENoaWxkID1cbiAgICAgIGUgJiYgYWN0aXZhdGVkVGFyZ2V0cy5sZW5ndGggPiAwICYmIGFjdGl2YXRlZFRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSk7XG4gICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5wdXNoKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZS50YXJnZXQpKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oZSk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgd3JhcHBlZCBpbiBhbiByQUYgY2FsbCBiL2Mgd2ViIGJyb3dzZXJzXG4gICAgICAvLyByZXBvcnQgYWN0aXZlIHN0YXRlcyBpbmNvbnNpc3RlbnRseSB3aGVuIHRoZXkncmUgY2FsbGVkIHdpdGhpblxuICAgICAgLy8gZXZlbnQgaGFuZGxpbmcgY29kZTpcbiAgICAgIC8vIC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjM1OTcxXG4gICAgICAvLyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTM3NDFcbiAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IChlICYmIGUudHlwZSA9PT0gJ2tleWRvd24nKSA/IHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlQWN0aXZlKCkgOiB0cnVlO1xuICAgICAgaWYgKGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzZXQgYWN0aXZhdGlvbiBzdGF0ZSBpbW1lZGlhdGVseSBpZiBlbGVtZW50IHdhcyBub3QgbWFkZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgYXJyYXkgb24gbmV4dCBmcmFtZSBhZnRlciB0aGUgY3VycmVudCBldmVudCBoYXMgaGFkIGEgY2hhbmNlIHRvIGJ1YmJsZSB0byBwcmV2ZW50IGFuY2VzdG9yIHJpcHBsZXNcbiAgICAgIGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBhY3RpdmF0ZShldmVudCA9IG51bGwpIHtcbiAgICB0aGlzLmFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYW5pbWF0ZUFjdGl2YXRpb25fKCkge1xuICAgIGNvbnN0IHtWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0RFQUNUSVZBVElPTl9USU1FT1VUX01TfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycztcblxuICAgIGxldCB0cmFuc2xhdGVTdGFydCA9ICcnO1xuICAgIGxldCB0cmFuc2xhdGVFbmQgPSAnJztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICBjb25zdCB7c3RhcnRQb2ludCwgZW5kUG9pbnR9ID0gdGhpcy5nZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCk7XG4gICAgICB0cmFuc2xhdGVTdGFydCA9IGAke3N0YXJ0UG9pbnQueH1weCwgJHtzdGFydFBvaW50Lnl9cHhgO1xuICAgICAgdHJhbnNsYXRlRW5kID0gYCR7ZW5kUG9pbnQueH1weCwgJHtlbmRQb2ludC55fXB4YDtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19UUkFOU0xBVEVfU1RBUlQsIHRyYW5zbGF0ZVN0YXJ0KTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19UUkFOU0xBVEVfRU5ELCB0cmFuc2xhdGVFbmQpO1xuICAgIC8vIENhbmNlbCBhbnkgb25nb2luZyBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbiBhbmltYXRpb25zXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfKTtcbiAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcblxuICAgIC8vIEZvcmNlIGxheW91dCBpbiBvcmRlciB0byByZS10cmlnZ2VyIHRoZSBhbmltYXRpb24uXG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfKCksIERFQUNUSVZBVElPTl9USU1FT1VUX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHt7c3RhcnRQb2ludDogUG9pbnRUeXBlLCBlbmRQb2ludDogUG9pbnRUeXBlfX1cbiAgICovXG4gIGdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKSB7XG4gICAgY29uc3Qge2FjdGl2YXRpb25FdmVudCwgd2FzQWN0aXZhdGVkQnlQb2ludGVyfSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcblxuICAgIGxldCBzdGFydFBvaW50O1xuICAgIGlmICh3YXNBY3RpdmF0ZWRCeVBvaW50ZXIpIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoXG4gICAgICAgIC8qKiBAdHlwZSB7IUV2ZW50fSAqLyAoYWN0aXZhdGlvbkV2ZW50KSxcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dQYWdlT2Zmc2V0KCksIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBvaW50ID0ge1xuICAgICAgICB4OiB0aGlzLmZyYW1lXy53aWR0aCAvIDIsXG4gICAgICAgIHk6IHRoaXMuZnJhbWVfLmhlaWdodCAvIDIsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBDZW50ZXIgdGhlIGVsZW1lbnQgYXJvdW5kIHRoZSBzdGFydCBwb2ludC5cbiAgICBzdGFydFBvaW50ID0ge1xuICAgICAgeDogc3RhcnRQb2ludC54IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgICB5OiBzdGFydFBvaW50LnkgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICB9O1xuXG4gICAgY29uc3QgZW5kUG9pbnQgPSB7XG4gICAgICB4OiAodGhpcy5mcmFtZV8ud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogKHRoaXMuZnJhbWVfLmhlaWdodCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIHJldHVybiB7c3RhcnRQb2ludCwgZW5kUG9pbnR9O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYm90aCB3aGVuIGEgcG9pbnRpbmcgZGV2aWNlIGlzIHJlbGVhc2VkLCBhbmQgd2hlbiB0aGUgYWN0aXZhdGlvbiBhbmltYXRpb24gZW5kcy5cbiAgICAvLyBUaGUgZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBzaG91bGQgb25seSBydW4gYWZ0ZXIgYm90aCBvZiB0aG9zZSBvY2N1ci5cbiAgICBjb25zdCB7RkdfREVBQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBjb25zdCB7aGFzRGVhY3RpdmF0aW9uVVhSdW4sIGlzQWN0aXZhdGVkfSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBjb25zdCBhY3RpdmF0aW9uSGFzRW5kZWQgPSBoYXNEZWFjdGl2YXRpb25VWFJ1biB8fCAhaXNBY3RpdmF0ZWQ7XG5cbiAgICBpZiAoYWN0aXZhdGlvbkhhc0VuZGVkICYmIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXykge1xuICAgICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfREVBQ1RJVkFUSU9OKTtcbiAgICAgIH0sIG51bWJlcnMuRkdfREVBQ1RJVkFUSU9OX01TKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCkge1xuICAgIGNvbnN0IHtGR19BQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICB9XG5cbiAgcmVzZXRBY3RpdmF0aW9uU3RhdGVfKCkge1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfLmFjdGl2YXRpb25FdmVudDtcbiAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgLy8gVG91Y2ggZGV2aWNlcyBtYXkgZmlyZSBhZGRpdGlvbmFsIGV2ZW50cyBmb3IgdGhlIHNhbWUgaW50ZXJhY3Rpb24gd2l0aGluIGEgc2hvcnQgdGltZS5cbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXMgZXZlbnQgdW50aWwgaXQncyBzYWZlIHRvIGFzc3VtZSB0aGF0IHN1YnNlcXVlbnQgZXZlbnRzIGFyZSBmb3IgbmV3IGludGVyYWN0aW9ucy5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbCwgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlRBUF9ERUxBWV9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlYWN0aXZhdGVfKGUpIHtcbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIHNjZW5hcmlvcyBzdWNoIGFzIHdoZW4geW91IGhhdmUgYSBrZXl1cCBldmVudCB0aGF0IGJsdXJzIHRoZSBlbGVtZW50LlxuICAgIGlmICghYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSAvKiogQHR5cGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqLyAoT2JqZWN0LmFzc2lnbih7fSwgYWN0aXZhdGlvblN0YXRlKSk7XG5cbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzUHJvZ3JhbW1hdGljKSB7XG4gICAgICBjb25zdCBldnRPYmplY3QgPSBudWxsO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oZXZ0T2JqZWN0LCBzdGF0ZSkpO1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8uaGFzRGVhY3RpdmF0aW9uVVhSdW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKGUsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudD19IGV2ZW50IE9wdGlvbmFsIGV2ZW50IGNvbnRhaW5pbmcgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBkZWFjdGl2YXRlKGV2ZW50ID0gbnVsbCkge1xuICAgIHRoaXMuZGVhY3RpdmF0ZV8oZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYW5pbWF0ZURlYWN0aXZhdGlvbl8oZSwge3dhc0FjdGl2YXRlZEJ5UG9pbnRlciwgd2FzRWxlbWVudE1hZGVBY3RpdmV9KSB7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlciB8fCB3YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0RnJhbWVfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxheW91dEZyYW1lXyk7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgbGF5b3V0SW50ZXJuYWxfKCkge1xuICAgIHRoaXMuZnJhbWVfID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgodGhpcy5mcmFtZV8uaGVpZ2h0LCB0aGlzLmZyYW1lXy53aWR0aCk7XG5cbiAgICAvLyBTdXJmYWNlIGRpYW1ldGVyIGlzIHRyZWF0ZWQgZGlmZmVyZW50bHkgZm9yIHVuYm91bmRlZCB2cy4gYm91bmRlZCByaXBwbGVzLlxuICAgIC8vIFVuYm91bmRlZCByaXBwbGUgZGlhbWV0ZXIgaXMgY2FsY3VsYXRlZCBzbWFsbGVyIHNpbmNlIHRoZSBzdXJmYWNlIGlzIGV4cGVjdGVkIHRvIGFscmVhZHkgYmUgcGFkZGVkIGFwcHJvcHJpYXRlbHlcbiAgICAvLyB0byBleHRlbmQgdGhlIGhpdGJveCwgYW5kIHRoZSByaXBwbGUgaXMgZXhwZWN0ZWQgdG8gbWVldCB0aGUgZWRnZXMgb2YgdGhlIHBhZGRlZCBoaXRib3ggKHdoaWNoIGlzIHR5cGljYWxseVxuICAgIC8vIHNxdWFyZSkuIEJvdW5kZWQgcmlwcGxlcywgb24gdGhlIG90aGVyIGhhbmQsIGFyZSBmdWxseSBleHBlY3RlZCB0byBleHBhbmQgYmV5b25kIHRoZSBzdXJmYWNlJ3MgbG9uZ2VzdCBkaWFtZXRlclxuICAgIC8vIChjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkaWFnb25hbCBwbHVzIGEgY29uc3RhbnQgcGFkZGluZyksIGFuZCBhcmUgY2xpcHBlZCBhdCB0aGUgc3VyZmFjZSdzIGJvcmRlciB2aWFcbiAgICAvLyBgb3ZlcmZsb3c6IGhpZGRlbmAuXG4gICAgY29uc3QgZ2V0Qm91bmRlZFJhZGl1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGh5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5mcmFtZV8ud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5mcmFtZV8uaGVpZ2h0LCAyKSk7XG4gICAgICByZXR1cm4gaHlwb3RlbnVzZSArIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5QQURESU5HO1xuICAgIH07XG5cbiAgICB0aGlzLm1heFJhZGl1c18gPSB0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkgPyBtYXhEaW0gOiBnZXRCb3VuZGVkUmFkaXVzKCk7XG5cbiAgICAvLyBSaXBwbGUgaXMgc2l6ZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgbGFyZ2VzdCBkaW1lbnNpb24gb2YgdGhlIHN1cmZhY2UsIHRoZW4gc2NhbGVzIHVwIHVzaW5nIGEgQ1NTIHNjYWxlIHRyYW5zZm9ybVxuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gbWF4RGltICogTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLklOSVRJQUxfT1JJR0lOX1NDQUxFO1xuICAgIHRoaXMuZmdTY2FsZV8gPSB0aGlzLm1heFJhZGl1c18gLyB0aGlzLmluaXRpYWxTaXplXztcblxuICAgIHRoaXMudXBkYXRlTGF5b3V0Q3NzVmFyc18oKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1cGRhdGVMYXlvdXRDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7XG4gICAgICBWQVJfRkdfU0laRSwgVkFSX0xFRlQsIFZBUl9UT1AsIFZBUl9GR19TQ0FMRSxcbiAgICB9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0laRSwgYCR7dGhpcy5pbml0aWFsU2l6ZV99cHhgKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TQ0FMRSwgdGhpcy5mZ1NjYWxlXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLnVuYm91bmRlZENvb3Jkc18gPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICAgIHRvcDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9MRUZULCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18ubGVmdH1weGApO1xuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfVE9QLCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18udG9wfXB4YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdW5ib3VuZGVkICovXG4gIHNldFVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICBjb25zdCB7VU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAodW5ib3VuZGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlRm91bmRhdGlvbjtcbiIsImltcG9ydCBNRENSaXBwbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvZm91bmRhdGlvbi5qcydcbmltcG9ydCB7c3VwcG9ydHNDc3NWYXJpYWJsZXMsIGdldE1hdGNoZXNQcm9wZXJ0eSwgYXBwbHlQYXNzaXZlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL3V0aWwnXG5cbmV4cG9ydCBjbGFzcyBSaXBwbGVCYXNlIGV4dGVuZHMgTURDUmlwcGxlRm91bmRhdGlvbiB7XG5cbiAgc3RhdGljIGdldCBNQVRDSEVTICgpIHtcbiAgICAvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbiAgICByZXR1cm4gUmlwcGxlQmFzZS5fbWF0Y2hlcyB8fFxuICAgICAgKCBSaXBwbGVCYXNlLl9tYXRjaGVzID0gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSkpXG4gIH1cblxuICBzdGF0aWMgaXNTdXJmYWNlQWN0aXZlIChyZWYpIHtcbiAgICByZXR1cm4gcmVmW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICB9XG5cbiAgY29uc3RydWN0b3IgKHZtLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7XG4gICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3cpXG4gICAgICB9LFxuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB2bS4kZWxbUmlwcGxlQmFzZS5NQVRDSEVTXSgnOmFjdGl2ZScpXG4gICAgICB9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZtLmRpc2FibGVkXG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3MgKGNsYXNzTmFtZSkge1xuICAgICAgICB2bS4kc2V0KHZtLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzcyAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHZtLiRkZWxldGUodm0uY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICh0YXJnZXQpID0+IHZtLiRlbC5jb250YWlucyh0YXJnZXQpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdm0uJGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdm0uJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFyTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdm0uJHNldCh2bS5zdHlsZXMsIHZhck5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZtLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICh7eDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXR9KVxuICAgICAgfSxcbiAgICB9LCBvcHRpb25zKSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUmlwcGxlTWl4aW4gPSB7XG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn0gICIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IDp0YWc9XCJ0YWdcIiBjbGFzcz1cIm1kYy1yaXBwbGVcIlxuICAgIDpjbGFzc2VzPVwiY2xhc3Nlc1wiIDpzdHlsZXM9XCJzdHlsZXNcIj5cbiAgICA8c2xvdCAvPlxuICA8L2N1c3RvbS1lbGVtZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7Q3VzdG9tRWxlbWVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHtSaXBwbGVNaXhpbn0gZnJvbSAnLi9tZGMtcmlwcGxlLWJhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1yaXBwbGUnLFxuICBtaXhpbnM6W0N1c3RvbUVsZW1lbnRNaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIHRhZzogU3RyaW5nXG4gIH0sXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNSaXBwbGUgZnJvbSAnLi9tZGMtcmlwcGxlLnZ1ZSdcblxuZXhwb3J0ICogZnJvbSAnLi9tZGMtcmlwcGxlLWJhc2UuanMnXG5cbmV4cG9ydCB7XG4gIG1kY1JpcHBsZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjUmlwcGxlXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWJ1dHRvbiByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmhyZWY9XCJocmVmXCIgOmxpbms9XCJsaW5rXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiBcbiAgICBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7UmlwcGxlTWl4aW59IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWJ1dHRvbi1iYXNlJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24nLFxuICBleHRlbmRzOiBtZGNCdXR0b25CYXNlLFxuICBwcm9wczoge1xuICAgIHJhaXNlZDogQm9vbGVhbixcbiAgICB1bmVsZXZhdGVkOiBCb29sZWFuLFxuICAgIHN0cm9rZWQ6IEJvb2xlYW4sXG4gICAgZGVuc2U6IEJvb2xlYW4sXG4gICAgY29tcGFjdDogQm9vbGVhbiwgXG4gICAgYWNjZW50OiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcbiAgICAgICAgJ21kYy1idXR0b24tLXJhaXNlZCc6IHRoaXMucmFpc2VkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCc6IHRoaXMudW5lbGV2YXRlZCxcbiAgICAgICAgJ21kYy1idXR0b24tLXN0cm9rZWQnOiB0aGlzLnN0cm9rZWQsXG4gICAgICAgICdtZGMtYnV0dG9uLS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtYnV0dG9uLS1jb21wYWN0JzogdGhpcy5jb21wYWN0LFxuICAgICAgICAnbWRjLWJ1dHRvbi0tYWNjZW50JzogdGhpcy5hY2NlbnRcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgcmFpc2VkICgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1yYWlzZWQnLCB0aGlzLnJhaXNlZCApXG4gICAgfSxcbiAgICB1bmVsZXZhdGVkICgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJywgdGhpcy51bmVsZXZhdGVkIClcbiAgICB9LFxuICAgIHN0cm9rZWQgKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLXN0cm9rZWQnLCB0aGlzLnN0cm9rZWQgKVxuICAgIH0sXG4gICAgZGVuc2UgKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWRlbnNlJywgdGhpcy5kZW5zZSApXG4gICAgfSxcbiAgICBjb21wYWN0ICgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1jb21wYWN0JywgdGhpcy5jb21wYWN0IClcbiAgICB9LFxuICAgIGFjY2VudCAoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tYWNjZW50JywgdGhpcy5hY2NlbnQgKVxuICAgIH0sXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0J1dHRvbiBmcm9tICcuL21kYy1idXR0b24udnVlJ1xuaW1wb3J0IG1kY0J1dHRvbkJhc2UgZnJvbSAnLi9tZGMtYnV0dG9uLWJhc2UudnVlJ1xuXG5leHBvcnQge21kY0J1dHRvbkJhc2UsIG1kY0J1dHRvbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0J1dHRvblxufSlcbiIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRjLWNhcmRcIiA6Y2xhc3M9XCJ7J21kYy1jYXJkLS1zdHJva2VkJzogc3Ryb2tlZH1cIj5cclxuICAgIDxzbG90PlxyXG4gICAgPC9zbG90PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6IFwibWRjLWNhcmRcIixcclxuICBwcm9wczoge1xyXG4gICAgc3Ryb2tlZDogQm9vbGVhblxyXG4gIH1cclxufTtcclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y3VzdG9tLWxpbmsgXHJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXByaW1hcnktYWN0aW9uIG1kYy1jYXJkX19wcmltYXJ5LWFjdGlvblwiXHJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCIgXHJcbiAgICA6bGluaz1cImxpbmtcIiBcclxuICAgIEBjbGljaz1cImRpc3BhdGNoRXZlbnRcIj5cclxuICAgIDxzbG90IC8+XHJcbiAgPC9jdXN0b20tbGluaz5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW59IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCB7IFJpcHBsZU1peGluIH0gZnJvbSAnLi4vcmlwcGxlL2luZGV4JztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1wcmltYXJ5LWFjdGlvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4sIFJpcHBsZU1peGluXSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC1tZWRpYSBtZGMtY2FyZF9fbWVkaWFcIiBcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJtZGMtY2FyZF9fbWVkaWEtY29udGVudFwiIHYtaWY9XCIkc2xvdHMuZGVmYXVsdFwiPlxyXG4gICAgICA8c2xvdD5cclxuICAgICAgPC9zbG90PlxyXG4gICAgPC9kaXY+XHJcbiAgPC9zZWN0aW9uPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6IFwibWRjLWNhcmQtbWVkaWFcIixcclxuICBwcm9wczoge1xyXG4gICAgc3JjOiBTdHJpbmcsXHJcbiAgICAnc3F1YXJlJzogQm9vbGVhblxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIHN0eWxlcygpIHtcclxuICAgICAgdmFyIHN0eWxlcyA9IHtcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHt0aGlzLnNyY30pYFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHN0eWxlcztcclxuICAgIH0sIFxyXG4gICAgY2xhc3NlcygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3F1YXJlID8gJ21kYy1jYXJkX19tZWRpYS0tc3F1YXJlJzogJ21kYy1jYXJkX19tZWRpYS0tMTYtOSdcclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC1oZWFkZXIgbWRjLWNhcmRfX3ByaW1hcnlcIj5cbiAgICA8c2xvdD5cbiAgICAgIDxoMSBjbGFzcz1cIm1kYy1jYXJkX190aXRsZVwiXG4gICAgICAgIDpjbGFzcz1cInsnbWRjLWNhcmRfX3RpdGxlLS1sYXJnZSc6IGxhcmdlVGl0bGV9XCJcbiAgICAgICAgdi1pZj1cInRpdGxlXCJcbiAgICAgICAgPlxuICAgICAgICB7eyB0aXRsZSB9fVxuICAgICAgPC9oMT5cbiAgICAgIDxoMiBjbGFzcz1cIm1kYy1jYXJkX19zdWJ0aXRsZVwiXG4gICAgICAgIHYtaWY9XCJzdWJ0aXRsZVwiXG4gICAgICA+XG4gICAgICAge3sgc3VidGl0bGUgfX0gXG4gICAgICA8L2gyPlxuICAgIDwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLWhlYWRlcicsXG4gIHByb3BzOiB7XG4gICAgJ3RpdGxlJzogU3RyaW5nLFxuICAgICdzdWJ0aXRsZSc6IFN0cmluZyxcbiAgICAnbGFyZ2UtdGl0bGUnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGgxIGNsYXNzPVwibWRjLWNhcmQtdGl0bGUgbWRjLWNhcmRfX3RpdGxlXCJcbiAgICAgIDpjbGFzcz1cInsnbWRjLWNhcmRfX3RpdGxlLS1sYXJnZSc6IGxhcmdlfVwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9oMT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10aXRsZScsXG4gIHByb3BzOiB7XG4gICAgJ2xhcmdlJzogQm9vbGVhblxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGgyIGNsYXNzPVwibWRjLWNhcmQtc3VidGl0bGUgbWRjLWNhcmRfX3N1YnRpdGxlXCI+XG4gICAgPHNsb3Q+XG4gICAgPC9zbG90PlxuICA8L2gyPlxuPC90ZW1wbGF0ZT5cblxuXG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC1zdWJ0aXRsZSdcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLXRleHQgbWRjLWNhcmRfX3N1cHBvcnRpbmctdGV4dFwiPlxuICAgIDxzbG90PlxuICAgIDwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLXRleHQnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbnMgbWRjLWNhcmRfX2FjdGlvbnNcIiBcclxuICAgICAgICAgIDpjbGFzcz1cImNsYXNzZXNcIj5cclxuICAgIDxzbG90PlxyXG4gICAgPC9zbG90PlxyXG4gIDwvc2VjdGlvbj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbnMnLFxyXG4gIHByb3BzOiB7XHJcbiAgICBmdWxsQmxlZWQ6IEJvb2xlYW5cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBjbGFzc2VzICgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICdtZGMtY2FyZF9fYWN0aW9ucy0tZnVsbC1ibGVlZCc6IHRoaXMuZnVsbEJsZWVkLFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgY2xhc3M9XCJtZGMtY2FyZC1hY3Rpb24tYnV0dG9ucyBtZGMtY2FyZF9fYWN0aW9uLWJ1dHRvbnNcIj5cclxuICAgIDxzbG90PlxyXG4gICAgPC9zbG90PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6IFwibWRjLWNhcmQtYWN0aW9uLWJ1dHRvbnNcIlxyXG59O1xyXG48L3NjcmlwdD5cclxuIiwiPHNjcmlwdD5cclxuaW1wb3J0IHttZGNCdXR0b25CYXNlfSBmcm9tICcuLi9idXR0b24nXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nLFxyXG4gIGV4dGVuZHM6IG1kY0J1dHRvbkJhc2UsXHJcbiAgcHJvcHM6IHtcclxuICAgIGNvbXBhY3Q6IEJvb2xlYW4sXHJcbiAgICBhY2NlbnQ6IEJvb2xlYW5cclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtYnV0dG9uLS1jb21wYWN0JzogdGhpcy5jb21wYWN0LFxyXG4gICAgICAgICdtZGMtYnV0dG9uLS1hY2NlbnQnOiB0aGlzLmFjY2VudCxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgd2F0Y2g6IHtcclxuICAgIGNvbXBhY3QgKCkge1xyXG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tY29tcGFjdCcsIHRoaXMuY29tcGFjdCApXHJcbiAgICB9LFxyXG4gICAgYWNjZW50ICgpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWFjY2VudCcsIHRoaXMuYWNjZW50IClcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbi1pY29ucyBtZGMtY2FyZF9fYWN0aW9uLWljb25zXCI+XHJcbiAgICA8c2xvdD5cclxuICAgIDwvc2xvdD5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiBcIm1kYy1jYXJkLWFjdGlvbi1pY29uc1wiXHJcbn07XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNwYW4gOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiIFxyXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxyXG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cclxuICA8L3NwYW4+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQge0Rpc3BhdGNoRXZlbnRNaXhpbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbi1pY29uJyxcclxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBpY29uOiBTdHJpbmdcclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtY2FyZC1hY3Rpb24taWNvbic6IHRydWUsIFxyXG4gICAgICAgICdtYXRlcmlhbC1pY29ucyc6ISF0aGlzLmljb24sXHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtY2FyZF9fYWN0aW9uLS1pY29uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWljb24tdG9nZ2xlJzogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgaWNvbiAoKSB7XHJcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtYXRlcmlhbC1pY29ucycsICEhdGhpcy5pY29uKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCAoKSB7XHJcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMse1xyXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gdHJ1ZSxcclxuICAgIH0pXHJcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xyXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCBtZGNDYXJkIGZyb20gJy4vbWRjLWNhcmQudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFByaW1hcnlBY3Rpb24gZnJvbSAnLi9tZGMtY2FyZC1wcmltYXJ5LWFjdGlvbi52dWUnXHJcbmltcG9ydCBtZGNDYXJkTWVkaWEgZnJvbSAnLi9tZGMtY2FyZC1tZWRpYS52dWUnXHJcbmltcG9ydCBtZGNDYXJkSGVhZGVyIGZyb20gJy4vbWRjLWNhcmQtaGVhZGVyLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRUaXRsZSBmcm9tICcuL21kYy1jYXJkLXRpdGxlLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRTdWJ0aXRsZSBmcm9tICcuL21kYy1jYXJkLXN1YnRpdGxlLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRUZXh0IGZyb20gJy4vbWRjLWNhcmQtdGV4dC52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbnMudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMgZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24tYnV0dG9ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uQnV0dG9uIGZyb20gJy4vbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbi52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uSWNvbnMgZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24taWNvbnMudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZEFjdGlvbkljb24gZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24taWNvbi52dWUnXHJcblxyXG5leHBvcnQge1xyXG4gIG1kY0NhcmQsXHJcbiAgbWRjQ2FyZFByaW1hcnlBY3Rpb24sIFxyXG4gIG1kY0NhcmRNZWRpYSxcclxuICBtZGNDYXJkSGVhZGVyLFxyXG4gIG1kY0NhcmRUaXRsZSxcclxuICBtZGNDYXJkU3VidGl0bGUsXHJcbiAgbWRjQ2FyZFRleHQsXHJcbiAgbWRjQ2FyZEFjdGlvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbixcclxuICBtZGNDYXJkQWN0aW9uSWNvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkljb24gXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0NhcmQsIFxyXG4gIG1kY0NhcmRQcmltYXJ5QWN0aW9uLFxyXG4gIG1kY0NhcmRNZWRpYSxcclxuICBtZGNDYXJkSGVhZGVyLFxyXG4gIG1kY0NhcmRUaXRsZSxcclxuICBtZGNDYXJkU3VidGl0bGUsXHJcbiAgbWRjQ2FyZFRleHQsXHJcbiAgbWRjQ2FyZEFjdGlvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbixcclxuICBtZGNDYXJkQWN0aW9uSWNvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkljb25cclxufSlcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IE1EQ1JpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENSaXBwbGVGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQGV4dGVuZHMgTURDQ29tcG9uZW50PCFNRENSaXBwbGVGb3VuZGF0aW9uPlxuICovXG5jbGFzcyBNRENSaXBwbGUgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKiogQHBhcmFtIHsuLi4/fSBhcmdzICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51bmJvdW5kZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHt7aXNVbmJvdW5kZWQ6IChib29sZWFufHVuZGVmaW5lZCl9PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlfVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QsIHtpc1VuYm91bmRlZCA9IHVuZGVmaW5lZH0gPSB7fSkge1xuICAgIGNvbnN0IHJpcHBsZSA9IG5ldyBNRENSaXBwbGUocm9vdCk7XG4gICAgLy8gT25seSBvdmVycmlkZSB1bmJvdW5kZWQgYmVoYXZpb3IgaWYgb3B0aW9uIGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkXG4gICAgaWYgKGlzVW5ib3VuZGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJpcHBsZS51bmJvdW5kZWQgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpc1VuYm91bmRlZCk7XG4gICAgfVxuICAgIHJldHVybiByaXBwbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUmlwcGxlQ2FwYWJsZVN1cmZhY2V9IGluc3RhbmNlXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFkYXB0ZXIoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBNQVRDSEVTID0gdXRpbC5nZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB1dGlsLnN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvdyksXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gaW5zdGFuY2UudW5ib3VuZGVkLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBpbnN0YW5jZS5yb290X1tNQVRDSEVTXSgnOmFjdGl2ZScpLFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IGluc3RhbmNlLmRpc2FibGVkLFxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IGluc3RhbmNlLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiBpbnN0YW5jZS5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiBpbnN0YW5jZS5yb290Xy5jb250YWlucyh0YXJnZXQpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBpbnN0YW5jZS5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGluc3RhbmNlLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4gaW5zdGFuY2Uucm9vdF8uc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpLFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gaW5zdGFuY2Uucm9vdF8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAoe3g6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0fSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgdW5ib3VuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuYm91bmRlZF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0IHVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICB0aGlzLnVuYm91bmRlZF8gPSBCb29sZWFuKHVuYm91bmRlZCk7XG4gICAgdGhpcy5zZXRVbmJvdW5kZWRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc3VyZSBDb21waWxlciB0aHJvd3MgYW4gYWNjZXNzIGNvbnRyb2wgZXJyb3Igd2hlbiBkaXJlY3RseSBhY2Nlc3NpbmcgYVxuICAgKiBwcm90ZWN0ZWQgb3IgcHJpdmF0ZSBwcm9wZXJ0eSBpbnNpZGUgYSBnZXR0ZXIvc2V0dGVyLCBsaWtlIHVuYm91bmRlZCBhYm92ZS5cbiAgICogQnkgYWNjZXNzaW5nIHRoZSBwcm90ZWN0ZWQgcHJvcGVydHkgaW5zaWRlIGEgbWV0aG9kLCB3ZSBzb2x2ZSB0aGF0IHByb2JsZW0uXG4gICAqIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBleGlzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRVbmJvdW5kZWRfKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0VW5ib3VuZGVkKHRoaXMudW5ib3VuZGVkXyk7XG4gIH1cblxuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlKCk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ubGF5b3V0KCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1JpcHBsZUZvdW5kYXRpb259ICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihNRENSaXBwbGUuY3JlYXRlQWRhcHRlcih0aGlzKSk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgdGhpcy51bmJvdW5kZWQgPSAnbWRjUmlwcGxlSXNVbmJvdW5kZWQnIGluIHRoaXMucm9vdF8uZGF0YXNldDtcbiAgfVxufVxuXG4vKipcbiAqIFNlZSBNYXRlcmlhbCBEZXNpZ24gc3BlYyBmb3IgbW9yZSBkZXRhaWxzIG9uIHdoZW4gdG8gdXNlIHJpcHBsZXMuXG4gKiBodHRwczovL21hdGVyaWFsLmlvL2d1aWRlbGluZXMvbW90aW9uL2Nob3Jlb2dyYXBoeS5odG1sI2Nob3Jlb2dyYXBoeS1jcmVhdGlvblxuICogQHJlY29yZFxuICovXG5jbGFzcyBSaXBwbGVDYXBhYmxlU3VyZmFjZSB7fVxuXG4vKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUucm9vdF87XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBibGVlZHMgb3V0IG9mIHRoZSBib3VuZHMgb2YgdGhlIGVsZW1lbnQuXG4gKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS51bmJvdW5kZWQ7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBpcyBhdHRhY2hlZCB0byBhIGRpc2FibGVkIGNvbXBvbmVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLmRpc2FibGVkO1xuXG5leHBvcnQge01EQ1JpcHBsZSwgTURDUmlwcGxlRm91bmRhdGlvbiwgUmlwcGxlQ2FwYWJsZVN1cmZhY2UsIHV0aWx9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1JpcHBsZX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9pbmRleCc7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGNoZWNrZWQ6IGJvb2xlYW4sXG4gKiAgIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4sXG4gKiAgIGRpc2FibGVkOiBib29sZWFuLFxuICogICB2YWx1ZTogP3N0cmluZ1xuICogfX1cbiAqL1xubGV0IE1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZTtcblxuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdGlvbkNvbnRyb2wge1xuICAvKiogQHJldHVybiB7P01EQ1JpcHBsZX0gKi9cbiAgZ2V0IHJpcHBsZSgpIHt9XG59XG5cbmV4cG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlLCBNRENTZWxlY3Rpb25Db250cm9sfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBDaGVja2JveC4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBldmVudCBoYW5kbGVyc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDQ2hlY2tib3hBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICByZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEByZXR1cm4geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9ICovXG4gIGdldE5hdGl2ZUNvbnRyb2woKSB7fVxuXG4gIGZvcmNlTGF5b3V0KCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNBdHRhY2hlZFRvRE9NKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IFJPT1QgPSAnbWRjLWNoZWNrYm94JztcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBVUEdSQURFRDogJ21kYy1jaGVja2JveC0tdXBncmFkZWQnLFxuICBDSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1jaGVja2VkJyxcbiAgSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0taW5kZXRlcm1pbmF0ZScsXG4gIERJU0FCTEVEOiAnbWRjLWNoZWNrYm94LS1kaXNhYmxlZCcsXG4gIEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tdW5jaGVja2VkLWNoZWNrZWQnLFxuICBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1pbmRldGVybWluYXRlJyxcbiAgQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLXVuY2hlY2tlZCcsXG4gIEFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXG4gIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtY2hlY2tlZCcsXG4gIEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUjogYC4ke1JPT1R9X19uYXRpdmUtY29udHJvbGAsXG4gIFRSQU5TSVRJT05fU1RBVEVfSU5JVDogJ2luaXQnLFxuICBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQ6ICdjaGVja2VkJyxcbiAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ6ICd1bmNoZWNrZWQnLFxuICBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEU6ICdpbmRldGVybWluYXRlJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgQU5JTV9FTkRfTEFUQ0hfTVM6IDI1MCxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5pbXBvcnQgTURDQ2hlY2tib3hBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqIEBjb25zdCB7IUFycmF5PHN0cmluZz59ICovXG5jb25zdCBDQl9QUk9UT19QUk9QUyA9IFsnY2hlY2tlZCcsICdpbmRldGVybWluYXRlJ107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0NoZWNrYm94QWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0NoZWNrYm94QWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDQ2hlY2tib3hBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGdldE5hdGl2ZUNvbnRyb2w6ICgpID0+IC8qICFNRENTZWxlY3Rpb25Db250cm9sU3RhdGUgKi8ge30sXG4gICAgICBmb3JjZUxheW91dDogKCkgPT4ge30sXG4gICAgICBpc0F0dGFjaGVkVG9ET006ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENDaGVja2JveEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuY3VycmVudENoZWNrU3RhdGVfID0gc3RyaW5ncy5UUkFOU0lUSU9OX1NUQVRFX0lOSVQ7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18gPSAnJztcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYW5pbUVuZExhdGNoVGltZXJfID0gMDtcblxuICAgIHRoaXMuYW5pbUVuZEhhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy5oYW5kbGVBbmltYXRpb25FbmQoKSk7XG5cbiAgICB0aGlzLmNoYW5nZUhhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy5oYW5kbGVDaGFuZ2UoKSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuY3VycmVudENoZWNrU3RhdGVfID0gdGhpcy5kZXRlcm1pbmVDaGVja1N0YXRlXyh0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckNoYW5nZUhhbmRsZXIodGhpcy5jaGFuZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcih0aGlzLmNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLnVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNDaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWQgKi9cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzSW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmluZGV0ZXJtaW5hdGU7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpbmRldGVybWluYXRlICovXG4gIHNldEluZGV0ZXJtaW5hdGUoaW5kZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgYW5pbWF0aW9uZW5kIGV2ZW50IGZvciB0aGUgY2hlY2tib3hcbiAgICovXG4gIGhhbmRsZUFuaW1hdGlvbkVuZCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8pO1xuICAgIHRoaXMuYW5pbUVuZExhdGNoVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKHRoaXMuYW5pbUVuZEhhbmRsZXJfKTtcbiAgICB9LCBudW1iZXJzLkFOSU1fRU5EX0xBVENIX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHRoZSBjaGVja2JveFxuICAgKi9cbiAgaGFuZGxlQ2hhbmdlKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbkNoZWNrU3RhdGVfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5nZXROYXRpdmVDb250cm9sXygpO1xuICAgIGNvbnN0IGNiUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmF0aXZlQ2IpO1xuXG4gICAgQ0JfUFJPVE9fUFJPUFMuZm9yRWFjaCgoY29udHJvbFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjYlByb3RvLCBjb250cm9sU3RhdGUpO1xuICAgICAgLy8gV2UgaGF2ZSB0byBjaGVjayBmb3IgdGhpcyBkZXNjcmlwdG9yLCBzaW5jZSBzb21lIGJyb3dzZXJzIChTYWZhcmkpIGRvbid0IHN1cHBvcnQgaXRzIHJldHVybi5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQ5NzM5XG4gICAgICBpZiAodmFsaWREZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUNiRGVzYyA9IC8qKiBAdHlwZSB7IU9iamVjdFByb3BlcnR5RGVzY3JpcHRvcn0gKi8gKHtcbiAgICAgICAgICBnZXQ6IGRlc2MuZ2V0LFxuICAgICAgICAgIHNldDogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKG5hdGl2ZUNiLCBzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25DaGVja1N0YXRlXygpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2IsIGNvbnRyb2xTdGF0ZSwgbmF0aXZlQ2JEZXNjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1bmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpIHtcbiAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKTtcbiAgICBjb25zdCBjYlByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5hdGl2ZUNiKTtcblxuICAgIENCX1BST1RPX1BST1BTLmZvckVhY2goKGNvbnRyb2xTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZGVzYyA9IC8qKiBAdHlwZSB7IU9iamVjdFByb3BlcnR5RGVzY3JpcHRvcn0gKi8gKFxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNiUHJvdG8sIGNvbnRyb2xTdGF0ZSkpO1xuICAgICAgaWYgKHZhbGlkRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2IsIGNvbnRyb2xTdGF0ZSwgZGVzYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdHJhbnNpdGlvbkNoZWNrU3RhdGVfKCkge1xuICAgIGNvbnN0IG5hdGl2ZUNiID0gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVDb250cm9sKCk7XG4gICAgaWYgKCFuYXRpdmVDYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudENoZWNrU3RhdGVfO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5kZXRlcm1pbmVDaGVja1N0YXRlXyhuYXRpdmVDYik7XG4gICAgaWYgKG9sZFN0YXRlID09PSBuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRvIGVuc3VyZSB0aGF0IHRoZXJlIGlzbid0IGEgcHJldmlvdXNseSBleGlzdGluZyBhbmltYXRpb24gY2xhc3MsIGluIGNhc2UgZm9yIGV4YW1wbGVcbiAgICAvLyB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIGNoZWNrYm94IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHdhcyBmaW5pc2hlZC5cbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfLmxlbmd0aCA+IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvcmNlTGF5b3V0KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfID0gdGhpcy5nZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSBuZXdTdGF0ZTtcblxuICAgIC8vIENoZWNrIGZvciBwYXJlbnROb2RlIHNvIHRoYXQgYW5pbWF0aW9ucyBhcmUgb25seSBydW4gd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZFxuICAgIC8vIHRvIHRoZSBET00uXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNBdHRhY2hlZFRvRE9NKCkgJiYgdGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKHRoaXMuYW5pbUVuZEhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBuYXRpdmVDYlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRlcm1pbmVDaGVja1N0YXRlXyhuYXRpdmVDYikge1xuICAgIGNvbnN0IHtcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURSxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VELFxuICAgIH0gPSBzdHJpbmdzO1xuXG4gICAgaWYgKG5hdGl2ZUNiLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEU7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVDYi5jaGVja2VkID8gVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEIDogVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdGF0ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfSU5JVCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VELFxuICAgIH0gPSBzdHJpbmdzO1xuXG4gICAgY29uc3Qge1xuICAgICAgQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRCxcbiAgICAgIEFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEUsXG4gICAgICBBTklNX0NIRUNLRURfVU5DSEVDS0VELFxuICAgICAgQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEUsXG4gICAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCxcbiAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQsXG4gICAgfSA9IE1EQ0NoZWNrYm94Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuXG4gICAgc3dpdGNoIChvbGRTdGF0ZSkge1xuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9JTklUOlxuICAgICAgaWYgKG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEOlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgPyBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIDogQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTtcbiAgICBjYXNlIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRDpcbiAgICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQgPyBBTklNX0NIRUNLRURfVU5DSEVDS0VEIDogQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEU7XG4gICAgLy8gVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEID9cbiAgICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQgOiBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlQ29udHJvbF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpIHx8IHtcbiAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J8dW5kZWZpbmVkfSBpbnB1dFByb3BEZXNjXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZERlc2NyaXB0b3IoaW5wdXRQcm9wRGVzYykge1xuICByZXR1cm4gISFpbnB1dFByb3BEZXNjICYmIHR5cGVvZiBpbnB1dFByb3BEZXNjLnNldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGb3JtIEZpZWxkLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHJpcHBsZSBhY3RpdmF0aW9uXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENGb3JtRmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICBhY3RpdmF0ZUlucHV0UmlwcGxlKCkge31cblxuICBkZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3JtRmllbGRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZvcm0tZmllbGQgPiBsYWJlbCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENGb3JtRmllbGRBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0Zvcm1GaWVsZEFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENGb3JtRmllbGRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IC8qKiBAdHlwZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQ2xpY2tfKCkpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGhhbmRsZUNsaWNrXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlSW5wdXRSaXBwbGUoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm9ybUZpZWxkRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIG5vUHJlZml4OiBzdHJpbmcsXG4gKiAgIHdlYmtpdFByZWZpeDogc3RyaW5nLFxuICogICBzdHlsZVByb3BlcnR5OiBzdHJpbmdcbiAqIH19XG4gKi9cbmxldCBWZW5kb3JQcm9wZXJ0eU1hcFR5cGU7XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgZXZlbnRUeXBlTWFwID0ge1xuICAnYW5pbWF0aW9uc3RhcnQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25zdGFydCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0QW5pbWF0aW9uU3RhcnQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uZW5kJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uaXRlcmF0aW9uJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25JdGVyYXRpb24nLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNpdGlvbmVuZCc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICd0cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgY3NzUHJvcGVydHlNYXAgPSB7XG4gICdhbmltYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtYW5pbWF0aW9uJyxcbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zZm9ybScsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICB9LFxuICAndHJhbnNpdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtdHJhbnNpdGlvbicsXG4gIH0sXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHtcbiAgcmV0dXJuICh3aW5kb3dPYmpbJ2RvY3VtZW50J10gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGV2ZW50Rm91bmRJbk1hcHMoZXZlbnRUeXBlKSB7XG4gIHJldHVybiAoZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCB8fCBldmVudFR5cGUgaW4gY3NzUHJvcGVydHlNYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSBtYXBcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEphdmFTY3JpcHRFdmVudE5hbWUoZXZlbnRUeXBlLCBtYXAsIGVsKSB7XG4gIHJldHVybiBtYXBbZXZlbnRUeXBlXS5zdHlsZVByb3BlcnR5IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBicm93c2VyIHByZWZpeCBmb3IgQ1NTMyBhbmltYXRpb24gZXZlbnRzXG4gKiBhbmQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcGFyYW0geyFPYmplY3R9IHdpbmRvd09ialxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb25OYW1lKHdpbmRvd09iaiwgZXZlbnRUeXBlKSB7XG4gIGlmICghaGFzUHJvcGVyU2hhcGUod2luZG93T2JqKSB8fCAhZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqLyAoXG4gICAgZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCA/IGV2ZW50VHlwZU1hcCA6IGNzc1Byb3BlcnR5TWFwXG4gICk7XG4gIGNvbnN0IGVsID0gd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10oJ2RpdicpO1xuICBsZXQgZXZlbnROYW1lID0gJyc7XG5cbiAgaWYgKG1hcCA9PT0gZXZlbnRUeXBlTWFwKSB7XG4gICAgZXZlbnROYW1lID0gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50TmFtZSA9IG1hcFtldmVudFR5cGVdLm5vUHJlZml4IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBQdWJsaWMgZnVuY3Rpb25zIHRvIGFjY2VzcyBnZXRBbmltYXRpb25OYW1lKCkgZm9yIEphdmFTY3JpcHQgZXZlbnRzIG9yIENTU1xuLy8gcHJvcGVydHkgbmFtZXMuXG5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyA9IFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNU1RyYW5zZm9ybSddO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG5leHBvcnQge3RyYW5zZm9ybVN0eWxlUHJvcGVydGllcywgZ2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgOmNsYXNzPWZvcm1GaWVsZENsYXNzZXMgY2xhc3M9XCJtZGMtY2hlY2tib3gtd3JhcHBlclwiPlxuICAgIDxkaXYgcmVmPVwicm9vdFwiIGNsYXNzPVwibWRjLWNoZWNrYm94XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCI+XG4gICAgICA8aW5wdXQgcmVmPVwiY29udHJvbFwiIDppZD1cIl91aWRcIiB0eXBlPVwiY2hlY2tib3hcIiA6bmFtZT1cIm5hbWVcIlxuICAgICAgICBjbGFzcz1cIm1kYy1jaGVja2JveF9fbmF0aXZlLWNvbnRyb2xcIiA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtY2hlY2tib3hfX2JhY2tncm91bmRcIj5cbiAgICAgICAgPHN2ZyBjbGFzcz1cIm1kYy1jaGVja2JveF9fY2hlY2ttYXJrXCJcbiAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBjbGFzcz1cImNoZWNrYm94X19jaGVja21hcmstcGF0aFwiXG4gICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgIHN0cm9rZT1cIndoaXRlXCJcbiAgICAgICAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIi8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLWNoZWNrYm94X19taXhlZG1hcmtcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxsYWJlbCByZWY9XCJsYWJlbFwiICA6Zm9yPVwiX3VpZFwiXG4gICAgPjxzbG90Pnt7bGFiZWx9fTwvc2xvdD48L2xhYmVsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cbi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuaW1wb3J0IE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbidcbmltcG9ydCBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQge2dldENvcnJlY3RFdmVudE5hbWV9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24nXG5pbXBvcnQge0Rpc3BhdGNoRm9jdXNNaXhpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7UmlwcGxlQmFzZX0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hlY2tib3gnLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdjaGVja2VkJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAnY2hlY2tlZCc6IEJvb2xlYW4sXG4gICAgJ2luZGV0ZXJtaW5hdGUnOiBCb29sZWFuLFxuICAgICdkaXNhYmxlZCc6IEJvb2xlYW4sXG4gICAgJ2xhYmVsJzogU3RyaW5nLFxuICAgICdhbGlnbi1lbmQnOiBCb29sZWFuLFxuICAgICd2YWx1ZSc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0ICgpIHsgcmV0dXJuICdvbicgfSB9LFxuICAgICduYW1lJzogU3RyaW5nXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgY2xhc3Nlczoge31cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWwgfHwgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIH0sXG4gICAgZm9ybUZpZWxkQ2xhc3NlcyAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWZvcm0tZmllbGQnOiB0aGlzLmhhc0xhYmVsLFxuICAgICAgICAnbWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZCc6IHRoaXMuaGFzTGFiZWwgJiYgdGhpcy5hbGlnbkVuZFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnY2hlY2tlZCcgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZCh2YWx1ZSlcbiAgICB9LFxuICAgICdkaXNhYmxlZCcgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodmFsdWUpXG4gICAgfSxcbiAgICAnaW5kZXRlcm1pbmF0ZScgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0SW5kZXRlcm1pbmF0ZSh2YWx1ZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENDaGVja2JveEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAnYW5pbWF0aW9uZW5kJyksIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogKGhhbmRsZXIpID0+IHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gdGhpcy4kcmVmcy5jb250cm9sLFxuICAgICAgZm9yY2VMYXlvdXQ6ICgpID0+IHRoaXMuJHJlZnMucm9vdC5vZmZzZXRXaWR0aCxcbiAgICAgIGlzQXR0YWNoZWRUb0RPTTogKCkgPT4gQm9vbGVhbih0aGlzLiRlbC5wYXJlbnROb2RlKVxuICAgIH0pXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBSaXBwbGVCYXNlLmlzU3VyZmFjZUFjdGl2ZSh0aGlzLiRyZWZzLmNvbnRyb2wpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcdFx0XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcdFx0XG4gICAgICB9LFx0XHRcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcdFx0XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcdFx0XG4gICAgICB9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm9ybUZpZWxkID0gbmV3IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24oe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuYWN0aXZhdGUoKVxuICAgICAgfSxcbiAgICAgIGRlYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZWFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgdGhpcy5mb3JtRmllbGQuaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQodGhpcy5jaGVja2VkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRJbmRldGVybWluYXRlKHRoaXMuaW5kZXRlcm1pbmF0ZSlcblxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvcm1GaWVsZC5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZSAoKSB7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6aW5kZXRlcm1pbmF0ZScsIHRoaXMuZm91bmRhdGlvbi5pc0luZGV0ZXJtaW5hdGUoKSlcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuZm91bmRhdGlvbi5pc0NoZWNrZWQoKSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0NoZWNrYm94IGZyb20gJy4vbWRjLWNoZWNrYm94LnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjQ2hlY2tib3hcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0NoZWNrYm94XG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBDaGlwLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIENoaXAgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gXCJNRENDaGlwOmludGVyYWN0aW9uXCIgZXZlbnQgZGVub3RpbmcgdGhlIGNoaXAgaGFzIGJlZW5cbiAgICogaW50ZXJhY3RlZCB3aXRoICh0eXBpY2FsbHkgb24gY2xpY2sgb3Iga2V5ZG93bikuXG4gICAqL1xuICBub3RpZnlJbnRlcmFjdGlvbigpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoaXBBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgSU5URVJBQ1RJT05fRVZFTlQ6ICdNRENDaGlwOmludGVyYWN0aW9uJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDQ2hpcEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0NoaXBBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENDaGlwRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENDaGlwQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENDaGlwQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoaXBBZGFwdGVyfSAqLyAoe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJbnRlcmFjdGlvbjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUludGVyYWN0aW9uXyhldnQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnQgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb25fKGV2dCkge1xuICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJyB8fCBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlJbnRlcmFjdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbjxkaXYgY2xhc3M9XCJtZGMtY2hpcFwiIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIiB0YWJpbmRleD1cIjBcIiA+XG4gIDxpIGNsYXNzPVwibWRjLWNoaXBfX2ljb24gbWRjLWNoaXBfX2ljb24tLWxlYWRpbmdcIiBcbiAgICA6Y2xhc3M9XCJsZWFkaW5nQ2xhc3Nlc1wiIHYtaWY9XCJoYXZlbGVhZGluZ0ljb25cIlxuICA+e3tsZWFkaW5nSWNvbn19PC9pPlxuICA8ZGl2IGNsYXNzZXM9XCJtZGMtY2hpcF9fdGV4dFwiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9kaXY+XG4gIDxpIGNsYXNzPVwibWRjLWNoaXBfX2ljb24gbWRjLWNoaXBfX2ljb24tLXRyYWlsaW5nXCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiIFxuICAgIDpjbGFzcz1cInRyYWlsaW5nQ2xhc3Nlc1wiIHYtaWY9XCJoYXZldHJhaWxpbmdJY29uXCJcbiAgPnt7dHJhaWxpbmdJY29ufX08L2k+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDQ2hpcEZvdW5kYXRpb24gZnJvbSBcIkBtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb25cIjtcbmltcG9ydCB7IEN1c3RvbUxpbmtNaXhpbiwgRGlzcGF0Y2hFdmVudE1peGluIH0gZnJvbSBcIi4uL2Jhc2VcIjtcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tIFwiLi4vcmlwcGxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJtZGMtY2hpcFwiLFxuICBtaXhpbnM6IFtDdXN0b21MaW5rTWl4aW4sIERpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgbGVhZGluZ0ljb246IFtTdHJpbmddLFxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZ10sXG4gICAgbGVhZGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XSxcbiAgICB0cmFpbGluZ0ljb25DbGFzc2VzOiBbT2JqZWN0XVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7fSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hpcEZvdW5kYXRpb24oe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBub3RpZnlJbnRlcmFjdGlvbjogKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAnY2xpY2snIH0pXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKTtcbiAgICB0aGlzLnJpcHBsZS5pbml0KCk7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGF2ZWxlYWRpbmdJY29uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5sZWFkaW5nSWNvbiB8fCB0aGlzLmxlYWRpbmdJY29uQ2xhc3NlcztcbiAgICB9LFxuICAgIGhhdmV0cmFpbGluZ0ljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLnRyYWlsaW5nSWNvbkNsYXNzZXM7XG4gICAgfSxcbiAgICBsZWFkaW5nQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAge1xuICAgICAgICAgIFwibWF0ZXJpYWwtaWNvbnNcIjogISF0aGlzLmxlYWRpbmdJY29uXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMubGVhZGluZ0ljb25DbGFzc2VzXG4gICAgICApO1xuICAgIH0sXG4gICAgdHJhaWxpbmdDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJtYXRlcmlhbC1pY29uc1wiOiAhIXRoaXMudHJhaWxpbmdJY29uXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMudHJhaWxpbmdJY29uQ2xhc3Nlc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KCk7XG4gIH1cbn07XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hpcCBTZXQuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgQ2hpcCBTZXQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBTZXRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoaXBTZXRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ0hJUF9TRUxFQ1RPUjogJy5tZGMtY2hpcCcsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NoaXBTZXRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hpcFNldEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0NoaXBTZXRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0NoaXBTZXRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0NoaXBTZXRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDQ2hpcFNldEFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDQ2hpcFNldEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoaXBTZXRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcFNldEZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgcmVmPVwicm9vdFwiIGNsYXNzPVwibWRjLWNoaXAtc2V0XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDQ2hpcFNldEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2NoaXBzL2NoaXAtc2V0L2ZvdW5kYXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hpcC1zZXQnLFxuICBwcm9wczoge30sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHt9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENDaGlwU2V0Rm91bmRhdGlvbih7XG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICB9KTtcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKTtcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNDaGlwIGZyb20gJy4vbWRjLWNoaXAudnVlJ1xuaW1wb3J0IG1kY0NoaXBTZXQgZnJvbSAnLi9tZGMtY2hpcC1zZXQudnVlJ1xuXG5leHBvcnQgeyBcbiAgbWRjQ2hpcCwgXG4gIG1kY0NoaXBTZXQgXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGlwLCBcbiAgbWRjQ2hpcFNldCBcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQge01EQ0ZvdW5kYXRpb24sIE1EQ0NvbXBvbmVudH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kaWFsb2cnLFxuICBPUEVOOiAnbWRjLWRpYWxvZy0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kaWFsb2ctLWFuaW1hdGluZycsXG4gIEJBQ0tEUk9QOiAnbWRjLWRpYWxvZ19fYmFja2Ryb3AnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kaWFsb2ctc2Nyb2xsLWxvY2snLFxuICBBQ0NFUFRfQlROOiAnbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWFjY2VwdCcsXG4gIENBTkNFTF9CVE46ICdtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tY2FuY2VsJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBPUEVOX0RJQUxPR19TRUxFQ1RPUjogJy5tZGMtZGlhbG9nLS1vcGVuJyxcbiAgRElBTE9HX1NVUkZBQ0VfU0VMRUNUT1I6ICcubWRjLWRpYWxvZ19fc3VyZmFjZScsXG4gIEFDQ0VQVF9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0JyxcbiAgQUNDRVBUX0VWRU5UOiAnTURDRGlhbG9nOmFjY2VwdCcsXG4gIENBTkNFTF9FVkVOVDogJ01EQ0RpYWxvZzpjYW5jZWwnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ0RpYWxvZ0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgvKiB0YXJnZXQ6IEV2ZW50VGFyZ2V0LCBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICB1bnRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICBpc0RpYWxvZzogKC8qIGVsOiBFbGVtZW50ICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgbGF5b3V0Rm9vdGVyUmlwcGxlczogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKGV2dC50YXJnZXQsIGNzc0NsYXNzZXMuQkFDS0RST1ApKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVEaWFsb2dDbGlja18oZXZ0KTtcbiAgICB0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgJiYgZXZ0LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZ0LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG4gIH07XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCBkaWFsb2cgaXMgY2xlYW5lZCB1cCB3aGVuIGRlc3Ryb3llZFxuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8udW50cmFwRm9jdXNPblN1cmZhY2UoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpYWxvZ0NsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXIodGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW5fO1xuICB9XG5cbiAgYWNjZXB0KHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5QWNjZXB0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgY2FuY2VsKHNob3VsZE5vdGlmeSkge1xuICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgaGFuZGxlRGlhbG9nQ2xpY2tfKGV2dCkge1xuICAgIGNvbnN0IHt0YXJnZXR9ID0gZXZ0O1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzLkFDQ0VQVF9CVE4pKSB7XG4gICAgICB0aGlzLmFjY2VwdCh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNzc0NsYXNzZXMuQ0FOQ0VMX0JUTikpIHtcbiAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzRGlhbG9nKGV2dC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnRyYXBGb2N1c09uU3VyZmFjZSgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmxheW91dEZvb3RlclJpcHBsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudERvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCB8fCBlbDtcbiAgdmFyIGJhc2ljVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG5cbiAgLy8gQSBub2RlIGlzIFwiYXZhaWxhYmxlXCIgaWZcbiAgLy8gLSBpdCdzIGNvbXB1dGVkIHN0eWxlXG4gIHZhciBpc1VuYXZhaWxhYmxlID0gY3JlYXRlSXNVbmF2YWlsYWJsZShlbGVtZW50RG9jdW1lbnQpO1xuXG4gIHZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICAgJ2lucHV0JyxcbiAgICAnc2VsZWN0JyxcbiAgICAnYVtocmVmXScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnW3RhYmluZGV4XScsXG4gIF07XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJykpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgaWYgKFxuICAgICAgY2FuZGlkYXRlU2VsZWN0b3JzLnNvbWUoZnVuY3Rpb24oY2FuZGlkYXRlU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUsIGNhbmRpZGF0ZUluZGV4O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcbiAgICBjYW5kaWRhdGVJbmRleCA9IHBhcnNlSW50KGNhbmRpZGF0ZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSB8fCBjYW5kaWRhdGUudGFiSW5kZXg7XG5cbiAgICBpZiAoXG4gICAgICBjYW5kaWRhdGVJbmRleCA8IDBcbiAgICAgIHx8IChjYW5kaWRhdGUudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBjYW5kaWRhdGUudHlwZSA9PT0gJ2hpZGRlbicpXG4gICAgICB8fCBjYW5kaWRhdGUuZGlzYWJsZWRcbiAgICAgIHx8IGlzVW5hdmFpbGFibGUoY2FuZGlkYXRlLCBlbGVtZW50RG9jdW1lbnQpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2FuZGlkYXRlSW5kZXggPT09IDApIHtcbiAgICAgIGJhc2ljVGFiYmFibGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVJbmRleCxcbiAgICAgICAgbm9kZTogY2FuZGlkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmluZGV4IC0gYi5pbmRleCA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xuICAgIH0pXG4gICAgLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYS5ub2RlXG4gICAgfSk7XG5cbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGFiYmFibGVOb2RlcywgYmFzaWNUYWJiYWJsZXMpO1xuXG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJc1VuYXZhaWxhYmxlKGVsZW1lbnREb2N1bWVudCkge1xuICAvLyBOb2RlIGNhY2hlIG11c3QgYmUgcmVmcmVzaGVkIG9uIGV2ZXJ5IGNoZWNrLCBpbiBjYXNlXG4gIC8vIHRoZSBjb250ZW50IG9mIHRoZSBlbGVtZW50IGhhcyBjaGFuZ2VkXG4gIHZhciBpc09mZkNhY2hlID0gW107XG5cbiAgLy8gXCJvZmZcIiBtZWFucyBgZGlzcGxheTogbm9uZTtgLCBhcyBvcHBvc2VkIHRvIFwiaGlkZGVuXCIsXG4gIC8vIHdoaWNoIG1lYW5zIGB2aXNpYmlsaXR5OiBoaWRkZW47YC4gZ2V0Q29tcHV0ZWRTdHlsZVxuICAvLyBhY2N1cmF0ZWx5IHJlZmxlY3RzIHZpc2libGl0eSBpbiBjb250ZXh0IGJ1dCBub3RcbiAgLy8gXCJvZmZcIiBzdGF0ZSwgc28gd2UgbmVlZCB0byByZWN1cnNpdmVseSBjaGVjayBwYXJlbnRzLlxuXG4gIGZ1bmN0aW9uIGlzT2ZmKG5vZGUsIG5vZGVDb21wdXRlZFN0eWxlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVsZW1lbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEZpbmQgdGhlIGNhY2hlZCBub2RlIChBcnJheS5wcm90b3R5cGUuZmluZCBub3QgYXZhaWxhYmxlIGluIElFOSlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaXNPZmZDYWNoZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzT2ZmQ2FjaGVbaV1bMF0gPT09IG5vZGUpIHJldHVybiBpc09mZkNhY2hlW2ldWzFdO1xuICAgIH1cblxuICAgIG5vZGVDb21wdXRlZFN0eWxlID0gbm9kZUNvbXB1dGVkU3R5bGUgfHwgZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICBpZiAobm9kZUNvbXB1dGVkU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICByZXN1bHQgPSBpc09mZihub2RlLnBhcmVudE5vZGUpO1xuICAgIH1cblxuICAgIGlzT2ZmQ2FjaGUucHVzaChbbm9kZSwgcmVzdWx0XSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGlzVW5hdmFpbGFibGUobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbGVtZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGVsZW1lbnREb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgaWYgKGlzT2ZmKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBjb21wdXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nO1xuICB9XG59XG4iLCJ2YXIgdGFiYmFibGUgPSByZXF1aXJlKCd0YWJiYWJsZScpO1xuXG52YXIgbGlzdGVuaW5nRm9jdXNUcmFwID0gbnVsbDtcblxuZnVuY3Rpb24gZm9jdXNUcmFwKGVsZW1lbnQsIHVzZXJPcHRpb25zKSB7XG4gIHZhciB0YWJiYWJsZU5vZGVzID0gW107XG4gIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IG51bGw7XG4gIHZhciBsYXN0VGFiYmFibGVOb2RlID0gbnVsbDtcbiAgdmFyIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IG51bGw7XG4gIHZhciBhY3RpdmUgPSBmYWxzZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICB2YXIgdGFiRXZlbnQgPSBudWxsO1xuXG4gIHZhciBjb250YWluZXIgPSAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KVxuICAgIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0gdXNlck9wdGlvbnMgfHwge307XG4gIGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGVcbiAgICA6IHRydWU7XG4gIGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMuZXNjYXBlRGVhY3RpdmF0ZXNcbiAgICA6IHRydWU7XG5cbiAgdmFyIHRyYXAgPSB7XG4gICAgYWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgIGRlYWN0aXZhdGU6IGRlYWN0aXZhdGUsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIHVucGF1c2U6IHVucGF1c2UsXG4gIH07XG5cbiAgcmV0dXJuIHRyYXA7XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGUoYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKGFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIG9uQWN0aXZhdGU6IChhY3RpdmF0ZU9wdGlvbnMgJiYgYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkFjdGl2YXRlLFxuICAgIH07XG5cbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUpIHtcbiAgICAgIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKCFhY3RpdmUpIHJldHVybjtcblxuICAgIHZhciBkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIHJldHVybkZvY3VzOiAoZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1c1xuICAgICAgICA6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSxcbiAgICAgIG9uRGVhY3RpdmF0ZTogKGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgfTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5Rm9jdXMobm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaWYgKHBhdXNlZCB8fCAhYWN0aXZlKSByZXR1cm47XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKCFwYXVzZWQgfHwgIWFjdGl2ZSkgcmV0dXJuO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghYWN0aXZlKSByZXR1cm47XG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG4gICAgaWYgKGxpc3RlbmluZ0ZvY3VzVHJhcCkge1xuICAgICAgbGlzdGVuaW5nRm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgfVxuICAgIGxpc3RlbmluZ0ZvY3VzVHJhcCA9IHRyYXA7XG5cbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgdHJ5Rm9jdXMoZmlyc3RGb2N1c05vZGUoKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjaGVja0ZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFhY3RpdmUgfHwgbGlzdGVuaW5nRm9jdXNUcmFwICE9PSB0cmFwKSByZXR1cm47XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGNoZWNrRm9jdXMsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG5cbiAgICBsaXN0ZW5pbmdGb2N1c1RyYXAgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlRm9yT3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG4gICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTtcbiAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIHJlZmVycyB0byBubyBrbm93biBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgZGlkIG5vdCByZXR1cm4gYSBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyc3RGb2N1c05vZGUoKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJyk7XG4gICAgfSBlbHNlIGlmIChjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdGFiYmFibGVOb2Rlc1swXSB8fCBnZXROb2RlRm9yT3B0aW9uKCdmYWxsYmFja0ZvY3VzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5cXCd0IGhhdmUgYSBmb2N1cy10cmFwIHdpdGhvdXQgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgb24gbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGluc3RlYWQgb2YgY2xpY2tcbiAgLy8gc28gdGhhdCBpdCBwcmVjZWRlcyB0aGUgZm9jdXMgZXZlbnRcbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRG93bihlKSB7XG4gICAgaWYgKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcyAmJiAhY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgZGVhY3RpdmF0ZSh7IHJldHVybkZvY3VzOiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9jdXMoZSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgLy8gQ2hlY2tpbmcgZm9yIGEgYmx1ciBtZXRob2QgaGVyZSByZXNvbHZlcyBhIEZpcmVmb3ggaXNzdWUgKCMxNSlcbiAgICBpZiAodHlwZW9mIGUudGFyZ2V0LmJsdXIgPT09ICdmdW5jdGlvbicpIGUudGFyZ2V0LmJsdXIoKTtcblxuICAgIGlmICh0YWJFdmVudCkge1xuICAgICAgcmVhZGp1c3RGb2N1cyh0YWJFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICBoYW5kbGVUYWIoZSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gZmFsc2UgJiYgaXNFc2NhcGVFdmVudChlKSkge1xuICAgICAgZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYihlKSB7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuXG4gICAgaWYgKGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBOdW1iZXIoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKSA8IDApIHtcbiAgICAgIHJldHVybiB0YWJFdmVudCA9IGU7XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjdXJyZW50Rm9jdXNJbmRleCA9IHRhYmJhYmxlTm9kZXMuaW5kZXhPZihlLnRhcmdldCk7XG5cbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZSB8fCB0YWJiYWJsZU5vZGVzLmluZGV4T2YoZS50YXJnZXQpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ5Rm9jdXModGFiYmFibGVOb2Rlc1tjdXJyZW50Rm9jdXNJbmRleCAtIDFdKTtcbiAgICB9XG5cbiAgICBpZiAoZS50YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGUpIHJldHVybiB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyh0YWJiYWJsZU5vZGVzW2N1cnJlbnRGb2N1c0luZGV4ICsgMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGFiYmFibGVOb2RlcygpIHtcbiAgICB0YWJiYWJsZU5vZGVzID0gdGFiYmFibGUoY29udGFpbmVyKTtcbiAgICBmaXJzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbMF07XG4gICAgbGFzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRqdXN0Rm9jdXMoZSkge1xuICAgIGlmIChlLnNoaWZ0S2V5KSByZXR1cm4gdHJ5Rm9jdXMobGFzdFRhYmJhYmxlTm9kZSk7XG5cbiAgICB0cnlGb2N1cyhmaXJzdFRhYmJhYmxlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFc2NhcGVFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ0VzY2FwZScgfHwgZS5rZXkgPT09ICdFc2MnIHx8IGUua2V5Q29kZSA9PT0gMjc7XG59XG5cbmZ1bmN0aW9uIHRyeUZvY3VzKG5vZGUpIHtcbiAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSByZXR1cm47XG4gIGlmIChub2RlID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAgcmV0dXJuO1xuXG4gIG5vZGUuZm9jdXMoKTtcbiAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgbm9kZS5zZWxlY3QoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzVHJhcDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBjcmVhdGVGb2N1c1RyYXAgZnJvbSAnZm9jdXMtdHJhcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZShzdXJmYWNlRWwsIGFjY2VwdEJ1dHRvbkVsLCBmb2N1c1RyYXBGYWN0b3J5ID0gY3JlYXRlRm9jdXNUcmFwKSB7XG4gIHJldHVybiBmb2N1c1RyYXBGYWN0b3J5KHN1cmZhY2VFbCwge1xuICAgIGluaXRpYWxGb2N1czogYWNjZXB0QnV0dG9uRWwsXG4gICAgY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM6IHRydWUsXG4gIH0pO1xufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGUgY2xhc3M9XCJtZGMtZGlhbG9nXCIgcmVmPVwicm9vdFwiIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIHJvbGU9XCJhbGVydGRpYWxvZ1wiXG4gICAgOmFyaWEtbGFiZWxsZWRieT1cIidsYWJlbCcgKyBfdWlkXCJcbiAgICA6YXJpYS1kZXNjcmliZWRieT1cIidkZXNjJyArIF91aWRcIlxuICA+XG4gICAgPGRpdiAgcmVmPVwic3VyZmFjZVwiIGNsYXNzPVwibWRjLWRpYWxvZ19fc3VyZmFjZVwiIDpjbGFzcz1cInN1cmZhY2VDbGFzc2VzXCI+XG4gICAgICA8aGVhZGVyIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyXCI+XG4gICAgICAgIDxoMiA6aWQ9XCInbGFiZWwnICsgX3VpZFwiIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyX190aXRsZVwiPlxuICAgICAgICAgIHt7IHRpdGxlIH19XG4gICAgICAgIDwvaDI+XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIDxzZWN0aW9uIDppZD1cIidkZXNjJyArIF91aWRcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2JvZHlcIiA6Y2xhc3M9XCJib2R5Q2xhc3Nlc1wiPlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgICAgPGZvb3RlciBjbGFzcz1cIm1kYy1kaWFsb2dfX2Zvb3RlclwiPlxuICAgICAgICA8bWRjQnV0dG9uIHJlZj1cImNhbmNlbFwiIHYtaWY9XCJjYW5jZWxcIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b25cIlxuICAgICAgICAgIDpjbGFzcz1cInsnbWRjLWRpYWxvZ19fYWN0aW9uJzphY2NlbnR9XCJcbiAgICAgICAgICBAY2xpY2s9XCJvbkNhbmNlbFwiXG4gICAgICAgICAgPnt7IGNhbmNlbCB9fTwvbWRjQnV0dG9uPlxuICAgICAgICA8bWRjQnV0dG9uICByZWY9XCJhY2NlcHRcIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b25cIlxuICAgICAgICAgIDpjbGFzcz1cInsnbWRjLWRpYWxvZ19fYWN0aW9uJzphY2NlbnR9XCJcbiAgICAgICAgICA6ZGlzYWJsZWQ9XCJhY2NlcHREaXNhYmxlZFwiXG4gICAgICAgICAgQGNsaWNrPVwib25BY2NlcHRcIlxuICAgICAgICA+e3sgYWNjZXB0IH19PC9tZGNCdXR0b24+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRpYWxvZ19fYmFja2Ryb3BcIj48L2Rpdj5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDRGlhbG9nRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZSB9IGZyb20gJ0BtYXRlcmlhbC9kaWFsb2cvdXRpbCdcbmltcG9ydCB7bWRjQnV0dG9ufSBmcm9tICcuLi9idXR0b24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kaWFsb2cnLFxuICBwcm9wczoge1xuICAgIHRpdGxlOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICBhY2NlcHQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnT2snIH0sXG4gICAgYWNjZXB0RGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgY2FuY2VsOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ0NhbmNlbCcgfSxcbiAgICBhY2NlbnQ6IEJvb2xlYW4sXG4gICAgc2Nyb2xsYWJsZTogQm9vbGVhblxuICB9LFxuICBjb21wb25lbnRzOiB7XG4gICAgbWRjQnV0dG9uIDogbWRjQnV0dG9uXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGhlbWUtLWRhcmsnOiB0aGlzLmRhcmtcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgc3VyZmFjZUNsYXNzZXM6IHt9LFxuICAgICAgYm9keUNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1kaWFsb2dfX2JvZHktLXNjcm9sbGFibGUnOiB0aGlzLnNjcm9sbGFibGVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm9jdXNUcmFwID0gY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UoXG4gICAgICB0aGlzLiRyZWZzLnN1cmZhY2UsIHRoaXMuJHJlZnMuYWNjZXB0KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0RpYWxvZ0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGFkZEJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IChjbGFzc05hbWUpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICByZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKmV2dCwgaGFuZGxlciovKSA9PiB7XG4gICAgICAgIC8vIFZNQV9IQUNLOiBoYW5kbGUgYnV0dG9uIGNsaWNrcyBvdXJzZWx2ZXNcbiAgICAgICAgLy8gdGhpcy4kcmVmcy5zdXJmYWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLypldnQsIGhhbmRsZXIqLykgPT4ge1xuICAgICAgICAvLyBWTUFfSEFDSzogaGFuZGxlIGJ1dHRvbiBjbGlja3Mgb3Vyc2VsdmVzXG4gICAgICAgIC8vIHRoaXMuJHJlZnMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKSxcbiAgICAgIG5vdGlmeUFjY2VwdDogKCkgPT4gdGhpcy4kZW1pdCgnYWNjZXB0JyksXG4gICAgICBub3RpZnlDYW5jZWw6ICgpID0+IHRoaXMuJGVtaXQoJ2NhbmNlbCcpLFxuICAgICAgdHJhcEZvY3VzT25TdXJmYWNlOiAoKSA9PiB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpLFxuICAgICAgdW50cmFwRm9jdXNPblN1cmZhY2U6ICgpID0+IHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoKSxcbiAgICAgIGlzRGlhbG9nOiAoZWwpID0+ICh0aGlzLiRyZWZzLnN1cmZhY2UgPT09IGVsKSxcbiAgICAgIGxheW91dEZvb3RlclJpcHBsZXM6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5hY2NlcHQucmlwcGxlLmxheW91dCgpXG4gICAgICAgIHRoaXMuY2FuY2VsICYmIHRoaXMuJHJlZnMuY2FuY2VsLnJpcHBsZS5sYXlvdXQoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2FuY2VsKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNhbmNlbCh0cnVlKTtcbiAgICB9LFxuICAgIG9uQWNjZXB0KCkge1xuICAgICAgaWYgKHRoaXMuJGxpc3RlbmVyc1sndmFsaWRhdGUnXSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd2YWxpZGF0ZScsIHtcbiAgICAgICAgICBhY2NlcHQ6IChub3RpZnkgPSB0cnVlKSA9PiB0aGlzLmZvdW5kYXRpb24uYWNjZXB0KG5vdGlmeSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uYWNjZXB0KHRydWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93ICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICB9LFxuICAgIGNsb3NlICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEaWFsb2cgZnJvbSAnLi9tZGMtZGlhbG9nLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjRGlhbG9nXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEaWFsb2dcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgY2xhc3M9XCJtZGMtcGVybWFuZW50LWRyYXdlciBtZGMtZHJhd2VyLS1wZXJtYW5lbnQgbWRjLXR5cG9ncmFwaHlcIj5cbiAgICA8bmF2IGNsYXNzPVwibWRjLWRyYXdlcl9fY29udGVudFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIgXG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCI+PC9kaXY+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcGVybWFuZW50LWRyYXdlcicsXG4gIHByb3BzOiB7XG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhbixcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID1cbiAgJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCAnICtcbiAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgW3RhYmluZGV4XSwgW2NvbnRlbnRlZGl0YWJsZV0nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnQ6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUcmFuc2xhdGVYOiAoLyogdmFsdWU6IG51bWJlciB8IG51bGwgKi8pID0+IHt9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IC8qIE5vZGVMaXN0ICovIHt9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKC8qIGVsOiBFbGVtZW50ICovKSA9PiB7fSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICBtYWtlRWxlbWVudFVudGFiYmFibGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7fSxcbiAgICAgIGlzUnRsOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCByb290Q3NzQ2xhc3MsIGFuaW1hdGluZ0Nzc0NsYXNzLCBvcGVuQ3NzQ2xhc3MpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5yb290Q3NzQ2xhc3NfID0gcm9vdENzc0NsYXNzO1xuICAgIHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfID0gYW5pbWF0aW5nQ3NzQ2xhc3M7XG4gICAgdGhpcy5vcGVuQ3NzQ2xhc3NfID0gb3BlbkNzc0NsYXNzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG5cbiAgICB0aGlzLmluZXJ0XyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoU3RhcnRfKGV2dCk7XG4gICAgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hNb3ZlXyhldnQpO1xuICAgIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVG91Y2hFbmRfKGV2dCk7XG4gICAgdGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2dC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3QgUk9PVCA9IHRoaXMucm9vdENzc0NsYXNzXztcbiAgICBjb25zdCBPUEVOID0gdGhpcy5vcGVuQ3NzQ2xhc3NfO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKFJPT1QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Uk9PVH0gY2xhc3MgcmVxdWlyZWQgaW4gcm9vdCBlbGVtZW50LmApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNOZWNlc3NhcnlEb20oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlZCBET00gbm9kZXMgbWlzc2luZyBpbiAke1JPT1R9IGNvbXBvbmVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhPUEVOKSkge1xuICAgICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXRhYmluYXRlXygpO1xuICAgICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaG1vdmUnLCB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaGVuZCcsIHRoaXMuY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNobW92ZScsIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hlbmQnLCB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8pO1xuICAgIC8vIERlcmVnaXN0ZXIgdGhlIGRvY3VtZW50IGtleWRvd24gaGFuZGxlciBqdXN0IGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgd2hpbGUgdGhlIG1lbnUgaXMgb3Blbi5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLnJldGFiaW5hdGVfKCk7XG4gICAgLy8gRGVib3VuY2UgbXVsdGlwbGUgY2FsbHNcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlPcGVuKCk7XG4gICAgfVxuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pO1xuICAgIHRoaXMuZGV0YWJpbmF0ZV8oKTtcbiAgICAvLyBEZWJvdW5jZSBtdWx0aXBsZSBjYWxsc1xuICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuXztcbiAgfVxuXG4gIC8qKlxuICAgKiAgUmVuZGVyIGFsbCBjaGlsZHJlbiBvZiB0aGUgZHJhd2VyIGluZXJ0IHdoZW4gaXQncyBjbG9zZWQuXG4gICAqL1xuICBkZXRhYmluYXRlXygpIHtcbiAgICBpZiAodGhpcy5pbmVydF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zYXZlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5tYWtlRWxlbWVudFVudGFiYmFibGUoZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5lcnRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgTWFrZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGRyYXdlciB0YWJiYWJsZSBhZ2FpbiB3aGVuIGl0J3Mgb3Blbi5cbiAgICovXG4gIHJldGFiaW5hdGVfKCkge1xuICAgIGlmICghdGhpcy5pbmVydF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluZXJ0XyA9IGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hTdGFydF8oZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKHRoaXMub3BlbkNzc0NsYXNzXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpcmVjdGlvbl8gPSB0aGlzLmFkYXB0ZXJfLmlzUnRsKCkgPyAtMSA6IDE7XG4gICAgdGhpcy5kcmF3ZXJXaWR0aF8gPSB0aGlzLmFkYXB0ZXJfLmdldERyYXdlcldpZHRoKCk7XG4gICAgdGhpcy5zdGFydFhfID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5wYWdlWCA6IGV2dC5wYWdlWDtcbiAgICB0aGlzLmN1cnJlbnRYXyA9IHRoaXMuc3RhcnRYXztcblxuICAgIHRoaXMudXBkYXRlUmFmXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZURyYXdlcl8uYmluZCh0aGlzKSk7XG4gIH1cblxuICBoYW5kbGVUb3VjaE1vdmVfKGV2dCkge1xuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50WF8gPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLnBhZ2VYIDogZXZ0LnBhZ2VYO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hFbmRfKGV2dCkge1xuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmVwYXJlRm9yVG91Y2hFbmRfKCk7XG5cbiAgICAvLyBEaWQgdGhlIHVzZXIgY2xvc2UgdGhlIGRyYXdlciBieSBtb3JlIHRoYW4gNTAlP1xuICAgIGlmIChNYXRoLmFicyh0aGlzLm5ld1Bvc2l0aW9uXyAvIHRoaXMuZHJhd2VyV2lkdGhfKSA+PSAwLjUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJpZ2dlcmluZyBhbiBvcGVuIGhlcmUgbWVhbnMgd2UnbGwgZ2V0IGEgbmljZSBhbmltYXRpb24gYmFjayB0byB0aGUgZnVsbHkgb3BlbiBzdGF0ZS5cbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVGb3JUb3VjaEVuZF8oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVSYWZfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFRyYW5zbGF0ZVgobnVsbCk7XG4gIH1cblxuICB1cGRhdGVEcmF3ZXJfKCkge1xuICAgIHRoaXMudXBkYXRlUmFmXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZURyYXdlcl8uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2xhdGVYKHRoaXMubmV3UG9zaXRpb25fKTtcbiAgfVxuXG4gIGdldCBuZXdQb3NpdGlvbl8oKSB7XG4gICAgbGV0IG5ld1BvcyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5kaXJlY3Rpb25fID09PSAxKSB7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1pbigwLCB0aGlzLmN1cnJlbnRYXyAtIHRoaXMuc3RhcnRYXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWF4KDAsIHRoaXMuY3VycmVudFhfIC0gdGhpcy5zdGFydFhfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZVxuICAgIC8vIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgdGhlIHJvb3QgZXZlbnQgdGFyZ2V0IGN1cnJlbnRseSB0cmFuc2l0aW9uaW5nLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIGlmICh0aGlzLmlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZXZ0LnRhcmdldCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIH1cbiAgfTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi9mb3VuZGF0aW9uJztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWRyYXdlci0tcGVyc2lzdGVudCcsXG4gIE9QRU46ICdtZGMtZHJhd2VyLS1vcGVuJyxcbiAgQU5JTUFUSU5HOiAnbWRjLWRyYXdlci0tYW5pbWF0aW5nJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBEUkFXRVJfU0VMRUNUT1I6ICcubWRjLWRyYXdlci0tcGVyc2lzdGVudCAubWRjLWRyYXdlcl9fZHJhd2VyJyxcbiAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICBPUEVOX0VWRU5UOiAnTURDUGVyc2lzdGVudERyYXdlcjpvcGVuJyxcbiAgQ0xPU0VfRVZFTlQ6ICdNRENQZXJzaXN0ZW50RHJhd2VyOmNsb3NlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIHtcbiAgICAgIGlzRHJhd2VyOiAoKSA9PiBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpLFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5ST09ULFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcsXG4gICAgICBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyhlbCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzRHJhd2VyKGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgVEFCX0RBVEEgPSAnZGF0YS1tZGMtdGFiaW5kZXgnO1xuY29uc3QgVEFCX0RBVEFfSEFORExFRCA9ICdkYXRhLW1kYy10YWJpbmRleC1oYW5kbGVkJztcblxubGV0IHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLy8gUmVtYXAgdG91Y2ggZXZlbnRzIHRvIHBvaW50ZXIgZXZlbnRzLCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdG91Y2ggZXZlbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHJlbWFwRXZlbnQoZXZlbnROYW1lLCBnbG9iYWxPYmogPSB3aW5kb3cpIHtcbiAgaWYgKCEoJ29udG91Y2hzdGFydCcgaW4gZ2xvYmFsT2JqLmRvY3VtZW50KSkge1xuICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICByZXR1cm4gJ3BvaW50ZXJkb3duJztcbiAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgcmV0dXJuICdwb2ludGVybW92ZSc7XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgcmV0dXJuICdwb2ludGVydXAnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbi8vIENob29zZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdXNlIG9uIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBjb25zdCBlbCA9IGdsb2JhbE9iai5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUgPSAoJ3RyYW5zZm9ybScgaW4gZWwuc3R5bGUgPyAndHJhbnNmb3JtJyA6ICctd2Via2l0LXRyYW5zZm9ybScpO1xuICAgIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPSB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWU7XG4gIH1cblxuICByZXR1cm4gc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcbn1cblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBDU1MgcHJvcGVydGllcy5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMoZ2xvYmFsT2JqID0gd2luZG93KSB7XG4gIGlmICgnQ1NTJyBpbiBnbG9iYWxPYmopIHtcbiAgICByZXR1cm4gZ2xvYmFsT2JqLkNTUy5zdXBwb3J0cygnKC0tY29sb3I6IHJlZCknKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZCBpZiBzbywgdXNlIHRoZW0uXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8vIFNhdmUgdGhlIHRhYiBzdGF0ZSBmb3IgYW4gZWxlbWVudC5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRWxlbWVudFRhYlN0YXRlKGVsKSB7XG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoVEFCX0RBVEEsIGVsLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSk7XG4gIH1cbiAgZWwuc2V0QXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQsIHRydWUpO1xufVxuXG4vLyBSZXN0b3JlIHRoZSB0YWIgc3RhdGUgZm9yIGFuIGVsZW1lbnQsIGlmIGl0IHdhcyBzYXZlZC5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKSB7XG4gIC8vIE9ubHkgbW9kaWZ5IGVsZW1lbnRzIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCwgaW4gY2FzZSBhbnl0aGluZyB3YXMgZHluYW1pY2FsbHkgYWRkZWQgc2luY2Ugd2Ugc2F2ZWQgc3RhdGUuXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCkpIHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKFRBQl9EQVRBKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIGVsLmdldEF0dHJpYnV0ZShUQUJfREFUQSkpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFRBQl9EQVRBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoVEFCX0RBVEFfSEFORExFRCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGFzaWRlIGNsYXNzPVwibWRjLXBlcnNpc3RlbnQtZHJhd2VyIG1kYy1kcmF3ZXItLXBlcnNpc3RlbnQgbWRjLXR5cG9ncmFwaHlcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPG5hdiByZWY9XCJkcmF3ZXJcIiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2RyYXdlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIgXG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCI+PC9kaXY+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L2FzaWRlPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZHJhd2VyL3BlcnNpc3RlbnQvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL2RyYXdlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuLFxuICAgICdvcGVuJzpCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbigpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2goKVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIF9yZWZyZXNoKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKSAgICAgICAgICBcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKCkgICAgICAgICAgXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICBjb25zdCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSA9IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLnN0cmluZ3NcblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICB9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKGVsKSA9PiB7XG4gICAgICAgIHV0aWwuc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiAoZWwpID0+IHtcbiAgICAgICAgdXRpbC5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsdHJ1ZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyxmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKVxuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIC8qIGdsb2JhbCBnZXRDb21wdXRlZFN0eWxlICovXG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCdcbiAgICAgIH0sXG4gICAgICBpc0RyYXdlcjogKGVsKSA9PiB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uaW5pdCgpICBcbiAgICB0aGlzLl9yZWZyZXNoKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtGT0NVU0FCTEVfRUxFTUVOVFN9IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtZHJhd2VyLS10ZW1wb3JhcnknLFxuICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kcmF3ZXItLWFuaW1hdGluZycsXG4gIFNDUk9MTF9MT0NLOiAnbWRjLWRyYXdlci1zY3JvbGwtbG9jaycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgRFJBV0VSX1NFTEVDVE9SOiAnLm1kYy1kcmF3ZXItLXRlbXBvcmFyeSAubWRjLWRyYXdlcl9fZHJhd2VyJyxcbiAgT1BBQ0lUWV9WQVJfTkFNRTogJy0tbWRjLXRlbXBvcmFyeS1kcmF3ZXItb3BhY2l0eScsXG4gIEZPQ1VTQUJMRV9FTEVNRU5UUyxcbiAgT1BFTl9FVkVOVDogJ01EQ1RlbXBvcmFyeURyYXdlcjpvcGVuJyxcbiAgQ0xPU0VfRVZFTlQ6ICdNRENUZW1wb3JhcnlEcmF3ZXI6Y2xvc2UnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9ufSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCB7XG4gICAgICBhZGRCb2R5Q2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBpc0RyYXdlcjogKCkgPT4gZmFsc2UsXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKC8qIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKC8qIHRhcmdldDogRXZlbnRUYXJnZXQsIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKFxuICAgICAgT2JqZWN0LmFzc2lnbihNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5ST09ULFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3MoZXZ0LnRhcmdldCwgY3NzQ2xhc3Nlcy5ST09UKSkge1xuICAgICAgICB0aGlzLmNsb3NlKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIHN1cGVyLmluaXQoKTtcblxuICAgIC8vIE1ha2UgYnJvd3NlciBhd2FyZSBvZiBjdXN0b20gcHJvcGVydHkgYmVpbmcgdXNlZCBpbiB0aGlzIGVsZW1lbnQuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBoYXJkLXRvLXJlcHJvZHVjZSBoZWlzZW5idWdzLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoMCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmVuYWJsZVNjcm9sbF8oKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5kaXNhYmxlU2Nyb2xsXygpO1xuICAgIC8vIE1ha2Ugc3VyZSBjdXN0b20gcHJvcGVydHkgdmFsdWVzIGFyZSBjbGVhcmVkIGJlZm9yZSBzdGFydGluZy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcblxuICAgIHN1cGVyLm9wZW4oKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIC8vIE1ha2Ugc3VyZSBjdXN0b20gcHJvcGVydHkgdmFsdWVzIGFyZSBjbGVhcmVkIGJlZm9yZSBtYWtpbmcgYW55IGNoYW5nZXMuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgnJyk7XG5cbiAgICBzdXBlci5jbG9zZSgpO1xuICB9XG5cbiAgcHJlcGFyZUZvclRvdWNoRW5kXygpIHtcbiAgICBzdXBlci5wcmVwYXJlRm9yVG91Y2hFbmRfKCk7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcbiAgfVxuXG4gIHVwZGF0ZURyYXdlcl8oKSB7XG4gICAgc3VwZXIudXBkYXRlRHJhd2VyXygpO1xuXG4gICAgY29uc3QgbmV3T3BhY2l0eSA9IE1hdGgubWF4KDAsIDEgKyB0aGlzLmRpcmVjdGlvbl8gKiAodGhpcy5uZXdQb3NpdGlvbl8gLyB0aGlzLmRyYXdlcldpZHRoXykpO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUobmV3T3BhY2l0eSk7XG4gIH1cblxuICBpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaXNEcmF3ZXIoZWwpO1xuICB9XG5cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KSB7XG4gICAgc3VwZXIuaGFuZGxlVHJhbnNpdGlvbkVuZF8oZXZ0KTtcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gICAgfVxuICB9O1xuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8YXNpZGUgY2xhc3M9XCJtZGMtdGVtcG9yYXJ5LWRyYXdlciBtZGMtZHJhd2VyLS10ZW1wb3JhcnkgbWRjLXR5cG9ncmFwaHlcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPG5hdiByZWY9XCJkcmF3ZXJcIiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2RyYXdlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIgdi1pZj1cInRvb2xiYXJTcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL2RyYXdlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgICdvcGVuJzogQm9vbGVhbixcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuLFxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW4oKSB7XG4gICAgICB0aGlzLl9yZWZyZXNoKClcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKCkgICAgICAgICAgXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpICAgICAgICAgIFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgY29uc3Qge0ZPQ1VTQUJMRV9FTEVNRU5UUywgT1BBQ0lUWV9WQVJfTkFNRX0gPSBcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uc3RyaW5nc1xuICAgIFxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgYWRkQm9keUNsYXNzOiAoY2xhc3NOYW1lKSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAodGFyZ2V0LCBjbGFzc05hbWUpID0+IHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLiRyZWZzLmRyYXdlclxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIodXRpbC5yZW1hcEV2ZW50KGV2dCksIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5yZW1vdmVFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZ2V0RHJhd2VyV2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLm9mZnNldFdpZHRoXG4gICAgICB9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh1dGlsLnN1cHBvcnRzQ3NzQ3VzdG9tUHJvcGVydGllcygpKSB7XG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUuc2V0UHJvcGVydHkoT1BBQ0lUWV9WQVJfTkFNRSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICB9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogKGVsKSA9PiB7XG4gICAgICAgIHV0aWwuc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiAoZWwpID0+IHtcbiAgICAgICAgdXRpbC5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsdHJ1ZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyxmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKVxuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIC8qIGdsb2JhbCBnZXRDb21wdXRlZFN0eWxlICovXG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCdcbiAgICAgIH0sXG4gICAgICBpc0RyYXdlcjogKGVsKSA9PiBlbCA9PT0gdGhpcy4kcmVmcy5kcmF3ZXIsXG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmluaXQoKSAgXG4gICAgdGhpcy5fcmVmcmVzaCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y29tcG9uZW50ICByZWY9XCJkcmF3ZXJcIiBjbGFzcz1cIm1kYy1kcmF3ZXJcIlxyXG4gICAgICA6aXM9XCJ0eXBlXCIgdi1tb2RlbD1cIm9wZW5fXCJcclxuICAgICAgOnRvb2xiYXItc3BhY2VyPVwidG9vbGJhclNwYWNlclwiXHJcbiAgICAgIEBjaGFuZ2U9XCIkcm9vdC4kZW1pdCgnbWRjOmxheW91dCcpXCIgXHJcbiAgICAgIEBvcGVuPVwiJGVtaXQoJ29wZW4nKVwiIFxyXG4gICAgICBAY2xvc2U9XCIkZW1pdCgnY2xvc2UnKVwiID5cclxuICAgIDxzbG90IC8+XHJcbiAgPC9jb21wb25lbnQ+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgbWRjUGVybWFuZW50RHJhd2VyIGZyb20gJy4vbWRjLXBlcm1hbmVudC1kcmF3ZXIudnVlJ1xyXG5pbXBvcnQgbWRjUGVyc2lzdGVudERyYXdlciBmcm9tICcuL21kYy1wZXJzaXN0ZW50LWRyYXdlci52dWUnXHJcbmltcG9ydCBtZGNUZW1wb3JhcnlEcmF3ZXIgZnJvbSAnLi9tZGMtdGVtcG9yYXJ5LWRyYXdlci52dWUnXHJcblxyXG5jb25zdCBtZWRpYSA9IG5ldyBjbGFzcyB7XHJcbiAgZ2V0IHNtYWxsICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zbWFsbCB8fCAodGhpcy5fc21hbGwgPVxyXG4gICAgICB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogODM5cHgpJykpXHJcbiAgfVxyXG5cclxuICBnZXQgbGFyZ2UgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xhcmdlIHx8ICh0aGlzLl9sYXJnZSA9XHJcbiAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiAxMjAwcHgpJykpXHJcbiAgfVxyXG59KClcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWRyYXdlcicsXHJcbiAgcHJvcHM6IHtcclxuICAgIHBlcm1hbmVudDogQm9vbGVhbixcclxuICAgIHBlcnNpc3RlbnQ6IEJvb2xlYW4sXHJcbiAgICB0ZW1wb3Jhcnk6IEJvb2xlYW4sXHJcbiAgICBkcmF3ZXJUeXBlOiB7XHJcbiAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgdmFsaWRhdG9yOiAodmFsKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCBpbiBbJ3RlbXBvcmFyeScsICdwZXJzaXN0ZW50JywgJ3Blcm1hbmVudCddXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0b29sYmFyU3BhY2VyOiBCb29sZWFuLFxyXG4gICAgdG9nZ2xlT246IFN0cmluZyxcclxuICAgIHRvZ2dsZU9uU291cmNlOiB7dHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2V9LFxyXG4gICAgb3Blbk9uOiBTdHJpbmcsXHJcbiAgICBvcGVuT25Tb3VyY2U6IHt0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZX0sXHJcbiAgICBjbG9zZU9uOiBTdHJpbmcsXHJcbiAgICBjbG9zZU9uU291cmNlOiB7dHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2V9LFxyXG4gIH0sXHJcbiAgcHJvdmlkZSAoKSB7XHJcbiAgICByZXR1cm4geyBtZGNEcmF3ZXI6IHRoaXMgfVxyXG4gIH0sXHJcbiAgZGF0YSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzbWFsbDogZmFsc2UsXHJcbiAgICAgIGxhcmdlOiBmYWxzZSxcclxuICAgICAgb3Blbl86IGZhbHNlLFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcG9uZW50czoge1xyXG4gICAgJ21kYy1wZXJtYW5lbnQtZHJhd2VyJzogbWRjUGVybWFuZW50RHJhd2VyLFxyXG4gICAgJ21kYy1wZXJzaXN0ZW50LWRyYXdlcic6IG1kY1BlcnNpc3RlbnREcmF3ZXIsXHJcbiAgICAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInOiBtZGNUZW1wb3JhcnlEcmF3ZXJcclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICB0eXBlICgpIHtcclxuICAgICAgaWYgKHRoaXMucGVybWFuZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICdtZGMtcGVybWFuZW50LWRyYXdlcidcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlcnNpc3RlbnQpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnRlbXBvcmFyeSkge1xyXG4gICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmRyYXdlclR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgJ3Blcm1hbmVudCc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXBlcm1hbmVudC1kcmF3ZXInO1xyXG4gICAgICAgICAgY2FzZSAncGVyc2lzdGVudCc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJztcclxuICAgICAgICAgIGNhc2UgJ3RlbXBvcmFyeSc6XHJcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc21hbGwgPyAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInIDogJ21kYy1wZXJzaXN0ZW50LWRyYXdlcidcclxuICAgICAgICB9XHJcbiAgICAgIH0gIFxyXG4gICAgfSxcclxuICAgIGlzUGVybWFuZW50ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGVybWFuZW50IHx8IHRoaXMudHlwZSA9PT0gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzUGVyc2lzdGVudCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy50eXBlID09PSAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzVGVtcG9yYXJ5ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMudHlwZSA9PT0gJ21kYy10ZW1wb3JhcnktZHJhd2VyJ1xyXG4gICAgfSxcclxuICAgIGlzUmVzcG9uc2l2ZSAoKSB7XHJcbiAgICAgIHJldHVybiAhKHRoaXMucGVybWFuZW50IHx8IHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLmRyYXdlclR5cGUpXHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBvcGVuICgpIHtcclxuICAgICAgdGhpcy5vcGVuXyA9IHRydWVcclxuICAgIH0sXHJcbiAgICBjbG9zZSAoKSB7XHJcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSBmYWxzZSlcclxuICAgIH0sXHJcbiAgICB0b2dnbGUgKCkge1xyXG4gICAgICB0aGlzLmlzUGVybWFuZW50IHx8ICh0aGlzLmlzT3BlbigpID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCkpXHJcbiAgICB9LFxyXG4gICAgaXNPcGVuICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaXNQZXJtYW5lbnR8fCAoIHRoaXMub3Blbl8gKVxyXG4gICAgfSxcclxuICAgIHJlZnJlc2hNZWRpYSAoKSB7XHJcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXHJcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzXHJcbiAgICAgIGlmICh0aGlzLmlzUmVzcG9uc2l2ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhcmdlKSB7XHJcbiAgICAgICAgICB0aGlzLm9wZW4oKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY3JlYXRlZCAoKSB7XHJcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5tYXRjaE1lZGlhKSB7XHJcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXHJcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkICgpIHtcclxuICAgIGlmICh0aGlzLnRvZ2dsZU9uKSB7XHJcbiAgICAgIGxldCBzb3VyY2UgPSB0aGlzLnRvZ2dsZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcclxuICAgICAgc291cmNlLiRvbih0aGlzLnRvZ2dsZU9uLCAoKSA9PiB0aGlzLnRvZ2dsZSgpKVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3Blbk9uKSB7XHJcbiAgICAgIGxldCBzb3VyY2UgPSB0aGlzLm9wZW5PblNvdXJjZSB8fCB0aGlzLiRyb290XHJcbiAgICAgIHNvdXJjZS4kb24odGhpcy5vcGVuT24sICgpID0+IHRoaXMub3BlbigpKVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY2xvc2VPbikge1xyXG4gICAgICBsZXQgc291cmNlID0gdGhpcy5jbG9zZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcclxuICAgICAgc291cmNlLiRvbih0aGlzLmNsb3NlT24sICgpID0+IHRoaXMuY2xvc2UoKSlcclxuICAgIH1cclxuICAgIG1lZGlhLnNtYWxsLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gICAgbWVkaWEubGFyZ2UuYWRkTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXHJcbiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB0aGlzLnJlZnJlc2hNZWRpYSgpKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICBtZWRpYS5zbWFsbC5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSlcclxuICAgIG1lZGlhLmxhcmdlLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlci1sYXlvdXRcIj5cbiAgICAgIDxzbG90IC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItbGF5b3V0Jyxcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aGVhZGVyIGNsYXNzPVwibWRjLWRyYXdlci1oZWFkZXIgbWRjLWRyYXdlcl9faGVhZGVyXCIgdi1pZj1cInNob3dcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlcl9faGVhZGVyLWNvbnRlbnRcIj5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9kaXY+XG4gIDwvaGVhZGVyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItaGVhZGVyJyxcbiAgcHJvcHM6IHtcbiAgICAncGVybWFuZW50JzogQm9vbGVhbixcbiAgICAncGVyc2lzdGVudCc6IEJvb2xlYW4sXG4gICAgJ3RlbXBvcmFyeSc6IEJvb2xlYW5cbiAgfSxcbiAgaW5qZWN0OiBbJ21kY0RyYXdlciddLFxuICBjb21wdXRlZDoge1xuICAgIHNob3cgKCkge1xuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnBlcm1hbmVudCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGVtcG9yYXJ5ICYmIHRoaXMubWRjRHJhd2VyLmlzVGVtcG9yYXJ5KSB8fFxuICAgICAgICAgICh0aGlzLnBlcnNpc3RlbnQgJiYgdGhpcy5tZGNEcmF3ZXIuaXNQZXJzaXN0ZW50KSB8fFxuICAgICAgICAgICAgKHRoaXMucGVybWFuZW50ICYmIHRoaXMubWRjRHJhd2VyLmlzUGVybWFuZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bmF2IGNsYXNzPVwibWRjLWRyYXdlci1saXN0IG1kYy1saXN0XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICAnZGVuc2UnOiBCb29sZWFuLFxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWxpc3QtLWRlbnNlJzogdGhpcy5kZW5zZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbn1cbjwvc2NyaXB0PiIsIjx0ZW1wbGF0ZT5cclxuICA8Y3VzdG9tLWxpbmsgOmxpbms9XCJsaW5rXCIgXHJcbiAgICBjbGFzcz1cIm1kYy1kcmF3ZXItaXRlbSBtZGMtbGlzdC1pdGVtXCIgXHJcbiAgICA6Y2xhc3M9XCJbY2xhc3NlcywgaXRlbUNsYXNzZXNdXCIgOnN0eWxlPVwic3R5bGVzXCJcclxuICAgIEBjbGljaz1cIm9uQ2xpY2tcIj5cclxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fZ3JhcGhpY1wiIHYtaWY9XCJoYXNTdGFydERldGFpbFwiPlxyXG4gICAgICA8c2xvdCBuYW1lPVwic3RhcnQtZGV0YWlsXCI+XHJcbiAgICAgICAgPGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt7c3RhcnRJY29ufX08L2k+XHJcbiAgICAgIDwvc2xvdD5cclxuICAgIDwvc3Bhbj5cclxuICAgIDxzbG90Pjwvc2xvdD5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1kcmF3ZXItaXRlbScsXHJcbiAgaW5qZWN0OiBbJ21kY0RyYXdlciddLFxyXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgc3RhcnRJY29uOiBTdHJpbmcsXHJcbiAgICB0ZW1wb3JhcnlDbG9zZTogeyBcclxuICAgICAgdHlwZTogQm9vbGVhbiwgXHJcbiAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW4sXHJcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiB7IFxyXG4gICAgICB0eXBlOiBTdHJpbmcsIFxyXG4gICAgICBkZWZhdWx0OiAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJyBcclxuICAgIH1cclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBpdGVtQ2xhc3NlcyAoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCc6IHRoaXMuYWN0aXZhdGVkXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoYXNTdGFydERldGFpbCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0SWNvbiB8fCB0aGlzLiRzbG90c1snc3RhcnQtZGV0YWlsJ11cclxuICAgIH1cclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIG9uQ2xpY2sgKGV2dCkge1xyXG4gICAgICB0aGlzLm1kY0RyYXdlci5pc1RlbXBvcmFyeSAmJiB0aGlzLnRlbXBvcmFyeUNsb3NlIFxyXG4gICAgICAgICYmIHRoaXMubWRjRHJhd2VyLmNsb3NlKClcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dClcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95ICgpIHtcclxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5yaXBwbGUgPSBudWxsXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XG4gIDxociBjbGFzcz1cIm1kYy1saXN0LWRpdmlkZXJcIj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWRpdmlkZXInLFxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRHJhd2VyIGZyb20gJy4vbWRjLWRyYXdlci52dWUnXG5pbXBvcnQgbWRjRHJhd2VyTGF5b3V0IGZyb20gJy4vbWRjLWRyYXdlci1sYXlvdXQudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckhlYWRlciBmcm9tICcuL21kYy1kcmF3ZXItaGVhZGVyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMaXN0IGZyb20gJy4vbWRjLWRyYXdlci1saXN0LnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJJdGVtIGZyb20gJy4vbWRjLWRyYXdlci1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJEaXZpZGVyIGZyb20gJy4vbWRjLWRyYXdlci1kaXZpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjRHJhd2VyLFxuICBtZGNEcmF3ZXJMYXlvdXQsXG4gIG1kY0RyYXdlckhlYWRlcixcbiAgbWRjRHJhd2VyTGlzdCxcbiAgbWRjRHJhd2VySXRlbSxcbiAgbWRjRHJhd2VyRGl2aWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRHJhd2VyLFxuICBtZGNEcmF3ZXJMYXlvdXQsXG4gIG1kY0RyYXdlckhlYWRlcixcbiAgbWRjRHJhd2VyTGlzdCxcbiAgbWRjRHJhd2VySXRlbSxcbiAgbWRjRHJhd2VyRGl2aWRlclxufSkiLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZWxldmF0aW9uXCI+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWVsZXZhdGlvbicsXG4gIHByb3BzOiB7XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0VsZXZhdGlvbiBmcm9tICcuL21kYy1lbGV2YXRpb24udnVlJ1xuXG5leHBvcnQge1xuICBtZGNFbGV2YXRpb25cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0VsZXZhdGlvblxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1idXR0b24gY2xhc3M9XCJtZGMtZmFiXCIgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgOmhyZWY9XCJocmVmXCIgOmxpbms9XCJsaW5rXCIgXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiID5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1mYWJfX2ljb25cIj5cbiAgICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gICAgPC9zcGFuPlxuICA8L2N1c3RvbS1idXR0b24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGlufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHtSaXBwbGVNaXhpbn0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZmFiJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZyxcbiAgICBtaW5pOiBCb29sZWFuLFxuICAgIGFic29sdXRlOiBCb29sZWFuLFxuICAgIGZpeGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtYXRlcmlhbC1pY29ucyc6IHRoaXMuaWNvbixcbiAgICAgICAgJ21kYy1mYWItLW1pbmknOiB0aGlzLm1pbmksXG4gICAgICAgICdtZGMtZmFiLS1hYnNvbHV0ZSc6IHRoaXMuYWJzb2x1dGUsXG4gICAgICAgICdtZGMtZmFiLS1maXhlZCc6IHRoaXMuZml4ZWRcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGljb24gKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21hdGVyaWFsLWljb25zJywgdGhpcy5pY29uIClcbiAgICB9LFxuICAgIG1pbmkgKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1mYWItLW1pbmknLCB0aGlzLm1pbmkgKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRkFCIGZyb20gJy4vbWRjLWZhYi52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0ZBQlxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRkFCXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUSUxFU19TRUxFQ1RPUjogJy5tZGMtZ3JpZC1saXN0X190aWxlcycsXG4gIFRJTEVfU0VMRUNUT1I6ICcubWRjLWdyaWQtdGlsZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDR3JpZExpc3RGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldE51bWJlck9mVGlsZXM6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0U3R5bGVGb3JUaWxlc0VsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0dyaWRMaXN0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmFsaWduQ2VudGVyKCk7XG4gICAgdGhpcy5yZXNpemVGcmFtZV8gPSAwO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5hbGlnbkNlbnRlcigpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuICBhbGlnbkNlbnRlcigpIHtcbiAgICBpZiAodGhpcy5yZXNpemVGcmFtZV8gIT09IDApIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVzaXplRnJhbWVfKTtcbiAgICB9XG4gICAgdGhpcy5yZXNpemVGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hbGlnbkNlbnRlcl8oKTtcbiAgICAgIHRoaXMucmVzaXplRnJhbWVfID0gMDtcbiAgICB9KTtcbiAgfVxuICBhbGlnbkNlbnRlcl8oKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZUaWxlcygpID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ3JpZFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IGl0ZW1XaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleCgwKTtcbiAgICBjb25zdCB0aWxlc1dpZHRoID0gaXRlbVdpZHRoICogTWF0aC5mbG9vcihncmlkV2lkdGggLyBpdGVtV2lkdGgpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JUaWxlc0VsZW1lbnQoJ3dpZHRoJywgYCR7dGlsZXNXaWR0aH1weGApO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZ3JpZC1saXN0XCI+XG4gICAgPHVsIGNsYXNzPVwibWRjLWdyaWQtbGlzdF9fdGlsZXNcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPXN0eWxlcz5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvdWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENHcmlkTGlzdEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2dyaWQtbGlzdC9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZ3JpZC1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICAnd2lkdGgnOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICdyYXRpbyc6IFN0cmluZyxcbiAgICAnbmFycm93LWd1dHRlcic6IEJvb2xlYW4sXG4gICAgJ2hlYWRlci1jYXB0aW9uJzogQm9vbGVhbixcbiAgICAnaWNvbi1hbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2ljb24tYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnd2l0aC1zdXBwb3J0LXRleHQnOiBCb29sZWFuLFxuICAgICdpbnRlcmFjdGl2ZSc6IEJvb2xlYW5cbiAgfSxcbiAgcHJvdmlkZSAoKSB7XG4gICAgcmV0dXJuIHsgbWRjR3JpZDogdGhpcyB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcyAoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IHt9XG5cbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXRpbGUtZ3V0dGVyLTEnXSA9IHRoaXMubmFycm93R3V0dGVyXG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS1oZWFkZXItY2FwdGlvbiddID0gdGhpcy5oZWFkZXJDYXB0aW9uXG4gICAgICBjbGFzc2VzW2BtZGMtZ3JpZC1saXN0LS10aWxlLWFzcGVjdC0ke3RoaXMucmF0aW99YF0gPSB0aGlzLnJhdGlvXG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS13aXRoLWljb24tYWxpZ24tc3RhcnQnXSA9IHRoaXMuaWNvbkFsaWduU3RhcnRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXdpdGgtaWNvbi1hbGlnbi1lbmQnXSA9IHRoaXMuaWNvbkFsaWduRW5kXG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS10d29saW5lLWNhcHRpb24nXSA9IHRoaXMud2l0aFN1cHBvcnRUZXh0XG4gICAgICBjbGFzc2VzWydtZGMtZ3JpZC1saXN0LS1ub24taW50ZXJhY3RpdmUnXSA9ICF0aGlzLmludGVyYWN0aXZlXG5cbiAgICAgIHJldHVybiBjbGFzc2VzXG4gICAgfSxcbiAgICBzdHlsZXMgKCkge1xuICAgICAgdmFyIGRlZmF1bHRXaWR0aCA9IDIwMFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJy0tbWRjLWdyaWQtbGlzdC10aWxlLXdpZHRoJzogYCR7dGhpcy53aWR0aCB8fCBkZWZhdWx0V2lkdGh9cHhgXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDR3JpZExpc3RGb3VuZGF0aW9uKHtcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mVGlsZXM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUikubGVuZ3RoXG4gICAgICB9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGhGb3JUaWxlQXRJbmRleDogKGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgIE1EQ0dyaWRMaXN0Rm91bmRhdGlvbi5zdHJpbmdzLlRJTEVfU0VMRUNUT1IpW2luZGV4XS5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlRm9yVGlsZXNFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRVNfU0VMRUNUT1IpLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBjbGFzcz1cIm1kYy1ncmlkLXRpbGVcIiBAY2xpY2s9XCJvbkNsaWNrXCJcbiAgICA6Y2xhc3M9XCJbY2xhc3NlcywgaXRlbUNsYXNzZXNdXCIgOnN0eWxlPVwic3R5bGVzXCJcbiAgICA6dGFiaW5kZXg9XCJpc0ludGVyYWN0aXZlID8gJzAnIDogdW5kZWZpbmVkXCJcbiAgICB2LW9uPVwiaXNJbnRlcmFjdGl2ZSA/ICRsaXN0ZW5lcnMgOiB7fVwiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCIgdi1pZj1cImNvdmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeS1jb250ZW50XCJcbiAgICAgICAgOnN0eWxlPVwieyBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwoJyArIHNyYyArICcpJyB9XCI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeVwiIHYtZWxzZT5cbiAgICAgICAgPGltZyBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3ByaW1hcnktY29udGVudFwiIDpzcmM9XCJzcmNcIiAvPlxuICAgIDwvZGl2PlxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fc2Vjb25kYXJ5XCIgdi1pZj1cInRpdGxlIHx8IHN1cHBvcnRUZXh0XCI+XG4gICAgICA8aSBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX2ljb24gbWF0ZXJpYWwtaWNvbnNcIiB2LWlmPVwiaWNvblwiPnt7IGljb24gfX08L2k+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3RpdGxlXCIgdi1pZj1cInRpdGxlXCI+e3sgdGl0bGUgfX08L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3N1cHBvcnQtdGV4dFwiIHYtaWY9XCJzdXBwb3J0VGV4dFwiPnt7IHN1cHBvcnRUZXh0IH19PC9zcGFuPlxuICAgIDwvc3Bhbj5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1ncmlkLXRpbGUnLFxuICBpbmplY3Q6IFsnbWRjR3JpZCddLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgICdzcmMnOiBTdHJpbmcsXG4gICAgJ2NvdmVyJzogQm9vbGVhbixcbiAgICAnaWNvbic6IFN0cmluZyxcbiAgICAndGl0bGUnOiBTdHJpbmcsXG4gICAgJ3N1cHBvcnQtdGV4dCc6IFN0cmluZyxcbiAgICAnc2VsZWN0ZWQnOiBCb29sZWFuLFxuICAgICdhY3RpdmF0ZWQnOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXRlbUNsYXNzZXMgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1ncmlkLXRpbGUtLXNlbGVjdGVkJzogdGhpcy5zZWxlY3RlZCxcbiAgICAgICAgJ21kYy1ncmlkLXRpbGUtLWFjdGl2YXRlZCc6IHRoaXMuYWN0aXZhdGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBpc0ludGVyYWN0aXZlICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kY0dyaWQgJiYgdGhpcy5tZGNHcmlkLmludGVyYWN0aXZlXG4gICAgfSxcbiAgICBoYXNTdGFydERldGFpbCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydEljb24gfHwgdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfSxcbiAgICBoYXNFbmREZXRhaWwgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5kSWNvbiB8fCB0aGlzLiRzbG90c1snZW5kLWRldGFpbCddXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzSW50ZXJhY3RpdmUgKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZGRSaXBwbGUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2xpY2sgKGV2dCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dClcbiAgICB9LFxuICAgIGFkZFJpcHBsZSAoKSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgICByaXBwbGUuaW5pdCgpXG4gICAgICAgIHRoaXMucmlwcGxlID0gcmlwcGxlXG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVSaXBwbGUgKCkge1xuICAgICAgaWYgKHRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSB0aGlzLnJpcHBsZVxuICAgICAgICB0aGlzLnJpcHBsZSA9IG51bGxcbiAgICAgICAgcmlwcGxlLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlICYmIHRoaXMuYWRkUmlwcGxlKClcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgY29uc29sZS5sb2codGhpcylcbiAgICBjb25zb2xlLmxvZyh0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcbiAgICBjb25zb2xlLmxvZyh0aGlzLnJpcHBsZSlcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNHcmlkTGlzdCBmcm9tICcuL21kYy1ncmlkLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0dyaWRUaWxlIGZyb20gJy4vbWRjLWdyaWQtdGlsZS52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0dyaWRMaXN0LFxuICBtZGNHcmlkVGlsZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjR3JpZExpc3QsXG4gIG1kY0dyaWRUaWxlXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8c3BhbiBjbGFzcz1cIm1kYy1pY29uIG1kYy1pY29uLS1tYXRlcmlhbFwiIDpjbGFzcz1cInsnbWF0ZXJpYWwtaWNvbnMnOiEhaWNvbn1cIj5cbiAgICA8c2xvdD57eyBpY29uIH19PC9zbG90PlxuICA8L3NwYW4+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWljb24nLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZ1xuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0ljb24gZnJvbSAnLi9tZGMtaWNvbi52dWUnXHJcblxyXG5leHBvcnQge1xyXG4gIG1kY0ljb25cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XHJcbiAgbWRjSWNvblxyXG59KVxyXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIEljb24gVG9nZ2xlLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIGlubmVyIHRleHRcbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqIC0gZXZlbnQgZGlzcGF0Y2hcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cblxuY2xhc3MgTURDSWNvblRvZ2dsZUFkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICovXG4gIHNldFRleHQodGV4dCkge31cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRUYWJJbmRleCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSB0YWJJbmRleCAqL1xuICBzZXRUYWJJbmRleCh0YWJJbmRleCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cihuYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIobmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG4gIHJtQXR0cihuYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFJY29uVG9nZ2xlRXZlbnR9IGV2dERhdGEgKi9cbiAgbm90aWZ5Q2hhbmdlKGV2dERhdGEpIHt9XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGlzT246IGJvb2xlYW4sXG4gKiB9fVxuICovXG5sZXQgSWNvblRvZ2dsZUV2ZW50O1xuXG5leHBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1pY29uLXRvZ2dsZScsXG4gIERJU0FCTEVEOiAnbWRjLWljb24tdG9nZ2xlLS1kaXNhYmxlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIERBVEFfVE9HR0xFX09OOiAnZGF0YS10b2dnbGUtb24nLFxuICBEQVRBX1RPR0dMRV9PRkY6ICdkYXRhLXRvZ2dsZS1vZmYnLFxuICBBUklBX1BSRVNTRUQ6ICdhcmlhLXByZXNzZWQnLFxuICBBUklBX0RJU0FCTEVEOiAnYXJpYS1kaXNhYmxlZCcsXG4gIEFSSUFfTEFCRUw6ICdhcmlhLWxhYmVsJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDSWNvblRvZ2dsZTpjaGFuZ2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDSWNvblRvZ2dsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUZXh0OiAoLyogdGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHNldFRhYkluZGV4OiAoLyogdGFiSW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBnZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmcgKi8gJycsXG4gICAgICBzZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtQXR0cjogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiBJY29uVG9nZ2xlRXZlbnQgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMub25fID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSAtMTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0ljb25Ub2dnbGVTdGF0ZX0gKi9cbiAgICB0aGlzLnRvZ2dsZU9uRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/SWNvblRvZ2dsZVN0YXRlfSAqL1xuICAgIHRoaXMudG9nZ2xlT2ZmRGF0YV8gPSBudWxsO1xuXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy50b2dnbGVGcm9tRXZ0XygpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmtleXVwSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2dnbGVGcm9tRXZ0XygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUb2dnbGVEYXRhKCk7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gIH1cblxuICByZWZyZXNoVG9nZ2xlRGF0YSgpIHtcbiAgICBjb25zdCB7REFUQV9UT0dHTEVfT04sIERBVEFfVE9HR0xFX09GRn0gPSBNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIHRoaXMudG9nZ2xlT25EYXRhXyA9IHRoaXMucGFyc2VKc29uRGF0YUF0dHJfKERBVEFfVE9HR0xFX09OKTtcbiAgICB0aGlzLnRvZ2dsZU9mZkRhdGFfID0gdGhpcy5wYXJzZUpzb25EYXRhQXR0cl8oREFUQV9UT0dHTEVfT0ZGKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRvZ2dsZUZyb21FdnRfKCkge1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgY29uc3Qge29uXzogaXNPbn0gPSB0aGlzO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKC8qKiBAdHlwZSB7IUljb25Ub2dnbGVFdmVudH0gKi8gKHtpc09ufSkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT24oKSB7XG4gICAgcmV0dXJuIHRoaXMub25fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IGlzT24gKi9cbiAgdG9nZ2xlKGlzT24gPSAhdGhpcy5vbl8pIHtcbiAgICB0aGlzLm9uXyA9IGlzT247XG5cbiAgICBjb25zdCB7QVJJQV9MQUJFTCwgQVJJQV9QUkVTU0VEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICBpZiAodGhpcy5vbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICdmYWxzZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHtjc3NDbGFzczogY2xhc3NUb1JlbW92ZX0gPVxuICAgICAgICB0aGlzLm9uXyA/IHRoaXMudG9nZ2xlT2ZmRGF0YV8gOiB0aGlzLnRvZ2dsZU9uRGF0YV87XG5cbiAgICBpZiAoY2xhc3NUb1JlbW92ZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjbGFzc1RvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7Y29udGVudCwgbGFiZWwsIGNzc0NsYXNzfSA9IHRoaXMub25fID8gdGhpcy50b2dnbGVPbkRhdGFfIDogdGhpcy50b2dnbGVPZmZEYXRhXztcblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRleHQoY29udGVudCk7XG4gICAgfVxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfTEFCRUwsIGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFBdHRyXG4gICAqIEByZXR1cm4geyFJY29uVG9nZ2xlU3RhdGV9XG4gICAqL1xuICBwYXJzZUpzb25EYXRhQXR0cl8oZGF0YUF0dHIpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLmFkYXB0ZXJfLmdldEF0dHIoZGF0YUF0dHIpO1xuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUgeyFJY29uVG9nZ2xlU3RhdGV9ICovIChKU09OLnBhcnNlKHZhbCkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBpc0Rpc2FibGVkO1xuXG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0FSSUFfRElTQUJMRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiSW5kZXgoLTEpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleCh0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyKEFSSUFfRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzS2V5Ym9hcmRBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNIYW5kbGluZ0tleWRvd25fO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyF7XG4gKiAgIGtleTogc3RyaW5nLFxuICogICBrZXlDb2RlOiBudW1iZXJcbiAqIH19XG4gKi9cbmxldCBLZXlib2FyZEtleTtcblxuLyoqXG4gKiBAcGFyYW0geyFLZXlib2FyZEtleX0ga2V5Ym9hcmRLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3BhY2Uoa2V5Ym9hcmRLZXkpIHtcbiAgcmV0dXJuIGtleWJvYXJkS2V5LmtleSA9PT0gJ1NwYWNlJyB8fCBrZXlib2FyZEtleS5rZXlDb2RlID09PSAzMjtcbn1cblxuXG4vKiogQHJlY29yZCAqL1xuY2xhc3MgSWNvblRvZ2dsZVN0YXRlIHt9XG5cbi8qKlxuICogVGhlIGFyaWEtbGFiZWwgdmFsdWUgb2YgdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gYXJpYS1sYWJlbC5cbiAqIEBleHBvcnQge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbkljb25Ub2dnbGVTdGF0ZS5wcm90b3R5cGUubGFiZWw7XG5cbi8qKlxuICogVGhlIHRleHQgZm9yIHRoZSBpY29uIHRvZ2dsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHRleHQuXG4gKiBAZXhwb3J0IHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5JY29uVG9nZ2xlU3RhdGUucHJvdG90eXBlLmNvbnRlbnQ7XG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0byBhZGQgdG8gdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gQ1NTIGNsYXNzLlxuICogQGV4cG9ydCB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuSWNvblRvZ2dsZVN0YXRlLnByb3RvdHlwZS5jc3NDbGFzcztcblxuZXhwb3J0IGRlZmF1bHQgTURDSWNvblRvZ2dsZUZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxzcGFuIGNsYXNzPVwibWRjLWljb24tdG9nZ2xlXCIgcm9sZT1cImJ1dHRvblwiIGFyaWEtcHJlc3NlZD1cImZhbHNlXCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCJcbiAgICA6dGFiaW5kZXg9XCJ0YWJJbmRleFwiXG4gICAgOmRhdGEtdG9nZ2xlLW9uPVwidG9nZ2xlT25EYXRhXCJcbiAgICA6ZGF0YS10b2dnbGUtb2ZmPVwidG9nZ2xlT2ZmRGF0YVwiPlxuICAgIDxpIDpjbGFzcz1cImljb25DbGFzc2VzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3t0ZXh0fX08L2k+XG4gIDwvc3Bhbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDSWNvblRvZ2dsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2ZvdW5kYXRpb24nXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWljb24tdG9nZ2xlJyxcbiAgcHJvcHM6IHtcbiAgICB0b2dnbGVPbjogW1N0cmluZywgT2JqZWN0XSxcbiAgICB0b2dnbGVPZmY6IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgdmFsdWU6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgYWNjZW50OiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtaWNvbi10b2dnbGUtLWFjY2VudCc6IHRoaXMuYWNjZW50XG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGljb25DbGFzc2VzOiB7fSxcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHZhbHVlICh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi50b2dnbGUodmFsdWUpXG4gICAgfSxcbiAgICBkaXNhYmxlZCAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgfSxcbiAgICB0b2dnbGVPbkRhdGEgKCkge1xuICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ucmVmcmVzaFRvZ2dsZURhdGEoKVxuICAgIH0sXG4gICAgYWNjZW50ICh2YWx1ZSkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1pY29uLXRvZ2dsZS0tc2Vjb25kYXJ5JywgdmFsdWUpXG4gICAgfSxcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB0b2dnbGVPbkRhdGEgKCkge1xuICAgICAgbGV0IHRvZ2dsZSA9IHRoaXMudG9nZ2xlT25cbiAgICAgIHJldHVybiB0b2dnbGUgJiYgSlNPTi5zdHJpbmdpZnkoKHR5cGVvZiB0b2dnbGUgPT09ICdzdHJpbmcnKSA/IHsgXG4gICAgICAgIGNvbnRlbnQ6IHRvZ2dsZSwgXG4gICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnIFxuICAgICAgfSA6IHtcbiAgICAgICAgY29udGVudDogdG9nZ2xlLmljb24gfHwgdG9nZ2xlLmNvbnRlbnQsXG4gICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgIGNzc0NsYXNzOiB0b2dnbGUuaWNvbiA/ICdtYXRlcmlhbC1pY29ucycgOiB0b2dnbGUuY3NzQ2xhc3NcbiAgICAgIH0pXG4gICAgfSAsXG4gICAgdG9nZ2xlT2ZmRGF0YSAoKSB7XG4gICAgICBsZXQgdG9nZ2xlID0gdGhpcy50b2dnbGVPZmZcbiAgICAgIHJldHVybiB0b2dnbGUgJiYgSlNPTi5zdHJpbmdpZnkoKHR5cGVvZiB0b2dnbGUgPT09ICdzdHJpbmcnKSA/IHsgXG4gICAgICAgIGNvbnRlbnQ6IHRvZ2dsZSwgXG4gICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnIFxuICAgICAgfSA6IHtcbiAgICAgICAgY29udGVudDogdG9nZ2xlLmljb24gfHwgdG9nZ2xlLmNvbnRlbnQsXG4gICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgIGNzc0NsYXNzOiB0b2dnbGUuaWNvbiA/ICdtYXRlcmlhbC1pY29ucycgOiB0b2dnbGUuY3NzQ2xhc3NcbiAgICAgIH0pXG4gICAgfSxcbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRzZXQodGhpcy5pY29uQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRkZWxldGUodGhpcy5pY29uQ2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBzZXRUZXh0OiAodGV4dCkgPT4geyB0aGlzLnRleHQgPSB0ZXh0IH0sXG4gICAgICBnZXRUYWJJbmRleDogKCkgPT4gdGhpcy50YWJJbmRleCxcbiAgICAgIHNldFRhYkluZGV4OiAodGFiSW5kZXgpID0+IHsgdGhpcy50YWJJbmRleCA9IHRhYkluZGV4IH0sXG4gICAgICBnZXRBdHRyOiAobmFtZSwgdmFsdWUpID0+IHRoaXMuJGVsLmdldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSksXG4gICAgICBzZXRBdHRyOiAobmFtZSwgdmFsdWUpID0+IHsgdGhpcy4kZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB9LFxuICAgICAgcm1BdHRyOiAobmFtZSkgPT4geyB0aGlzLiRlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgfSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKGV2dERhdGEpID0+IHsgdGhpcy4kZW1pdCgnaW5wdXQnLCBldnREYXRhLmlzT24pIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB0aGlzLmZvdW5kYXRpb24uaXNLZXlib2FyZEFjdGl2YXRlZCgpLFxuICAgIH0pXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjSUNvblRvZ2dsZSBmcm9tICcuL21kYy1pY29uLXRvZ2dsZS52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0lDb25Ub2dnbGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0lDb25Ub2dnbGVcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS10b29sYmFyLXdyYXBwZXJcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJ0b29sYmFyXCIgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcC0tbWFpbi1jb250YWluZXJcIj5cblxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS1kcmF3ZXItd3JhcHBlclwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwiZHJhd2VyXCIgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLWNvbnRlbnQtd3JhcHBlclwiPlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1hcHAnLFxufVxuPC9zY3JpcHQ+IiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xheW91dEFwcCBmcm9tICcuL21kYy1sYXlvdXQtYXBwLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjTGF5b3V0QXBwXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMYXlvdXRBcHBcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWdyaWRcIiA6Y2xhc3M9Y2xhc3Nlcz5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1ncmlkX19pbm5lclwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1sYXlvdXQtZ3JpZCcsXG4gIHByb3BzOiB7XG4gICAgJ2ZpeGVkLWNvbHVtbi13aWR0aCc6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1sYXlvdXQtZ3JpZC0tZml4ZWQtY29sdW1uLXdpZHRoJzogdGhpcy5maXhlZENvbHVtbldpZHRoXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtY2VsbCBtZGMtbGF5b3V0LWdyaWRfX2NlbGxcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5jb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgZGVmYXVsdDogbnVsbCxcbiAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgbnVtID0gTnVtYmVyKHZhbHVlKVxuICAgIHJldHVybiBpc0Zpbml0ZShudW0pICYmIChudW0gPD0gMTIpICYmIChudW0gPiAwKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1sYXlvdXQtY2VsbCcsXG4gIHByb3BzOiB7XG4gICAgc3Bhbjogc3Bhbk9wdGlvbnMsXG4gICAgb3JkZXI6IHNwYW5PcHRpb25zLFxuICAgIHBob25lOiBzcGFuT3B0aW9ucyxcbiAgICB0YWJsZXQ6IHNwYW5PcHRpb25zLFxuICAgIGRlc2t0b3A6IHNwYW5PcHRpb25zLFxuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJywgJ21pZGRsZSddLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzICgpIHtcbiAgICAgIGxldCBjbGFzc2VzID0gW11cblxuICAgICAgaWYgKHRoaXMuc3Bhbikge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMuc3Bhbn1gKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcmRlcikge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tb3JkZXItJHt0aGlzLm9yZGVyfWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBob25lKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy5waG9uZX0tcGhvbmVgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50YWJsZXQpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLnRhYmxldH0tdGFibGV0YClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGVza3RvcCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMuZGVza3RvcH0tZGVza3RvcGApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFsaWduKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1hbGlnbi0ke3RoaXMuYWxpZ259YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1pbm5lci1ncmlkIG1kYy1sYXlvdXQtZ3JpZF9faW5uZXJcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1sYXlvdXQtaW5uZXItZ3JpZCcsXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMYXlvdXRHcmlkIGZyb20gJy4vbWRjLWxheW91dC1ncmlkLnZ1ZSdcbmltcG9ydCBtZGNMYXlvdXRDZWxsIGZyb20gJy4vbWRjLWxheW91dC1jZWxsLnZ1ZSdcbmltcG9ydCBtZGNMYXlvdXRJbm5lckdyaWQgZnJvbSAnLi9tZGMtbGF5b3V0LWlubmVyLWdyaWQudnVlJ1xuXG5leHBvcnQge1xuICBtZGNMYXlvdXRHcmlkLFxuICBtZGNMYXlvdXRDZWxsLFxuICBtZGNMYXlvdXRJbm5lckdyaWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0xheW91dEdyaWQsXG4gIG1kY0xheW91dENlbGwsXG4gIG1kY0xheW91dElubmVyR3JpZFxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBDTE9TRURfQ0xBU1M6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1jbG9zZWQnLFxuICBJTkRFVEVSTUlOQVRFX0NMQVNTOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0taW5kZXRlcm1pbmF0ZScsXG4gIFJFVkVSU0VEX0NMQVNTOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0tcmV2ZXJzZWQnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFBSSU1BUllfQkFSX1NFTEVDVE9SOiAnLm1kYy1saW5lYXItcHJvZ3Jlc3NfX3ByaW1hcnktYmFyJyxcbiAgQlVGRkVSX1NFTEVDVE9SOiAnLm1kYy1saW5lYXItcHJvZ3Jlc3NfX2J1ZmZlcicsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge3RyYW5zZm9ybVN0eWxlUHJvcGVydGllc30gZnJvbSAnQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleCc7XG5cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENMaW5lYXJQcm9ncmVzc0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRQcmltYXJ5QmFyOiAoKSA9PiAvKiBlbDogRWxlbWVudCAqLyB7fSxcbiAgICAgIGdldEJ1ZmZlcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge30sXG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiBmYWxzZSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGU6ICgvKiBlbDogRWxlbWVudCwgc3R5bGVQcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuZGV0ZXJtaW5hdGVfID0gIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICB0aGlzLnJldmVyc2VfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLlJFVkVSU0VEX0NMQVNTKTtcbiAgICB0aGlzLnByb2dyZXNzXyA9IDA7XG4gIH1cblxuICBzZXREZXRlcm1pbmF0ZShpc0RldGVybWluYXRlKSB7XG4gICAgdGhpcy5kZXRlcm1pbmF0ZV8gPSBpc0RldGVybWluYXRlO1xuICAgIGlmICh0aGlzLmRldGVybWluYXRlXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ0xBU1MpO1xuICAgICAgdGhpcy5zZXRTY2FsZV8odGhpcy5hZGFwdGVyXy5nZXRQcmltYXJ5QmFyKCksIHRoaXMucHJvZ3Jlc3NfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLklOREVURVJNSU5BVEVfQ0xBU1MpO1xuICAgICAgdGhpcy5zZXRTY2FsZV8odGhpcy5hZGFwdGVyXy5nZXRQcmltYXJ5QmFyKCksIDEpO1xuICAgICAgdGhpcy5zZXRTY2FsZV8odGhpcy5hZGFwdGVyXy5nZXRCdWZmZXIoKSwgMSk7XG4gICAgfVxuICB9XG5cbiAgc2V0UHJvZ3Jlc3ModmFsdWUpIHtcbiAgICB0aGlzLnByb2dyZXNzXyA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmRldGVybWluYXRlXykge1xuICAgICAgdGhpcy5zZXRTY2FsZV8odGhpcy5hZGFwdGVyXy5nZXRQcmltYXJ5QmFyKCksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBzZXRCdWZmZXIodmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0QnVmZmVyKCksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBzZXRSZXZlcnNlKGlzUmV2ZXJzZWQpIHtcbiAgICB0aGlzLnJldmVyc2VfID0gaXNSZXZlcnNlZDtcbiAgICBpZiAodGhpcy5yZXZlcnNlXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlJFVkVSU0VEX0NMQVNTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLlJFVkVSU0VEX0NMQVNTKTtcbiAgICB9XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TRURfQ0xBU1MpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkNMT1NFRF9DTEFTUyk7XG4gIH1cblxuICBzZXRTY2FsZV8oZWwsIHNjYWxlVmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9ICdzY2FsZVgoJyArIHNjYWxlVmFsdWUgKyAnKSc7XG4gICAgdHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzLmZvckVhY2goKHRyYW5zZm9ybVN0eWxlUHJvcGVydHkpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoZWwsIHRyYW5zZm9ybVN0eWxlUHJvcGVydHksIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJvbGU9XCJwcm9ncmVzc2JhclwiIGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc1wiIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyaW5nLWRvdHNcIj48L2Rpdj5cbiAgICA8ZGl2IHJlZj1cImJ1ZmZlclwiIGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyXCI+PC9kaXY+XG4gICAgPGRpdiByZWY9XCJwcmltYXJ5XCIgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXIgbWRjLWxpbmVhci1wcm9ncmVzc19fcHJpbWFyeS1iYXJcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc19fYmFyLWlubmVyXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXIgbWRjLWxpbmVhci1wcm9ncmVzc19fc2Vjb25kYXJ5LWJhclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXItaW5uZXJcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gIDwvZGl2PiAgXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGluZWFyLXByb2dyZXNzL2ZvdW5kYXRpb24nXG5cbmNvbnN0IFByb2dyZXNzUHJvcFR5cGUgPSB7XG4gIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gIHZhbGlkYXRvciAodmFsdWUpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSA+PSAwICYmIE51bWJlcih2YWx1ZSkgPD0gMVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saW5lYXItcHJvZ3Jlc3MnLFxuICBwcm9wczoge1xuICAgICdvcGVuJzogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgJ2luZGV0ZXJtaW5hdGUnOiBCb29sZWFuLFxuICAgICdyZXZlcnNlJzogQm9vbGVhbixcbiAgICAnYWNjZW50JzogQm9vbGVhbixcbiAgICAncHJvZ3Jlc3MnOiBQcm9ncmVzc1Byb3BUeXBlLFxuICAgICdidWZmZXInOiBQcm9ncmVzc1Byb3BUeXBlXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7J21kYy1saW5lYXItcHJvZ3Jlc3MtLWFjY2VudCc6IHRoaXMuYWNjZW50fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbiAoKSB7XG4gICAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9ncmVzcyAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIH0sXG4gICAgYnVmZmVyICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRCdWZmZXIoTnVtYmVyKHRoaXMuYnVmZmVyKSlcbiAgICB9LFxuICAgIGluZGV0ZXJtaW5hdGUgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERldGVybWluYXRlKCF0aGlzLmluZGV0ZXJtaW5hdGUpXG4gICAgfSxcbiAgICByZXZlcnNlICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENMaW5lYXJQcm9ncmVzc0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIGdldFByaW1hcnlCYXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucHJpbWFyeVxuICAgICAgfSxcbiAgICAgIGdldEJ1ZmZlcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5idWZmZXJcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZTogKGVsLCBzdHlsZVByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBlbC5zdHlsZVtzdHlsZVByb3BlcnR5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UmV2ZXJzZSh0aGlzLnJldmVyc2UpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFByb2dyZXNzKE51bWJlcih0aGlzLnByb2dyZXNzKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0QnVmZmVyKE51bWJlcih0aGlzLmJ1ZmZlcikpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERldGVybWluYXRlKCF0aGlzLmluZGV0ZXJtaW5hdGUpXG4gICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMaW5lYXJQcm9ncmVzcyBmcm9tICcuL21kYy1saW5lYXItcHJvZ3Jlc3MudnVlJ1xuXG5leHBvcnQge1xuICBtZGNMaW5lYXJQcm9ncmVzc1xufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGluZWFyUHJvZ3Jlc3Ncbn0pIiwiPHRlbXBsYXRlPlxuICA8dWwgY2xhc3M9XCJtZGMtbGlzdFwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvdWw+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QnLFxuICBwcm9wczoge1xuICAgIGRlbnNlOiBCb29sZWFuLFxuICAgIGF2YXRhckxpc3Q6IEJvb2xlYW4sXG4gICAgdHdvTGluZTogQm9vbGVhbixcbiAgICBib3JkZXJlZDogQm9vbGVhbixcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhblxuICB9LFxuICBwcm92aWRlICgpIHtcbiAgICByZXR1cm4geyBtZGNMaXN0OiB0aGlzIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtbGlzdC0tZGVuc2UnOiB0aGlzLmRlbnNlLFxuICAgICAgICAnbWRjLWxpc3QtLWF2YXRhci1saXN0JzogdGhpcy5hdmF0YXJMaXN0LFxuICAgICAgICAnbWRjLWxpc3QtLXR3by1saW5lJzogdGhpcy50d29MaW5lLFxuICAgICAgICAnbWRjLWxpc3QtLWJvcmRlcmVkJzogdGhpcy5ib3JkZXJlZCxcbiAgICAgICAgJ21kYy1saXN0LS1ub24taW50ZXJhY3RpdmUnOiAhdGhpcy5pbnRlcmFjdGl2ZVxuICAgICAgfSAgICAgIFxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBjbGFzcz1cIm1kYy1saXN0LWl0ZW1cIlxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIiA6c3R5bGU9XCJzdHlsZXNcIiAgIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIlxuICAgIHYtb249XCJpc0ludGVyYWN0aXZlID8gJGxpc3RlbmVycyA6IHt9XCI+XG5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX2dyYXBoaWNcIiB2LWlmPVwiaGFzU3RhcnREZXRhaWxcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIj48L3Nsb3Q+XG4gICAgPC9zcGFuPlxuXG4gICAgPHNwYW4gY2xhc3M9XCJtZGMtbGlzdC1pdGVtX190ZXh0XCIgdi1pZj1cImhhc1NlY29uZGFyeVwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19zZWNvbmRhcnktdGV4dFwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwic2Vjb25kYXJ5XCI+PC9zbG90PlxuICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbiAgICA8c2xvdCB2LWVsc2U+PC9zbG90PlxuXG4gICAgPHNwYW4gY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19tZXRhXCIgdi1pZj1cImhhc0VuZERldGFpbFwiPlxuICAgICAgPHNsb3QgbmFtZT1cImVuZC1kZXRhaWxcIj48L3Nsb3Q+XG4gICAgPC9zcGFuPlxuXG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWl0ZW0nLFxuICBpbmplY3Q6IFsnbWRjTGlzdCddLFxuICBwcm9wczoge1xuICAgIHNlbGVjdGVkOiBCb29sZWFuLFxuICAgIGFjdGl2YXRlZDogQm9vbGVhblxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfSBcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpdGVtQ2xhc3NlcyAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWxpc3QtaXRlbS0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkLFxuICAgICAgICAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzSW50ZXJhY3RpdmUgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QuaW50ZXJhY3RpdmVcbiAgICB9LFxuICAgIGhhc1NlY29uZGFyeSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc2xvdHNbJ3NlY29uZGFyeSddICYmIChcbiAgICAgICAgdGhpcy5tZGNMaXN0ICYmIHRoaXMubWRjTGlzdC50d29MaW5lXG4gICAgICApIFxuICAgIH0sXG4gICAgaGFzRW5kRGV0YWlsICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuJHNsb3RzWydzdGFydC1kZXRhaWwnXVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBpc0ludGVyYWN0aXZlICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmFkZFJpcHBsZSgpIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVtb3ZlUmlwcGxlKClcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlICYmIHRoaXMuYWRkUmlwcGxlKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYWRkUmlwcGxlICgpIHtcbiAgICAgIGlmICghdGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgICAgIHJpcHBsZS5pbml0KClcbiAgICAgICAgdGhpcy5yaXBwbGUgPSByaXBwbGUgICAgICAgICAgICAgICAgIFxuICAgICAgfSBcbiAgICB9LFxuICAgIHJlbW92ZVJpcHBsZSAoKSB7XG4gICAgICBpZiAodGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IHRoaXMucmlwcGxlXG4gICAgICAgIHRoaXMucmlwcGxlID0gbnVsbCBcbiAgICAgICAgcmlwcGxlLmRlc3Ryb3koKVxuICAgICAgfSAgICAgICAgICAgICAgICBcbiAgICB9XG4gIH1cbiAgXG59XG48L3NjcmlwdD5cbiAgIiwiPHRlbXBsYXRlPlxuICA8bGkgcm9sZT1cInNlcGFyYXRvclwiIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiIFxuICA6Y2xhc3M9XCJjbGFzc2VzXCI+PC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1kaXZpZGVyJyxcbiAgcHJvcHM6IHtcbiAgICBpbnNldDogQm9vbGVhbixcbiAgICBwYWRkZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtbGlzdC1kaXZpZGVyLS1pbnNldCc6IHRoaXMuaW5zZXQsXG4gICAgICAgICdtZGMtbGlzdC1kaXZpZGVyLS1wYWRkZWQnOiB0aGlzLnBhZGRlZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtbGlzdC1ncm91cFwiPjxzbG90Pjwvc2xvdD48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1ncm91cCcsXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGgzIGNsYXNzPVwibWRjLWxpc3QtZ3JvdXAtaGVhZGVyIG1kYy1saXN0LWdyb3VwX19zdWJoZWFkZXJcIj48c2xvdD48L3Nsb3Q+PC9oMz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1ncm91cC1oZWFkZXInLFxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxociBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWRpdmlkZXIgbWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwLWRpdmlkZXInLFxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjTGlzdCBmcm9tICcuL21kYy1saXN0LnZ1ZSdcbmltcG9ydCBtZGNMaXN0SXRlbSBmcm9tICcuL21kYy1saXN0LWl0ZW0udnVlJ1xuaW1wb3J0IG1kY0xpc3REaXZpZGVyIGZyb20gJy4vbWRjLWxpc3QtZGl2aWRlci52dWUnXG5pbXBvcnQgbWRjTGlzdEdyb3VwIGZyb20gJy4vbWRjLWxpc3QtZ3JvdXAudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cEhlYWRlciBmcm9tICcuL21kYy1saXN0LWdyb3VwLWhlYWRlci52dWUnXG5pbXBvcnQgbWRjTGlzdEdyb3VwRGl2aWRlciBmcm9tICcuL21kYy1saXN0LWdyb3VwLWRpdmlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNMaXN0LFxuICBtZGNMaXN0SXRlbSxcbiAgbWRjTGlzdERpdmlkZXIsXG4gIG1kY0xpc3RHcm91cCxcbiAgbWRjTGlzdEdyb3VwSGVhZGVyLFxuICBtZGNMaXN0R3JvdXBEaXZpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMaXN0LFxuICBtZGNMaXN0SXRlbSxcbiAgbWRjTGlzdERpdmlkZXIsXG4gIG1kY0xpc3RHcm91cCxcbiAgbWRjTGlzdEdyb3VwSGVhZGVyLFxuICBtZGNMaXN0R3JvdXBEaXZpZGVyXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBNZW51LiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIGZvY3VzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ01lbnVBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBoYXNOZWNlc3NhcnlEb20oKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZU5hbWVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQodGFyZ2V0LCBhdHRyaWJ1dGVOYW1lKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gIGdldElubmVyRGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGhhc0FuY2hvcigpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSAqL1xuICBnZXRBbmNob3JEaW1lbnNpb25zKCkge31cblxuICAvKiogQHJldHVybiB7eyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSAqL1xuICBnZXRXaW5kb3dEaW1lbnNpb25zKCkge31cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXROdW1iZXJPZkl0ZW1zKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEluZGV4Rm9yRXZlbnRUYXJnZXQodGFyZ2V0KSB7fVxuXG4gIC8qKiBAcGFyYW0ge3tpbmRleDogbnVtYmVyfX0gZXZ0RGF0YSAqL1xuICBub3RpZnlTZWxlY3RlZChldnREYXRhKSB7fVxuXG4gIG5vdGlmeUNhbmNlbCgpIHt9XG5cbiAgc2F2ZUZvY3VzKCkge31cblxuICByZXN0b3JlRm9jdXMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0ZvY3VzZWQoKSB7fVxuXG4gIGZvY3VzKCkge31cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRGb2N1c2VkSXRlbUluZGV4KCkgLyogbnVtYmVyICovIHt9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAqL1xuICBmb2N1c0l0ZW1BdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1J0bCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gKi9cbiAgc2V0VHJhbnNmb3JtT3JpZ2luKG9yaWdpbikge31cblxuICAvKiogQHBhcmFtIHt7XG4gICogICB0b3A6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgKiAgIHJpZ2h0OiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICBib3R0b206IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgKiAgIGxlZnQ6IChzdHJpbmd8dW5kZWZpbmVkKVxuICAqIH19IHBvc2l0aW9uICovXG4gIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gaGVpZ2h0ICovXG4gIHNldE1heEhlaWdodChoZWlnaHQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHJGb3JPcHRpb25BdEluZGV4KGluZGV4LCBhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICBybUF0dHJGb3JPcHRpb25BdEluZGV4KGluZGV4LCBhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4KGluZGV4LCBjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBybUNsYXNzRm9yT3B0aW9uQXRJbmRleChpbmRleCwgY2xhc3NOYW1lKSB7fVxufVxuXG5leHBvcnQge01EQ01lbnVBZGFwdGVyfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtbWVudScsXG4gIE9QRU46ICdtZGMtbWVudS0tb3BlbicsXG4gIEFOSU1BVElOR19PUEVOOiAnbWRjLW1lbnUtLWFuaW1hdGluZy1vcGVuJyxcbiAgQU5JTUFUSU5HX0NMT1NFRDogJ21kYy1tZW51LS1hbmltYXRpbmctY2xvc2VkJyxcbiAgU0VMRUNURURfTElTVF9JVEVNOiAnbWRjLWxpc3QtaXRlbS0tc2VsZWN0ZWQnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBJVEVNU19TRUxFQ1RPUjogJy5tZGMtbWVudV9faXRlbXMnLFxuICBTRUxFQ1RFRF9FVkVOVDogJ01EQ01lbnU6c2VsZWN0ZWQnLFxuICBDQU5DRUxfRVZFTlQ6ICdNRENNZW51OmNhbmNlbCcsXG4gIEFSSUFfRElTQUJMRURfQVRUUjogJ2FyaWEtZGlzYWJsZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICAvLyBBbW91bnQgb2YgdGltZSB0byB3YWl0IGJlZm9yZSB0cmlnZ2VyaW5nIGEgc2VsZWN0ZWQgZXZlbnQgb24gdGhlIG1lbnUuIE5vdGUgdGhhdCB0aGlzIHRpbWVcbiAgLy8gd2lsbCBtb3N0IGxpa2VseSBiZSBidW1wZWQgdXAgb25jZSBpbnRlcmFjdGl2ZSBsaXN0cyBhcmUgc3VwcG9ydGVkIHRvIGFsbG93IGZvciB0aGUgcmlwcGxlIHRvXG4gIC8vIGFuaW1hdGUgYmVmb3JlIGNsb3NpbmcgdGhlIG1lbnVcbiAgU0VMRUNURURfVFJJR0dFUl9ERUxBWTogNTAsXG4gIC8vIFRvdGFsIGR1cmF0aW9uIG9mIG1lbnUgb3BlbiBhbmltYXRpb24uXG4gIFRSQU5TSVRJT05fT1BFTl9EVVJBVElPTjogMTIwLFxuICAvLyBUb3RhbCBkdXJhdGlvbiBvZiBtZW51IGNsb3NlIGFuaW1hdGlvbi5cbiAgVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTjogNzUsXG4gIC8vIE1hcmdpbiBsZWZ0IHRvIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCB3aGVuIG1lbnUgaXMgYXQgbWF4aW11bSBwb3NzaWJsZSBoZWlnaHQuXG4gIE1BUkdJTl9UT19FREdFOiAzMixcbiAgLy8gUmF0aW8gb2YgYW5jaG9yIHdpZHRoIHRvIG1lbnUgd2lkdGggZm9yIHN3aXRjaGluZyBmcm9tIGNvcm5lciBwb3NpdGlvbmluZyB0byBjZW50ZXIgcG9zaXRpb25pbmcuXG4gIEFOQ0hPUl9UT19NRU5VX1dJRFRIX1JBVElPOiAwLjY3LFxuICAvLyBSYXRpbyBvZiB2ZXJ0aWNhbCBvZmZzZXQgdG8gbWVudSBoZWlnaHQgZm9yIHN3aXRjaGluZyBmcm9tIGNvcm5lciB0byBtaWQtd2F5IG9yaWdpbiBwb3NpdGlvbmluZy5cbiAgT0ZGU0VUX1RPX01FTlVfSEVJR0hUX1JBVElPOiAwLjEsXG59O1xuXG4vKipcbiAqIEVudW0gZm9yIGJpdHMgaW4gdGhlIHtAc2VlIENvcm5lcikgYml0bWFwLlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ29ybmVyQml0ID0ge1xuICBCT1RUT006IDEsXG4gIENFTlRFUjogMixcbiAgUklHSFQ6IDQsXG4gIEZMSVBfUlRMOiA4LFxufTtcblxuLyoqXG4gKiBFbnVtIGZvciByZXByZXNlbnRpbmcgYW4gZWxlbWVudCBjb3JuZXIgZm9yIHBvc2l0aW9uaW5nIHRoZSBtZW51LlxuICpcbiAqIFRoZSBTVEFSVCBjb25zdGFudHMgbWFwIHRvIExFRlQgaWYgZWxlbWVudCBkaXJlY3Rpb25hbGl0eSBpcyBsZWZ0XG4gKiB0byByaWdodCBhbmQgUklHSFQgaWYgdGhlIGRpcmVjdGlvbmFsaXR5IGlzIHJpZ2h0IHRvIGxlZnQuXG4gKiBMaWtld2lzZSBFTkQgbWFwcyB0byBSSUdIVCBvciBMRUZUIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uYWxpdHkuXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ29ybmVyID0ge1xuICBUT1BfTEVGVDogMCxcbiAgVE9QX1JJR0hUOiBDb3JuZXJCaXQuUklHSFQsXG4gIEJPVFRPTV9MRUZUOiBDb3JuZXJCaXQuQk9UVE9NLFxuICBCT1RUT01fUklHSFQ6IENvcm5lckJpdC5CT1RUT00gfCBDb3JuZXJCaXQuUklHSFQsXG4gIFRPUF9TVEFSVDogQ29ybmVyQml0LkZMSVBfUlRMLFxuICBUT1BfRU5EOiBDb3JuZXJCaXQuRkxJUF9SVEwgfCBDb3JuZXJCaXQuUklHSFQsXG4gIEJPVFRPTV9TVEFSVDogQ29ybmVyQml0LkJPVFRPTSB8IENvcm5lckJpdC5GTElQX1JUTCxcbiAgQk9UVE9NX0VORDogQ29ybmVyQml0LkJPVFRPTSB8IENvcm5lckJpdC5SSUdIVCB8IENvcm5lckJpdC5GTElQX1JUTCxcbn07XG5cblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzLCBDb3JuZXJCaXQsIENvcm5lcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB0b3A6IG51bWJlcixcbiAqICAgcmlnaHQ6IG51bWJlcixcbiAqICAgYm90dG9tOiBudW1iZXIsXG4gKiAgIGxlZnQ6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEFuY2hvck1hcmdpbjtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdmlld3BvcnQ6IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSxcbiAqICAgdmlld3BvcnREaXN0YW5jZToge3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfSxcbiAqICAgYW5jaG9ySGVpZ2h0OiBudW1iZXIsXG4gKiAgIGFuY2hvcldpZHRoOiBudW1iZXIsXG4gKiAgIG1lbnVIZWlnaHQ6IG51bWJlcixcbiAqICAgbWVudVdpZHRoOiBudW1iZXIsXG4gKiB9fVxuICovXG5sZXQgQXV0b0xheW91dE1lYXN1cmVtZW50cztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge01EQ01lbnVBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzLCBDb3JuZXIsIENvcm5lckJpdH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENNZW51QWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ01lbnVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyfSAqL1xuICBzdGF0aWMgZ2V0IENvcm5lcigpIHtcbiAgICByZXR1cm4gQ29ybmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ01lbnVBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ01lbnVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDTWVudUFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4gZmFsc2UsXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IGZhbHNlLFxuICAgICAgZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQ6ICgpID0+IHt9LFxuICAgICAgZ2V0SW5uZXJEaW1lbnNpb25zOiAoKSA9PiAoe30pLFxuICAgICAgaGFzQW5jaG9yOiAoKSA9PiBmYWxzZSxcbiAgICAgIGdldEFuY2hvckRpbWVuc2lvbnM6ICgpID0+ICh7fSksXG4gICAgICBnZXRXaW5kb3dEaW1lbnNpb25zOiAoKSA9PiAoe30pLFxuICAgICAgZ2V0TnVtYmVyT2ZJdGVtczogKCkgPT4gMCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGdldEluZGV4Rm9yRXZlbnRUYXJnZXQ6ICgpID0+IDAsXG4gICAgICBub3RpZnlTZWxlY3RlZDogKCkgPT4ge30sXG4gICAgICBub3RpZnlDYW5jZWw6ICgpID0+IHt9LFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIHJlc3RvcmVGb2N1czogKCkgPT4ge30sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IGZhbHNlLFxuICAgICAgZm9jdXM6ICgpID0+IHt9LFxuICAgICAgZ2V0Rm9jdXNlZEl0ZW1JbmRleDogKCkgPT4gLTEsXG4gICAgICBmb2N1c0l0ZW1BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGlzUnRsOiAoKSA9PiBmYWxzZSxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogKCkgPT4ge30sXG4gICAgICBzZXRQb3NpdGlvbjogKCkgPT4ge30sXG4gICAgICBzZXRNYXhIZWlnaHQ6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBhZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXg6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IU1EQ01lbnVBZGFwdGVyfSBhZGFwdGVyICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ01lbnVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyhldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5Ym9hcmREb3duXyhldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmtleXVwSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUtleWJvYXJkVXBfKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrXyhldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7IXsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgICB0aGlzLmRpbWVuc2lvbnNfO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaXRlbUhlaWdodF87XG4gICAgLyoqIEBwcml2YXRlIHtDb3JuZXJ9ICovXG4gICAgdGhpcy5hbmNob3JDb3JuZXJfID0gQ29ybmVyLlRPUF9TVEFSVDtcbiAgICAvKiogQHByaXZhdGUge0FuY2hvck1hcmdpbn0gKi9cbiAgICB0aGlzLmFuY2hvck1hcmdpbl8gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfTtcbiAgICAvKiogQHByaXZhdGUgez9BdXRvTGF5b3V0TWVhc3VyZW1lbnRzfSAqL1xuICAgIHRoaXMubWVhc3VyZXNfID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLnNlbGVjdGVkSW5kZXhfID0gLTE7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb25fID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMucXVpY2tPcGVuXyA9IGZhbHNlO1xuXG4gICAgLy8gQSBrZXl1cCBldmVudCBvbiB0aGUgbWVudSBuZWVkcyB0byBoYXZlIGEgY29ycmVzcG9uZGluZyBrZXlkb3duXG4gICAgLy8gZXZlbnQgb24gdGhlIG1lbnUuIElmIHRoZSB1c2VyIG9wZW5zIHRoZSBtZW51IHdpdGggYSBrZXlkb3duIGV2ZW50IG9uIGFcbiAgICAvLyBidXR0b24sIHRoZSBtZW51IHdpbGwgb25seSBnZXQgdGhlIGtleSB1cCBldmVudCBjYXVzaW5nIGJ1Z2d5IGJlaGF2aW9yIHdpdGggc2VsZWN0ZWQgZWxlbWVudHMuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMua2V5RG93bldpdGhpbk1lbnVfID0gZmFsc2U7XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnN0IHtST09ULCBPUEVOfSA9IE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoUk9PVCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtST09UfSBjbGFzcyByZXF1aXJlZCBpbiByb290IGVsZW1lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc05lY2Vzc2FyeURvbSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVkIERPTSBub2RlcyBtaXNzaW5nIGluICR7Uk9PVH0gY29tcG9uZW50LmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE9QRU4pKSB7XG4gICAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyk7XG4gICAgLy8gQ2FuY2VsIGFueSBjdXJyZW50bHkgcnVubmluZyBhbmltYXRpb25zLlxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXIodGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUNvcm5lcn0gY29ybmVyIERlZmF1bHQgYW5jaG9yIGNvcm5lciBhbGlnbm1lbnQgb2YgdG9wLWxlZnQgbWVudSBjb3JuZXIuXG4gICAqL1xuICBzZXRBbmNob3JDb3JuZXIoY29ybmVyKSB7XG4gICAgdGhpcy5hbmNob3JDb3JuZXJfID0gY29ybmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFuY2hvck1hcmdpbn0gbWFyZ2luIDQtcGxldCBvZiBtYXJnaW5zIGZyb20gYW5jaG9yLlxuICAgKi9cbiAgc2V0QW5jaG9yTWFyZ2luKG1hcmdpbikge1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy50b3AgPSB0eXBlb2YgbWFyZ2luLnRvcCA9PT0gJ251bWJlcicgPyBtYXJnaW4udG9wIDogMDtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8ucmlnaHQgPSB0eXBlb2YgbWFyZ2luLnJpZ2h0ID09PSAnbnVtYmVyJyA/IG1hcmdpbi5yaWdodCA6IDA7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbSA9IHR5cGVvZiBtYXJnaW4uYm90dG9tID09PSAnbnVtYmVyJyA/IG1hcmdpbi5ib3R0b20gOiAwO1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0ID0gdHlwZW9mIG1hcmdpbi5sZWZ0ID09PSAnbnVtYmVyJyA/IG1hcmdpbi5sZWZ0IDogMDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHJlbWVtYmVyU2VsZWN0aW9uICovXG4gIHNldFJlbWVtYmVyU2VsZWN0aW9uKHJlbWVtYmVyU2VsZWN0aW9uKSB7XG4gICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbl8gPSByZW1lbWJlclNlbGVjdGlvbjtcbiAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgoLTEpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gcXVpY2tPcGVuICovXG4gIHNldFF1aWNrT3BlbihxdWlja09wZW4pIHtcbiAgICB0aGlzLnF1aWNrT3Blbl8gPSBxdWlja09wZW47XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/bnVtYmVyfSBmb2N1c0luZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmb2N1c09uT3Blbl8oZm9jdXNJbmRleCkge1xuICAgIGlmIChmb2N1c0luZGV4ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGluc3RhbmNlIG9mIE1EQ01lbnUgcmVtZW1iZXJzIHNlbGVjdGlvbnMsIGFuZCB0aGUgdXNlciBoYXNcbiAgICAgIC8vIG1hZGUgYSBzZWxlY3Rpb24sIHRoZW4gZm9jdXMgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbVxuICAgICAgaWYgKHRoaXMucmVtZW1iZXJTZWxlY3Rpb25fICYmIHRoaXMuc2VsZWN0ZWRJbmRleF8gPj0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4Xyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1cygpO1xuICAgICAgLy8gSWYgdGhhdCBkb2Vzbid0IHdvcmssIGZvY3VzIGZpcnN0IGl0ZW0gaW5zdGVhZC5cbiAgICAgIGlmICghdGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChmb2N1c0luZGV4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBhbmQgY2FuY2VsIHRoZSBtZW51IGlmIG5vdCBhIGNoaWxkIGxpc3QtaXRlbVxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEb2N1bWVudENsaWNrXyhldnQpIHtcbiAgICBsZXQgZWwgPSBldnQudGFyZ2V0O1xuXG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldEluZGV4Rm9yRXZlbnRUYXJnZXQoZWwpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDYW5jZWwoKTtcbiAgICB0aGlzLmNsb3NlKGV2dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBrZXlzIHRoYXQgd2Ugd2FudCB0byByZXBlYXQgb24gaG9sZCAodGFiIGFuZCBhcnJvd3MpLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVLZXlib2FyZERvd25fKGV2dCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgQWx0LCBDdHJsIG9yIE1ldGEgYXJlIHByZXNzZWQuXG4gICAgaWYgKGV2dC5hbHRLZXkgfHwgZXZ0LmN0cmxLZXkgfHwgZXZ0Lm1ldGFLZXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHtrZXlDb2RlLCBrZXksIHNoaWZ0S2V5fSA9IGV2dDtcbiAgICBjb25zdCBpc1RhYiA9IGtleSA9PT0gJ1RhYicgfHwga2V5Q29kZSA9PT0gOTtcbiAgICBjb25zdCBpc0Fycm93VXAgPSBrZXkgPT09ICdBcnJvd1VwJyB8fCBrZXlDb2RlID09PSAzODtcbiAgICBjb25zdCBpc0Fycm93RG93biA9IGtleSA9PT0gJ0Fycm93RG93bicgfHwga2V5Q29kZSA9PT0gNDA7XG4gICAgY29uc3QgaXNTcGFjZSA9IGtleSA9PT0gJ1NwYWNlJyB8fCBrZXlDb2RlID09PSAzMjtcbiAgICBjb25zdCBpc0VudGVyID0ga2V5ID09PSAnRW50ZXInIHx8IGtleUNvZGUgPT09IDEzO1xuICAgIC8vIFRoZSBtZW51IG5lZWRzIHRvIGtub3cgaWYgdGhlIGtleWRvd24gZXZlbnQgd2FzIHRyaWdnZXJlZCBvbiB0aGUgbWVudVxuICAgIHRoaXMua2V5RG93bldpdGhpbk1lbnVfID0gaXNFbnRlciB8fCBpc1NwYWNlO1xuXG4gICAgY29uc3QgZm9jdXNlZEl0ZW1JbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNlZEl0ZW1JbmRleCgpO1xuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mSXRlbXMoKSAtIDE7XG5cbiAgICBpZiAoc2hpZnRLZXkgJiYgaXNUYWIgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGxhc3RJdGVtSW5kZXgpO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFzaGlmdEtleSAmJiBpc1RhYiAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSBsYXN0SXRlbUluZGV4KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoMCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgQXJyb3d7VXAsRG93bn0gYW5kIHNwYWNlIGRvIG5vdCBjYXVzZSBpbmFkdmVydGVudCBzY3JvbGxpbmdcbiAgICBpZiAoaXNBcnJvd1VwIHx8IGlzQXJyb3dEb3duIHx8IGlzU3BhY2UpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmIChpc0Fycm93VXApIHtcbiAgICAgIGlmIChmb2N1c2VkSXRlbUluZGV4ID09PSAwIHx8IHRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGxhc3RJdGVtSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGZvY3VzZWRJdGVtSW5kZXggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXJyb3dEb3duKSB7XG4gICAgICBpZiAoZm9jdXNlZEl0ZW1JbmRleCA9PT0gbGFzdEl0ZW1JbmRleCB8fCB0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChmb2N1c2VkSXRlbUluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGtleXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvIHJlcGVhdCBvbiBob2xkIChFbnRlciwgU3BhY2UsIEVzY2FwZSkuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUtleWJvYXJkVXBfKGV2dCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgQWx0LCBDdHJsIG9yIE1ldGEgYXJlIHByZXNzZWQuXG4gICAgaWYgKGV2dC5hbHRLZXkgfHwgZXZ0LmN0cmxLZXkgfHwgZXZ0Lm1ldGFLZXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHtrZXlDb2RlLCBrZXl9ID0gZXZ0O1xuICAgIGNvbnN0IGlzRW50ZXIgPSBrZXkgPT09ICdFbnRlcicgfHwga2V5Q29kZSA9PT0gMTM7XG4gICAgY29uc3QgaXNTcGFjZSA9IGtleSA9PT0gJ1NwYWNlJyB8fCBrZXlDb2RlID09PSAzMjtcbiAgICBjb25zdCBpc0VzY2FwZSA9IGtleSA9PT0gJ0VzY2FwZScgfHwga2V5Q29kZSA9PT0gMjc7XG5cbiAgICBpZiAoaXNFbnRlciB8fCBpc1NwYWNlKSB7XG4gICAgICAvLyBJZiB0aGUga2V5ZG93biBldmVudCBkaWRuJ3Qgb2NjdXIgb24gdGhlIG1lbnUsIHRoZW4gaXQgc2hvdWxkXG4gICAgICAvLyBkaXNyZWdhcmQgdGhlIHBvc3NpYmxlIHNlbGVjdGVkIGV2ZW50LlxuICAgICAgaWYgKHRoaXMua2V5RG93bldpdGhpbk1lbnVfKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9zc2libGVTZWxlY3RlZF8oZXZ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5RG93bldpdGhpbk1lbnVfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRXNjYXBlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNhbmNlbCgpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfKGV2dCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0KGV2dC50YXJnZXQsIHN0cmluZ3MuQVJJQV9ESVNBQkxFRF9BVFRSKSA9PT0gJ3RydWUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRJbmRleEZvckV2ZW50VGFyZ2V0KGV2dC50YXJnZXQpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVib3VuY2UgbXVsdGlwbGUgc2VsZWN0aW9uc1xuICAgIGlmICh0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8gPSAwO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgaWYgKHRoaXMucmVtZW1iZXJTZWxlY3Rpb25fKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJbmRleCh0YXJnZXRJbmRleCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNlbGVjdGVkKHtpbmRleDogdGFyZ2V0SW5kZXh9KTtcbiAgICB9LCBudW1iZXJzLlNFTEVDVEVEX1RSSUdHRVJfREVMQVkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0F1dG9MYXlvdXRNZWFzdXJlbWVudHN9IE1lYXN1cmVtZW50cyB1c2VkIHRvIHBvc2l0aW9uIG1lbnUgcG9wdXAuXG4gICAqL1xuICBnZXRBdXRvTGF5b3V0TWVhc3VyZW1lbnRzXygpIHtcbiAgICBjb25zdCBhbmNob3JSZWN0ID0gdGhpcy5hZGFwdGVyXy5nZXRBbmNob3JEaW1lbnNpb25zKCk7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLmFkYXB0ZXJfLmdldFdpbmRvd0RpbWVuc2lvbnMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICB2aWV3cG9ydERpc3RhbmNlOiB7XG4gICAgICAgIHRvcDogYW5jaG9yUmVjdC50b3AsXG4gICAgICAgIHJpZ2h0OiB2aWV3cG9ydC53aWR0aCAtIGFuY2hvclJlY3QucmlnaHQsXG4gICAgICAgIGxlZnQ6IGFuY2hvclJlY3QubGVmdCxcbiAgICAgICAgYm90dG9tOiB2aWV3cG9ydC5oZWlnaHQgLSBhbmNob3JSZWN0LmJvdHRvbSxcbiAgICAgIH0sXG4gICAgICBhbmNob3JIZWlnaHQ6IGFuY2hvclJlY3QuaGVpZ2h0LFxuICAgICAgYW5jaG9yV2lkdGg6IGFuY2hvclJlY3Qud2lkdGgsXG4gICAgICBtZW51SGVpZ2h0OiB0aGlzLmRpbWVuc2lvbnNfLmhlaWdodCxcbiAgICAgIG1lbnVXaWR0aDogdGhpcy5kaW1lbnNpb25zXy53aWR0aCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBjb3JuZXIgb2YgdGhlIGFuY2hvciBmcm9tIHdoaWNoIHRvIGFuaW1hdGUgYW5kIHBvc2l0aW9uIHRoZSBtZW51LlxuICAgKiBAcmV0dXJuIHtDb3JuZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRPcmlnaW5Db3JuZXJfKCkge1xuICAgIC8vIERlZmF1bHRzOiBvcGVuIGZyb20gdGhlIHRvcCBsZWZ0LlxuICAgIGxldCBjb3JuZXIgPSBDb3JuZXIuVE9QX0xFRlQ7XG5cbiAgICBjb25zdCB7dmlld3BvcnREaXN0YW5jZSwgYW5jaG9ySGVpZ2h0LCBhbmNob3JXaWR0aCwgbWVudUhlaWdodCwgbWVudVdpZHRofSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzQm90dG9tQWxpZ25lZCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkJPVFRPTSk7XG4gICAgY29uc3QgYXZhaWxhYmxlVG9wID0gaXNCb3R0b21BbGlnbmVkID8gdmlld3BvcnREaXN0YW5jZS50b3AgKyBhbmNob3JIZWlnaHQgKyB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tXG4gICAgICA6IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcbiAgICBjb25zdCBhdmFpbGFibGVCb3R0b20gPSBpc0JvdHRvbUFsaWduZWQgPyB2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSAtIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b21cbiAgICAgIDogdmlld3BvcnREaXN0YW5jZS5ib3R0b20gKyBhbmNob3JIZWlnaHQgLSB0aGlzLmFuY2hvck1hcmdpbl8udG9wO1xuXG4gICAgY29uc3QgdG9wT3ZlcmZsb3cgPSBtZW51SGVpZ2h0IC0gYXZhaWxhYmxlVG9wO1xuICAgIGNvbnN0IGJvdHRvbU92ZXJmbG93ID0gbWVudUhlaWdodCAtIGF2YWlsYWJsZUJvdHRvbTtcbiAgICBpZiAoYm90dG9tT3ZlcmZsb3cgPiAwICYmIHRvcE92ZXJmbG93IDwgYm90dG9tT3ZlcmZsb3cpIHtcbiAgICAgIGNvcm5lciB8PSBDb3JuZXJCaXQuQk9UVE9NO1xuICAgIH1cblxuICAgIGNvbnN0IGlzUnRsID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpO1xuICAgIGNvbnN0IGlzRmxpcFJ0bCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkZMSVBfUlRMKTtcbiAgICBjb25zdCBhdm9pZEhvcml6b250YWxPdmVybGFwID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuUklHSFQpO1xuICAgIGNvbnN0IGlzQWxpZ25lZFJpZ2h0ID0gKGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgJiYgIWlzUnRsKSB8fFxuICAgICAgKCFhdm9pZEhvcml6b250YWxPdmVybGFwICYmIGlzRmxpcFJ0bCAmJiBpc1J0bCk7XG4gICAgY29uc3QgYXZhaWxhYmxlTGVmdCA9IGlzQWxpZ25lZFJpZ2h0ID8gdmlld3BvcnREaXN0YW5jZS5sZWZ0ICsgYW5jaG9yV2lkdGggKyB0aGlzLmFuY2hvck1hcmdpbl8ucmlnaHQgOlxuICAgICAgdmlld3BvcnREaXN0YW5jZS5sZWZ0ICsgdGhpcy5hbmNob3JNYXJnaW5fLmxlZnQ7XG4gICAgY29uc3QgYXZhaWxhYmxlUmlnaHQgPSBpc0FsaWduZWRSaWdodCA/IHZpZXdwb3J0RGlzdGFuY2UucmlnaHQgLSB0aGlzLmFuY2hvck1hcmdpbl8ucmlnaHQgOlxuICAgICAgdmlld3BvcnREaXN0YW5jZS5yaWdodCArIGFuY2hvcldpZHRoIC0gdGhpcy5hbmNob3JNYXJnaW5fLmxlZnQ7XG5cbiAgICBjb25zdCBsZWZ0T3ZlcmZsb3cgPSBtZW51V2lkdGggLSBhdmFpbGFibGVMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0T3ZlcmZsb3cgPSBtZW51V2lkdGggLSBhdmFpbGFibGVSaWdodDtcblxuICAgIGlmICgobGVmdE92ZXJmbG93IDwgMCAmJiBpc0FsaWduZWRSaWdodCAmJiBpc1J0bCkgfHxcbiAgICAgICAgKGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgJiYgIWlzQWxpZ25lZFJpZ2h0ICYmIGxlZnRPdmVyZmxvdyA8IDApIHx8XG4gICAgICAgIChyaWdodE92ZXJmbG93ID4gMCAmJiBsZWZ0T3ZlcmZsb3cgPCByaWdodE92ZXJmbG93KSkge1xuICAgICAgY29ybmVyIHw9IENvcm5lckJpdC5SSUdIVDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29ybmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgT3JpZ2luIGNvcm5lciBvZiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIb3Jpem9udGFsIG9mZnNldCBvZiBtZW51IG9yaWdpbiBjb3JuZXIgZnJvbSBjb3JyZXNwb25kaW5nIGFuY2hvciBjb3JuZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRIb3Jpem9udGFsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpIHtcbiAgICBjb25zdCB7YW5jaG9yV2lkdGh9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgY29uc3QgaXNSaWdodEFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5SSUdIVCk7XG4gICAgY29uc3QgYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LlJJR0hUKTtcbiAgICBsZXQgeCA9IDA7XG4gICAgaWYgKGlzUmlnaHRBbGlnbmVkKSB7XG4gICAgICBjb25zdCByaWdodE9mZnNldCA9IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0IDogdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0O1xuICAgICAgeCA9IHJpZ2h0T2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA/IGFuY2hvcldpZHRoIC0gdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDogdGhpcy5hbmNob3JNYXJnaW5fLmxlZnQ7XG4gICAgICB4ID0gbGVmdE9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBPcmlnaW4gY29ybmVyIG9mIHRoZSBtZW51LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZlcnRpY2FsIG9mZnNldCBvZiBtZW51IG9yaWdpbiBjb3JuZXIgZnJvbSBjb3JyZXNwb25kaW5nIGFuY2hvciBjb3JuZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRWZXJ0aWNhbE9yaWdpbk9mZnNldF8oY29ybmVyKSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0LCB2aWV3cG9ydERpc3RhbmNlLCBhbmNob3JIZWlnaHQsIG1lbnVIZWlnaHR9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgY29uc3QgaXNCb3R0b21BbGlnbmVkID0gQm9vbGVhbihjb3JuZXIgJiBDb3JuZXJCaXQuQk9UVE9NKTtcbiAgICBjb25zdCB7TUFSR0lOX1RPX0VER0V9ID0gTURDTWVudUZvdW5kYXRpb24ubnVtYmVycztcbiAgICBjb25zdCBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkJPVFRPTSk7XG4gICAgY29uc3QgY2FuT3ZlcmxhcFZlcnRpY2FsbHkgPSAhYXZvaWRWZXJ0aWNhbE92ZXJsYXA7XG4gICAgbGV0IHkgPSAwO1xuXG4gICAgaWYgKGlzQm90dG9tQWxpZ25lZCkge1xuICAgICAgeSA9IGF2b2lkVmVydGljYWxPdmVybGFwID8gYW5jaG9ySGVpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnRvcCA6IC10aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tO1xuICAgICAgLy8gYWRqdXN0IGZvciB3aGVuIG1lbnUgY2FuIG92ZXJsYXAgYW5jaG9yLCBidXQgdG9vIHRhbGwgdG8gYmUgYWxpZ25lZCB0byBib3R0b21cbiAgICAgIC8vIGFuY2hvciBjb3JuZXIuIEJvdHRvbSBtYXJnaW4gaXMgaWdub3JlZCBpbiBzdWNoIGNhc2VzLlxuICAgICAgaWYgKGNhbk92ZXJsYXBWZXJ0aWNhbGx5ICYmIG1lbnVIZWlnaHQgPiB2aWV3cG9ydERpc3RhbmNlLnRvcCArIGFuY2hvckhlaWdodCkge1xuICAgICAgICB5ID0gLShNYXRoLm1pbihtZW51SGVpZ2h0LCB2aWV3cG9ydC5oZWlnaHQgLSBNQVJHSU5fVE9fRURHRSkgLSAodmlld3BvcnREaXN0YW5jZS50b3AgKyBhbmNob3JIZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IGF2b2lkVmVydGljYWxPdmVybGFwID8gKGFuY2hvckhlaWdodCArIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b20pIDogdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcbiAgICAgIC8vIGFkanVzdCBmb3Igd2hlbiBtZW51IGNhbiBvdmVybGFwIGFuY2hvciwgYnV0IHRvbyB0YWxsIHRvIGJlIGFsaWduZWQgdG8gdG9wXG4gICAgICAvLyBhbmNob3IgY29ybmVycy4gVG9wIG1hcmdpbiBpcyBpZ25vcmVkIGluIHRoYXQgY2FzZS5cbiAgICAgIGlmIChjYW5PdmVybGFwVmVydGljYWxseSAmJiBtZW51SGVpZ2h0ID4gdmlld3BvcnREaXN0YW5jZS5ib3R0b20gKyBhbmNob3JIZWlnaHQpIHtcbiAgICAgICAgeSA9IC0oTWF0aC5taW4obWVudUhlaWdodCwgdmlld3BvcnQuaGVpZ2h0IC0gTUFSR0lOX1RPX0VER0UpIC0gKHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgT3JpZ2luIGNvcm5lciBvZiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNYXhpbXVtIGhlaWdodCBvZiB0aGUgbWVudSwgYmFzZWQgb24gYXZhaWxhYmxlIHNwYWNlLiAwIGluZGljYXRlcyBzaG91bGQgbm90IGJlIHNldC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1lbnVNYXhIZWlnaHRfKGNvcm5lcikge1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGNvbnN0IHt2aWV3cG9ydERpc3RhbmNlfSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzQm90dG9tQWxpZ25lZCA9IEJvb2xlYW4oY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSk7XG5cbiAgICAvLyBXaGVuIG1heGltdW0gaGVpZ2h0IGlzIG5vdCBzcGVjaWZpZWQsIGl0IGlzIGhhbmRsZWQgZnJvbSBjc3MuXG4gICAgaWYgKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pIHtcbiAgICAgIGlmIChpc0JvdHRvbUFsaWduZWQpIHtcbiAgICAgICAgbWF4SGVpZ2h0ID0gdmlld3BvcnREaXN0YW5jZS50b3AgKyB0aGlzLmFuY2hvck1hcmdpbl8udG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4SGVpZ2h0ID0gdmlld3BvcnREaXN0YW5jZS5ib3R0b20gLSB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXhIZWlnaHQ7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYXV0b1Bvc2l0aW9uXygpIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzQW5jaG9yKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIG1lYXN1cmVtZW50cyBmb3IgYXV0b3Bvc2l0aW9uIG1ldGhvZHMgcmV1c2UuXG4gICAgdGhpcy5tZWFzdXJlc18gPSB0aGlzLmdldEF1dG9MYXlvdXRNZWFzdXJlbWVudHNfKCk7XG5cbiAgICBjb25zdCBjb3JuZXIgPSB0aGlzLmdldE9yaWdpbkNvcm5lcl8oKTtcbiAgICBjb25zdCBtYXhNZW51SGVpZ2h0ID0gdGhpcy5nZXRNZW51TWF4SGVpZ2h0Xyhjb3JuZXIpO1xuICAgIGxldCB2ZXJ0aWNhbEFsaWdubWVudCA9IChjb3JuZXIgJiBDb3JuZXJCaXQuQk9UVE9NKSA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgbGV0IGhvcml6b250YWxBbGlnbm1lbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LlJJR0hUKSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgY29uc3QgaG9yaXpvbnRhbE9mZnNldCA9IHRoaXMuZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8oY29ybmVyKTtcbiAgICBjb25zdCB2ZXJ0aWNhbE9mZnNldCA9IHRoaXMuZ2V0VmVydGljYWxPcmlnaW5PZmZzZXRfKGNvcm5lcik7XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICBbaG9yaXpvbnRhbEFsaWdubWVudF06IGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0ICsgJ3B4JyA6ICcwJyxcbiAgICAgIFt2ZXJ0aWNhbEFsaWdubWVudF06IHZlcnRpY2FsT2Zmc2V0ID8gdmVydGljYWxPZmZzZXQgKyAncHgnIDogJzAnLFxuICAgIH07XG4gICAgY29uc3Qge2FuY2hvcldpZHRoLCBtZW51SGVpZ2h0LCBtZW51V2lkdGh9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgLy8gQ2VudGVyIGFsaWduIHdoZW4gYW5jaG9yIHdpZHRoIGlzIGNvbXBhcmFibGUgb3IgZ3JlYXRlciB0aGFuIG1lbnUsIG90aGVyd2lzZSBrZWVwIGNvcm5lci5cbiAgICBpZiAoYW5jaG9yV2lkdGggLyBtZW51V2lkdGggPiBudW1iZXJzLkFOQ0hPUl9UT19NRU5VX1dJRFRIX1JBVElPKSB7XG4gICAgICBob3Jpem9udGFsQWxpZ25tZW50ID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IHZlcnRpY2FsIG9yaWdpbiB3aGVuIG1lbnUgaXMgcG9zaXRpb25lZCB3aXRoIHNpZ25pZmljYW50IG9mZnNldCBmcm9tIGFuY2hvci4gVGhpcyBpcyBkb25lIHNvIHRoYXRcbiAgICAvLyBzY2FsZSBhbmltYXRpb24gaXMgXCJhbmNob3JlZFwiIG9uIHRoZSBhbmNob3IuXG4gICAgaWYgKCEodGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkJPVFRPTSkgJiZcbiAgICAgICAgTWF0aC5hYnModmVydGljYWxPZmZzZXQgLyBtZW51SGVpZ2h0KSA+IG51bWJlcnMuT0ZGU0VUX1RPX01FTlVfSEVJR0hUX1JBVElPKSB7XG4gICAgICBjb25zdCB2ZXJ0aWNhbE9mZnNldFBlcmNlbnQgPSBNYXRoLmFicyh2ZXJ0aWNhbE9mZnNldCAvIG1lbnVIZWlnaHQpICogMTAwO1xuICAgICAgY29uc3Qgb3JpZ2luUGVyY2VudCA9IChjb3JuZXIgJiBDb3JuZXJCaXQuQk9UVE9NKSA/IDEwMCAtIHZlcnRpY2FsT2Zmc2V0UGVyY2VudCA6IHZlcnRpY2FsT2Zmc2V0UGVyY2VudDtcbiAgICAgIHZlcnRpY2FsQWxpZ25tZW50ID0gTWF0aC5yb3VuZChvcmlnaW5QZXJjZW50ICogMTAwKSAvIDEwMCArICclJztcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFRyYW5zZm9ybU9yaWdpbihgJHtob3Jpem9udGFsQWxpZ25tZW50fSAke3ZlcnRpY2FsQWxpZ25tZW50fWApO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0TWF4SGVpZ2h0KG1heE1lbnVIZWlnaHQgPyBtYXhNZW51SGVpZ2h0ICsgJ3B4JyA6ICcnKTtcblxuICAgIC8vIENsZWFyIG1lYXN1cmVzIGFmdGVyIHBvc2l0aW9uaW5nIGlzIGNvbXBsZXRlLlxuICAgIHRoaXMubWVhc3VyZXNfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge3tmb2N1c0luZGV4OiA/bnVtYmVyfT19IG9wdGlvbnNcbiAgICovXG4gIG9wZW4oe2ZvY3VzSW5kZXggPSBudWxsfSA9IHt9KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zYXZlRm9jdXMoKTtcblxuICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HX09QRU4pO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmRpbWVuc2lvbnNfID0gdGhpcy5hZGFwdGVyXy5nZXRJbm5lckRpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuYXV0b1Bvc2l0aW9uXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICAgICAgdGhpcy5mb2N1c09uT3Blbl8oZm9jdXNJbmRleCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcih0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgICB0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfID0gMDtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HX09QRU4pO1xuICAgICAgICB9LCBudW1iZXJzLlRSQU5TSVRJT05fT1BFTl9EVVJBVElPTik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldnRcbiAgICovXG4gIGNsb3NlKGV2dCA9IG51bGwpIHtcbiAgICBjb25zdCB0YXJnZXRJc0Rpc2FibGVkID0gZXZ0ID9cbiAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQoZXZ0LnRhcmdldCwgc3RyaW5ncy5BUklBX0RJU0FCTEVEX0FUVFIpID09PSAndHJ1ZScgOlxuICAgICAgZmFsc2U7XG5cbiAgICBpZiAodGFyZ2V0SXNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXIodGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcl8pO1xuXG4gICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfQ0xPU0VEKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICAgICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgICAgdGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfID0gMDtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HX0NMT1NFRCk7XG4gICAgICAgIH0sIG51bWJlcnMuVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5yZXN0b3JlRm9jdXMoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuXztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFNlbGVjdGVkSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBpdGVtIHRvIHNldCBhcyBzZWxlY3RlZC5cbiAgICovXG4gIHNldFNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRJbmRleF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2U2VsZWN0ZWRJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleF87XG4gICAgaWYgKHByZXZTZWxlY3RlZEluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyRm9yT3B0aW9uQXRJbmRleChwcmV2U2VsZWN0ZWRJbmRleCwgJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1DbGFzc0Zvck9wdGlvbkF0SW5kZXgocHJldlNlbGVjdGVkSW5kZXgsIGNzc0NsYXNzZXMuU0VMRUNURURfTElTVF9JVEVNKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdGVkSW5kZXhfID0gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZJdGVtcygpID8gaW5kZXggOiAtMTtcbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4XyA+PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJGb3JPcHRpb25BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8sICdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8sIGNzc0NsYXNzZXMuU0VMRUNURURfTElTVF9JVEVNKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtNRENNZW51Rm91bmRhdGlvbiwgQW5jaG9yTWFyZ2lufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cbmxldCBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHByb3BlcnR5IHRvIHVzZSBvbiB0aGUgY3VycmVudCBicm93c2VyLlxuICogQHBhcmFtIHshV2luZG93fSBnbG9iYWxPYmpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlUmVmcmVzaFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUoZ2xvYmFsT2JqLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGVsID0gZ2xvYmFsT2JqLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHRyYW5zZm9ybVByb3BlcnR5TmFtZSA9ICgndHJhbnNmb3JtJyBpbiBlbC5zdHlsZSA/ICd0cmFuc2Zvcm0nIDogJ3dlYmtpdFRyYW5zZm9ybScpO1xuICAgIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPSB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWU7XG4gIH1cblxuICByZXR1cm4gc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcbn1cblxuLyoqXG4gKiBDbGFtcHMgYSB2YWx1ZSBiZXR3ZWVuIHRoZSBtaW5pbXVtIGFuZCB0aGUgbWF4aW11bSwgcmV0dXJuaW5nIHRoZSBjbGFtcGVkIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWUpKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVhc2luZyB2YWx1ZSB0byBhcHBseSBhdCB0aW1lIHQsIGZvciBhIGdpdmVuIGN1YmljIGJlemllciBjdXJ2ZS5cbiAqIENvbnRyb2wgcG9pbnRzIFAwIGFuZCBQMyBhcmUgYXNzdW1lZCB0byBiZSAoMCwwKSBhbmQgKDEsMSksIHJlc3BlY3RpdmVseS5cbiAqIFBhcmFtZXRlcnMgYXJlIGFzIGZvbGxvd3M6XG4gKiAtIHRpbWU6IFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIGFuaW1hdGlvbiwgc2NhbGVkIGJldHdlZW4gMCBhbmQgMS5cbiAqIC0geDE6IFRoZSB4IHZhbHVlIG9mIGNvbnRyb2wgcG9pbnQgUDEuXG4gKiAtIHkxOiBUaGUgeSB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAxLlxuICogLSB4MjogVGhlIHggdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMi5cbiAqIC0geTI6IFRoZSB5IHZhbHVlIG9mIGNvbnRyb2wgcG9pbnQgUDIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGJlemllclByb2dyZXNzKHRpbWUsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHJldHVybiBnZXRCZXppZXJDb29yZGluYXRlXyhzb2x2ZVBvc2l0aW9uRnJvbVhWYWx1ZV8odGltZSwgeDEsIHgyKSwgeTEsIHkyKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIGEgc2luZ2xlIGNvb3JkaW5hdGUgYXQgYSBwb3NpdGlvbiBwb2ludCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBjMSBhbmQgYzIgYXJlIHRoZSBtYXRjaGluZyBjb29yZGluYXRlIG9uIGNvbnRyb2wgcG9pbnRzIFAxIGFuZCBQMiwgcmVzcGVjdGl2ZWx5LlxuICogQ29udHJvbCBwb2ludHMgUDAgYW5kIFAzIGFyZSBhc3N1bWVkIHRvIGJlICgwLDApIGFuZCAoMSwxKSwgcmVzcGVjdGl2ZWx5LlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2Jlemllci5qcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcGFyYW0ge251bWJlcn0gYzFcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCZXppZXJDb29yZGluYXRlXyh0LCBjMSwgYzIpIHtcbiAgLy8gU3BlY2lhbCBjYXNlIHN0YXJ0IGFuZCBlbmQuXG4gIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIC8vIFN0ZXAgb25lIC0gZnJvbSA0IHBvaW50cyB0byAzXG4gIGxldCBpYzAgPSB0ICogYzE7XG4gIGxldCBpYzEgPSBjMSArIHQgKiAoYzIgLSBjMSk7XG4gIGNvbnN0IGljMiA9IGMyICsgdCAqICgxIC0gYzIpO1xuXG4gIC8vIFN0ZXAgdHdvIC0gZnJvbSAzIHBvaW50cyB0byAyXG4gIGljMCArPSB0ICogKGljMSAtIGljMCk7XG4gIGljMSArPSB0ICogKGljMiAtIGljMSk7XG5cbiAgLy8gRmluYWwgc3RlcCAtIGxhc3QgcG9pbnRcbiAgcmV0dXJuIGljMCArIHQgKiAoaWMxIC0gaWMwKTtcbn1cblxuLyoqXG4gKiBQcm9qZWN0IGEgcG9pbnQgb250byB0aGUgQmV6aWVyIGN1cnZlLCBmcm9tIGEgZ2l2ZW4gWC4gQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gdCBhbG9uZyB0aGUgY3VydmUuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvYmV6aWVyLmpzLlxuICogQHBhcmFtIHtudW1iZXJ9IHhWYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNvbHZlUG9zaXRpb25Gcm9tWFZhbHVlXyh4VmFsLCB4MSwgeDIpIHtcbiAgY29uc3QgRVBTSUxPTiA9IDFlLTY7XG4gIGNvbnN0IE1BWF9JVEVSQVRJT05TID0gODtcblxuICBpZiAoeFZhbCA8PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoeFZhbCA+PSAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyBJbml0aWFsIGVzdGltYXRlIG9mIHQgdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24uXG4gIGxldCB0ID0geFZhbDtcblxuICAvLyBUcnkgZ3JhZGllbnQgZGVzY2VudCB0byBzb2x2ZSBmb3IgdC4gSWYgaXQgd29ya3MsIGl0IGlzIHZlcnkgZmFzdC5cbiAgbGV0IHRNaW4gPSAwO1xuICBsZXQgdE1heCA9IDE7XG4gIGxldCB2YWx1ZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lURVJBVElPTlM7IGkrKykge1xuICAgIHZhbHVlID0gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCwgeDEsIHgyKTtcbiAgICBjb25zdCBkZXJpdmF0aXZlID0gKGdldEJlemllckNvb3JkaW5hdGVfKHQgKyBFUFNJTE9OLCB4MSwgeDIpIC0gdmFsdWUpIC8gRVBTSUxPTjtcbiAgICBpZiAoTWF0aC5hYnModmFsdWUgLSB4VmFsKSA8IEVQU0lMT04pIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGVyaXZhdGl2ZSkgPCBFUFNJTE9OKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlIDwgeFZhbCkge1xuICAgICAgICB0TWluID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRNYXggPSB0O1xuICAgICAgfVxuICAgICAgdCAtPSAodmFsdWUgLSB4VmFsKSAvIGRlcml2YXRpdmU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIGdyYWRpZW50IGRlc2NlbnQgZ290IHN0dWNrIGluIGEgbG9jYWwgbWluaW11bSwgZS5nLiBiZWNhdXNlXG4gIC8vIHRoZSBkZXJpdmF0aXZlIHdhcyBjbG9zZSB0byAwLCB1c2UgYSBEaWNob3RvbXkgcmVmaW5lbWVudCBpbnN0ZWFkLlxuICAvLyBXZSBsaW1pdCB0aGUgbnVtYmVyIG9mIGludGVyYXRpb25zIHRvIDguXG4gIGZvciAobGV0IGkgPSAwOyBNYXRoLmFicyh2YWx1ZSAtIHhWYWwpID4gRVBTSUxPTiAmJiBpIDwgTUFYX0lURVJBVElPTlM7IGkrKykge1xuICAgIGlmICh2YWx1ZSA8IHhWYWwpIHtcbiAgICAgIHRNaW4gPSB0O1xuICAgICAgdCA9ICh0ICsgdE1heCkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0TWF4ID0gdDtcbiAgICAgIHQgPSAodCArIHRNaW4pIC8gMjtcbiAgICB9XG4gICAgdmFsdWUgPSBnZXRCZXppZXJDb29yZGluYXRlXyh0LCB4MSwgeDIpO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQge2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZSwgY2xhbXAsIGJlemllclByb2dyZXNzfTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiByZWY9XCJyb290XCIgY2xhc3M9XCJtZGMtbWVudSBtZGMtc2ltcGxlLW1lbnVcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICB0YWJpbmRleD1cIi0xXCI+XG4gICAgPHVsIHJlZj1cIml0ZW1zXCIgY2xhc3M9XCJtZGMtc2ltcGxlLW1lbnVfX2l0ZW1zIG1kYy1saXN0XCIgXG4gICAgICByb2xlPVwibWVudVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvdWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7TURDTWVudUZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9tZW51L2ZvdW5kYXRpb24nXG5pbXBvcnQge2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZX0gZnJvbSAnQG1hdGVyaWFsL21lbnUvdXRpbCdcbmltcG9ydCB7ZW1pdEN1c3RvbUV2ZW50fSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudScsXG4gIHByb3BzOiB7XG4gICAgJ29wZW4tZnJvbS10b3AtbGVmdCc6IEJvb2xlYW4sXG4gICAgJ29wZW4tZnJvbS10b3AtcmlnaHQnOiBCb29sZWFuLFxuICAgICdvcGVuLWZyb20tYm90dG9tLWxlZnQnOiBCb29sZWFuLFxuICAgICdvcGVuLWZyb20tYm90dG9tLXJpZ2h0JzogQm9vbGVhblxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXNpbXBsZS1tZW51LS1vcGVuLWZyb20tdG9wLWxlZnQnOiB0aGlzLm9wZW5Gcm9tVG9wTGVmdCxcbiAgICAgICAgJ21kYy1zaW1wbGUtbWVudS0tb3Blbi1mcm9tLXRvcC1yaWdodCc6IHRoaXMub3BlbkZyb21Ub3BSaWdodCxcbiAgICAgICAgJ21kYy1zaW1wbGUtbWVudS0tb3Blbi1mcm9tLWJvdHRvbS1sZWZ0JzogdGhpcy5vcGVuRnJvbUJvdHRvbUxlZnQsXG4gICAgICAgICdtZGMtc2ltcGxlLW1lbnUtLW9wZW4tZnJvbS1ib3R0b20tcmlnaHQnOiB0aGlzLm9wZW5Gcm9tQm90dG9tUmlnaHRcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgaXRlbXM6IFtdXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2hvdyAob3B0aW9ucykge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4ob3B0aW9ucylcbiAgICB9LFxuICAgIGhpZGUgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICB9LFxuICAgIGlzT3BlbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uID8gdGhpcy5mb3VuZGF0aW9uLmlzT3BlbigpIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIGNvbnN0IHJlZnJlc2hJdGVtcyA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXRlbXMgPSBbXS5zbGljZS5jYWxsKFxuICAgICAgICB0aGlzLiRyZWZzLml0ZW1zLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZGMtbGlzdC1pdGVtW3JvbGVdJykpXG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGUnKVxuICAgIH1cbiAgICB0aGlzLnNsb3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHJlZnJlc2hJdGVtcygpKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pXG5cbiAgICB0aGlzLl9wcmV2aW91c0ZvY3VzID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDTWVudUZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRyZWZzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IEJvb2xlYW4odGhpcy4kcmVmcy5pdGVtcyksXG4gICAgICBnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldDogKHRhcmdldCwgYXR0cmlidXRlTmFtZSkgPT5cbiAgICAgICAgdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIGdldElubmVyRGltZW5zaW9uczogKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IHRoaXMuJHJlZnMuaXRlbXMub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy4kcmVmcy5pdGVtcy5vZmZzZXRIZWlnaHRcbiAgICAgIH0pLFxuICAgICAgaGFzQW5jaG9yOiAoKSA9PiB0aGlzLiRyZWZzLnJvb3QucGFyZW50RWxlbWVudCAmJlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ21kYy1tZW51LWFuY2hvcicpLFxuICAgICAgZ2V0QW5jaG9yRGltZW5zaW9uczogKCkgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRXaW5kb3dEaW1lbnNpb25zOiAoKSA9PiAoe1xuICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICB9KSxcbiAgICAgIGdldE51bWJlck9mSXRlbXM6ICgpID0+IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldDogKHRhcmdldCkgPT4gdGhpcy5pdGVtcy5pbmRleE9mKHRhcmdldCksXG4gICAgICBub3RpZnlTZWxlY3RlZDogKGV2dERhdGEpID0+IHtcbiAgICAgICAgY29uc3QgZXZ0ID0ge1xuICAgICAgICAgIGluZGV4OiBldnREYXRhLmluZGV4LFxuICAgICAgICAgIGl0ZW06IHRoaXMuaXRlbXNbZXZ0RGF0YS5pbmRleF1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QnLCBldnQpXG4gICAgICAgIGVtaXRDdXN0b21FdmVudCh0aGlzLiRlbCxcbiAgICAgICAgICBNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULFxuICAgICAgICAgIGV2dClcbiAgICAgIH0sXG4gICAgICBub3RpZnlDYW5jZWw6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2FuY2VsJylcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KHRoaXMuJGVsLFxuICAgICAgICAgIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULFxuICAgICAgICAgIHt9KVxuICAgICAgfSxcbiAgICAgIHNhdmVGb2N1czogKCkgPT4geyB0aGlzLl9wcmV2aW91c0ZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNGb2N1cy5mb2N1cygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJHJlZnMucm9vdCxcbiAgICAgIGZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLnJvb3QuZm9jdXMoKSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IHRoaXMuaXRlbXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6IChpbmRleCkgPT4gdGhpcy5pdGVtc1tpbmRleF0uZm9jdXMoKSxcbiAgICAgIGlzUnRsOiAoKSA9PiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMucm9vdClcbiAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogKG9yaWdpbikgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdHlsZXMsIGAke2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZSh3aW5kb3cpfS1vcmlnaW5gLCBvcmlnaW4pXG4gICAgICB9LFxuICAgICAgc2V0UG9zaXRpb246IChwb3NpdGlvbikgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdHlsZXMsJ2xlZnQnLCBwb3NpdGlvbi5sZWZ0KVxuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdHlsZXMsJ3JpZ2h0JywgcG9zaXRpb24ucmlnaHQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywndG9wJywgcG9zaXRpb24udG9wKVxuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdHlsZXMsJ2JvdHRvbScsIHBvc2l0aW9uLmJvdHRvbSlcbiAgICAgIH0sXG4gICAgICBzZXRNYXhIZWlnaHQ6IChoZWlnaHQpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCdtYXgtaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgfSxcbiAgICAgIHNldEF0dHJGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGF0dHIsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBybUF0dHJGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGF0dHIpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBybUNsYXNzRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICByZWZyZXNoSXRlbXMoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IG51bGxcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bGkgY2xhc3M9XCJtZGMtbWVudS1pdGVtIG1kYy1saXN0LWl0ZW1cIiByb2xlPVwibWVudWl0ZW1cIiBcbiAgICA6dGFiaW5kZXg9XCJkaXNhYmxlZD8nLTEnOicwJ1wiXG4gICAgOmFyaWEtZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1pdGVtJyxcbiAgcHJvcHM6IHtcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIHJvbGU9XCJzZXBhcmF0b3JcIiBjbGFzcz1cIm1kYy1tZW51LWRpdmlkZXIgbWRjLWxpc3QtZGl2aWRlclwiPjwvbGk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtZGl2aWRlcicsXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbjxkaXYgY2xhc3M9XCJtZGMtbWVudS1hbmNob3JcIj5cbiAgPHNsb3Q+XG4gIDwvc2xvdD5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51LWFuY2hvcicsXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNNZW51IGZyb20gJy4vbWRjLW1lbnUudnVlJ1xuaW1wb3J0IG1kY01lbnVJdGVtIGZyb20gJy4vbWRjLW1lbnUtaXRlbS52dWUnXG5pbXBvcnQgbWRjTWVudURpdmlkZXIgZnJvbSAnLi9tZGMtbWVudS1kaXZpZGVyLnZ1ZSdcbmltcG9ydCBtZGNNZW51QW5jaG9yIGZyb20gJy4vbWRjLW1lbnUtYW5jaG9yLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjTWVudSxcbiAgbWRjTWVudUl0ZW0sXG4gIG1kY01lbnVEaXZpZGVyLFxuICBtZGNNZW51QW5jaG9yXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNNZW51LFxuICBtZGNNZW51SXRlbSxcbiAgbWRjTWVudURpdmlkZXIsXG4gIG1kY01lbnVBbmNob3Jcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgUmFkaW8uIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JhZGlvQWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEByZXR1cm4geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9ICovXG4gIGdldE5hdGl2ZUNvbnRyb2woKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSYWRpb0FkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUjogJy5tZGMtcmFkaW9fX25hdGl2ZS1jb250cm9sJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1yYWRpbycsXG4gIERJU0FCTEVEOiAnbWRjLXJhZGlvLS1kaXNhYmxlZCcsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuaW1wb3J0IE1EQ1JhZGlvQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1JhZGlvQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JhZGlvRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1JhZGlvQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDUmFkaW9BZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldE5hdGl2ZUNvbnRyb2w6ICgpID0+IC8qICFNRENTZWxlY3Rpb25Db250cm9sU3RhdGUgKi8ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNDaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWQgKi9cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5kaXNhYmxlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkICovXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ1JhZGlvRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRElTQUJMRUQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlQ29udHJvbF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpIHx8IHtcbiAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSYWRpb0ZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG48ZGl2IDpjbGFzcz1cImZvcm1GaWVsZENsYXNzZXNcIiBjbGFzcz1cIm1kYy1yYWRpby13cmFwcGVyXCI+XG4gIDxkaXYgcmVmPVwicm9vdFwiIGNsYXNzPVwibWRjLXJhZGlvXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiPlxuICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiByZWY9XCJjb250cm9sXCIgOmlkPVwiX3VpZFwiIDpuYW1lPVwibmFtZVwiIFxuICAgICAgY2xhc3M9XCJtZGMtcmFkaW9fX25hdGl2ZS1jb250cm9sXCIgQGNoYW5nZT1cInN5bmNcIj5cbiAgXG4gICAgPGRpdiByZWY9XCJsYWJlbFwiIGNsYXNzPVwibWRjLXJhZGlvX19iYWNrZ3JvdW5kXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXJhZGlvX19vdXRlci1jaXJjbGVcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX2lubmVyLWNpcmNsZVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgPGxhYmVsIHJlZj1cImxhYmVsXCIgOmZvcj1cIl91aWRcIj48c2xvdD57e2xhYmVsfX08L3Nsb3Q+PC9sYWJlbD5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENSYWRpb0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3JhZGlvL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHtEaXNwYXRjaEZvY3VzTWl4aW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcmFkaW8nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdwaWNrZWQnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgICduYW1lJzoge3R5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWV9LFxuICAgICd2YWx1ZSc6IFN0cmluZyxcbiAgICAncGlja2VkJzogU3RyaW5nLFxuICAgICdjaGVja2VkJzogQm9vbGVhbixcbiAgICAnbGFiZWwnOiBTdHJpbmcsXG4gICAgJ2FsaWduLWVuZCc6IEJvb2xlYW4sXG4gICAgJ2Rpc2FibGVkJzogQm9vbGVhbixcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGZvcm1GaWVsZENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkJzogdGhpcy5sYWJlbCxcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiB0aGlzLmxhYmVsICYmIHRoaXMuYWxpZ25FbmRcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIC8vIGFkZCBmb3VuZGF0aW9uXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1JhZGlvRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gdGhpcy4kcmVmcy5jb250cm9sXG4gICAgfSlcblxuICAgIC8vIGFkZCByaXBwbGVcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3JtRmllbGQgPSBuZXcgTURDRm9ybUZpZWxkRm91bmRhdGlvbih7XG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5hY3RpdmF0ZSgpXG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlYWN0aXZhdGUoKVxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgICB0aGlzLmZvcm1GaWVsZC5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlID8gdGhpcy52YWx1ZSA6IHRoaXMubGFiZWwpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQodGhpcy5jaGVja2VkIHx8IHRoaXMucGlja2VkID09IHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKVxuXG4gICAgLy8gcmVmcmVzaCBtb2RlbFxuICAgIHRoaXMuY2hlY2tlZCAmJiB0aGlzLnN5bmMoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvcm1GaWVsZC5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZGlzYWJsZWQgKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodmFsdWUpXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaXNDaGVja2VkICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uaXNDaGVja2VkKClcbiAgICB9LFxuICAgIHN5bmMgKCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNSYWRpbyBmcm9tICcuL21kYy1yYWRpby52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1JhZGlvXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNSYWRpb1xufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlbGVjdCByZWY9XCJyb290XCIgY2xhc3M9XCJtZGMtc2VsZWN0IG1kYy1uYXRpdmUtc2VsZWN0XCIgXG4gICAgdi1tb2RlbD1cInNlbGVjdGVkXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIlxuICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXG4gID5cbiAgICA8b3B0aW9uIGRpc2FibGVkIHZhbHVlPVwiXCIgdi1pZj1cImxhYmVsXCI+e3sgbGFiZWwgfX08L29wdGlvbj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvc2VsZWN0PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1uYXRpdmUtc2VsZWN0JyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZ1xuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWQ6IHRoaXMudmFsdWVcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZSAoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLnNlbGVjdGVkKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEJPVFRPTV9MSU5FOiAnbWRjLXNlbGVjdF9fYm90dG9tLWxpbmUnLFxuICBCT1RUT01fTElORV9BQ1RJVkU6ICdtZGMtc2VsZWN0X19ib3R0b20tbGluZS0tYWN0aXZlJyxcbiAgQk9YOiAnbWRjLXNlbGVjdC0tYm94JyxcbiAgRElTQUJMRUQ6ICdtZGMtc2VsZWN0LS1kaXNhYmxlZCcsXG4gIE9QRU46ICdtZGMtc2VsZWN0LS1vcGVuJyxcbiAgUk9PVDogJ21kYy1zZWxlY3QnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1zZWxlY3Qtc2Nyb2xsLWxvY2snLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIENIQU5HRV9FVkVOVDogJ01EQ1NlbGVjdDpjaGFuZ2UnLFxuICBCT1RUT01fTElORV9TRUxFQ1RPUjogJy5tZGMtc2VsZWN0X19ib3R0b20tbGluZScsXG4gIExBQkVMX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX2xhYmVsJyxcbiAgTUVOVV9TRUxFQ1RPUjogJy5tZGMtc2VsZWN0X19tZW51JyxcbiAgU1VSRkFDRV9TRUxFQ1RPUjogJy5tZGMtc2VsZWN0X19zdXJmYWNlJyxcbiAgU0VMRUNURURfVEVYVF9TRUxFQ1RPUjogJy5tZGMtc2VsZWN0X19zZWxlY3RlZC10ZXh0Jyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHtnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWV9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge01EQ01lbnVGb3VuZGF0aW9uLCBBbmNob3JNYXJnaW59IGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQge0Nvcm5lciwgQ29ybmVyQml0fSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMgTURDQ29tcG9uZW50PCFNRENNZW51Rm91bmRhdGlvbj5cbiAqL1xuY2xhc3MgTURDTWVudSBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKiBAcGFyYW0gey4uLj99IGFyZ3MgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIC8qKiBAcHJpdmF0ZSB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5wcmV2aW91c0ZvY3VzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSByb290XG4gICAqIEByZXR1cm4geyFNRENNZW51fVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IE1EQ01lbnUocm9vdCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgZ2V0IG9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uaXNPcGVuKCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuICBzZXQgb3Blbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uXy5vcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbl8uY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHt7Zm9jdXNJbmRleDogP251bWJlcn09fSBvcHRpb25zICovXG4gIHNob3coe2ZvY3VzSW5kZXggPSBudWxsfSA9IHt9KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5vcGVuKHtmb2N1c0luZGV4OiBmb2N1c0luZGV4fSk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIERlZmF1bHQgYW5jaG9yIGNvcm5lciBhbGlnbm1lbnQgb2YgdG9wLWxlZnRcbiAgICogICAgIG1lbnUgY29ybmVyLlxuICAgKi9cbiAgc2V0QW5jaG9yQ29ybmVyKGNvcm5lcikge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0QW5jaG9yQ29ybmVyKGNvcm5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBbmNob3JNYXJnaW59IG1hcmdpblxuICAgKi9cbiAgc2V0QW5jaG9yTWFyZ2luKG1hcmdpbikge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0QW5jaG9yTWFyZ2luKG1hcmdpbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpdGVtIGNvbnRhaW5lciBlbGVtZW50IGluc2lkZSB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/RWxlbWVudH1cbiAgICovXG4gIGdldCBpdGVtc0NvbnRhaW5lcl8oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvcihNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLklURU1TX1NFTEVDVE9SKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGl0ZW1zIHdpdGhpbiB0aGUgbWVudS4gTm90ZSB0aGF0IHRoaXMgb25seSBjb250YWlucyB0aGUgc2V0IG9mIGVsZW1lbnRzIHdpdGhpblxuICAgKiB0aGUgaXRlbXMgY29udGFpbmVyIHRoYXQgYXJlIHByb3BlciBsaXN0IGl0ZW1zLCBhbmQgbm90IHN1cHBsZW1lbnRhbCAvIHByZXNlbnRhdGlvbmFsIERPTVxuICAgKiBlbGVtZW50cy5cbiAgICogQHJldHVybiB7IUFycmF5PCFFbGVtZW50Pn1cbiAgICovXG4gIGdldCBpdGVtcygpIHtcbiAgICBjb25zdCB7aXRlbXNDb250YWluZXJfOiBpdGVtc0NvbnRhaW5lcn0gPSB0aGlzO1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGl0ZW1zQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZGMtbGlzdC1pdGVtW3JvbGVdJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaXRlbSB3aXRoaW4gdGhlIG1lbnUgdGhhdCBpcyBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4gez9FbGVtZW50fVxuICAgKi9cbiAgZ2V0T3B0aW9uQnlJbmRleChpbmRleCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcblxuICAgIGlmIChpbmRleCA8IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IGluZGV4ICovXG4gIHNldCBzZWxlY3RlZEl0ZW1JbmRleChpbmRleCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0U2VsZWN0ZWRJbmRleChpbmRleCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXQgc2VsZWN0ZWRJdGVtSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbl8uZ2V0U2VsZWN0ZWRJbmRleCgpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IWJvb2xlYW59IHJlbWVtYmVyU2VsZWN0aW9uICovXG4gIHNldCByZW1lbWJlclNlbGVjdGlvbihyZW1lbWJlclNlbGVjdGlvbikge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0UmVtZW1iZXJTZWxlY3Rpb24ocmVtZW1iZXJTZWxlY3Rpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gcXVpY2tPcGVuICovXG4gIHNldCBxdWlja09wZW4ocXVpY2tPcGVuKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRRdWlja09wZW4ocXVpY2tPcGVuKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDTWVudUZvdW5kYXRpb259ICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDTWVudUZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgaGFzQ2xhc3M6IChjbGFzc05hbWUpID0+IHRoaXMucm9vdF8uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IEJvb2xlYW4odGhpcy5pdGVtc0NvbnRhaW5lcl8pLFxuICAgICAgZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQ6ICh0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpID0+IHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSksXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+IHtcbiAgICAgICAgY29uc3Qge2l0ZW1zQ29udGFpbmVyXzogaXRlbXNDb250YWluZXJ9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHt3aWR0aDogaXRlbXNDb250YWluZXIub2Zmc2V0V2lkdGgsIGhlaWdodDogaXRlbXNDb250YWluZXIub2Zmc2V0SGVpZ2h0fTtcbiAgICAgIH0sXG4gICAgICBoYXNBbmNob3I6ICgpID0+IHRoaXMucm9vdF8ucGFyZW50RWxlbWVudCAmJiB0aGlzLnJvb3RfLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZGMtbWVudS1hbmNob3InKSxcbiAgICAgIGdldEFuY2hvckRpbWVuc2lvbnM6ICgpID0+IHRoaXMucm9vdF8ucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdldFdpbmRvd0RpbWVuc2lvbnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHt3aWR0aDogd2luZG93LmlubmVyV2lkdGgsIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0fTtcbiAgICAgIH0sXG4gICAgICBnZXROdW1iZXJPZkl0ZW1zOiAoKSA9PiB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4gdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKGhhbmRsZXIpID0+IGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyOiAoaGFuZGxlcikgPT4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldDogKHRhcmdldCkgPT4gdGhpcy5pdGVtcy5pbmRleE9mKHRhcmdldCksXG4gICAgICBub3RpZnlTZWxlY3RlZDogKGV2dERhdGEpID0+IHRoaXMuZW1pdChNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULCB7XG4gICAgICAgIGluZGV4OiBldnREYXRhLmluZGV4LFxuICAgICAgICBpdGVtOiB0aGlzLml0ZW1zW2V2dERhdGEuaW5kZXhdLFxuICAgICAgfSksXG4gICAgICBub3RpZnlDYW5jZWw6ICgpID0+IHRoaXMuZW1pdChNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLkNBTkNFTF9FVkVOVCwge30pLFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJldmlvdXNGb2N1c18gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHJlc3RvcmVGb2N1czogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91c0ZvY3VzXykge1xuICAgICAgICAgIHRoaXMucHJldmlvdXNGb2N1c18uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5yb290XyxcbiAgICAgIGZvY3VzOiAoKSA9PiB0aGlzLnJvb3RfLmZvY3VzKCksXG4gICAgICBnZXRGb2N1c2VkSXRlbUluZGV4OiAoKSA9PiB0aGlzLml0ZW1zLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCksXG4gICAgICBmb2N1c0l0ZW1BdEluZGV4OiAoaW5kZXgpID0+IHRoaXMuaXRlbXNbaW5kZXhdLmZvY3VzKCksXG4gICAgICBpc1J0bDogKCkgPT4gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnJvb3RfKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXG4gICAgICBzZXRUcmFuc2Zvcm1PcmlnaW46IChvcmlnaW4pID0+IHtcbiAgICAgICAgdGhpcy5yb290Xy5zdHlsZVtgJHtnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUod2luZG93KX0tb3JpZ2luYF0gPSBvcmlnaW47XG4gICAgICB9LFxuICAgICAgc2V0UG9zaXRpb246IChwb3NpdGlvbikgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlLmxlZnQgPSAnbGVmdCcgaW4gcG9zaXRpb24gPyBwb3NpdGlvbi5sZWZ0IDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290Xy5zdHlsZS5yaWdodCA9ICdyaWdodCcgaW4gcG9zaXRpb24gPyBwb3NpdGlvbi5yaWdodCA6IG51bGw7XG4gICAgICAgIHRoaXMucm9vdF8uc3R5bGUudG9wID0gJ3RvcCcgaW4gcG9zaXRpb24gPyBwb3NpdGlvbi50b3AgOiBudWxsO1xuICAgICAgICB0aGlzLnJvb3RfLnN0eWxlLmJvdHRvbSA9ICdib3R0b20nIGluIHBvc2l0aW9uID8gcG9zaXRpb24uYm90dG9tIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBzZXRNYXhIZWlnaHQ6IChoZWlnaHQpID0+IHtcbiAgICAgICAgdGhpcy5yb290Xy5zdHlsZS5tYXhIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9LFxuICAgICAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0ciwgdmFsdWUpID0+IHRoaXMuaXRlbXNbaW5kZXhdLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXG4gICAgICBybUF0dHJGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGF0dHIpID0+IHRoaXMuaXRlbXNbaW5kZXhdLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSxcbiAgICAgIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHRoaXMuaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJtQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGNsYXNzTmFtZSkgPT4gdGhpcy5pdGVtc1tpbmRleF0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7TURDTWVudUZvdW5kYXRpb24sIE1EQ01lbnUsIEFuY2hvck1hcmdpbiwgQ29ybmVyLCBDb3JuZXJCaXR9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7TURDTWVudUZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9tZW51L2luZGV4JztcblxuY29uc3QgT1BFTkVSX0tFWVMgPSBbXG4gIHtrZXk6ICdBcnJvd1VwJywga2V5Q29kZTogMzgsIGZvclR5cGU6ICdrZXlkb3duJ30sXG4gIHtrZXk6ICdBcnJvd0Rvd24nLCBrZXlDb2RlOiA0MCwgZm9yVHlwZTogJ2tleWRvd24nfSxcbiAge2tleTogJ1NwYWNlJywga2V5Q29kZTogMzIsIGZvclR5cGU6ICdrZXl1cCd9LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDU2VsZWN0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZmxvYXRMYWJlbDogKC8qIHZhbHVlOiBib29sZWFuICovKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzVG9Cb3R0b21MaW5lOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3NGcm9tQm90dG9tTGluZTogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldEJvdHRvbUxpbmVBdHRyOiAoLyogYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcm1BdHRyOiAoLyogYXR0cjogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfSAqLyAoe2xlZnQ6IDAsIHRvcDogMH0pLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBmb2N1czogKCkgPT4ge30sXG4gICAgICBtYWtlVGFiYmFibGU6ICgpID0+IHt9LFxuICAgICAgbWFrZVVudGFiYmFibGU6ICgpID0+IHt9LFxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIHNldFN0eWxlOiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY3JlYXRlMmRSZW5kZXJpbmdDb250ZXh0OiAoKSA9PiAvKiB7Zm9udDogc3RyaW5nLCBtZWFzdXJlVGV4dDogKHN0cmluZykgPT4ge3dpZHRoOiBudW1iZXJ9fSAqLyAoe1xuICAgICAgICBmb250OiAnJyxcbiAgICAgICAgbWVhc3VyZVRleHQ6ICgpID0+ICh7d2lkdGg6IDB9KSxcbiAgICAgIH0pLFxuICAgICAgc2V0TWVudUVsU3R5bGU6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRNZW51RWxBdHRyOiAoLyogYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtTWVudUVsQXR0cjogKC8qIGF0dHI6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRNZW51RWxPZmZzZXRIZWlnaHQ6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgb3Blbk1lbnU6ICgvKiBmb2N1c0luZGV4OiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgaXNNZW51T3BlbjogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHNldFNlbGVjdGVkVGV4dENvbnRlbnQ6ICgvKiB0ZXh0Q29udGVudDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldE51bWJlck9mT3B0aW9uczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRUZXh0Rm9yT3B0aW9uQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIGdldFZhbHVlRm9yT3B0aW9uQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIHN0cmluZyAqLyAnJyxcbiAgICAgIHNldEF0dHJGb3JPcHRpb25BdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciwgYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyLCBhdHRyOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0VG9wRm9yT3B0aW9uQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKCkgPT4ge30sXG4gICAgICBnZXRXaW5kb3dJbm5lckhlaWdodDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NlbGVjdEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLmN0eF8gPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSAtMTtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gMDtcblxuICAgIHRoaXMuZGlzcGxheUhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNNZW51T3BlbigpKSB7XG4gICAgICAgIHRoaXMub3Blbl8oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGlzcGxheVZpYUtleWJvYXJkSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURpc3BsYXlWaWFLZXlib2FyZF8oZXZ0KTtcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXJfID0gKHtkZXRhaWx9KSA9PiB7XG4gICAgICBjb25zdCB7aW5kZXh9ID0gZGV0YWlsO1xuXG4gICAgICBpZiAoaW5kZXggIT09IHRoaXMuc2VsZWN0ZWRJbmRleF8pIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KGluZGV4KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2VfKCk7XG4gICAgfTtcbiAgICB0aGlzLmNhbmNlbEhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZV8oKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXhfID09PSAtMSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuY3R4XyA9IHRoaXMuYWRhcHRlcl8uY3JlYXRlMmRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmRpc3BsYXlIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMuZGlzcGxheVZpYUtleWJvYXJkSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kaXNwbGF5VmlhS2V5Ym9hcmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3Rlck1lbnVJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULCB0aGlzLnNlbGVjdGlvbkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULCB0aGlzLmNhbmNlbEhhbmRsZXJfKTtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBEcm9wIHJlZmVyZW5jZSB0byBjb250ZXh0IG9iamVjdCB0byBwcmV2ZW50IHBvdGVudGlhbCBsZWFrc1xuICAgIHRoaXMuY3R4XyA9IG51bGw7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaXNwbGF5SGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMuZGlzcGxheVZpYUtleWJvYXJkSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRpc3BsYXlWaWFLZXlib2FyZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwgdGhpcy5zZWxlY3Rpb25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlcihcbiAgICAgIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuQ0FOQ0VMX0VWRU5ULCB0aGlzLmNhbmNlbEhhbmRsZXJfKTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXhfID49IDAgPyB0aGlzLmFkYXB0ZXJfLmdldFZhbHVlRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfKSA6ICcnO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgfVxuXG4gIHNldFNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBwcmV2U2VsZWN0ZWRJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleF87XG4gICAgaWYgKHByZXZTZWxlY3RlZEluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCAnYXJpYS1zZWxlY3RlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZk9wdGlvbnMoKSA/IGluZGV4IDogLTE7XG4gICAgbGV0IHNlbGVjdGVkVGV4dENvbnRlbnQgPSAnJztcbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4XyA+PSAwKSB7XG4gICAgICBzZWxlY3RlZFRleHRDb250ZW50ID0gdGhpcy5hZGFwdGVyXy5nZXRUZXh0Rm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfKS50cmltKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJGb3JPcHRpb25BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8sICdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICB9XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTZWxlY3RlZFRleHRDb250ZW50KHNlbGVjdGVkVGV4dENvbnRlbnQpO1xuICB9XG5cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhYmxlZF87XG4gIH1cblxuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGNvbnN0IHtESVNBQkxFRH0gPSBNRENTZWxlY3RGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBkaXNhYmxlZDtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubWFrZVVudGFiYmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJtQXR0cignYXJpYS1kaXNhYmxlZCcpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5tYWtlVGFiYmFibGUoKTtcbiAgICB9XG4gIH1cblxuICByZXNpemUoKSB7XG4gICAgY29uc3QgZm9udCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250Jyk7XG4gICAgY29uc3QgbGV0dGVyU3BhY2luZyA9IHBhcnNlRmxvYXQodGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ2xldHRlci1zcGFjaW5nJykpO1xuXG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIHRoaXMuY3R4Xy5mb250ID0gZm9udDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJpbWFyeUZvbnRGYW1pbHkgPSB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnZm9udC1mYW1pbHknKS5zcGxpdCgnLCcpWzBdO1xuICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnZm9udC1zaXplJyk7XG4gICAgICB0aGlzLmN0eF8uZm9udCA9IGAke2ZvbnRTaXplfSAke3ByaW1hcnlGb250RmFtaWx5fWA7XG4gICAgfVxuXG4gICAgbGV0IG1heFRleHRMZW5ndGggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mT3B0aW9ucygpOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBzdXJmYWNlUGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQodGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSwgMTApO1xuICAgICAgY29uc3Qgc3VyZmFjZVBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ3BhZGRpbmctbGVmdCcpLCAxMCk7XG4gICAgICBjb25zdCBzZWxlY3RCb3hBZGRlZFBhZGRpbmcgPSBzdXJmYWNlUGFkZGluZ1JpZ2h0ICsgc3VyZmFjZVBhZGRpbmdMZWZ0O1xuICAgICAgY29uc3QgdHh0ID0gdGhpcy5hZGFwdGVyXy5nZXRUZXh0Rm9yT3B0aW9uQXRJbmRleChpKS50cmltKCk7XG4gICAgICBjb25zdCB7d2lkdGh9ID0gdGhpcy5jdHhfLm1lYXN1cmVUZXh0KHR4dCk7XG4gICAgICBjb25zdCBhZGRlZFNwYWNlID0gbGV0dGVyU3BhY2luZyAqIHR4dC5sZW5ndGg7XG5cbiAgICAgIG1heFRleHRMZW5ndGggPVxuICAgICAgICBNYXRoLm1heChtYXhUZXh0TGVuZ3RoLCBNYXRoLmNlaWwod2lkdGggKyBhZGRlZFNwYWNlICsgc2VsZWN0Qm94QWRkZWRQYWRkaW5nKSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZSgnd2lkdGgnLCBgJHttYXhUZXh0TGVuZ3RofXB4YCk7XG4gIH1cblxuICBvcGVuXygpIHtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgY29uc3Qge09QRU59ID0gTURDU2VsZWN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IGZvY3VzSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXhfIDwgMCA/IDAgOiB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuXG4gICAgdGhpcy5zZXRNZW51U3R5bGVzRm9yT3BlbkF0SW5kZXhfKGZvY3VzSW5kZXgpO1xuICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzVG9Cb3R0b21MaW5lKGNzc0NsYXNzZXMuQk9UVE9NX0xJTkVfQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE9QRU4pO1xuICAgIHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm9wZW5NZW51KGZvY3VzSW5kZXgpO1xuICAgICAgdGhpcy5pc0ZvY3VzZWRfID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldE1lbnVTdHlsZXNGb3JPcGVuQXRJbmRleF8oaW5kZXgpIHtcbiAgICBjb25zdCBpbm5lckhlaWdodCA9IHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93SW5uZXJIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVmdCwgdG9wfSA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZW51RWxBdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZW51RWxTdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xuICAgIGNvbnN0IG1lbnVIZWlnaHQgPSB0aGlzLmFkYXB0ZXJfLmdldE1lbnVFbE9mZnNldEhlaWdodCgpO1xuICAgIGNvbnN0IGl0ZW1PZmZzZXRUb3AgPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFRvcEZvck9wdGlvbkF0SW5kZXgoaW5kZXgpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0TWVudUVsU3R5bGUoJ2Rpc3BsYXknLCAnJyk7XG4gICAgdGhpcy5hZGFwdGVyXy5ybU1lbnVFbEF0dHIoJ2FyaWEtaGlkZGVuJyk7XG5cbiAgICBsZXQgYWRqdXN0ZWRUb3AgPSB0b3AgLSBpdGVtT2Zmc2V0VG9wO1xuICAgIGNvbnN0IG92ZXJmbG93c1RvcCA9IGFkanVzdGVkVG9wIDwgMDtcbiAgICBjb25zdCBvdmVyZmxvd3NCb3R0b20gPSBhZGp1c3RlZFRvcCArIG1lbnVIZWlnaHQgPiBpbm5lckhlaWdodDtcbiAgICBpZiAob3ZlcmZsb3dzVG9wKSB7XG4gICAgICBhZGp1c3RlZFRvcCA9IDA7XG4gICAgfSBlbHNlIGlmIChvdmVyZmxvd3NCb3R0b20pIHtcbiAgICAgIGFkanVzdGVkVG9wID0gTWF0aC5tYXgoMCwgaW5uZXJIZWlnaHQgLSBtZW51SGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZW51RWxTdHlsZSgnbGVmdCcsIGAke2xlZnR9cHhgKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lbnVFbFN0eWxlKCd0b3AnLCBgJHthZGp1c3RlZFRvcH1weGApO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0TWVudUVsU3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBgY2VudGVyICR7aXRlbU9mZnNldFRvcH1weGApO1xuICB9XG5cbiAgY2xvc2VfKCkge1xuICAgIGNvbnN0IHtPUEVOfSA9IE1EQ1NlbGVjdEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE9QRU4pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3NGcm9tQm90dG9tTGluZShjc3NDbGFzc2VzLkJPVFRPTV9MSU5FX0FDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy5mb2N1cygpO1xuICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICB9XG5cbiAgaGFuZGxlRGlzcGxheVZpYUtleWJvYXJkXyhldnQpIHtcbiAgICAvLyBXZSB1c2UgYSBoYXJkLWNvZGVkIDIgaW5zdGVhZCBvZiBFdmVudC5BVF9UQVJHRVQgdG8gYXZvaWQgaGF2aW5nIHRvIHJlZmVyZW5jZSBhIGJyb3dzZXJcbiAgICAvLyBnbG9iYWwuXG4gICAgY29uc3QgRVZFTlRfUEhBU0VfQVRfVEFSR0VUID0gMjtcbiAgICBpZiAoZXZ0LmV2ZW50UGhhc2UgIT09IEVWRU5UX1BIQVNFX0FUX1RBUkdFVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcHJlc3Npbmcgc3BhY2UgZG93biBmcm9tIHNjcm9sbGluZyB0aGUgcGFnZVxuICAgIGNvbnN0IGlzU3BhY2VEb3duID0gZXZ0LnR5cGUgPT09ICdrZXlkb3duJyAmJiAoZXZ0LmtleSA9PT0gJ1NwYWNlJyB8fCBldnQua2V5Q29kZSA9PT0gMzIpO1xuICAgIGlmIChpc1NwYWNlRG93bikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNPcGVuZXJLZXkgPSBPUEVORVJfS0VZUy5zb21lKCh7a2V5LCBrZXlDb2RlLCBmb3JUeXBlfSkgPT4ge1xuICAgICAgcmV0dXJuIGV2dC50eXBlID09PSBmb3JUeXBlICYmIChldnQua2V5ID09PSBrZXkgfHwgZXZ0LmtleUNvZGUgPT09IGtleUNvZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzT3BlbmVyS2V5KSB7XG4gICAgICB0aGlzLmRpc3BsYXlIYW5kbGVyXyhldnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG5cbiAgZW5hYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTZWxlY3QgTGFiZWwuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgU2VsZWN0IGxhYmVsIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTZWxlY3RMYWJlbEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1NlbGVjdExhYmVsQWRhcHRlcjtcbiIsImV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBMQUJFTF9GTE9BVF9BQk9WRTogJ21kYy1zZWxlY3RfX2xhYmVsLS1mbG9hdC1hYm92ZScsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1NlbGVjdExhYmVsQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDU2VsZWN0TGFiZWxBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTZWxlY3RMYWJlbEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDU2VsZWN0TGFiZWxBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdExhYmVsQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1NlbGVjdExhYmVsQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3RMYWJlbEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NlbGVjdExhYmVsRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgbGFiZWwgdG8gZmxvYXQgb3IgZGVmbG9hdCBhcyBuZWNlc3NhcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZCBXaGV0aGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQmFkSW5wdXQgVGhlIGlucHV0J3MgYHZhbGlkaXR5LmJhZElucHV0YCB2YWx1ZS5cbiAgICovXG4gIHN0eWxlRmxvYXQodmFsdWUpIHtcbiAgICBjb25zdCB7TEFCRUxfRkxPQVRfQUJPVkV9ID0gTURDU2VsZWN0TGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKCEhdmFsdWUpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTEFCRUxfRkxPQVRfQUJPVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX0ZMT0FUX0FCT1ZFKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2VsZWN0TGFiZWxGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgY2xhc3M9XCJtZGMtc2VsZWN0IG1kYy1tZW51LXNlbGVjdFwiIFxyXG4gICAgcm9sZT1cImxpc3Rib3hcIiBcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIj5cclxuICAgIDxkaXYgcmVmPVwic3VyZmFjZVwiIGNsYXNzPVwibWRjLXNlbGVjdF9fc3VyZmFjZVwiXHJcbiAgICAgIDpzdHlsZT1cInN1cmZhY2VTdHlsZXNcIiA6dGFiaW5kZXg9XCJ0YWJJbmRleFwiPlxyXG4gICAgICAgIDxkaXYgcmVmPVwibGFiZWxcIiBjbGFzcz1cIm1kYy1zZWxlY3RfX2xhYmVsXCJcclxuICAgICAgICAgIDpjbGFzcz1cImxhYmVsQ2xhc3Nlc1wiXHJcbiAgICAgICAgPnt7bGFiZWx9fTwvZGl2PlxyXG4gICAgICAgIDxkaXYgcmVmPVwic2VsZWN0ZWRDb250ZW50XCIgY2xhc3M9XCJtZGMtc2VsZWN0X19zZWxlY3RlZC10ZXh0XCIgXHJcbiAgICAgICAgPnt7c2VsZWN0ZWRUZXh0Q29udGVudH19PC9kaXY+XHJcbiAgICAgICAgPGRpdiByZWY9XCJib3R0b21MaW5lXCIgY2xhc3M9XCJtZGMtc2VsZWN0X19ib3R0b20tbGluZVwiXHJcbiAgICAgICAgICA6Y2xhc3M9XCJib3R0b21MaW5lQ2xhc3Nlc1wiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8bWRjLW1lbnUgcmVmPVwibWVudVwiIFxyXG4gICAgICBjbGFzcz1cIm1kYy1zZWxlY3RfX21lbnVcIlxyXG4gICAgICBAdXBkYXRlPVwicmVmcmVzaEluZGV4XCI+XHJcbiAgICAgIDxzbG90Pjwvc2xvdD5cclxuICAgIDwvbWRjLW1lbnU+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBtZGNNZW51IH0gZnJvbSAnLi4vbWVudSdcclxuaW1wb3J0IE1EQ1NlbGVjdEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdC9mb3VuZGF0aW9uJ1xyXG5pbXBvcnQgTURDU2VsZWN0TGFiZWxGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zZWxlY3QvbGFiZWwvZm91bmRhdGlvbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLW1lbnUtc2VsZWN0JyxcclxuICBtb2RlbDoge1xyXG4gICAgcHJvcDogJ3ZhbHVlJyxcclxuICAgIGV2ZW50OiAnY2hhbmdlJ1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIG11bHRpcGxlOiBCb29sZWFuLFxyXG4gICAgdmFsdWU6IFtTdHJpbmcsIEFycmF5XSxcclxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxyXG4gICAgbGFiZWw6IFN0cmluZywgXHJcbiAgICBib3g6IEJvb2xlYW5cclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtc2VsZWN0LS1ib3gnOiB0aGlzLmJveFxyXG4gICAgICB9LFxyXG4gICAgICBsYWJlbENsYXNzZXM6IHt9LFxyXG4gICAgICBib3R0b21MaW5lQ2xhc3Nlczoge30sXHJcbiAgICAgIHN1cmZhY2VTdHlsZXM6IHt9LFxyXG4gICAgICB0YWJJbmRleDogMCxcclxuICAgICAgc2VsZWN0ZWRUZXh0Q29udGVudDogJydcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXBvbmVudHM6IHtcclxuICAgICdtZGMtbWVudSc6IG1kY01lbnUgXHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgZGlzYWJsZWQgKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodmFsdWUpXHJcbiAgICB9LFxyXG4gICAgdmFsdWUgKCkge1xyXG4gICAgICB0aGlzLnJlZnJlc2hJbmRleCgpXHJcbiAgICB9LFxyXG4gICAgYm94ICgpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1zZWxlY3QtLWJveCcgLCB0aGlzLmJveClcclxuICAgIH1cclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIHJlZnJlc2hJbmRleCAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmZvdW5kYXRpb24pIHtcclxuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuJHJlZnMubWVudS5pdGVtc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IG9wdGlvblZhbHVlID0gb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSB8fCBvcHRpb25zW2ldLnRleHRDb250ZW50LnRyaW0oKVxyXG4gICAgICAgICAgaWYgKHRoaXMudmFsdWUgPT0gb3B0aW9uVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFNlbGVjdGVkSW5kZXgoaSlcclxuICAgICAgICAgICAgLy9UT0RPOiBNRENGSVggZm9yY2UgZmxvYXQgYWJvdmUgaWYgdmFsdWUgaXMgdmFsaWRcclxuICAgICAgICAgICAgdGhpcy4kc2V0KHRoaXMubGFiZWxDbGFzc2VzLCAnbWRjLXNlbGVjdF9fbGFiZWwtLWZsb2F0LWFib3ZlJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9UT0RPOiBNRENGSVggZm9yY2UgZmxvYXQgYWJvdmUgaWYgdmFsdWUgaXMgdmFsaWRcclxuICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0U2VsZWN0ZWRJbmRleCgtMSlcclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYWJlbENsYXNzZXMsICdtZGMtc2VsZWN0X19sYWJlbC0tZmxvYXQtYWJvdmUnLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpIC8vIFRPRE86IE1EQ0ZJWFxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgbW91bnRlZCAoKSB7XHJcblxyXG4gICAgdGhpcy5sYWJlbEZvdW5kYXRpb24gPSBuZXcgTURDU2VsZWN0TGFiZWxGb3VuZGF0aW9uKHtcclxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMubGFiZWxDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxyXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT5cclxuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSksXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMuZm91bmRhdGlvbiAgPSBuZXcgTURDU2VsZWN0Rm91bmRhdGlvbih7XHJcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PlxyXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXHJcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PlxyXG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXHJcbiAgICAgIGZsb2F0TGFiZWw6ICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLnN0eWxlRmxvYXQodmFsdWUpIFxyXG4gICAgICB9LFxyXG4gICAgICBhZGRDbGFzc1RvQm90dG9tTGluZTogKGNsYXNzTmFtZSkgPT4gXHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuYm90dG9tTGluZUNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXHJcbiAgICAgIHJlbW92ZUNsYXNzRnJvbUJvdHRvbUxpbmU6IChjbGFzc05hbWUpID0+XHJcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuYm90dG9tTGluZUNsYXNzZXMsIGNsYXNzTmFtZSksXHJcbiAgICAgIHNldEJvdHRvbUxpbmVBdHRyOiAoYXR0ciwgdmFsdWUpID0+IFxyXG4gICAgICAgIHRoaXMuJHJlZnMuYm90dG9tTGluZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcclxuICAgICAgcm1BdHRyOiAoYXR0ciwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcclxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5zdXJmYWNlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXHJcbiAgICAgIGZvY3VzOiAoKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMuc3VyZmFjZS5mb2N1cygpLFxyXG4gICAgICBtYWtlVGFiYmFibGU6ICgpID0+IHtcclxuICAgICAgICB0aGlzLnRhYkluZGV4ID0gMFxyXG4gICAgICB9LFxyXG4gICAgICBtYWtlVW50YWJiYWJsZTogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAtMVxyXG4gICAgICB9LFxyXG4gICAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWU6IChwcm9wKSA9PlxyXG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMuc3VyZmFjZSkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKSxcclxuICAgICAgc2V0U3R5bGU6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PlxyXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN1cmZhY2VTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpLFxyXG4gICAgICBjcmVhdGUyZFJlbmRlcmluZ0NvbnRleHQ6ICgpID0+XHJcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKSxcclxuICAgICAgc2V0TWVudUVsU3R5bGU6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS4kZWwuc3R5bGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlLFxyXG4gICAgICBzZXRNZW51RWxBdHRyOiAoYXR0ciwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51LiRlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBybU1lbnVFbEF0dHI6IChhdHRyKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS4kZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpLFxyXG4gICAgICBnZXRNZW51RWxPZmZzZXRIZWlnaHQ6ICgpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51LiRlbC5vZmZzZXRIZWlnaHQsXHJcbiAgICAgIG9wZW5NZW51OiAoZm9jdXNJbmRleCkgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuc2hvdyh7Zm9jdXNJbmRleH0pLFxyXG4gICAgICBpc01lbnVPcGVuOiAoKSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS5pc09wZW4oKSxcclxuICAgICAgc2V0U2VsZWN0ZWRUZXh0Q29udGVudDogKHNlbGVjdGVkVGV4dENvbnRlbnQpID0+IHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkVGV4dENvbnRlbnQgPSBzZWxlY3RlZFRleHRDb250ZW50XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldE51bWJlck9mT3B0aW9uczogKCkgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuaXRlbXMubGVuZ3RoLFxyXG4gICAgICBnZXRUZXh0Rm9yT3B0aW9uQXRJbmRleDogKGluZGV4KSA9PlxyXG4gICAgICAgIHRoaXMuJHJlZnMubWVudS5pdGVtc1tpbmRleF0udGV4dENvbnRlbnQudHJpbSgpLFxyXG4gICAgICBnZXRWYWx1ZUZvck9wdGlvbkF0SW5kZXg6IChpbmRleCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLm1lbnUuaXRlbXNbaW5kZXhdLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpIFxyXG4gICAgICAgICAgfHwgdGhpcy4kcmVmcy5tZW51Lml0ZW1zW2luZGV4XS50ZXh0Q29udGVudC50cmltKClcclxuICAgICAgfSxcclxuICAgICAgc2V0QXR0ckZvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgYXR0ciwgdmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51Lml0ZW1zW2luZGV4XS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBybUF0dHJGb3JPcHRpb25BdEluZGV4OiAoaW5kZXgsIGF0dHIpID0+XHJcbiAgICAgICAgdGhpcy4kcmVmcy5tZW51Lml0ZW1zW2luZGV4XS5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXHJcbiAgICAgIGdldE9mZnNldFRvcEZvck9wdGlvbkF0SW5kZXg6IChpbmRleCkgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuaXRlbXNbaW5kZXhdLm9mZnNldFRvcCxcclxuICAgICAgcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuJGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXHJcbiAgICAgIGRlcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cclxuICAgICAgICB0aGlzLiRyZWZzLm1lbnUuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXHJcbiAgICAgIG5vdGlmeUNoYW5nZTogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKVxyXG4gICAgICB9LFxyXG4gICAgICBnZXRXaW5kb3dJbm5lckhlaWdodDogKCkgPT4gd2luZG93LmlubmVySGVpZ2h0LFxyXG4gICAgICBhZGRCb2R5Q2xhc3M6IChjbGFzc05hbWUpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxyXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IChjbGFzc05hbWUpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxyXG4gICAgfSlcclxuXHJcblxyXG4gICAgLy9UT0RPOiBNRENGSVhcclxuICAgIGxldCBmb3VuZGF0aW9uID0gdGhpcy5mb3VuZGF0aW9uXHJcbiAgICBmb3VuZGF0aW9uLnJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGZvbnQgPSBmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnZm9udCcpO1xyXG4gICAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gcGFyc2VGbG9hdChmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnbGV0dGVyLXNwYWNpbmcnKSk7XHJcblxyXG4gICAgICBpZiAoZm9udCkge1xyXG4gICAgICAgIGZvdW5kYXRpb24uY3R4Xy5mb250ID0gZm9udDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBwcmltYXJ5Rm9udEZhbWlseSA9IGZvdW5kYXRpb24uYWRhcHRlcl8uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCdmb250LWZhbWlseScpLnNwbGl0KCcsJylbMF07XHJcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnZm9udC1zaXplJyk7XHJcbiAgICAgICAgZm91bmRhdGlvbi5jdHhfLmZvbnQgPSBgJHtmb250U2l6ZX0gJHtwcmltYXJ5Rm9udEZhbWlseX1gO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgbWF4VGV4dExlbmd0aCA9IDA7XHJcblxyXG4gICAgICBjb25zdCBzdXJmYWNlUGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoZm91bmRhdGlvbi5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSwgMTApO1xyXG4gICAgICBjb25zdCBzdXJmYWNlUGFkZGluZ0xlZnQgPSBwYXJzZUludChmb3VuZGF0aW9uLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksIDEwKTtcclxuICAgICAgY29uc3Qgc2VsZWN0Qm94QWRkZWRQYWRkaW5nID0gc3VyZmFjZVBhZGRpbmdSaWdodCArIHN1cmZhY2VQYWRkaW5nTGVmdDtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZm91bmRhdGlvbi5hZGFwdGVyXy5nZXROdW1iZXJPZk9wdGlvbnMoKTsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHR4dCA9IGZvdW5kYXRpb24uYWRhcHRlcl8uZ2V0VGV4dEZvck9wdGlvbkF0SW5kZXgoaSkudHJpbSgpO1xyXG4gICAgICAgIGNvbnN0IHt3aWR0aH0gPSBmb3VuZGF0aW9uLmN0eF8ubWVhc3VyZVRleHQodHh0KTtcclxuICAgICAgICBjb25zdCBhZGRlZFNwYWNlID0gbGV0dGVyU3BhY2luZyAqIHR4dC5sZW5ndGg7XHJcblxyXG4gICAgICAgIG1heFRleHRMZW5ndGggPVxyXG4gICAgICAgICAgTWF0aC5tYXgobWF4VGV4dExlbmd0aCwgTWF0aC5jZWlsKHdpZHRoICsgYWRkZWRTcGFjZSArIHNlbGVjdEJveEFkZGVkUGFkZGluZykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsYWJlbFR4dCA9IHRoaXMubGFiZWw7XHJcbiAgICAgIGNvbnN0IHt3aWR0aH0gPSBmb3VuZGF0aW9uLmN0eF8ubWVhc3VyZVRleHQobGFiZWxUeHQpO1xyXG4gICAgICBjb25zdCBhZGRlZFNwYWNlID0gbGV0dGVyU3BhY2luZyAqIGxhYmVsVHh0Lmxlbmd0aDtcclxuXHJcbiAgICAgIG1heFRleHRMZW5ndGggPVxyXG4gICAgICAgIE1hdGgubWF4KG1heFRleHRMZW5ndGgsIE1hdGguY2VpbCh3aWR0aCArIGFkZGVkU3BhY2UgKyBzZWxlY3RCb3hBZGRlZFBhZGRpbmcpKTtcclxuXHJcblxyXG4gICAgICBmb3VuZGF0aW9uLmFkYXB0ZXJfLnNldFN0eWxlKCd3aWR0aCcsIGAke21heFRleHRMZW5ndGh9cHhgKTtcclxuICAgIH1cclxuICAgIC8vLyBcclxuICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLmluaXQoKVxyXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxyXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXHJcbiAgICB0aGlzLnJlZnJlc2hJbmRleCAoKVxyXG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKSB7XHJcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICBsZXQgZm91bmRhdGlvbiA9IHRoaXMuZm91bmRhdGlvblxyXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxyXG4gICAgZm91bmRhdGlvbi5kZXN0cm95KClcclxuICAgIFxyXG4gICAgbGV0IGZvdW5kYXRpb25MYWJlbCA9IHRoaXMuZm91bmRhdGlvbkxhYmVsXHJcbiAgICB0aGlzLmZvdW5kYXRpb25MYWJlbCA9IG51bGxcclxuICAgIGZvdW5kYXRpb25MYWJlbC5kZXN0cm95KClcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VsZWN0IDptdWx0aXBsZT1cIm11bHRpcGxlXCIgIHJlZj1cInJvb3RcIiB2LW1vZGVsPVwic2VsZWN0ZWRcIiBcclxuICAgIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgIDpzdHlsZT1cInN0eWxlc1wiICBcclxuICAgIGNsYXNzPVwibWRjLXNlbGVjdCBtZGMtbXVsdGktc2VsZWN0IG1kYy1saXN0XCJcclxuICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXHJcbiAgPlxyXG4gICAgPG9wdGdyb3VwIHJlZj1cIm9wdGdyb3VwXCIgY2xhc3M9XCJtZGMtbGlzdC1ncm91cFwiIDpsYWJlbD1cImxhYmVsXCIgdi1pZj1cImxhYmVsXCI+XHJcbiAgICAgICAgPHNsb3Q+PC9zbG90PlxyXG4gICAgPC9vcHRncm91cD5cclxuICAgIDxzbG90IHYtZWxzZT48L3Nsb3Q+XHJcbiAgPC9zZWxlY3Q+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1tdWx0aS1zZWxlY3QnLFxyXG4gIG1vZGVsOiB7XHJcbiAgICBwcm9wOiAndmFsdWUnLFxyXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXHJcbiAgICB2YWx1ZTogW1N0cmluZywgQXJyYXldLFxyXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXHJcbiAgICBsYWJlbDogU3RyaW5nLFxyXG4gICAgbWF4U2l6ZToge1xyXG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxyXG4gICAgICBkZWZhdWx0OiA0XHJcbiAgICB9XHJcbiAgfSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNlbGVjdGVkOiB0aGlzLnZhbHVlLFxyXG4gICAgICBzaXplOiB1bmRlZmluZWQsXHJcbiAgICAgIGNvdW50OiB1bmRlZmluZWRcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBzdHlsZXMgKCkge1xyXG4gICAgICBsZXQgc2Nyb2xsID0gKHRoaXMuY291bnQgPiB0aGlzLnNpemUpXHJcbiAgICAgIGxldCBzaXplID0gNDgqIHRoaXMuc2l6ZSArIChzY3JvbGw/IDAgOiAxNilcclxuXHJcbiAgICAgIGxldCBzdHlsZXMgPSAge1xyXG4gICAgICAgICdoZWlnaHQnOiBzaXplICsgJ3B4JyxcclxuICAgICAgICAnb3ZlcmZsb3cteSc6ICBzY3JvbGwgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nXHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFzY3JvbGwpIHtcclxuICAgICAgICBzdHlsZXNbJ2JhY2tncm91bmQtaW1hZ2UnXSA9ICd1bnNldCdcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3R5bGVzXHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBvbkNoYW5nZSAoKSB7XHJcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuc2VsZWN0ZWQpXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkICgpIHtcclxuICAgIGNvbnN0IHJlZnJlc2hTaXplID0gKCkgPT4ge1xyXG4gICAgICBsZXQgY291bnQgPSB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uLCBvcHRncm91cCcpLmxlbmd0aFxyXG4gICAgICB0aGlzLmNvdW50ID0gY291bnRcclxuICAgICAgbGV0IG1heCA9IE51bWJlcih0aGlzLm1heFNpemUpXHJcbiAgICAgIGlmICh0aGlzLmxhYmVsKSB7XHJcbiAgICAgICAgbWF4ICs9IDFcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNpemUgPSBNYXRoLm1pbihjb3VudCwgbWF4KVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2xvdE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gcmVmcmVzaFNpemUoKSlcclxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pXHJcblxyXG4gICAgcmVmcmVzaFNpemUoKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5kaXNjb25uZWN0KClcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y29tcG9uZW50IDppcz1cInR5cGVcIiA6bXVsdGlwbGU9XCJtdWx0aXBsZVwiXHJcbiAgICA6bGFiZWw9XCJsYWJlbFwiIFxyXG4gICAgOnZhbHVlPVwidmFsdWVcIiBAY2hhbmdlPVwib25DaGFuZ2VcIlxyXG4gICAgdi1iaW5kPVwiJGF0dHJzXCJcclxuICA+XHJcbiAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgPC9jb21wb25lbnQ+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgTURDTmF0aXZlU2VsZWN0IGZyb20gJy4vbWRjLW5hdGl2ZS1zZWxlY3QudnVlJ1xyXG5pbXBvcnQgTURDTWVudVNlbGVjdCBmcm9tICcuL21kYy1tZW51LXNlbGVjdC52dWUnXHJcbmltcG9ydCBNRENNdWx0aVNlbGVjdCBmcm9tICcuL21kYy1tdWx0aS1zZWxlY3QudnVlJ1xyXG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xyXG4gXHJcbmNvbnN0IG1lZGlhID0gbmV3IGNsYXNzIHtcclxuICBnZXQgbW9iaWxlICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9tb2JpbGUgfHwgKHRoaXMuX21vYmlsZSA9XHJcbiAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiA2MDBweCkgYW5kIChwb2ludGVyOiBjb2Fyc2UpJykpXHJcbiAgfVxyXG59KClcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLXNlbGVjdCcsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluXSxcclxuICBtb2RlbDoge1xyXG4gICAgcHJvcDogJ3ZhbHVlJyxcclxuICAgIGV2ZW50OiAnY2hhbmdlJ1xyXG4gIH0sXHJcbiAgcHJvcHM6IHtcclxuICAgIG11bHRpcGxlOiBCb29sZWFuLFxyXG4gICAgdmFsdWU6IFtTdHJpbmcsIEFycmF5XSxcclxuICAgIGxhYmVsOiBTdHJpbmcsXHJcbiAgICBuYXRpdmU6IEJvb2xlYW5cclxuICB9LFxyXG4gIHByb3ZpZGUgKCkge1xyXG4gICAgcmV0dXJuIHttZGNTZWxlY3Q6IHRoaXN9XHJcbiAgfSxcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICAnbWRjLW5hdGl2ZS1zZWxlY3QnOiBNRENOYXRpdmVTZWxlY3QsXHJcbiAgICAnbWRjLW1lbnUtc2VsZWN0JzogTURDTWVudVNlbGVjdCxcclxuICAgICdtZGMtbXVsdGktc2VsZWN0JzogTURDTXVsdGlTZWxlY3RcclxuICB9LFxyXG4gIGRhdGEgKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbW9iaWxlOiAod2luZG93KSA/IG1lZGlhLm1vYmlsZS5tYXRjaGVzIDogdHJ1ZVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIHR5cGUgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/ICdtZGMtbXVsdGktc2VsZWN0J1xyXG4gICAgICAgIDogdGhpcy5tZW51ID8gJ21kYy1tZW51LXNlbGVjdCdcclxuICAgICAgICA6IHRoaXMuaXNOYXRpdmUgPyAnbWRjLW5hdGl2ZS1zZWxlY3QnXHJcbiAgICAgICAgICA6ICdtZGMtbWVudS1zZWxlY3QnXHJcbiAgICB9LFxyXG4gICAgaXNOYXRpdmUgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5uYXRpdmUgfHwgdGhpcy5tdWx0aXBsZSB8fCB0aGlzLm1vYmlsZVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgb25DaGFuZ2UgKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHZhbHVlKVxyXG4gICAgfSxcclxuICAgIHJlZnJlc2hNZWRpYSAoKSB7XHJcbiAgICAgIHRoaXMubW9iaWxlID0gbWVkaWEubW9iaWxlLm1hdGNoZXNcclxuICAgIH1cclxuICB9LFxyXG4gIGJlZm9yZU1vdW50ICgpIHtcclxuICAgIG1lZGlhLm1vYmlsZS5hZGRMaXN0ZW5lcih0aGlzLnJlZnJlc2hNZWRpYSlcclxuICAgIHRoaXMucmVmcmVzaE1lZGlhKClcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xyXG4gICAgbWVkaWEubW9iaWxlLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICAgPG9wdGlvbiA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIDp2YWx1ZT1cInZhbHVlXCIgdi1pZj1cImhhc1ZhbHVlXCJcbiAgICBjbGFzcz1cIm1kYy1vcHRpb24gbWRjLW5hdGl2ZS1vcHRpb25cIj5cbiAgICAgPHNsb3Q+PC9zbG90PlxuICAgPC9vcHRpb24+XG4gICA8b3B0aW9uIDpkaXNhYmxlZD1cImRpc2FibGVkXCIgdi1lbHNlXG4gICAgY2xhc3M9XCJtZGMtb3B0aW9uIG1kYy1uYXRpdmUtb3B0aW9uXCI+XG4gICAgIDxzbG90Pjwvc2xvdD5cbiAgIDwvb3B0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1uYXRpdmUtb3B0aW9uJyxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzVmFsdWUgKCkge1xuICAgICAgcmV0dXJuICEodHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICA8bGkgY2xhc3M9XCJtZGMtb3B0aW9uIG1kYy1tZW51LW9wdGlvbiBtZGMtbGlzdC1pdGVtXCIgXG4gICAgcm9sZT1cIm9wdGlvblwiIFxuICAgIDp0YWJpbmRleD1cImRpc2FibGVkPy0xOjBcIlxuICAgIDphcmlhLWRpc2FibGVkPVwiZGlzYWJsZWRcIlxuICAgIDpkYXRhLXZhbHVlPVwidmFsdWVcIj5cbiAgICAgPHNsb3Q+PC9zbG90PlxuICAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1vcHRpb24nLFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gICA8b3B0aW9uIGNsYXNzPVwibWRjLW9wdGlvbiBtZGMtbXVsdGktb3B0aW9uIG1kYy1saXN0LWl0ZW1cIiBcbiAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIDp2YWx1ZT1cInZhbHVlXCIgdi1pZj1cImhhc1ZhbHVlXCI+XG4gICAgIDxzbG90Pjwvc2xvdD5cbiAgIDwvb3B0aW9uPlxuICAgPG9wdGlvbiBjbGFzcz1cIm1kYy1vcHRpb24gbWRjLW11bHRpLW9wdGlvbiBtZGMtbGlzdC1pdGVtXCIgXG4gICAgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiB2LWVsc2U+XG4gICAgIDxzbG90Pjwvc2xvdD5cbiAgIDwvb3B0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tdWx0aS1vcHRpb24nLFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXNWYWx1ZSAoKSB7XG4gICAgICByZXR1cm4gISh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGNvbXBvbmVudCA6aXM9XCJ0eXBlXCIgOmRpc2FibGVkPVwiZGlzYWJsZWRcIiA6dmFsdWU9dmFsdWU+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2NvbXBvbmVudD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTmF0aXZlT3B0aW9uIGZyb20gJy4vbWRjLW5hdGl2ZS1vcHRpb24udnVlJ1xuaW1wb3J0IE1EQ01lbnVPcHRpb24gZnJvbSAnLi9tZGMtbWVudS1vcHRpb24udnVlJ1xuaW1wb3J0IE1EQ011bHRpT3B0aW9uIGZyb20gJy4vbWRjLW11bHRpLW9wdGlvbi52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1vcHRpb24nLFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfSxcbiAgaW5qZWN0OiBbJ21kY1NlbGVjdCddLFxuICBjb21wb25lbnRzOiB7XG4gICAgJ21kYy1uYXRpdmUtb3B0aW9uJzogTURDTmF0aXZlT3B0aW9uLFxuICAgICdtZGMtbXVsdGktb3B0aW9uJzogTURDTXVsdGlPcHRpb24sXG4gICAgJ21kYy1tZW51LW9wdGlvbic6IE1EQ01lbnVPcHRpb25cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc05hdGl2ZSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNTZWxlY3QuaXNOYXRpdmVcbiAgICB9LFxuICAgIG11bHRpcGxlICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kY1NlbGVjdC5tdWx0aXBsZVxuICAgIH0sXG4gICAgdHlwZSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/ICdtZGMtbXVsdGktb3B0aW9uJ1xuICAgICAgICA6IHRoaXMuaXNOYXRpdmUgPyAnbWRjLW5hdGl2ZS1vcHRpb24nXG4gICAgICAgICAgOiAnbWRjLW1lbnUtb3B0aW9uJ1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU2VsZWN0IGZyb20gJy4vbWRjLXNlbGVjdC52dWUnXG5pbXBvcnQgbWRjT3B0aW9uIGZyb20gJy4vbWRjLW9wdGlvbi52dWUnXG5cblxuZXhwb3J0IHtcbiAgbWRjU2VsZWN0LFxuICBtZGNPcHRpb24sXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTZWxlY3QsXG4gIG1kY09wdGlvbixcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBBQ1RJVkU6ICdtZGMtc2xpZGVyLS1hY3RpdmUnLFxuICBESVNBQkxFRDogJ21kYy1zbGlkZXItLWRpc2FibGVkJyxcbiAgRElTQ1JFVEU6ICdtZGMtc2xpZGVyLS1kaXNjcmV0ZScsXG4gIEZPQ1VTOiAnbWRjLXNsaWRlci0tZm9jdXMnLFxuICBJTl9UUkFOU0lUOiAnbWRjLXNsaWRlci0taW4tdHJhbnNpdCcsXG4gIElTX0RJU0NSRVRFOiAnbWRjLXNsaWRlci0tZGlzY3JldGUnLFxuICBIQVNfVFJBQ0tfTUFSS0VSOiAnbWRjLXNsaWRlci0tZGlzcGxheS1tYXJrZXJzJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVFJBQ0tfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2snLFxuICBUUkFDS19NQVJLRVJfQ09OVEFJTkVSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlci1jb250YWluZXInLFxuICBMQVNUX1RSQUNLX01BUktFUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjay1tYXJrZXI6bGFzdC1jaGlsZCcsXG4gIFRIVU1CX0NPTlRBSU5FUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190aHVtYi1jb250YWluZXInLFxuICBQSU5fVkFMVUVfTUFSS0VSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3Bpbi12YWx1ZS1tYXJrZXInLFxuICBBUklBX1ZBTFVFTUlOOiAnYXJpYS12YWx1ZW1pbicsXG4gIEFSSUFfVkFMVUVNQVg6ICdhcmlhLXZhbHVlbWF4JyxcbiAgQVJJQV9WQUxVRU5PVzogJ2FyaWEtdmFsdWVub3cnLFxuICBBUklBX0RJU0FCTEVEOiAnYXJpYS1kaXNhYmxlZCcsXG4gIFNURVBfREFUQV9BVFRSOiAnZGF0YS1zdGVwJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDU2xpZGVyOmNoYW5nZScsXG4gIElOUFVUX0VWRU5UOiAnTURDU2xpZGVyOmlucHV0Jyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgUEFHRV9GQUNUT1I6IDQsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTbGlkZXIuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgU2xpZGVyIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTbGlkZXJBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjbGFzc05hbWUgZXhpc3RzIGZvciB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyBpZiBhdHRyaWJ1dGUgbmFtZSBleGlzdHMgb24gdGhlIHNsaWRlciBFbGVtZW50LFxuICAgKiBvdGhlcndpc2UgcmV0dXJucyBudWxsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGUobmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyBhdHRyaWJ1dGUgbmFtZSBvbiBzbGlkZXIgRWxlbWVudCB0byB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhdHRyaWJ1dGUgbmFtZSBmcm9tIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUobmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3QgZm9yIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcmV0dXJuIHs/Q2xpZW50UmVjdH1cbiAgICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YWIgaW5kZXggb2YgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFRhYkluZGV4KCkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHRodW1iIGNvbnRhaW5lciBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSB0aHVtYiBjb250YWluZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgYm9keSBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSBib2R5IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIHdpbmRvdyByZXNpemUgZXZlbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIGV2ZW50IE1EQ1NsaWRlcjppbnB1dCBmcm9tIHRoZSByb290XG4gICAqL1xuICBub3RpZnlJbnB1dCgpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIGV2ZW50IE1EQ1NsaWRlcjpjaGFuZ2UgZnJvbSB0aGUgcm9vdFxuICAgKi9cbiAgbm90aWZ5Q2hhbmdlKCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSB0aHVtYiBjb250YWluZXIgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSB0cmFjayBlbGVtZW50IHRvIHRoZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFRyYWNrU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbm5lciB0ZXh0IG9mIHRoZSBwaW4gbWFya2VyIHRvIHRoZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqL1xuICBzZXRNYXJrZXJWYWx1ZSh2YWx1ZSkge31cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgcGFzc2VkIG51bWJlciBvZiB0cmFjayBtYXJrZXJzIHRvIHRoZSB0cmFjayBtYXJrIGNvbnRhaW5lciBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1NYXJrZXJzXG4gICAqL1xuICBhcHBlbmRUcmFja01hcmtlcnMobnVtTWFya2Vycykge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdHJhY2sgbWFya2VycyBmcm9tdCBoZSB0cmFjayBtYXJrIGNvbnRhaW5lciBlbGVtZW50XG4gICAqL1xuICByZW1vdmVUcmFja01hcmtlcnMoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGxhc3QgdHJhY2sgbWFya2VyIHRvIHRoZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGlzIFJUTCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1JUTCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1NsaWRlckFkYXB0ZXI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBNRENTbGlkZXJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5cbmltcG9ydCB7Z2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX0gZnJvbSAnQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleCc7XG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBLRVlfSURTID0ge1xuICBBUlJPV19MRUZUOiAnQXJyb3dMZWZ0JyxcbiAgQVJST1dfUklHSFQ6ICdBcnJvd1JpZ2h0JyxcbiAgQVJST1dfVVA6ICdBcnJvd1VwJyxcbiAgQVJST1dfRE9XTjogJ0Fycm93RG93bicsXG4gIEhPTUU6ICdIb21lJyxcbiAgRU5EOiAnRW5kJyxcbiAgUEFHRV9VUDogJ1BhZ2VVcCcsXG4gIFBBR0VfRE9XTjogJ1BhZ2VEb3duJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgTU9WRV9FVkVOVF9NQVAgPSB7XG4gICdtb3VzZWRvd24nOiAnbW91c2Vtb3ZlJyxcbiAgJ3RvdWNoc3RhcnQnOiAndG91Y2htb3ZlJyxcbiAgJ3BvaW50ZXJkb3duJzogJ3BvaW50ZXJtb3ZlJyxcbn07XG5cbmNvbnN0IERPV05fRVZFTlRTID0gWydtb3VzZWRvd24nLCAncG9pbnRlcmRvd24nLCAndG91Y2hzdGFydCddO1xuY29uc3QgVVBfRVZFTlRTID0gWydtb3VzZXVwJywgJ3BvaW50ZXJ1cCcsICd0b3VjaGVuZCddO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENTbGlkZXJBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDU2xpZGVyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1NsaWRlckFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1NsaWRlckFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldEF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4gLyogc3RyaW5nfG51bGwgKi8gbnVsbCxcbiAgICAgIHNldEF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVBdHRyaWJ1dGU6ICgvKiBuYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyAoe1xuICAgICAgICB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgICB9KSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUlucHV0OiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKCkgPT4ge30sXG4gICAgICBzZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHk6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRUcmFja1N0eWxlUHJvcGVydHk6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRNYXJrZXJWYWx1ZTogKC8qIHZhbHVlOiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgYXBwZW5kVHJhY2tNYXJrZXJzOiAoLyogbnVtTWFya2VyczogbnVtYmVyICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZVRyYWNrTWFya2VyczogKCkgPT4ge30sXG4gICAgICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGlzUlRMOiAoKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgTURDU2xpZGVyRm91bmRhdGlvblxuICAgKiBAcGFyYW0gez9NRENTbGlkZXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTbGlkZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgLyoqIEBwcml2YXRlIHs/Q2xpZW50UmVjdH0gKi9cbiAgICB0aGlzLnJlY3RfID0gbnVsbDtcbiAgICAvLyBXZSBzZXQgdGhpcyB0byBOYU4gc2luY2Ugd2Ugd2FudCBpdCB0byBiZSBhIG51bWJlciwgYnV0IHdlIGNhbid0IHVzZSAnMCcgb3IgJy0xJ1xuICAgIC8vIGJlY2F1c2UgdGhvc2UgY291bGQgYmUgdmFsaWQgdGFiaW5kaWNlcyBzZXQgYnkgdGhlIGNsaWVudCBjb2RlLlxuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSBOYU47XG4gICAgdGhpcy5hY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5pblRyYW5zaXRfID0gZmFsc2U7XG4gICAgdGhpcy5pc0Rpc2NyZXRlXyA9IGZhbHNlO1xuICAgIHRoaXMuaGFzVHJhY2tNYXJrZXJfID0gZmFsc2U7XG4gICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IGZhbHNlO1xuICAgIHRoaXMubWluXyA9IDA7XG4gICAgdGhpcy5tYXhfID0gMTAwO1xuICAgIHRoaXMuc3RlcF8gPSAwO1xuICAgIHRoaXMudmFsdWVfID0gMDtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMucHJldmVudEZvY3VzU3RhdGVfID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVVSUZyYW1lXyA9IDA7XG4gICAgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8gPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZURvd25fKGV2dCk7XG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUtleWRvd25fKGV2dCk7XG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVGb2N1c18oKTtcbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlQmx1cl8oKTtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5pc0Rpc2NyZXRlXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5JU19ESVNDUkVURSk7XG4gICAgdGhpcy5oYXNUcmFja01hcmtlcl8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEFTX1RSQUNLX01BUktFUik7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4gdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXykpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMudGh1bWJDb250YWluZXJQb2ludGVySGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMubGF5b3V0KCk7XG4gICAgLy8gQXQgbGFzdCBzdGVwLCBwcm92aWRlIGEgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlIHRvIGRpc2NyZXRlIHNsaWRlclxuICAgIGlmICh0aGlzLmlzRGlzY3JldGVfICYmIHRoaXMuZ2V0U3RlcCgpID09IDApIHtcbiAgICAgIHRoaXMuc3RlcF8gPSAxO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIERPV05fRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMudGh1bWJDb250YWluZXJQb2ludGVySGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cblxuICBzZXR1cFRyYWNrTWFya2VyKCkge1xuICAgIGlmICh0aGlzLmlzRGlzY3JldGVfICYmIHRoaXMuaGFzVHJhY2tNYXJrZXJfJiYgdGhpcy5nZXRTdGVwKCkgIT0gMCkge1xuICAgICAgY29uc3QgbWluID0gdGhpcy5nZXRNaW4oKTtcbiAgICAgIGNvbnN0IG1heCA9IHRoaXMuZ2V0TWF4KCk7XG4gICAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRTdGVwKCk7XG4gICAgICBsZXQgbnVtTWFya2VycyA9IChtYXggLSBtaW4pIC8gc3RlcDtcblxuICAgICAgLy8gSW4gY2FzZSBkaXN0YW5jZSBiZXR3ZWVuIG1heCAmIG1pbiBpcyBpbmRpdmlzaWJsZSB0byBzdGVwLFxuICAgICAgLy8gd2UgcGxhY2UgdGhlIHNlY29uZGFyeSB0byBsYXN0IG1hcmtlciBwcm9wb3J0aW9uYWxseSBhdCB3aGVyZSB0aHVtYlxuICAgICAgLy8gY291bGQgcmVhY2ggYW5kIHBsYWNlIHRoZSBsYXN0IG1hcmtlciBhdCBtYXggdmFsdWVcbiAgICAgIGNvbnN0IGluZGl2aXNpYmxlID0gTWF0aC5jZWlsKG51bU1hcmtlcnMpICE9PSBudW1NYXJrZXJzO1xuICAgICAgaWYgKGluZGl2aXNpYmxlKSB7XG4gICAgICAgIG51bU1hcmtlcnMgPSBNYXRoLmNlaWwobnVtTWFya2Vycyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlVHJhY2tNYXJrZXJzKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFwcGVuZFRyYWNrTWFya2VycyhudW1NYXJrZXJzKTtcblxuICAgICAgaWYgKGluZGl2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTdGVwUmF0aW8gPSAobWF4IC0gbnVtTWFya2VycyAqIHN0ZXApIC8gc3RlcCArIDE7XG4gICAgICAgIGNvbnN0IGZsZXggPSBnZXRDb3JyZWN0UHJvcGVydHlOYW1lKHdpbmRvdywgJ2ZsZXgnKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eShmbGV4LCBTdHJpbmcobGFzdFN0ZXBSYXRpbykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICB0aGlzLnJlY3RfID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgdGhpcy51cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFZhbHVlXyh2YWx1ZSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TWF4KCkge1xuICAgIHJldHVybiB0aGlzLm1heF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IG1heCAqL1xuICBzZXRNYXgobWF4KSB7XG4gICAgaWYgKG1heCA8IHRoaXMubWluXykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG1heCB0byBiZSBsZXNzIHRoYW4gdGhlIHNsaWRlclxcJ3MgbWluaW11bSB2YWx1ZScpO1xuICAgIH1cbiAgICB0aGlzLm1heF8gPSBtYXg7XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVNQVgsIFN0cmluZyh0aGlzLm1heF8pKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldE1pbigpIHtcbiAgICByZXR1cm4gdGhpcy5taW5fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBtaW4gKi9cbiAgc2V0TWluKG1pbikge1xuICAgIGlmIChtaW4gPiB0aGlzLm1heF8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBtaW4gdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSBzbGlkZXJcXCdzIG1heGltdW0gdmFsdWUnKTtcbiAgICB9XG4gICAgdGhpcy5taW5fID0gbWluO1xuICAgIHRoaXMuc2V0VmFsdWVfKHRoaXMudmFsdWVfLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX1ZBTFVFTUlOLCBTdHJpbmcodGhpcy5taW5fKSk7XG4gICAgdGhpcy5zZXR1cFRyYWNrTWFya2VyKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBzdGVwICovXG4gIHNldFN0ZXAoc3RlcCkge1xuICAgIGlmIChzdGVwIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGVwIGNhbm5vdCBiZSBzZXQgdG8gYSBuZWdhdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgKHR5cGVvZihzdGVwKSAhPT0gJ251bWJlcicgfHwgc3RlcCA8IDEpKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICB9XG4gICAgdGhpcy5zdGVwXyA9IHN0ZXA7XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkICovXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBkaXNhYmxlZDtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzXyhjc3NDbGFzc2VzLkRJU0FCTEVELCB0aGlzLmRpc2FibGVkXyk7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWRfKSB7XG4gICAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJJbmRleCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX0RJU0FCTEVELCAndHJ1ZScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cmlidXRlKHN0cmluZ3MuQVJJQV9ESVNBQkxFRCk7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuc2F2ZWRUYWJJbmRleF8pKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIFN0cmluZyh0aGlzLnNhdmVkVGFiSW5kZXhfKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBpbnRlcmFjdGluZyB3aXRoIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRG93bl8oZXZ0KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSB0cnVlO1xuICAgIHRoaXMuc2V0SW5UcmFuc2l0XyghdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0Xyk7XG4gICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IGZhbHNlO1xuICAgIHRoaXMuc2V0QWN0aXZlXyh0cnVlKTtcblxuICAgIGNvbnN0IG1vdmVIYW5kbGVyID0gKGV2dCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlXyhldnQpO1xuICAgIH07XG5cbiAgICAvLyBOb3RlOiB1cEhhbmRsZXIgaXMgW2RlXXJlZ2lzdGVyZWQgb24gQUxMIHBvdGVudGlhbCBwb2ludGVyLXJlbGF0ZWQgcmVsZWFzZSBldmVudCB0eXBlcywgc2luY2Ugc29tZSBicm93c2Vyc1xuICAgIC8vIGRvIG5vdCBhbHdheXMgZmlyZSB0aGVzZSBjb25zaXN0ZW50bHkgaW4gcGFpcnMuXG4gICAgLy8gKFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9pc3N1ZXMvMTE5MilcbiAgICBjb25zdCB1cEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVVwXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihNT1ZFX0VWRU5UX01BUFtldnQudHlwZV0sIG1vdmVIYW5kbGVyKTtcbiAgICAgIFVQX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHVwSGFuZGxlcikpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihNT1ZFX0VWRU5UX01BUFtldnQudHlwZV0sIG1vdmVIYW5kbGVyKTtcbiAgICBVUF9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4gdGhpcy5hZGFwdGVyXy5yZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdXBIYW5kbGVyKSk7XG4gICAgdGhpcy5zZXRWYWx1ZUZyb21FdnRfKGV2dCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVNb3ZlXyhldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnNldFZhbHVlRnJvbUV2dF8oZXZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlcidzIGludGVyYWN0aW9uIHdpdGggdGhlIHNsaWRlciBlbmRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVVcF8oKSB7XG4gICAgdGhpcy5zZXRBY3RpdmVfKGZhbHNlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhZ2VYIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBhZ2VYXyhldnQpIHtcbiAgICBpZiAoZXZ0LnRhcmdldFRvdWNoZXMgJiYgZXZ0LnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGV2dC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIH1cbiAgICByZXR1cm4gZXZ0LnBhZ2VYO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNsaWRlciB2YWx1ZSBmcm9tIGFuIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFZhbHVlRnJvbUV2dF8oZXZ0KSB7XG4gICAgY29uc3QgcGFnZVggPSB0aGlzLmdldFBhZ2VYXyhldnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb21wdXRlVmFsdWVGcm9tUGFnZVhfKHBhZ2VYKTtcbiAgICB0aGlzLnNldFZhbHVlXyh2YWx1ZSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG5ldyB2YWx1ZSBmcm9tIHRoZSBwYWdlWCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyhwYWdlWCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbn0gPSB0aGlzO1xuICAgIGNvbnN0IHhQb3MgPSBwYWdlWCAtIHRoaXMucmVjdF8ubGVmdDtcbiAgICBsZXQgcGN0Q29tcGxldGUgPSB4UG9zIC8gdGhpcy5yZWN0Xy53aWR0aDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1JUTCgpKSB7XG4gICAgICBwY3RDb21wbGV0ZSA9IDEgLSBwY3RDb21wbGV0ZTtcbiAgICB9XG4gICAgLy8gRml0IHRoZSBwZXJjZW50YWdlIGNvbXBsZXRlIGJldHdlZW4gdGhlIHJhbmdlIFttaW4sbWF4XVxuICAgIC8vIGJ5IHJlbWFwcGluZyBmcm9tIFswLCAxXSB0byBbbWluLCBtaW4rKG1heC1taW4pXS5cbiAgICByZXR1cm4gbWluICsgcGN0Q29tcGxldGUgKiAobWF4IC0gbWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZUtleWRvd25fKGV2dCkge1xuICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZF8oZXZ0KTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JLZXlJZF8oa2V5SWQpO1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHBhZ2UgZnJvbSBzY3JvbGxpbmcgZHVlIHRvIGtleSBwcmVzc2VzIHRoYXQgd291bGQgbm9ybWFsbHkgc2Nyb2xsIHRoZSBwYWdlXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTKTtcbiAgICB0aGlzLnNldFZhbHVlXyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0ga2JkRXZ0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEtleUlkXyhrYmRFdnQpIHtcbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19MRUZUIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzNykge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfTEVGVDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuQVJST1dfUklHSFQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM5KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19SSUdIVDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuQVJST1dfVVAgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM4KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19VUDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuQVJST1dfRE9XTiB8fCBrYmRFdnQua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX0RPV047XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkhPTUUgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM2KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5IT01FO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5FTkQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM1KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5FTkQ7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLlBBR0VfVVAgfHwga2JkRXZ0LmtleUNvZGUgPT09IDMzKSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5QQUdFX1VQO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5QQUdFX0RPV04gfHwga2JkRXZ0LmtleUNvZGUgPT09IDM0KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5QQUdFX0RPV047XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSB2YWx1ZSBnaXZlbiBhIGtleWJvYXJkIGtleSBJRFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5SWRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VmFsdWVGb3JLZXlJZF8oa2V5SWQpIHtcbiAgICBjb25zdCB7bWF4XzogbWF4LCBtaW5fOiBtaW4sIHN0ZXBfOiBzdGVwfSA9IHRoaXM7XG4gICAgbGV0IGRlbHRhID0gc3RlcCB8fCAobWF4IC0gbWluKSAvIDEwMDtcbiAgICBjb25zdCB2YWx1ZU5lZWRzVG9CZUZsaXBwZWQgPSB0aGlzLmFkYXB0ZXJfLmlzUlRMKCkgJiYgKFxuICAgICAga2V5SWQgPT09IEtFWV9JRFMuQVJST1dfTEVGVCB8fCBrZXlJZCA9PT0gS0VZX0lEUy5BUlJPV19SSUdIVFxuICAgICk7XG4gICAgaWYgKHZhbHVlTmVlZHNUb0JlRmxpcHBlZCkge1xuICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgfVxuXG4gICAgc3dpdGNoIChrZXlJZCkge1xuICAgIGNhc2UgS0VZX0lEUy5BUlJPV19MRUZUOlxuICAgIGNhc2UgS0VZX0lEUy5BUlJPV19ET1dOOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfIC0gZGVsdGE7XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX1JJR0hUOlxuICAgIGNhc2UgS0VZX0lEUy5BUlJPV19VUDpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXyArIGRlbHRhO1xuICAgIGNhc2UgS0VZX0lEUy5IT01FOlxuICAgICAgcmV0dXJuIHRoaXMubWluXztcbiAgICBjYXNlIEtFWV9JRFMuRU5EOlxuICAgICAgcmV0dXJuIHRoaXMubWF4XztcbiAgICBjYXNlIEtFWV9JRFMuUEFHRV9VUDpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXyArIGRlbHRhICogbnVtYmVycy5QQUdFX0ZBQ1RPUjtcbiAgICBjYXNlIEtFWV9JRFMuUEFHRV9ET1dOOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfIC0gZGVsdGEgKiBudW1iZXJzLlBBR0VfRkFDVE9SO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUZvY3VzXygpIHtcbiAgICBpZiAodGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTKTtcbiAgfVxuXG4gIGhhbmRsZUJsdXJfKCkge1xuICAgIHRoaXMucHJldmVudEZvY3VzU3RhdGVfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEZpcmVJbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVxuICAgKi9cbiAgc2V0VmFsdWVfKHZhbHVlLCBzaG91bGRGaXJlSW5wdXQsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMudmFsdWVfICYmICFmb3JjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHttaW5fOiBtaW4sIG1heF86IG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IHZhbHVlU2V0VG9Cb3VuZGFyeSA9IHZhbHVlID09PSBtaW4gfHwgdmFsdWUgPT09IG1heDtcbiAgICBpZiAodGhpcy5zdGVwXyAmJiAhdmFsdWVTZXRUb0JvdW5kYXJ5KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucXVhbnRpemVfKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICB2YWx1ZSA9IG1pbjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICB2YWx1ZSA9IG1heDtcbiAgICB9XG4gICAgdGhpcy52YWx1ZV8gPSB2YWx1ZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVOT1csIFN0cmluZyh0aGlzLnZhbHVlXykpO1xuICAgIHRoaXMudXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCk7XG5cbiAgICBpZiAoc2hvdWxkRmlyZUlucHV0KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUlucHV0KCk7XG4gICAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldE1hcmtlclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcXVhbnRpemVkIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBxdWFudGl6ZV8odmFsdWUpIHtcbiAgICBjb25zdCBudW1TdGVwcyA9IE1hdGgucm91bmQodmFsdWUgLyB0aGlzLnN0ZXBfKTtcbiAgICBjb25zdCBxdWFudGl6ZWRWYWwgPSBudW1TdGVwcyAqIHRoaXMuc3RlcF87XG4gICAgcmV0dXJuIHF1YW50aXplZFZhbDtcbiAgfVxuXG4gIHVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpIHtcbiAgICBjb25zdCB7bWF4XzogbWF4LCBtaW5fOiBtaW4sIHZhbHVlXzogdmFsdWV9ID0gdGhpcztcbiAgICBjb25zdCBwY3RDb21wbGV0ZSA9ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICBsZXQgdHJhbnNsYXRlUHggPSBwY3RDb21wbGV0ZSAqIHRoaXMucmVjdF8ud2lkdGg7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNSVEwoKSkge1xuICAgICAgdHJhbnNsYXRlUHggPSB0aGlzLnJlY3RfLndpZHRoIC0gdHJhbnNsYXRlUHg7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcCA9IGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAndHJhbnNmb3JtJyk7XG4gICAgY29uc3QgdHJhbnNpdGlvbmVuZEV2dE5hbWUgPSBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ3RyYW5zaXRpb25lbmQnKTtcblxuICAgIGlmICh0aGlzLmluVHJhbnNpdF8pIHtcbiAgICAgIGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRJblRyYW5zaXRfKGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHJhbnNpdGlvbmVuZEV2dE5hbWUsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKHRyYW5zaXRpb25lbmRFdnROYW1lLCBvblRyYW5zaXRpb25FbmQpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVUlGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgLy8gTk9URSh0cmF2aXNrYXVmbWFuKTogSXQgd291bGQgYmUgbmljZSB0byB1c2UgY2FsYygpIGhlcmUsXG4gICAgICAvLyBidXQgSUUgY2Fubm90IGhhbmRsZSBjYWxjcyBpbiB0cmFuc2Zvcm1zIGNvcnJlY3RseS5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9nb28uZ2wvTkMyaXRrXG4gICAgICAvLyBBbHNvIG5vdGUgdGhhdCB0aGUgLTUwJSBvZmZzZXQgaXMgdXNlZCB0byBjZW50ZXIgdGhlIHNsaWRlciB0aHVtYi5cbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5KHRyYW5zZm9ybVByb3AsIGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlUHh9cHgpIHRyYW5zbGF0ZVgoLTUwJSlgKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhY2tTdHlsZVByb3BlcnR5KHRyYW5zZm9ybVByb3AsIGBzY2FsZVgoJHtwY3RDb21wbGV0ZX0pYCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmVcbiAgICovXG4gIHNldEFjdGl2ZV8oYWN0aXZlKSB7XG4gICAgdGhpcy5hY3RpdmVfID0gYWN0aXZlO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuQUNUSVZFLCB0aGlzLmFjdGl2ZV8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGluVHJhbnNpdCBzdGF0ZSBvZiB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5UcmFuc2l0XG4gICAqL1xuICBzZXRJblRyYW5zaXRfKGluVHJhbnNpdCkge1xuICAgIHRoaXMuaW5UcmFuc2l0XyA9IGluVHJhbnNpdDtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzXyhjc3NDbGFzc2VzLklOX1RSQU5TSVQsIHRoaXMuaW5UcmFuc2l0Xyk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSBhZGRzIG9yIHJlbW92ZXMgYSBjbGFzcyBiYXNlZCBvbiBzaG91bGRCZVByZXNlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEJlUHJlc2VudFxuICAgKi9cbiAgdG9nZ2xlQ2xhc3NfKGNsYXNzTmFtZSwgc2hvdWxkQmVQcmVzZW50KSB7XG4gICAgaWYgKHNob3VsZEJlUHJlc2VudCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1NsaWRlckZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJzbGlkZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2stY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2tcIiA6c3R5bGU9XCJ0cmFja1N0eWxlc1wiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlci1jb250YWluZXJcIiB2LWlmPVwiaGFzTWFya2Vyc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2stbWFya2VyXCIgXG4gICAgICAgICAgdi1mb3I9XCJtYXJrZXJOdW0gaW4gbnVtTWFya2Vyc1wiXG4gICAgICAgICAgOmtleT1cIm1hcmtlck51bVwiXG4gICAgICAgICAgOnN0eWxlPVwiKG1hcmtlck51bSA9PSBudW1NYXJrZXJzKSA/IGxhc3RUcmFja01hcmtlcnNTdHlsZXMgOiB7fVwiXG4gICAgICAgICAgPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiByZWY9XCJ0aHVtYkNvbnRhaW5lclwiIDpzdHlsZT1cInRodW1iU3R5bGVzXCIgY2xhc3M9XCJtZGMtc2xpZGVyX190aHVtYi1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19waW5cIiB2LWlmPVwiaXNEaXNjcmV0ZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cIm1kYy1zbGlkZXJfX3Bpbi12YWx1ZS1tYXJrZXJcIj57e21hcmtlclZhbHVlfX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxzdmcgY2xhc3M9XCJtZGMtc2xpZGVyX190aHVtYlwiIHdpZHRoPVwiMjFcIiBoZWlnaHQ9XCIyMVwiPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiMTAuNVwiIGN5PVwiMTAuNVwiIHI9XCI3Ljg3NVwiPjwvY2lyY2xlPlxuICAgICAgPC9zdmc+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fZm9jdXMtcmluZ1wiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2xpZGVyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24nXG5pbXBvcnQge0Rpc3BhdGNoRm9jdXNNaXhpbn0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXNsaWRlcicsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3ZhbHVlJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogW051bWJlciwgU3RyaW5nXSxcbiAgICBtaW46IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMCB9LFxuICAgIG1heDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAxMDAgfSxcbiAgICBzdGVwOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDAgfSxcbiAgICBkaXNwbGF5TWFya2VyczogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBsYXlvdXRPbjogU3RyaW5nLFxuICAgIGxheW91dE9uU291cmNlOiB7dHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2V9LFxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXNsaWRlci0tZGlzY3JldGUnOiAhIXRoaXMuc3RlcCxcbiAgICAgICAgJ21kYy1zbGlkZXItLWRpc3BsYXktbWFya2Vycyc6IHRoaXMuZGlzcGxheU1hcmtlcnNcbiAgICAgIH0sXG4gICAgICB0cmFja1N0eWxlczoge30sXG4gICAgICBsYXN0VHJhY2tNYXJrZXJzU3R5bGVzOiB7fSxcbiAgICAgIHRodW1iU3R5bGVzOiB7fSxcbiAgICAgIG1hcmtlclZhbHVlOiAnJyxcbiAgICAgIG51bU1hcmtlcnM6IDBcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNEaXNjcmV0ZSAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXBcbiAgICB9LFxuICAgIGhhc01hcmtlcnMgKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5zdGVwICYmIHRoaXMuZGlzcGxheU1hcmtlcnMgJiYgdGhpcy5udW1NYXJrZXJzXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHZhbHVlICgpIHtcbiAgICAgIGlmICh0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSAhPT0gTnVtYmVyKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlKVxuICAgICAgfVxuICAgIH0sXG4gICAgbWluICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9LFxuICAgIG1heCAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpXG4gICAgfSxcbiAgICBzdGVwICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTdGVwKE51bWJlcih0aGlzLnN0ZXApKVxuICAgIH0sXG4gICAgZGlzYWJsZWQgKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbGF5b3V0ICgpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KClcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDU2xpZGVyRm91bmRhdGlvbih7XG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIGdldEF0dHJpYnV0ZTogKG5hbWUpID0+IHRoaXMuJGVsLmdldEF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIHNldEF0dHJpYnV0ZTogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgcmVtb3ZlQXR0cmlidXRlOiAobmFtZSkgPT4gdGhpcy4kZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpLFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gdGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRUYWJJbmRleDogKCkgPT4gdGhpcy4kZWwudGFiSW5kZXgsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnRodW1iQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUlucHV0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKVxuICAgICAgfSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMudGh1bWJTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgc2V0VHJhY2tTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy50cmFja1N0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRNYXJrZXJWYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMubWFya2VyVmFsdWUgPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIGFwcGVuZFRyYWNrTWFya2VyczogKG51bU1hcmtlcnMpID0+IHtcbiAgICAgICAgdGhpcy5udW1NYXJrZXJzID0gbnVtTWFya2Vyc1xuICAgICAgfSxcbiAgICAgIHJlbW92ZVRyYWNrTWFya2VyczogKCkgPT4ge1xuICAgICAgICB0aGlzLm51bU1hcmtlcnMgPSAwXG4gICAgICB9LFxuICAgICAgc2V0TGFzdFRyYWNrTWFya2Vyc1N0eWxlUHJvcGVydHk6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxhc3RUcmFja01hcmtlcnNTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgaXNSVEw6ICgpID0+IGZhbHNlXG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWluKE51bWJlcih0aGlzLm1pbikpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldE1heChOdW1iZXIodGhpcy5tYXgpKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTdGVwKE51bWJlcih0aGlzLnN0ZXApKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZShOdW1iZXIodGhpcy52YWx1ZSkpXG4gICAgaWYgKHRoaXMuaGFzTWFya2Vycykge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldHVwVHJhY2tNYXJrZXIoKVxuICAgIH1cbiAgICBcbiAgICB0aGlzLiRyb290LiRvbignbWRjOmxheW91dCcsIHRoaXMubGF5b3V0KVxuXG4gICAgaWYgKHRoaXMubGF5b3V0T24pIHtcbiAgICAgIGxldCBzb3VyY2UgPSB0aGlzLmxheW91dE9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHNvdXJjZS4kb24odGhpcy5sYXlvdXRPbiwgdGhpcy5sYXlvdXQpXG4gICAgfVxuICAgIFxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NsaWRlciBmcm9tICcuL21kYy1zbGlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNTbGlkZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1NsaWRlclxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1zbmFja2JhcicsXG4gIFRFWFQ6ICdtZGMtc25hY2tiYXJfX3RleHQnLFxuICBBQ1RJT05fV1JBUFBFUjogJ21kYy1zbmFja2Jhcl9fYWN0aW9uLXdyYXBwZXInLFxuICBBQ1RJT05fQlVUVE9OOiAnbWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uJyxcbiAgQUNUSVZFOiAnbWRjLXNuYWNrYmFyLS1hY3RpdmUnLFxuICBNVUxUSUxJTkU6ICdtZGMtc25hY2tiYXItLW11bHRpbGluZScsXG4gIEFDVElPTl9PTl9CT1RUT006ICdtZGMtc25hY2tiYXItLWFjdGlvbi1vbi1ib3R0b20nLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRFWFRfU0VMRUNUT1I6ICcubWRjLXNuYWNrYmFyX190ZXh0JyxcbiAgQUNUSU9OX1dSQVBQRVJfU0VMRUNUT1I6ICcubWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlcicsXG4gIEFDVElPTl9CVVRUT05fU0VMRUNUT1I6ICcubWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uJyxcbiAgU0hPV19FVkVOVDogJ01EQ1NuYWNrYmFyOnNob3cnLFxuICBISURFX0VWRU5UOiAnTURDU25hY2tiYXI6aGlkZScsXG59O1xuXG5leHBvcnQgY29uc3QgbnVtYmVycyA9IHtcbiAgTUVTU0FHRV9USU1FT1VUOiAyNzUwLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1NuYWNrYmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0QXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICB1bnNldEFyaWFIaWRkZW46ICgpID0+IHt9LFxuICAgICAgc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICB1bnNldEFjdGlvbkFyaWFIaWRkZW46ICgpID0+IHt9LFxuICAgICAgc2V0QWN0aW9uVGV4dDogKC8qIGFjdGlvblRleHQ6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRNZXNzYWdlVGV4dDogKC8qIG1lc3NhZ2U6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRGb2N1czogKCkgPT4ge30sXG4gICAgICB2aXNpYmlsaXR5SXNIaWRkZW46ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICByZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQWN0aW9uQ2xpY2tIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQWN0aW9uQ2xpY2tIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeVNob3c6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5SGlkZTogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlXztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NuYWNrYmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5hY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5hY3Rpb25XYXNDbGlja2VkXyA9IGZhbHNlO1xuICAgIHRoaXMuZGlzbWlzc09uQWN0aW9uXyA9IHRydWU7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5wb2ludGVyRG93blJlY29nbml6ZWRfID0gZmFsc2U7XG4gICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IGZhbHNlO1xuICAgIHRoaXMuc25hY2tiYXJEYXRhXyA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZV8gPSBbXTtcbiAgICB0aGlzLmFjdGlvbkNsaWNrSGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGlvbldhc0NsaWNrZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52b2tlQWN0aW9uXygpO1xuICAgIH07XG4gICAgdGhpcy52aXNpYmlsaXR5Y2hhbmdlSGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICAgIHRoaXMuc25hY2tiYXJIYXNGb2N1c18gPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcl8udmlzaWJpbGl0eUlzSGlkZGVuKCkpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNsZWFudXBfLmJpbmQodGhpcyksIHRoaXMuc25hY2tiYXJEYXRhXy50aW1lb3V0IHx8IG51bWJlcnMuTUVTU0FHRV9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQudHlwZSA9PSAndG91Y2hzdGFydCcgfHwgZXZ0LnR5cGUgPT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyRG93blJlY29nbml6ZWRfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlUG9zc2libGVUYWJLZXlib2FyZEZvY3VzXyhldnQpO1xuXG4gICAgICBpZiAoZXZ0LnR5cGUgPT0gJ2ZvY3VzJykge1xuICAgICAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIodGhpcy5hY3Rpb25DbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEFyaWFIaWRkZW4oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQWN0aW9uQ2xpY2tIYW5kbGVyKHRoaXMuYWN0aW9uQ2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcih0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIodGhpcy52aXNpYmlsaXR5Y2hhbmdlSGFuZGxlcl8pO1xuICAgIFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nLCAnZm9jdXMnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzbWlzc2VzT25BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzbWlzc09uQWN0aW9uXztcbiAgfVxuXG4gIHNldERpc21pc3NPbkFjdGlvbihkaXNtaXNzT25BY3Rpb24pIHtcbiAgICB0aGlzLmRpc21pc3NPbkFjdGlvbl8gPSAhIWRpc21pc3NPbkFjdGlvbjtcbiAgfVxuXG4gIHNob3coZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUGxlYXNlIHByb3ZpZGUgYSBkYXRhIG9iamVjdCB3aXRoIGF0IGxlYXN0IGEgbWVzc2FnZSB0byBkaXNwbGF5LicpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubWVzc2FnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLicpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5hY3Rpb25IYW5kbGVyICYmICFkYXRhLmFjdGlvblRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYWN0aW9uIHRleHQgd2l0aCB0aGUgaGFuZGxlci4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICB0aGlzLnF1ZXVlXy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICB0aGlzLnNuYWNrYmFyRGF0YV8gPSBkYXRhO1xuICAgIHRoaXMuZmlyc3RGb2N1c18gPSB0cnVlO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcih0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXIodGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nLCAnZm9jdXMnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHtBQ1RJVkUsIE1VTFRJTElORSwgQUNUSU9OX09OX0JPVFRPTX0gPSBjc3NDbGFzc2VzO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRNZXNzYWdlVGV4dCh0aGlzLnNuYWNrYmFyRGF0YV8ubWVzc2FnZSk7XG5cbiAgICBpZiAodGhpcy5zbmFja2JhckRhdGFfLm11bHRpbGluZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNVUxUSUxJTkUpO1xuICAgICAgaWYgKHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25PbkJvdHRvbSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEFDVElPTl9PTl9CT1RUT00pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNuYWNrYmFyRGF0YV8uYWN0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3Rpb25UZXh0KHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25UZXh0KTtcbiAgICAgIHRoaXMuYWN0aW9uSGFuZGxlcl8gPSB0aGlzLnNuYWNrYmFyRGF0YV8uYWN0aW9uSGFuZGxlcjtcbiAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyh0cnVlKTtcbiAgICAgIHRoaXMuYWN0aW9uSGFuZGxlcl8gPSBudWxsO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3Rpb25UZXh0KG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZlXyA9IHRydWU7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhBQ1RJVkUpO1xuICAgIHRoaXMuYWRhcHRlcl8udW5zZXRBcmlhSGlkZGVuKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTaG93KCk7XG5cbiAgICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICB9XG5cbiAgaGFuZGxlUG9zc2libGVUYWJLZXlib2FyZEZvY3VzXygpIHtcbiAgICBjb25zdCBoaWphY2tGb2N1cyA9XG4gICAgICB0aGlzLmZpcnN0Rm9jdXNfICYmICF0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF87XG5cbiAgICBpZiAoaGlqYWNrRm9jdXMpIHtcbiAgICAgIHRoaXMuc2V0Rm9jdXNPbkFjdGlvbl8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gZmFsc2U7XG4gIH1cblxuICBzZXRGb2N1c09uQWN0aW9uXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEZvY3VzKCk7XG4gICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IGZhbHNlO1xuICB9XG5cbiAgaW52b2tlQWN0aW9uXygpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmFjdGlvbkhhbmRsZXJfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5kaXNtaXNzT25BY3Rpb25fKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cF8oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGVhbnVwXygpIHtcbiAgICBjb25zdCBhbGxvd0Rpc21pc3NhbCA9ICF0aGlzLnNuYWNrYmFySGFzRm9jdXNfIHx8IHRoaXMuYWN0aW9uV2FzQ2xpY2tlZF87XG5cbiAgICBpZiAoYWxsb3dEaXNtaXNzYWwpIHtcbiAgICAgIGNvbnN0IHtBQ1RJVkUsIE1VTFRJTElORSwgQUNUSU9OX09OX0JPVFRPTX0gPSBjc3NDbGFzc2VzO1xuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEFDVElWRSk7XG5cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNVUxUSUxJTkUpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEFDVElPTl9PTl9CT1RUT00pO1xuICAgICAgICB0aGlzLnNldEFjdGlvbkhpZGRlbl8odHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXJpYUhpZGRlbigpO1xuICAgICAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUhpZGUoKTtcbiAgICAgICAgdGhpcy5zaG93TmV4dF8oKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBzaG93TmV4dF8oKSB7XG4gICAgaWYgKCF0aGlzLnF1ZXVlXy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zaG93KHRoaXMucXVldWVfLnNoaWZ0KCkpO1xuICB9XG5cbiAgc2V0QWN0aW9uSGlkZGVuXyhpc0hpZGRlbikge1xuICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3Rpb25BcmlhSGlkZGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8udW5zZXRBY3Rpb25BcmlhSGlkZGVuKCk7XG4gICAgfVxuICB9XG59XG4iLCI8dGVtcGxhdGU+XG48ZGl2IHJlZj1cInJvb3RcIiBjbGFzcz1cIm1kYy1zbmFja2JhclwiIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiIDphcmlhLWhpZGRlbj1cImhpZGRlblwiPlxuICA8ZGl2IGNsYXNzPVwibWRjLXNuYWNrYmFyX190ZXh0XCI+e3ttZXNzYWdlfX08L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fYWN0aW9uLXdyYXBwZXJcIj5cbiAgICA8YnV0dG9uIHJlZj1cImJ1dHRvblwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fYWN0aW9uLWJ1dHRvblwiXG4gICAgICAgIDphcmlhLWhpZGRlbj1cImFjdGlvbkhpZGRlblwiPnt7YWN0aW9uVGV4dH19PC9idXR0b24+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1NuYWNrYmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc25hY2tiYXIvZm91bmRhdGlvbidcbmltcG9ydCB7IGdldENvcnJlY3RFdmVudE5hbWUgfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc25hY2tiYXInLFxuICBwcm9wczoge1xuICAgICdhbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2V2ZW50Jzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdCAoKSB7IHJldHVybiAnc2hvdy1zbmFja2JhcicgfVxuICAgIH0sXG4gICAgJ2V2ZW50LXNvdXJjZSc6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdCB9XG4gICAgfSxcbiAgICAnZGlzbWlzc2VzLW9uLWFjdGlvbic6IHt0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlfVxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXNuYWNrYmFyLS1hbGlnbi1zdGFydCc6IHRoaXMuYWxpZ25TdGFydFxuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6ICcnLFxuICAgICAgYWN0aW9uVGV4dDogJycsXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgYWN0aW9uSGlkZGVuOiBmYWxzZSxcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzaG93IChkYXRhKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2hvdyhkYXRhKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1NuYWNrYmFyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgc2V0QXJpYUhpZGRlbjogKCkgPT4gdGhpcy5oaWRkZW4gPSB0cnVlLFxuICAgICAgdW5zZXRBcmlhSGlkZGVuOiAoKSA9PiB0aGlzLmhpZGRlbiA9IGZhbHNlLFxuICAgICAgc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4gdGhpcy5hY3Rpb25IaWRkZW4gPSB0cnVlLFxuICAgICAgdW5zZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiB0aGlzLmFjdGlvbkhpZGRlbiA9IGZhbHNlLFxuICAgICAgc2V0QWN0aW9uVGV4dDogKHRleHQpID0+IHsgdGhpcy5hY3Rpb25UZXh0ID0gdGV4dCB9LFxuICAgICAgc2V0TWVzc2FnZVRleHQ6ICh0ZXh0KSA9PiB7IHRoaXMubWVzc2FnZSA9IHRleHQgIH0sXG4gICAgICBzZXRGb2N1czogKCkgPT4gdGhpcy4kcmVmcy5idXR0b24uZm9jdXMoKSxcbiAgICAgIHZpc2liaWxpdHlJc0hpZGRlbjogKCkgPT4gZG9jdW1lbnQuaGlkZGVuLFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyOiAoaGFuZGxlcikgPT4gdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlciwgdHJ1ZSksXG4gICAgICByZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyOiAoaGFuZGxlcikgPT4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyOiAoaGFuZGxlcikgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgdHJ1ZSksXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IChoYW5kbGVyKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlcjogKGhhbmRsZXIpID0+IHRoaXMuJHJlZnMuYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciksXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ3RyYW5zaXRpb25lbmQnKSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeVNob3c6ICgpID0+IHRoaXMuJGVtaXQoJ3Nob3cnKSxcbiAgICAgIG5vdGlmeUhpZGU6ICgpID0+IHRoaXMuJGVtaXQoJ2hpZGUnKSxcbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICBpZiAodGhpcy5ldmVudCkge1xuICAgICAgdGhpcy5ldmVudFNvdXJjZS4kb24odGhpcy5ldmVudCwgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNob3coZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNtaXNzT25BY3Rpb24odGhpcy5kaXNtaXNzZXNPbkFjdGlvbilcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNTbmFja2JhciBmcm9tICcuL21kYy1zbmFja2Jhci52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1NuYWNrYmFyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTbmFja2JhclxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2gtd3JhcHBlclwiIFxuICAgIDpjbGFzcz1cIntcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkJzogdGhpcy5oYXNMYWJlbCxcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiB0aGlzLmhhc0xhYmVsICYmIHRoaXMuYWxpZ25FbmRcbiAgICAgIH1cIiA+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXN3aXRjaFwiIFxuICAgICAgOmNsYXNzPVwieydtZGMtc3dpdGNoLS1kaXNhYmxlZCc6IGRpc2FibGVkIH1cIj5cbiAgICAgIDxpbnB1dCByZWY9XCJjb250cm9sXCIgdHlwZT1cImNoZWNrYm94XCIgXG4gICAgICAgIDpuYW1lPVwibmFtZVwiIDppZD1cIl91aWRcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtc3dpdGNoX19uYXRpdmUtY29udHJvbFwiIFxuICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRcIiBcbiAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWRcIlxuICAgICAgICBAY2hhbmdlPVwib25DaGFuZ2VkXCIgLz5cblxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2JhY2tncm91bmRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2tub2JcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8bGFiZWwgOmZvcj1cIl91aWRcIiB2LWlmPVwiaGFzTGFiZWxcIlxuICAgICAgY2xhc3M9XCJtZGMtc3dpdGNoLWxhYmVsXCI+XG4gICAgICA8c2xvdD57e2xhYmVsfX08L3Nsb3Q+XG4gICAgPC9sYWJlbD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge0Rpc3BhdGNoRm9jdXNNaXhpbn0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXN3aXRjaCcsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ2NoZWNrZWQnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgICdjaGVja2VkJzogQm9vbGVhbixcbiAgICAnbGFiZWwnOiBTdHJpbmcsXG4gICAgJ2FsaWduRW5kJzogQm9vbGVhbixcbiAgICAnZGlzYWJsZWQnOiBCb29sZWFuLFxuICAgICd2YWx1ZSc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0ICgpIHsgcmV0dXJuICdvbicgfSB9LFxuICAgICduYW1lJzogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWwgfHwgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlZCAoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2ZW50LnRhcmdldC5jaGVja2VkKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU3dpdGNoIGZyb20gJy4vbWRjLXN3aXRjaC52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1N3aXRjaFxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU3dpdGNoXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEFDVElWRTogJ21kYy10YWItLWFjdGl2ZScsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgU0VMRUNURURfRVZFTlQ6ICdNRENUYWI6c2VsZWN0ZWQnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1RhYkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlTZWxlY3RlZDogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IDA7XG4gICAgdGhpcy5jb21wdXRlZExlZnRfID0gMDtcbiAgICB0aGlzLmlzQWN0aXZlXyA9IGZhbHNlO1xuICAgIHRoaXMucHJldmVudERlZmF1bHRPbkNsaWNrXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJldmVudERlZmF1bHRPbkNsaWNrXykge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSAmJiBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNlbGVjdGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIGdldENvbXB1dGVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRXaWR0aF87XG4gIH1cblxuICBnZXRDb21wdXRlZExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRMZWZ0XztcbiAgfVxuXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQWN0aXZlXztcbiAgfVxuXG4gIHNldEFjdGl2ZShpc0FjdGl2ZSkge1xuICAgIHRoaXMuaXNBY3RpdmVfID0gaXNBY3RpdmU7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmVfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgfVxuICB9XG5cbiAgcHJldmVudHNEZWZhdWx0T25DbGljaygpIHtcbiAgICByZXR1cm4gdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfO1xuICB9XG5cbiAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaykge1xuICAgIHRoaXMucHJldmVudERlZmF1bHRPbkNsaWNrXyA9IHByZXZlbnREZWZhdWx0T25DbGljaztcbiAgfVxuXG4gIG1lYXN1cmVTZWxmKCkge1xuICAgIHRoaXMuY29tcHV0ZWRXaWR0aF8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgdGhpcy5jb21wdXRlZExlZnRfID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRMZWZ0KCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y3VzdG9tLWxpbmsgY2xhc3M9XCJtZGMtdGFiXCIgXHJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCJcclxuICAgIDpsaW5rPVwibGlua1wiIFxyXG4gICAgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxyXG5cclxuICAgIDxpIHJlZj1cImljb25cIiB2LWlmPVwiISFoYXNJY29uXCJcclxuICAgICAgdGFiaW5kZXg9XCIwXCIgXHJcbiAgICAgIGNsYXNzPVwibWRjLXRhYl9faWNvblwiICBcclxuICAgICAgOmNsYXNzPVwiaGFzSWNvbi5jbGFzc2VzXCI+XHJcbiAgICAgIDxzbG90IG5hbWU9XCJpY29uXCI+e3sgaGFzSWNvbi5jb250ZW50IH19PC9zbG90PlxyXG4gICAgPC9pPlxyXG5cclxuICAgIDxzcGFuIDpjbGFzcz1cInsnbWRjLXRhYl9faWNvbi10ZXh0JzogISFoYXNJY29ufVwiIHYtaWY9XCJoYXNUZXh0XCI+XHJcbiAgICAgIDxzbG90Pjwvc2xvdD4gIFxyXG4gICAgPC9zcGFuPlxyXG5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXHJcbmltcG9ydCB7Q3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW4sIGVtaXRDdXN0b21FdmVudCwgZXh0cmFjdEljb25Qcm9wIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHtSaXBwbGVCYXNlfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy10YWInLFxyXG4gIG1peGluczogW0N1c3RvbUxpbmtNaXhpbiwgRGlzcGF0Y2hFdmVudE1peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgYWN0aXZlOiBCb29sZWFuLFxyXG4gICAgaWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXHJcbiAgfSxcclxuICBkYXRhICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaGFzSWNvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmljb24gfHwgdGhpcy4kc2xvdHMuaWNvbikge1xyXG4gICAgICAgIHRoaXMuaWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmljb24pIDoge31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBoYXNUZXh0ICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHMuZGVmYXVsdFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgZ2V0Q29tcHV0ZWRXaWR0aCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uZ2V0Q29tcHV0ZWRXaWR0aCgpXHJcbiAgICB9LFxyXG4gICAgZ2V0Q29tcHV0ZWRMZWZ0ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5nZXRDb21wdXRlZExlZnQoKVxyXG4gICAgfSxcclxuICAgIGlzQWN0aXZlICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc0FjdGl2ZSgpXHJcbiAgICB9LFxyXG4gICAgc2V0QWN0aXZlIChpc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QWN0aXZlKGlzQWN0aXZlKVxyXG4gICAgfSxcclxuICAgIGlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2sgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLnByZXZlbnRzRGVmYXVsdE9uQ2xpY2soKVxyXG4gICAgfSxcclxuICAgIHNldFByZXZlbnREZWZhdWx0T25DbGljayAocHJldmVudERlZmF1bHRPbkNsaWNrKSB7XHJcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKVxyXG4gICAgfSxcclxuICAgIG1lYXN1cmVTZWxmICgpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLm1lYXN1cmVTZWxmKClcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RhYkZvdW5kYXRpb24oe1xyXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT5cclxuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxyXG4gICAgICByZW1vdmVDbGFzczogKGNsYXNzTmFtZSkgPT5cclxuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxyXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kZWwub2Zmc2V0V2lkdGhcclxuICAgICAgfSxcclxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT5cclxuICAgICAgICB0aGlzLiRlbC5vZmZzZXRMZWZ0LFxyXG4gICAgICBub3RpZnlTZWxlY3RlZDogKCkgPT4ge1xyXG4gICAgICAgIGVtaXRDdXN0b21FdmVudCh0aGlzLiRlbCxcclxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwge3RhYjogdGhpc30sIHRydWUpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB0aGlzLnNldEFjdGl2ZSh0aGlzLmFjdGl2ZSlcclxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcclxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSAoKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXHJcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBVUEdSQURFRDogJ21kYy10YWItYmFyLXVwZ3JhZGVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUQUJfU0VMRUNUT1I6ICcubWRjLXRhYicsXG4gIElORElDQVRPUl9TRUxFQ1RPUjogJy5tZGMtdGFiLWJhcl9faW5kaWNhdG9yJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDVGFiQmFyOmNoYW5nZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2dldENvcnJlY3RQcm9wZXJ0eU5hbWV9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT4ge30sXG4gICAgICB1bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0U3R5bGVGb3JJbmRpY2F0b3I6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiB7YWN0aXZlVGFiSW5kZXg6IG51bWJlcn0gKi8pID0+IHt9LFxuICAgICAgZ2V0TnVtYmVyT2ZUYWJzOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGlzVGFiQWN0aXZlQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBzZXRUYWJBY3RpdmVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciwgaXNBY3RpdmU6IHRydWUgKi8pID0+IHt9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrRm9yVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIsIHByZXZlbnREZWZhdWx0T25DbGljazogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgICBtZWFzdXJlVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiQmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5pc0luZGljYXRvclNob3duXyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZWRXaWR0aF8gPSAwO1xuICAgIHRoaXMuY29tcHV0ZWRMZWZ0XyA9IDA7XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSAwO1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICBjb25zdCBhY3RpdmVUYWJJbmRleCA9IHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICAgIGlmIChhY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhYkluZGV4XyA9IGFjdGl2ZVRhYkluZGV4O1xuICAgIH1cbiAgICB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8udW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZvckVhY2hUYWJJbmRleF8oKGluZGV4KSA9PiB0aGlzLmFkYXB0ZXJfLm1lYXN1cmVUYWJBdEluZGV4KGluZGV4KSk7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgfVxuXG4gIGxheW91dEluZGljYXRvcl8oKSB7XG4gICAgY29uc3QgaXNJbmRpY2F0b3JGaXJzdFJlbmRlciA9ICF0aGlzLmlzSW5kaWNhdG9yU2hvd25fO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgaW5kaWNhdG9yIGFwcGVhcnMgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uIGltbWVkaWF0ZWx5IGZvciBjb3JyZWN0IGZpcnN0IHJlbmRlci5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcigndHJhbnNpdGlvbicsICdub25lJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4Xyk7XG4gICAgY29uc3Qgc2NhbGVBbXRGb3JBY3RpdmVUYWJXaWR0aCA9XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4KHRoaXMuYWN0aXZlVGFiSW5kZXhfKSAvIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybVZhbHVlID0gYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVBbXRGb3JBY3RpdmVUYWJMZWZ0fXB4KSBzY2FsZSgke3NjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGh9LCAxKWA7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcihnZXRDb3JyZWN0UHJvcGVydHlOYW1lKHdpbmRvdywgJ3RyYW5zZm9ybScpLCB0cmFuc2Zvcm1WYWx1ZSk7XG5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgLy8gRm9yY2UgbGF5b3V0IHNvIHRoYXQgdHJhbnNmb3JtIHN0eWxlcyB0byB0YWtlIGVmZmVjdC5cbiAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGhGb3JJbmRpY2F0b3IoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JJbmRpY2F0b3IoJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9ySW5kaWNhdG9yKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgIHRoaXMuaXNJbmRpY2F0b3JTaG93bl8gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRBY3RpdmVUYWJJbmRleF8oKSB7XG4gICAgbGV0IGFjdGl2ZVRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy5mb3JFYWNoVGFiSW5kZXhfKChpbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNUYWJBY3RpdmVBdEluZGV4KGluZGV4KSkge1xuICAgICAgICBhY3RpdmVUYWJJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aXZlVGFiSW5kZXg7XG4gIH1cblxuICBmb3JFYWNoVGFiSW5kZXhfKGl0ZXJhdG9yKSB7XG4gICAgY29uc3QgbnVtVGFicyA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZUYWJzKCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVRhYnM7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNob3VsZEJyZWFrID0gaXRlcmF0b3IoaW5kZXgpO1xuICAgICAgaWYgKHNob3VsZEJyZWFrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG5cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgc3dpdGNoVG9UYWJBdEluZGV4KGluZGV4LCBzaG91bGROb3RpZnkpIHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuYWN0aXZlVGFiSW5kZXhfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mVGFicygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dCBvZiBib3VuZHMgaW5kZXggc3BlY2lmaWVkIGZvciB0YWI6ICR7aW5kZXh9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldkFjdGl2ZVRhYkluZGV4ID0gdGhpcy5hY3RpdmVUYWJJbmRleF87XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSBpbmRleDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKHByZXZBY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleChwcmV2QWN0aXZlVGFiSW5kZXgsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4XywgdHJ1ZSk7XG4gICAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2Uoe2FjdGl2ZVRhYkluZGV4OiB0aGlzLmFjdGl2ZVRhYkluZGV4X30pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWN0aXZlVGFiSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgY2xhc3M9XCJtZGMtdGFiLWJhclwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPHNwYW4gcmVmPVwiaW5kaWNhdG9yXCIgY2xhc3M9XCJtZGMtdGFiLWJhcl9faW5kaWNhdG9yXCIgXG4gICAgICA6c3R5bGU9XCJpbmRpY2F0b3JTdHlsZXNcIj48L3NwYW4+XG4gIDwvbmF2PiAgXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RhYkJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10YWItYmFyJyxcbiAgcHJvcHM6IHtcbiAgICAnaW5kaWNhdG9yLXByaW1hcnknOiBCb29sZWFuLFxuICAgICdpbmRpY2F0b3ItYWNjZW50JzogQm9vbGVhblxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRhYi1iYXItLWluZGljYXRvci1wcmltYXJ5JzogdGhpcy5pbmRpY2F0b3JQcmltYXJ5LFxuICAgICAgICAnbWRjLXRhYi1iYXItLWluZGljYXRvci1hY2NlbnQnOiB0aGlzLmluZGljYXRvckFjY2VudFxuICAgICAgfSxcbiAgICAgIGluZGljYXRvclN0eWxlczoge30sXG4gICAgICB0YWJzOiBbXVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uU2VsZWN0ICh7ZGV0YWlsfSkge1xuICAgICAgY29uc3Qge3RhYn0gPSBkZXRhaWxcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWJzLmluZGV4T2YodGFiKVxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21kYy10YWItYmFyIGludGVybmFsIGVycm9yOiBpbmRleCBub3QgZm91bmQnKVxuICAgICAgfVxuICAgICAgdGhpcy5mb3VuZGF0aW9uLnN3aXRjaFRvVGFiQXRJbmRleChpbmRleCwgdHJ1ZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUYWJCYXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PlxuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBiaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULCB0aGlzLm9uU2VsZWN0KVxuICAgICAgfSxcbiAgICAgIHVuYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT5cbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsIHRoaXMub25TZWxlY3QpLFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PlxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT5cbiAgICAgICAgdGhpcy4kZWwub2Zmc2V0V2lkdGgsXG4gICAgICBzZXRTdHlsZUZvckluZGljYXRvcjogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmluZGljYXRvclN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSksXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5pbmRpY2F0b3Iub2Zmc2V0V2lkdGgsXG4gICAgICBub3RpZnlDaGFuZ2U6IChldnREYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGV2dERhdGEuYWN0aXZlVGFiSW5kZXgpXG4gICAgICB9LFxuICAgICAgZ2V0TnVtYmVyT2ZUYWJzOiAoKSA9PlxuICAgICAgICB0aGlzLnRhYnMubGVuZ3RoLFxuICAgICAgaXNUYWJBY3RpdmVBdEluZGV4OiAoaW5kZXgpID0+XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uaXNBY3RpdmUoKSxcbiAgICAgIHNldFRhYkFjdGl2ZUF0SW5kZXg6IChpbmRleCwgaXNBY3RpdmUpID0+IHtcbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5zZXRBY3RpdmUoaXNBY3RpdmUpXG4gICAgICB9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5pc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrKCksXG4gICAgICBzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2tGb3JUYWJBdEluZGV4OiAoaW5kZXgsIHByZXZlbnREZWZhdWx0T25DbGljaykgPT4ge1xuICAgICAgICB0aGlzLnRhYnNbaW5kZXhdLnNldFByZXZlbnREZWZhdWx0T25DbGljayhwcmV2ZW50RGVmYXVsdE9uQ2xpY2spXG4gICAgICB9LFxuICAgICAgbWVhc3VyZVRhYkF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5tZWFzdXJlU2VsZigpLFxuICAgICAgZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXg6IChpbmRleCkgPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5nZXRDb21wdXRlZFdpZHRoKCksXG4gICAgICBnZXRDb21wdXRlZExlZnRGb3JUYWJBdEluZGV4OiAoaW5kZXgpID0+XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uZ2V0Q29tcHV0ZWRMZWZ0KClcbiAgICB9KVxuXG4gICAgY29uc3QgcmVzZXRUYWJzID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGFiRWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKFxuICAgICAgICB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKE1EQ1RhYkJhckZvdW5kYXRpb24uc3RyaW5ncy5UQUJfU0VMRUNUT1IpKVxuICAgICAgdGhpcy50YWJzID0gdGFiRWxlbWVudHMubWFwKChlbCkgPT4gZWwuX192dWVfXylcblxuICAgICAgbGV0IGhhc1RleHQsIGhhc0ljb25cbiAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnNcbiAgICAgIGZvciAobGV0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgIGlmICh0YWIuaGFzVGV4dCkge1xuICAgICAgICAgIGhhc1RleHQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgaWYgKHRhYi5oYXNJY29uKSB7XG4gICAgICAgICAgaGFzSWNvbiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNUZXh0ICYmIGhhc0ljb24pIHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy10YWItYmFyLS1pY29ucy13aXRoLXRleHQnLCB0cnVlKVxuICAgICAgfSBlbHNlIGlmIChoYXNJY29uKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtdGFiLWJhci0taWNvbi10YWItYmFyJywgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xuICAgICAgICBjb25zdCBhY3RpdmVUYWJJbmRleCA9IHRoaXMuZm91bmRhdGlvbi5nZXRBY3RpdmVUYWJJbmRleCgpXG4gICAgICAgIGlmIChhY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnN3aXRjaFRvVGFiQXRJbmRleChhY3RpdmVUYWJJbmRleCwgdHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uc3dpdGNoVG9UYWJBdEluZGV4KDAsIHRydWUpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmxheW91dCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRUYWJzKClcblxuICAgIHRoaXMuc2xvdE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gcmVzZXRUYWJzKCkpXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUYWIgZnJvbSAnLi9tZGMtdGFiLnZ1ZSdcbmltcG9ydCBtZGNUYWJCYXIgZnJvbSAnLi9tZGMtdGFiLWJhci52dWUnXG5cbmV4cG9ydCB7IFxuICBtZGNUYWIsIFxuICBtZGNUYWJCYXIgXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUYWIsIFxuICBtZGNUYWJCYXIgXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0RmllbGQgTGluZSBSaXBwbGUuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgbGluZSByaXBwbGUgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0xpbmVSaXBwbGVBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgbGluZSByaXBwbGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgbGluZSByaXBwbGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgbGluZSByaXBwbGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbGluZSByaXBwbGUgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTGluZVJpcHBsZUFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBMSU5FX1JJUFBMRV9BQ1RJVkU6ICdtZGMtbGluZS1yaXBwbGUtLWFjdGl2ZScsXG4gIExJTkVfUklQUExFX0RFQUNUSVZBVElORzogJ21kYy1saW5lLXJpcHBsZS0tZGVhY3RpdmF0aW5nJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDTGluZVJpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0xpbmVSaXBwbGVBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENMaW5lUmlwcGxlQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENMaW5lUmlwcGxlQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENMaW5lUmlwcGxlQWRhcHRlcj19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSAvKiogQHR5cGUgeyFNRENMaW5lUmlwcGxlQWRhcHRlcn0gKi8gKHt9KSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTGluZVJpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJFdmVudEhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlXG4gICAqL1xuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfQUNUSVZFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjZW50ZXIgb2YgdGhlIHJpcHBsZSBhbmltYXRpb24gdG8gdGhlIGdpdmVuIFggY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHshbnVtYmVyfSB4Q29vcmRpbmF0ZVxuICAgKi9cbiAgc2V0UmlwcGxlQ2VudGVyKHhDb29yZGluYXRlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlU3RyaW5nID1cbiAgICAgICAgYHRyYW5zZm9ybS1vcmlnaW46ICR7eENvb3JkaW5hdGV9cHggY2VudGVyYDtcblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cignc3R5bGUnLCBhdHRyaWJ1dGVTdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZVxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgdHJhbnNpdGlvbiBlbmQgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgbGluZSByaXBwbGUgdG8gYmUgZWl0aGVyIHRyYW5zcGFyZW50IG9yIG9wYXF1ZVxuICAgIC8vIGJlZm9yZSBlbWl0dGluZyB0aGUgYW5pbWF0aW9uIGVuZCBldmVudFxuICAgIGNvbnN0IGlzRGVhY3RpdmF0aW5nID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG5cbiAgICBpZiAoZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICBpZiAoaXNEZWFjdGl2YXRpbmcpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0FDVElWRSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZCBIZWxwZXIgVGV4dC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUZXh0RmllbGQgaGVscGVyIHRleHQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gdmFsdWUgb24gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZUF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IGZvciB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICovXG4gIHNldENvbnRlbnQoY29udGVudCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX0hJRERFTjogJ2FyaWEtaGlkZGVuJyxcbiAgUk9MRTogJ3JvbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBIRUxQRVJfVEVYVF9QRVJTSVNURU5UOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnLFxuICBIRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRzogJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZycsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZW1vdmVBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldENvbnRlbnQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIGhlbHBlciB0ZXh0IGZpZWxkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQZXJzaXN0ZW50IFNldHMgdGhlIHBlcnNpc3RlbmN5IG9mIHRoZSBoZWxwZXIgdGV4dC4gKi9cbiAgc2V0UGVyc2lzdGVudChpc1BlcnNpc3RlbnQpIHtcbiAgICBpZiAoaXNQZXJzaXN0ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkYXRpb24gVHJ1ZSB0byBtYWtlIHRoZSBoZWxwZXIgdGV4dCBhY3QgYXMgYW5cbiAgICogICBlcnJvciB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAqL1xuICBzZXRWYWxpZGF0aW9uKGlzVmFsaWRhdGlvbikge1xuICAgIGlmIChpc1ZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIE1ha2VzIHRoZSBoZWxwZXIgdGV4dCB2aXNpYmxlIHRvIHRoZSBzY3JlZW4gcmVhZGVyLiAqL1xuICBzaG93VG9TY3JlZW5SZWFkZXIoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKHN0cmluZ3MuQVJJQV9ISURERU4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbGlkaXR5IG9mIHRoZSBoZWxwZXIgdGV4dCBiYXNlZCBvbiB0aGUgaW5wdXQgdmFsaWRpdHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5wdXRJc1ZhbGlkXG4gICAqL1xuICBzZXRWYWxpZGl0eShpbnB1dElzVmFsaWQpIHtcbiAgICBjb25zdCBoZWxwZXJUZXh0SXNQZXJzaXN0ZW50ID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0cpO1xuICAgIGNvbnN0IHZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkgPSBoZWxwZXJUZXh0SXNWYWxpZGF0aW9uTXNnICYmICFpbnB1dElzVmFsaWQ7XG5cbiAgICBpZiAodmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuUk9MRSwgJ2FsZXJ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cihzdHJpbmdzLlJPTEUpO1xuICAgIH1cblxuICAgIGlmICghaGVscGVyVGV4dElzUGVyc2lzdGVudCAmJiAhdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5oaWRlXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgaGVscCB0ZXh0IGZyb20gc2NyZWVuIHJlYWRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoaWRlXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX0hJRERFTiwgJ3RydWUnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZCBJY29uLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIHRleHQgZmllbGQgaWNvbiBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXIge1xuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIGV2ZW50IFwiTURDVGV4dEZpZWxkOmljb25cIiBkZW5vdGluZyBhIHVzZXIgaGFzIGNsaWNrZWQgdGhlIGljb24uXG4gICAqL1xuICBub3RpZnlJY29uQWN0aW9uKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBJQ09OX0VWRU5UOiAnTURDVGV4dEZpZWxkOmljb24nLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEljb25BZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEljb25BZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9ICovICh7XG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5SWNvbkFjdGlvbjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUludGVyYWN0aW9uKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQgZmllbGQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAgICovXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCAnMCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGFuIGludGVyYWN0aW9uIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZUludGVyYWN0aW9uKGV2dCkge1xuICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJyB8fCBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlJY29uQWN0aW9uKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIExhYmVsLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHQgRmllbGQgbGFiZWwgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZExhYmVsQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkTGFiZWxBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgTEFCRUxfRkxPQVRfQUJPVkU6ICdtZGMtdGV4dC1maWVsZF9fbGFiZWwtLWZsb2F0LWFib3ZlJyxcbiAgTEFCRUxfU0hBS0U6ICdtZGMtdGV4dC1maWVsZF9fbGFiZWwtLXNoYWtlJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkTGFiZWxBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRMYWJlbEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRMYWJlbEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkTGFiZWxBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkTGFiZWxBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgZ2V0V2lkdGg6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RleHRGaWVsZExhYmVsQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFdpZHRoKCk7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBsYWJlbCB0byBwcm9kdWNlIHRoZSBsYWJlbCBzaGFrZSBmb3IgZXJyb3JzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWQgV2hldGhlciB0aGUgaW5wdXQncyB2YWx1ZSBpcyB2YWxpZCAocGFzc2VzIGFsbFxuICAgKiAgICAgdmFsaWRpdHkgY2hlY2tzKS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ZvY3VzZWQgV2hldGhlciB0aGUgaW5wdXQgaXMgZm9jdXNlZC5cbiAgICovXG4gIHN0eWxlU2hha2UoaXNWYWxpZCwgaXNGb2N1c2VkKSB7XG4gICAgY29uc3Qge0xBQkVMX1NIQUtFfSA9IE1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc1ZhbGlkIHx8IGlzRm9jdXNlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGxhYmVsIHRvIGZsb2F0IG9yIGRlZmxvYXQgYXMgbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ZvY3VzZWQgV2hldGhlciB0aGUgaW5wdXQgaXMgZm9jdXNlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0JhZElucHV0IFRoZSBpbnB1dCdzIGB2YWxpZGl0eS5iYWRJbnB1dGAgdmFsdWUuXG4gICAqL1xuICBzdHlsZUZsb2F0KHZhbHVlLCBpc0ZvY3VzZWQsIGlzQmFkSW5wdXQpIHtcbiAgICBjb25zdCB7TEFCRUxfRkxPQVRfQUJPVkUsIExBQkVMX1NIQUtFfSA9IE1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmICghIXZhbHVlIHx8IGlzRm9jdXNlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgfSBlbHNlIGlmICghaXNCYWRJbnB1dCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkTGFiZWxGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIE91dGxpbmUuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGV4dCBGaWVsZCBvdXRsaW5lIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRIZWlnaHQoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBcImRcIiBhdHRyaWJ1dGUgb2YgdGhlIG91dGxpbmUgZWxlbWVudCdzIFNWRyBwYXRoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldE91dGxpbmVQYXRoQXR0cih2YWx1ZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWRsZSBvdXRsaW5lIGVsZW1lbnQncyBjb21wdXRlZCBzdHlsZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY3NzIHByb3BlcnR5IGBwcm9wZXJ0eU5hbWVgLlxuICAgKiBXZSBhY2hpZXZlIHRoaXMgdmlhIGBnZXRDb21wdXRlZFN0eWxlKC4uLikuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUocHJvcGVydHlOYW1lKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFBBVEhfU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX291dGxpbmUtcGF0aCcsXG4gIElETEVfT1VUTElORV9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9faWRsZS1vdXRsaW5lJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkT3V0bGluZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkT3V0bGluZUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkT3V0bGluZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlcn0gKi8gKHtcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGdldEhlaWdodDogKCkgPT4ge30sXG4gICAgICBzZXRPdXRsaW5lUGF0aEF0dHI6ICgpID0+IHt9LFxuICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRPdXRsaW5lQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBTVkcgcGF0aCBvZiB0aGUgZm9jdXMgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBnaXZlbiB3aWR0aCBvZiB0aGVcbiAgICogbGFiZWwgZWxlbWVudCBhbmQgdGhlIFJUTCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxXaWR0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1J0bFxuICAgKi9cbiAgdXBkYXRlU3ZnUGF0aChsYWJlbFdpZHRoLCBpc1J0bCA9IGZhbHNlKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgYSBzcGVjaWZpYyBjb3JuZXIncyBzdHlsZSBiZWNhdXNlIEZpcmVmb3ggZG9lc24ndCByZXBvcnQgdGhlIHN0eWxlIG9uIGJvcmRlci1yYWRpdXMuXG4gICAgY29uc3QgcmFkaXVzU3R5bGVWYWx1ZSA9IHRoaXMuYWRhcHRlcl8uZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlKCdib3JkZXItcmFkaXVzJykgfHxcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5nZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUoJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnKTtcbiAgICBjb25zdCByYWRpdXMgPSBwYXJzZUZsb2F0KHJhZGl1c1N0eWxlVmFsdWUpO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuYWRhcHRlcl8uZ2V0SGVpZ2h0KCk7XG4gICAgY29uc3QgY29ybmVyV2lkdGggPSByYWRpdXMgKyAxLjI7XG4gICAgY29uc3QgbGVhZGluZ1N0cm9rZUxlbmd0aCA9IE1hdGguYWJzKDExIC0gY29ybmVyV2lkdGgpO1xuICAgIGNvbnN0IHBhZGRlZExhYmVsV2lkdGggPSBsYWJlbFdpZHRoICsgODtcblxuICAgIC8vIFRoZSByaWdodCwgYm90dG9tLCBhbmQgbGVmdCBzaWRlcyBvZiB0aGUgb3V0bGluZSBmb2xsb3cgdGhlIHNhbWUgU1ZHIHBhdGguXG4gICAgY29uc3QgcGF0aE1pZGRsZSA9ICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIHJhZGl1cyArICcsJyArIHJhZGl1c1xuICAgICAgKyAndicgKyAoaGVpZ2h0IC0gKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIC1yYWRpdXMgKyAnLCcgKyByYWRpdXNcbiAgICAgICsgJ2gnICsgKC13aWR0aCArICgyICogY29ybmVyV2lkdGgpKVxuICAgICAgKyAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyAtcmFkaXVzICsgJywnICsgLXJhZGl1c1xuICAgICAgKyAndicgKyAoLWhlaWdodCArICgyICogY29ybmVyV2lkdGgpKVxuICAgICAgKyAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyByYWRpdXMgKyAnLCcgKyAtcmFkaXVzO1xuXG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKCFpc1J0bCkge1xuICAgICAgcGF0aCA9ICdNJyArIChjb3JuZXJXaWR0aCArIGxlYWRpbmdTdHJva2VMZW5ndGggKyBwYWRkZWRMYWJlbFdpZHRoKSArICcsJyArIDFcbiAgICAgICAgKyAnaCcgKyAod2lkdGggLSAoMiAqIGNvcm5lcldpZHRoKSAtIHBhZGRlZExhYmVsV2lkdGggLSBsZWFkaW5nU3Ryb2tlTGVuZ3RoKVxuICAgICAgICArIHBhdGhNaWRkbGVcbiAgICAgICAgKyAnaCcgKyBsZWFkaW5nU3Ryb2tlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gJ00nICsgKHdpZHRoIC0gY29ybmVyV2lkdGggLSBsZWFkaW5nU3Ryb2tlTGVuZ3RoKSArICcsJyArIDFcbiAgICAgICAgKyAnaCcgKyBsZWFkaW5nU3Ryb2tlTGVuZ3RoXG4gICAgICAgICsgcGF0aE1pZGRsZVxuICAgICAgICArICdoJyArICh3aWR0aCAtICgyICogY29ybmVyV2lkdGgpIC0gcGFkZGVkTGFiZWxXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0T3V0bGluZVBhdGhBdHRyKHBhdGgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZE91dGxpbmVGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJy4vaGVscGVyLXRleHQvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnLi9pY29uL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbiBmcm9tICcuL2xhYmVsL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZE91dGxpbmVGb3VuZGF0aW9uIGZyb20gJy4vb3V0bGluZS9mb3VuZGF0aW9uJztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdmFsdWU6IHN0cmluZyxcbiAqICAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gKiAgIGJhZElucHV0OiBib29sZWFuLFxuICogICB2YWxpZGl0eToge1xuICogICAgIGJhZElucHV0OiBib29sZWFuLFxuICogICAgIHZhbGlkOiBib29sZWFuLFxuICogICB9LFxuICogfX1cbiAqL1xubGV0IE5hdGl2ZUlucHV0VHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBsaW5lUmlwcGxlOiAoIU1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9ufHVuZGVmaW5lZCksXG4gKiAgIGhlbHBlclRleHQ6ICghTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqICAgaWNvbjogKCFNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogICBsYWJlbDogKCFNRENUZXh0RmllbGRMYWJlbEZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqICAgb3V0bGluZTogKCFNRENUZXh0RmllbGRPdXRsaW5lRm91bmRhdGlvbnx1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgRm91bmRhdGlvbk1hcFR5cGU7XG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRleHQgRmllbGQuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGV4dCBGaWVsZCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBFbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hdGl2ZSB0ZXh0IGlucHV0IGVsZW1lbnQsIHdpdGggYVxuICAgKiBzaW1pbGFyIEFQSSBzaGFwZS4gVGhlIG9iamVjdCByZXR1cm5lZCBzaG91bGQgaW5jbHVkZSB0aGUgdmFsdWUsIGRpc2FibGVkXG4gICAqIGFuZCBiYWRJbnB1dCBwcm9wZXJ0aWVzLCBhcyB3ZWxsIGFzIHRoZSBjaGVja1ZhbGlkaXR5KCkgZnVuY3Rpb24uIFdlIG5ldmVyXG4gICAqIGFsdGVyIHRoZSB2YWx1ZSB3aXRoaW4gb3VyIGNvZGUsIGhvd2V2ZXIgd2UgZG8gdXBkYXRlIHRoZSBkaXNhYmxlZFxuICAgKiBwcm9wZXJ0eSwgc28gaWYgeW91IGNob29zZSB0byBkdWNrLXR5cGUgdGhlIHJldHVybiB2YWx1ZSBmb3IgdGhpcyBtZXRob2RcbiAgICogaW4geW91ciBpbXBsZW1lbnRhdGlvbiBpdCdzIGltcG9ydGFudCB0byBrZWVwIHRoaXMgaW4gbWluZC4gQWxzbyBub3RlIHRoYXRcbiAgICogdGhpcyBtZXRob2QgY2FuIHJldHVybiBudWxsLCB3aGljaCB0aGUgZm91bmRhdGlvbiB3aWxsIGhhbmRsZSBncmFjZWZ1bGx5LlxuICAgKiBAcmV0dXJuIHs/RWxlbWVudHw/TmF0aXZlSW5wdXRUeXBlfVxuICAgKi9cbiAgZ2V0TmF0aXZlSW5wdXQoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRleHRmaWVsZCBpcyBmb2N1c2VkLlxuICAgKiBXZSBhY2hpZXZlIHRoaXMgdmlhIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnJvb3RfYC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRm9jdXNlZCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSByb290IGVsZW1lbnQgaXMgc2V0IHRvIFJUTC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUnRsKCkge31cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZS5cbiAgICovXG4gIGFjdGl2YXRlTGluZVJpcHBsZSgpIHt9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZS5cbiAgICovXG4gIGRlYWN0aXZhdGVMaW5lUmlwcGxlKCkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIG9yaWdpbiBvZiB0aGUgbGluZSByaXBwbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkWFxuICAgKi9cbiAgc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbihub3JtYWxpemVkWCkge31cbn1cblxuZXhwb3J0IHtNRENUZXh0RmllbGRBZGFwdGVyLCBOYXRpdmVJbnB1dFR5cGUsIEZvdW5kYXRpb25NYXBUeXBlfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfQ09OVFJPTFM6ICdhcmlhLWNvbnRyb2xzJyxcbiAgSU5QVVRfU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX2lucHV0JyxcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX2xhYmVsJyxcbiAgSUNPTl9TRUxFQ1RPUjogJy5tZGMtdGV4dC1maWVsZF9faWNvbicsXG4gIE9VVExJTkVfU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX291dGxpbmUnLFxuICBCT1RUT01fTElORV9TRUxFQ1RPUjogJy5tZGMtbGluZS1yaXBwbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXRleHQtZmllbGQnLFxuICBVUEdSQURFRDogJ21kYy10ZXh0LWZpZWxkLS11cGdyYWRlZCcsXG4gIERJU0FCTEVEOiAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJyxcbiAgREVOU0U6ICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnLFxuICBGT0NVU0VEOiAnbWRjLXRleHQtZmllbGQtLWZvY3VzZWQnLFxuICBJTlZBTElEOiAnbWRjLXRleHQtZmllbGQtLWludmFsaWQnLFxuICBCT1g6ICdtZGMtdGV4dC1maWVsZC0tYm94JyxcbiAgT1VUTElORUQ6ICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBMQUJFTF9TQ0FMRTogMC43NSxcbiAgREVOU0VfTEFCRUxfU0NBTEU6IDAuOTIzLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7TURDVGV4dEZpZWxkQWRhcHRlciwgTmF0aXZlSW5wdXRUeXBlLCBGb3VuZGF0aW9uTWFwVHlwZX0gZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJy4vaGVscGVyLXRleHQvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnLi9pY29uL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbiBmcm9tICcuL2xhYmVsL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZE91dGxpbmVGb3VuZGF0aW9uIGZyb20gJy4vb3V0bGluZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGdldE5hdGl2ZUlucHV0OiAoKSA9PiB7fSxcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4ge30sXG4gICAgICBhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHt9LFxuICAgICAgZGVhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHt9LFxuICAgICAgc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkQWRhcHRlcn0gYWRhcHRlclxuICAgKiBAcGFyYW0geyFGb3VuZGF0aW9uTWFwVHlwZT19IGZvdW5kYXRpb25NYXAgTWFwIGZyb20gc3ViY29tcG9uZW50IG5hbWVzIHRvIHRoZWlyIHN1YmZvdW5kYXRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciwgZm91bmRhdGlvbk1hcCA9IC8qKiBAdHlwZSB7IUZvdW5kYXRpb25NYXBUeXBlfSAqLyAoe30pKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oZWxwZXJUZXh0XyA9IGZvdW5kYXRpb25NYXAuaGVscGVyVGV4dDtcbiAgICAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pY29uXyA9IGZvdW5kYXRpb25NYXAuaWNvbjtcbiAgICAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRMYWJlbEZvdW5kYXRpb258dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMubGFiZWxfID0gZm91bmRhdGlvbk1hcC5sYWJlbDtcbiAgICAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRPdXRsaW5lRm91bmRhdGlvbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5vdXRsaW5lXyA9IGZvdW5kYXRpb25NYXAub3V0bGluZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzRm9jdXNlZF8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5yZWNlaXZlZFVzZXJJbnB1dF8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzVmFsaWRfID0gdHJ1ZTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWN0aXZhdGVGb2N1cygpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRCbHVySGFuZGxlcl8gPSAoKSA9PiB0aGlzLmRlYWN0aXZhdGVGb2N1cygpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfID0gKCkgPT4gdGhpcy5hdXRvQ29tcGxldGVGb2N1cygpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuc2V0UG9pbnRlclhPZmZzZXRfID0gKGV2dCkgPT4gdGhpcy5zZXRUcmFuc2Zvcm1PcmlnaW4oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZVRleHRGaWVsZEludGVyYWN0aW9uKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICAvLyBFbnN1cmUgbGFiZWwgZG9lcyBub3QgY29sbGlkZSB3aXRoIGFueSBwcmUtZmlsbGVkIHZhbHVlLlxuICAgIGlmICh0aGlzLmxhYmVsXyAmJiB0aGlzLmdldFZhbHVlKCkpIHtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlRmxvYXQoXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5pc0ZvY3VzZWRfLCB0aGlzLmlzQmFkSW5wdXRfKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXygpO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdpbnB1dCcsIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfKTtcbiAgICBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuc2V0UG9pbnRlclhPZmZzZXRfKTtcbiAgICB9KTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmlucHV0Qmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignaW5wdXQnLCB0aGlzLmlucHV0SW5wdXRIYW5kbGVyXyk7XG4gICAgWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuc2V0UG9pbnRlclhPZmZzZXRfKTtcbiAgICB9KTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy50ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFRleHQgRmllbGQuXG4gICAqL1xuICBoYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbigpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmb2N1cyBvdXRsaW5lIGZvciBvdXRsaW5lZCB0ZXh0IGZpZWxkcy5cbiAgICovXG4gIHVwZGF0ZU91dGxpbmUoKSB7XG4gICAgaWYgKCF0aGlzLm91dGxpbmVfIHx8ICF0aGlzLmxhYmVsXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRGVuc2UgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuREVOU0UpO1xuICAgIGNvbnN0IGxhYmVsU2NhbGUgPSBpc0RlbnNlID8gbnVtYmVycy5ERU5TRV9MQUJFTF9TQ0FMRSA6IG51bWJlcnMuTEFCRUxfU0NBTEU7XG4gICAgY29uc3QgbGFiZWxXaWR0aCA9IHRoaXMubGFiZWxfLmdldFdpZHRoKCkgKiBsYWJlbFNjYWxlO1xuICAgIGNvbnN0IGlzUnRsID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpO1xuICAgIHRoaXMub3V0bGluZV8udXBkYXRlU3ZnUGF0aChsYWJlbFdpZHRoLCBpc1J0bCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0ZXh0IGZpZWxkIGZvY3VzIHN0YXRlLlxuICAgKi9cbiAgYWN0aXZhdGVGb2N1cygpIHtcbiAgICB0aGlzLmlzRm9jdXNlZF8gPSB0cnVlO1xuICAgIHRoaXMuc3R5bGVGb2N1c2VkXyh0aGlzLmlzRm9jdXNlZF8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVMaW5lUmlwcGxlKCk7XG4gICAgaWYgKHRoaXMub3V0bGluZV8pIHtcbiAgICAgIHRoaXMudXBkYXRlT3V0bGluZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYWJlbF8pIHtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlU2hha2UodGhpcy5pc1ZhbGlkKCksIHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgICB0aGlzLmxhYmVsXy5zdHlsZUZsb2F0KFxuICAgICAgICB0aGlzLmdldFZhbHVlKCksIHRoaXMuaXNGb2N1c2VkXywgdGhpcy5pc0JhZElucHV0XygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2hvd1RvU2NyZWVuUmVhZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpbmUgcmlwcGxlJ3MgdHJhbnNmb3JtIG9yaWdpbiwgc28gdGhhdCB0aGUgbGluZSByaXBwbGUgYWN0aXZhdGVcbiAgICogYW5pbWF0aW9uIHdpbGwgYW5pbWF0ZSBvdXQgZnJvbSB0aGUgdXNlcidzIGNsaWNrIGxvY2F0aW9uLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBzZXRUcmFuc2Zvcm1PcmlnaW4oZXZ0KSB7XG4gICAgY29uc3QgdGFyZ2V0Q2xpZW50UmVjdCA9IGV2dC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZXZ0Q29vcmRzID0ge3g6IGV2dC5jbGllbnRYLCB5OiBldnQuY2xpZW50WX07XG4gICAgY29uc3Qgbm9ybWFsaXplZFggPSBldnRDb29yZHMueCAtIHRhcmdldENsaWVudFJlY3QubGVmdDtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW4obm9ybWFsaXplZFgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgVGV4dCBGaWVsZCdzIGZvY3VzIHN0YXRlIGluIGNhc2VzIHdoZW4gdGhlIGlucHV0IHZhbHVlXG4gICAqIGNoYW5nZXMgd2l0aG91dCB1c2VyIGlucHV0IChlLmcuIHByb2dyYW1hdGljYWxseSkuXG4gICAqL1xuICBhdXRvQ29tcGxldGVGb2N1cygpIHtcbiAgICBpZiAoIXRoaXMucmVjZWl2ZWRVc2VySW5wdXRfKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlRm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIFRleHQgRmllbGQncyBmb2N1cyBzdGF0ZS5cbiAgICovXG4gIGRlYWN0aXZhdGVGb2N1cygpIHtcbiAgICB0aGlzLmlzRm9jdXNlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlYWN0aXZhdGVMaW5lUmlwcGxlKCk7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldE5hdGl2ZUlucHV0XygpO1xuICAgIGNvbnN0IHNob3VsZFJlbW92ZUxhYmVsRmxvYXQgPSAhaW5wdXQudmFsdWUgJiYgIXRoaXMuaXNCYWRJbnB1dF8oKTtcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICB0aGlzLnN0eWxlRm9jdXNlZF8odGhpcy5pc0ZvY3VzZWRfKTtcbiAgICBpZiAodGhpcy5sYWJlbF8pIHtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlU2hha2UodGhpcy5pc1ZhbGlkKCksIHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgICB0aGlzLmxhYmVsXy5zdHlsZUZsb2F0KFxuICAgICAgICB0aGlzLmdldFZhbHVlKCksIHRoaXMuaXNGb2N1c2VkXywgdGhpcy5pc0JhZElucHV0XygpKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFJlbW92ZUxhYmVsRmxvYXQpIHtcbiAgICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBFbGVtZW50LlxuICAgKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgb24gdGhlIGlucHV0IEVsZW1lbnQuXG4gICAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkudmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICBpZiAodGhpcy5sYWJlbF8pIHtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlU2hha2UoaXNWYWxpZCwgdGhpcy5pc0ZvY3VzZWRfKTtcbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlRmxvYXQoXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5pc0ZvY3VzZWRfLCB0aGlzLmlzQmFkSW5wdXRfKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiBhIGN1c3RvbSB2YWxpZGl0eSBpcyBzZXQsIHJldHVybnMgdGhhdCB2YWx1ZS5cbiAgICogICAgIE90aGVyd2lzZSwgcmV0dXJucyB0aGUgcmVzdWx0IG9mIG5hdGl2ZSB2YWxpZGl0eSBjaGVja3MuXG4gICAqL1xuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfXG4gICAgICA/IHRoaXMuaXNWYWxpZF8gOiB0aGlzLmlzTmF0aXZlSW5wdXRWYWxpZF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWQgU2V0cyB0aGUgdmFsaWRpdHkgc3RhdGUgb2YgdGhlIFRleHQgRmllbGQuXG4gICAqL1xuICBzZXRWYWxpZChpc1ZhbGlkKSB7XG4gICAgdGhpcy51c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nXyA9IHRydWU7XG4gICAgdGhpcy5pc1ZhbGlkXyA9IGlzVmFsaWQ7XG4gICAgLy8gUmV0cmlldmUgZnJvbSB0aGUgZ2V0dGVyIHRvIGVuc3VyZSBjb3JyZWN0IGxvZ2ljIGlzIGFwcGxpZWQuXG4gICAgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgaWYgKHRoaXMubGFiZWxfKSB7XG4gICAgICB0aGlzLmxhYmVsXy5zdHlsZVNoYWtlKGlzVmFsaWQsIHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIFRleHQgRmllbGQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgU2V0cyB0aGUgdGV4dC1maWVsZCBkaXNhYmxlZCBvciBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgdGhpcy5zdHlsZURpc2FibGVkXyhkaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgVGV4dCBGaWVsZCBpcyByZXF1aXJlZC5cbiAgICovXG4gIGlzUmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkucmVxdWlyZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1JlcXVpcmVkIFNldHMgdGhlIHRleHQtZmllbGQgcmVxdWlyZWQgb3Igbm90LlxuICAgKi9cbiAgc2V0UmVxdWlyZWQoaXNSZXF1aXJlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlSW5wdXRfKCkucmVxdWlyZWQgPSBpc1JlcXVpcmVkO1xuICAgIC8vIEFkZGl0aW9uIG9mIHRoZSBhc3RlcmlzayBpcyBhdXRvbWF0aWMgYmFzZWQgb24gQ1NTLCBidXQgdmFsaWRpdHkgY2hlY2tpbmdcbiAgICAvLyBuZWVkcyB0byBiZSBtYW51YWxseSBydW4uXG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyh0aGlzLmlzVmFsaWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQuXG4gICAqL1xuICBzZXRIZWxwZXJUZXh0Q29udGVudChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2V0Q29udGVudChjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgVGV4dCBGaWVsZCBpbnB1dCBmYWlscyBpbiBjb252ZXJ0aW5nIHRoZVxuICAgKiAgICAgdXNlci1zdXBwbGllZCB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQmFkSW5wdXRfKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbGlkaXR5LmJhZElucHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZXN1bHQgb2YgbmF0aXZlIHZhbGlkaXR5IGNoZWNraW5nXG4gICAqICAgICAoVmFsaWRpdHlTdGF0ZS52YWxpZCkuXG4gICAqL1xuICBpc05hdGl2ZUlucHV0VmFsaWRfKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbGlkaXR5LnZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSB2YWxpZGl0eSBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKSB7XG4gICAgY29uc3Qge0lOVkFMSUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKElOVkFMSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKElOVkFMSUQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Xy5zZXRWYWxpZGl0eShpc1ZhbGlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGZvY3VzZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGb2N1c2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdHlsZUZvY3VzZWRfKGlzRm9jdXNlZCkge1xuICAgIGNvbnN0IHtGT0NVU0VEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNGb2N1c2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZPQ1VTRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZPQ1VTRUQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgZGlzYWJsZWQgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVEaXNhYmxlZF8oaXNEaXNhYmxlZCkge1xuICAgIGNvbnN0IHtESVNBQkxFRCwgSU5WQUxJRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhJTlZBTElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmljb25fKSB7XG4gICAgICB0aGlzLmljb25fLnNldERpc2FibGVkKGlzRGlzYWJsZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRWxlbWVudHwhTmF0aXZlSW5wdXRUeXBlfSBUaGUgbmF0aXZlIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAgICogaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBkdW1teSBpZiBub25lIGV4aXN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hdGl2ZUlucHV0XygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpIHx8XG4gICAgLyoqIEB0eXBlIHshTmF0aXZlSW5wdXRUeXBlfSAqLyAoe1xuICAgICAgdmFsdWU6ICcnLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgdmFsaWRpdHk6IHtcbiAgICAgICAgYmFkSW5wdXQ6IGZhbHNlLFxuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRjLXRleHRmaWVsZC13cmFwcGVyXCIgOnN0eWxlPVwie3dpZHRoOmZ1bGx3aWR0aD8nMTAwJSc6dW5kZWZpbmVkfVwiPlxyXG5cclxuICAgIDxkaXYgcmVmPVwicm9vdFwiIDpjbGFzcz1cInJvb3RDbGFzc2VzXCI+XHJcblxyXG4gICAgICA8aSByZWY9XCJpY29uXCIgdi1pZj1cIiEhaGFzTGVhZGluZ0ljb25cIlxyXG4gICAgICAgIHRhYmluZGV4PVwiMFwiIFxyXG4gICAgICAgIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2ljb25cIiAgXHJcbiAgICAgICAgOmNsYXNzPVwiaGFzTGVhZGluZ0ljb24uY2xhc3Nlc1wiPlxyXG4gICAgICAgIDxzbG90IG5hbWU9XCJsZWFkaW5nLWljb25cIj57eyBoYXNMZWFkaW5nSWNvbi5jb250ZW50IH19PC9zbG90PlxyXG4gICAgICA8L2k+XHJcblxyXG4gICAgICA8dGV4dGFyZWEgcmVmPVwiaW5wdXRcIiB2LWlmPVwibXVsdGlsaW5lXCJcclxuICAgICAgICB2LW9uPVwiJGxpc3RlbmVyc1wiXHJcbiAgICAgICAgdi1iaW5kPVwiaW5wdXRBdHRyc1wiXHJcbiAgICAgICAgOmNsYXNzPVwiaW5wdXRDbGFzc2VzXCJcclxuICAgICAgICBAaW5wdXQ9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXHJcbiAgICAgICAgOm1pbmxlbmd0aD1cIm1pbmxlbmd0aFwiIDptYXhsZW5ndGg9XCJtYXhsZW5ndGhcIlxyXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cImlucHV0UGxhY2VIb2xkZXJcIlxyXG4gICAgICAgIDphcmlhLWxhYmVsPVwiaW5wdXRQbGFjZUhvbGRlclwiXHJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJpbnB1dEFyaWFDb250cm9sc1wiXHJcbiAgICAgICAgOnJvd3M9XCJyb3dzXCIgOmNvbHM9XCJjb2xzXCIgXHJcbiAgICAgICAgPjwvdGV4dGFyZWE+XHJcblxyXG4gICAgICA8aW5wdXQgcmVmPVwiaW5wdXRcIiB2LWVsc2VcclxuICAgICAgICB2LW9uPVwiJGxpc3RlbmVyc1wiIFxyXG4gICAgICAgIHYtYmluZD1cImlucHV0QXR0cnNcIlxyXG4gICAgICAgIDpjbGFzcz1cImlucHV0Q2xhc3Nlc1wiXHJcbiAgICAgICAgQGlucHV0PVwidXBkYXRlVmFsdWUoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxyXG4gICAgICAgIDp0eXBlPVwidHlwZVwiXHJcbiAgICAgICAgOm1pbmxlbmd0aD1cIm1pbmxlbmd0aFwiIDptYXhsZW5ndGg9XCJtYXhsZW5ndGhcIlxyXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cImlucHV0UGxhY2VIb2xkZXJcIlxyXG4gICAgICAgIDphcmlhLWxhYmVsPVwiaW5wdXRQbGFjZUhvbGRlclwiXHJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJpbnB1dEFyaWFDb250cm9sc1wiIFxyXG4gICAgICAgIC8+XHJcblxyXG4gICAgICA8bGFiZWwgcmVmPVwibGFiZWxcIiA6Y2xhc3M9XCJsYWJlbENsYXNzZXNVcGdyYWRlZFwiIDpmb3I9XCJfdWlkXCIgIHYtaWY9XCJoYXNMYWJlbFwiPlxyXG4gICAgICAgIHt7IGxhYmVsIH19XHJcbiAgICAgIDwvbGFiZWw+XHJcblxyXG4gICAgICA8aSByZWY9XCJpY29uXCIgdi1pZj1cIiEhaGFzVHJhaWxpbmdJY29uXCJcclxuICAgICAgICB0YWJpbmRleD1cIjBcIiBcclxuICAgICAgICBjbGFzcz1cIm1kYy10ZXh0LWZpZWxkX19pY29uXCIgIFxyXG4gICAgICAgIDpjbGFzcz1cImhhc1RyYWlsaW5nSWNvbi5jbGFzc2VzXCI+XHJcbiAgICAgICAgPHNsb3QgbmFtZT1cInRyYWlsaW5nLWljb25cIj57eyBoYXNUcmFpbGluZ0ljb24uY29udGVudCB9fTwvc2xvdD5cclxuICAgICAgPC9pPlxyXG5cclxuICAgICAgPGRpdiByZWY9XCJvdXRsaW5lXCIgY2xhc3M9XCJtZGMtdGV4dC1maWVsZF9fb3V0bGluZVwiIHYtaWY9XCJoYXNPdXRsaW5lXCI+XHJcbiAgICAgICAgPHN2Zz5cclxuICAgICAgICAgIDxwYXRoIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX291dGxpbmUtcGF0aFwiIDpkPVwib3V0bGluZVBhdGhBdHRyXCIgLz5cclxuICAgICAgICA8L3N2Zz5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgcmVmPVwib3V0bGluZUlkbGVcIiBjbGFzcz1cIm1kYy10ZXh0LWZpZWxkX19pZGxlLW91dGxpbmVcIiB2LWlmPVwiaGFzT3V0bGluZVwiPjwvZGl2PlxyXG4gICAgICA8ZGl2IHJlZj1cImJvdHRvbVwiIDpjbGFzcz1cImJvdHRvbUNsYXNzZXNcIiB2LWlmPVwiaGFzQm90dG9tTGluZVwiPjwvZGl2PlxyXG5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDxwIHJlZj1cImhlbHBcIiA6aWQ9XCInaGVscC0nK191aWRcIiA6Y2xhc3M9XCJoZWxwQ2xhc3Nlc1wiXHJcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHYtaWY9XCJoZWxwdGV4dFwiPlxyXG4gICAgICB7eyBoZWxwdGV4dCAgfX1cclxuICAgIDwvcD5cclxuXHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgTURDVGV4dGZpZWxkRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2ZvdW5kYXRpb24nXHJcbmltcG9ydCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbidcclxuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvZm91bmRhdGlvbidcclxuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9mb3VuZGF0aW9uJztcclxuaW1wb3J0IE1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2xhYmVsL2ZvdW5kYXRpb24nO1xyXG5pbXBvcnQgTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9vdXRsaW5lL2ZvdW5kYXRpb24nO1xyXG5cclxuaW1wb3J0IHtcclxuICBleHRyYWN0SWNvblByb3AsIFxyXG4gIERpc3BhdGNoRm9jdXNNaXhpbiwgQ3VzdG9tRWxlbWVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQge1JpcHBsZUJhc2V9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLXRleHRmaWVsZCcsXHJcbiAgbWl4aW5zOiBbQ3VzdG9tRWxlbWVudE1peGluLCBEaXNwYXRjaEZvY3VzTWl4aW5dLFxyXG4gIG1vZGVsOiB7XHJcbiAgICBwcm9wOiAndmFsdWUnLFxyXG4gICAgZXZlbnQ6ICdtb2RlbCdcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICB2YWx1ZTogU3RyaW5nLFxyXG4gICAgdHlwZToge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICd0ZXh0JyxcclxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gWyd0ZXh0JywgJ2VtYWlsJywgJ3NlYXJjaCcsICdwYXNzd29yZCcsICd0ZWwnLCAndXJsJ11cclxuICAgICAgICAgIC5pbmRleE9mKHZhbHVlKSAhPT0gLTFcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRlbnNlOiBCb29sZWFuLFxyXG4gICAgbGFiZWw6IFN0cmluZyxcclxuICAgIGhlbHB0ZXh0OiBTdHJpbmcsXHJcbiAgICBoZWxwdGV4dFBlcnNpc3RlbnQ6IEJvb2xlYW4sXHJcbiAgICBoZWxwdGV4dFZhbGlkYXRpb246IEJvb2xlYW4sXHJcbiAgICBib3g6IEJvb2xlYW4sXHJcbiAgICBvdXRsaW5lOiBCb29sZWFuLFxyXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXHJcbiAgICByZXF1aXJlZDogQm9vbGVhbixcclxuICAgIHZhbGlkOiB7dHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdW5kZWZpbmVkfSwgXHJcbiAgICBmdWxsd2lkdGg6IEJvb2xlYW4sXHJcbiAgICBtdWx0aWxpbmU6IEJvb2xlYW4sXHJcbiAgICBsZWFkaW5nSWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXHJcbiAgICB0cmFpbGluZ0ljb246IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxyXG4gICAgc2l6ZTogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAyMCB9LFxyXG4gICAgbWlubGVuZ3RoOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IHVuZGVmaW5lZCB9LFxyXG4gICAgbWF4bGVuZ3RoOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IHVuZGVmaW5lZCB9LFxyXG4gICAgcm93czogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiA4IH0sXHJcbiAgICBjb2xzOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDQwIH0sXHJcbiAgICBcclxuICAgIC8vIG90aGVyIGlucHV0IHByb3BzICBcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIHJlYWRvbmx5OiBCb29sZWFuLFxyXG4gICAgYXV0b2NvbXBsZXRlOiBCb29sZWFuLFxyXG4gICAgYXV0b2ZvY3VzOiBCb29sZWFuLFxyXG4gIH0sXHJcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dDogdGhpcy52YWx1ZSxcclxuICAgICAgcm9vdENsYXNzZXM6IHtcclxuICAgICAgICAnbWRjLXRleHRmaWVsZCc6IHRydWUsXHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLXVwZ3JhZGVkJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWRlbnNlJzogdGhpcy5kZW5zZSxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWZ1bGx3aWR0aCc6IHRoaXMuZnVsbHdpZHRoLFxyXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tdGV4dGFyZWEnOiB0aGlzLm11bHRpbGluZSxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWJveCc6ICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLmJveCxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLW91dGxpbmVkJzogIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMub3V0bGluZSxcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRDbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkX19pbnB1dCc6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgbGFiZWxDbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkX19sYWJlbCc6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgYm90dG9tQ2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtbGluZS1yaXBwbGUnOiB0cnVlXHJcbiAgICAgIH0sXHJcbiAgICAgIGhlbHBDbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0JzogdHJ1ZSxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnOiB0aGlzLmhlbHB0ZXh0UGVyc2lzdGVudCxcclxuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJzogdGhpcy5oZWxwdGV4dFZhbGlkYXRpb25cclxuICAgICAgfSxcclxuICAgICAgb3V0bGluZVBhdGhBdHRyOiB1bmRlZmluZWQsXHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDogIHtcclxuICAgIGRpc2FibGVkICgpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxyXG4gICAgfSxcclxuICAgIHJlcXVpcmVkICgpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXRSZXF1aXJlZCh0aGlzLmRpc2FibGVkKVxyXG4gICAgfSxcclxuICAgIHZhbGlkICgpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXRWYWxpZCh0aGlzLnZhbGlkKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGVuc2UgKCkge1xyXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCAnbWRjLXRleHQtZmllbGQtLWRlbnNlJywgdGhpcy5kZW5zZSlcclxuICAgIH0sXHJcbiAgICBoZWxwdGV4dFBlcnNpc3RlbnQgKCkge1xyXG4gICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uIFxyXG4gICAgICAgICYmIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uc2V0UGVyc2lzdGVudCh0aGlzLmhlbHB0ZXh0UGVyc2lzdGVudClcclxuICAgIH0sXHJcbiAgICBoZWxwdGV4dFZhbGlkYXRpb24gKCkge1xyXG4gICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uIFxyXG4gICAgICAgICYmIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uc2V0VmFsaWRhdGlvbih0aGlzLmhlbHB0ZXh0VmFsaWRhdGlvbilcclxuICAgIH0sXHJcbiAgICB2YWx1ZSAodmFsdWUpIHtcclxuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpIHtcclxuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh2YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgIH0gXHJcbiAgICB9XHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICB1cGRhdGVWYWx1ZSAodmFsdWUpIHtcclxuICAgICAgdGhpcy4kZW1pdCgnbW9kZWwnLCB2YWx1ZSlcclxuICAgIH0sXHJcbiAgICBmb2N1cyAoKSB7XHJcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpIFxyXG4gICAgfSxcclxuICAgIGJsdXIgKCkge1xyXG4gICAgICB0aGlzLiRyZWZzLmlucHV0ICYmIHRoaXMuJHJlZnMuaW5wdXQuYmx1cigpIFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIGlucHV0QXR0cnMgKCkge1xyXG4gICAgICBsZXQgeyBuYW1lLCByZWFkb25seSwgYXV0b2NvbXBsZXRlLCBhdXRvZm9jdXN9ID0gdGhpc1xyXG4gICAgICByZXR1cm4geyBuYW1lLCByZWFkb25seSwgYXV0b2NvbXBsZXRlLCBhdXRvZm9jdXN9O1xyXG4gICAgfSxcclxuICAgIGlucHV0UGxhY2VIb2xkZXIgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mdWxsd2lkdGggPyB0aGlzLmxhYmVsIDogdW5kZWZpbmVkXHJcbiAgICB9LFxyXG4gICAgaW5wdXRBcmlhQ29udHJvbHMgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5oZWxwID8gJ2hlbHAtJyArIHRoaXMuX3VpZDogdW5kZWZpbmVkXHJcbiAgICB9LFxyXG4gICAgaGFzTGFiZWwgKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMubGFiZWxcclxuICAgIH0sXHJcbiAgICBoYXNPdXRsaW5lICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLm91dGxpbmUgXHJcbiAgICB9LFxyXG4gICAgaGFzQm90dG9tTGluZSAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5oYXNPdXRsaW5lICYmICF0aGlzLm11bHRpbGluZVxyXG4gICAgfSxcclxuICAgIGhhc0xlYWRpbmdJY29uICgpIHtcclxuICAgICAgaWYgKCh0aGlzLmxlYWRpbmdJY29uIHx8IHRoaXMuJHNsb3RzWydsZWFkaW5nLWljb24nXSlcclxuICAgICAgICAgJiYgISh0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLiRzbG90c1sndHJhaWxpbmctaWNvbiddKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlYWRpbmdJY29uID8gZXh0cmFjdEljb25Qcm9wKHRoaXMubGVhZGluZ0ljb24pIDoge31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBoYXNUcmFpbGluZ0ljb24gKCkge1xyXG4gICAgICBpZiAodGhpcy50cmFpbGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ3RyYWlsaW5nLWljb24nXSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYWlsaW5nSWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLnRyYWlsaW5nSWNvbikgOiB7fVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuICAgIGxhYmVsQ2xhc3Nlc1VwZ3JhZGVkICgpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5sYWJlbENsYXNzZXMsIHtcclxuICAgICAgICAnbWRjLXRleHQtZmllbGRfX2xhYmVsLS1mbG9hdC1hYm92ZSc6IHRoaXMudmFsdWVcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQgKCkge1xyXG5cclxuICAgIGlmICh0aGlzLiRyZWZzLmJvdHRvbSkge1xyXG4gICAgICB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uKHtcclxuICAgICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMuYm90dG9tQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmJvdHRvbUNsYXNzZXMsIGNsYXNzTmFtZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmJvdHRvbUNsYXNzZXMuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5ib3R0b20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmJvdHRvbS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5ib3R0b20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pXHJcbiAgICAgIHRoaXMuYm90dG9tTGluZUZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuJHJlZnMuaGVscCkge1xyXG4gICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uKHtcclxuICAgICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMuaGVscENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmhlbHAuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5oZWxwLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUF0dHI6IChuYW1lKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLiRyZWZzLmhlbHAucmVtb3ZlQXR0cmlidXRlKG5hbWUpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRDb250ZW50OiAoIC8qY29udGVudCovKSA9PiB7XHJcbiAgICAgICAgICAvLyBoZWxwIHRleHQgZ2V0J3MgdXBkYXRlZCBmcm9tIHt7aGVscHRleHR9fVxyXG4gICAgICAgICAgLy8gdGhpcy4kcmVmcy5oZWxwLnRleHRDb250ZW50ID0gY29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuJHJlZnMuaWNvbikge1xyXG4gICAgICBpZiAodGhpcy5oYXNMZWFkaW5nSWNvbil7XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0td2l0aC1sZWFkaW5nLWljb24nLCB0cnVlKVxyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzVHJhaWxpbmdJY29uKSB7XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0td2l0aC10cmFpbGluZy1pY29uJywgdHJ1ZSlcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pY29uRm91bmRhdGlvbiA9IG5ldyBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbih7XHJcbiAgICAgICAgc2V0QXR0cjogKGF0dHIsIHZhbHVlKSA9PiB0aGlzLiRyZWZzLmljb24uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKSxcclxuICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcclxuICAgICAgICAgIHRoaXMuJHJlZnMuaWNvbi5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgdGhpcy4kcmVmcy5pY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vdGlmeUljb25BY3Rpb246ICgpID0+IHRoaXMuJGVtaXQoJ2ljb24tYWN0aW9uJylcclxuICAgICAgfSlcclxuICAgICAgdGhpcy5pY29uRm91bmRhdGlvbi5pbml0KClcclxuICAgIH0gICAgXHJcbiAgICBcclxuICAgIGlmICh0aGlzLiRyZWZzLmxhYmVsKSB7XHJcbiAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbih7XHJcbiAgICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMubGFiZWwub2Zmc2V0V2lkdGgsXHJcbiAgICAgIH0pXHJcbiAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLmluaXQoKVxyXG4gICAgfSAgICBcclxuXHJcbiAgICBpZiAodGhpcy4kcmVmcy5vdXRsaW5lKSB7XHJcbiAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb24oe1xyXG4gICAgICAgIGdldFdpZHRoOiAoKSA9PiB0aGlzLiRyZWZzLm91dGxpbmUub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgZ2V0SGVpZ2h0OiAoKSA9PiB0aGlzLiRyZWZzLm91dGxpbmUub2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgIHNldE91dGxpbmVQYXRoQXR0cjogKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLm91dGxpbmVQYXRoQXR0ciA9IHZhbHVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWU6IChwcm9wZXJ0eU5hbWUpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGlkbGVPdXRsaW5lRWxlbWVudCA9IHRoaXMuJHJlZnMub3V0bGluZUlkbGU7XHJcbiAgICAgICAgICBpZiAoaWRsZU91dGxpbmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpZGxlT3V0bGluZUVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICB9KVxyXG4gICAgICB0aGlzLm91dGxpbmVGb3VuZGF0aW9uLmluaXQoKVxyXG4gICAgfSAgICBcclxuXHJcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGV4dGZpZWxkRm91bmRhdGlvbih7XHJcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcclxuICAgICAgfSxcclxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcclxuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxyXG4gICAgICB9LFxyXG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xyXG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxyXG4gICAgICB9LFxyXG4gICAgICByZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcclxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxyXG4gICAgICB9LFxyXG4gICAgICBkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXHJcbiAgICAgIH0sXHJcbiAgICAgIGlzRm9jdXNlZDogKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRyZWZzLmlucHV0XHJcbiAgICAgIH0sXHJcbiAgICAgIGlzUnRsOiAoKSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRyZWZzLnJvb3QpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJywgICAgIFxyXG4gICAgICBkZWFjdGl2YXRlTGluZVJpcHBsZTogKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmJvdHRvbSkge1xyXG4gICAgICAgICAgdGhpcy5ib3R0b20uZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuYm90dG9tKSB7XHJcbiAgICAgICAgICB0aGlzLmJvdHRvbS5hY3RpdmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbjogKG5vcm1hbGl6ZWRYKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuYm90dG9tKSB7XHJcbiAgICAgICAgICB0aGlzLmJvdHRvbS5zZXRSaXBwbGVDZW50ZXIobm9ybWFsaXplZFgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcclxuICAgICAgICB0aGlzLiRyZWZzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcclxuICAgICAgfSxcclxuICAgICAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgIHRoaXMuJHJlZnMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxyXG4gICAgICB9LFxyXG4gICAgICBnZXROYXRpdmVJbnB1dDogKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmlucHV0XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgfSwge1xyXG4gICAgICBib3R0b21MaW5lOiB0aGlzLmJvdHRvbUxpbmVGb3VuZGF0aW9uLFxyXG4gICAgICBoZWxwZXJUZXh0OiB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLFxyXG4gICAgICBpY29uOiB0aGlzLmljb25Gb3VuZGF0aW9uLFxyXG4gICAgICBsYWJlbDogdGhpcy5sYWJlbEZvdW5kYXRpb24sXHJcbiAgICAgIG91dGxpbmU6IHRoaXMub3V0bGluZUZvdW5kYXRpb24sXHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsdWUodGhpcy52YWx1ZSlcclxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxyXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFJlcXVpcmVkKHRoaXMucmVxdWlyZWQpXHJcbiAgICBpZiAodHlwZW9mIHRoaXMudmFsaWQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudGV4dGJveCkge1xyXG4gICAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXHJcbiAgICAgIHRoaXMucmlwcGxlLmluaXQoKVxyXG4gICAgfVxyXG5cclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xyXG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcclxuICAgIHRoaXMuYm90dG9tTGluZUZvdW5kYXRpb24gJiYgdGhpcy5ib3R0b21MaW5lRm91bmRhdGlvbi5kZXN0cm95KClcclxuICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiYgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5kZXN0cm95KClcclxuICAgIHRoaXMuaWNvbkZvdW5kYXRpb24gJiYgdGhpcy5pY29uRm91bmRhdGlvbi5kZXN0cm95KClcclxuICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uICYmIHRoaXMubGFiZWxGb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiAmJiB0aGlzLm91dGxpbmVGb3VuZGF0aW9uLmRlc3Ryb3koKVxyXG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgfVxyXG59XHJcblxyXG48L3NjcmlwdD5cclxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1RleHRGaWVsZCBmcm9tICcuL21kYy10ZXh0ZmllbGQudnVlJ1xuXG5leHBvcnQge21kY1RleHRGaWVsZH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RleHRGaWVsZFxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IDp0YWc9XCJ0YWdcIiBcbiAgICBjbGFzcz1cIm1kYy10aGVtZVwiXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90IC8+XG4gIDwvY3VzdG9tLWVsZW1lbnQ+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi4vYmFzZSdcblxuXG5jb25zdCBUSEVNRV9DT0xPUlMgPSBbXG4gICdwcmltYXJ5JyxcbiAgJ3NlY29uZGFyeScsXG4gICdiYWNrZ3JvdW5kJyxcbiAgJ3ByaW1hcnktbGlnaHQnLFxuICAnc2Vjb25kYXJ5LWxpZ2h0JyxcbiAgJ3NlY29uZGFyeS1kYXJrJyxcbiAgJ3ByaW1hcnktZGFyaydcbl1cblxuY29uc3QgVEhFTUVfU1RZTEVTID0gW1xuICAndGV4dC1wcmltYXJ5JyxcbiAgJ3RleHQtc2Vjb25kYXJ5JyxcbiAgJ3RleHQtaGludCcsXG4gICd0ZXh0LWljb24nLFxuICAndGV4dC1kaXNhYmxlZCdcbl1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRoZW1lJyxcbiAgY29tcG9uZW50czoge1xuICAgIEN1c3RvbUVsZW1lbnRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IHt0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdkaXYnIH0sXG4gICAgY29sb3I6IFN0cmluZyxcbiAgICBiYWNrZ3JvdW5kOiBTdHJpbmdcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzICgpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge31cblxuICAgICAgaWYgKHRoaXMuY29sb3IgJiYgVEhFTUVfQ09MT1JTLmluZGV4T2YodGhpcy5jb2xvcikgIT09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlc1tgbWRjLXRoZW1lLS0ke3RoaXMuY29sb3J9YF0gPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmQgJiYgVEhFTUVfQ09MT1JTLmluZGV4T2YodGhpcy5iYWNrZ3JvdW5kKSAhPT0gLTEpIHtcbiAgICAgICAgY2xhc3Nlc1tgbWRjLXRoZW1lLS0ke3RoaXMuYmFja2dyb3VuZH0tYmdgXSA9IHRydWVcblxuICAgICAgICBpZiAodGhpcy5jb2xvciAmJiBUSEVNRV9TVFlMRVMuaW5kZXhPZih0aGlzLmNvbG9yKSAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5jb2xvcn0tb24tJHt0aGlzLmJhY2tncm91bmR9YF0gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGFzc2VzXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUaGVtZSBmcm9tICcuL21kYy10aGVtZS52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY1RoZW1lXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUaGVtZVxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBGSVhFRDogJ21kYy10b29sYmFyLS1maXhlZCcsXG4gIEZJWEVEX0xBU1RST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JyxcbiAgRklYRURfQVRfTEFTVF9ST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtYXQtbGFzdC1yb3cnLFxuICBUT09MQkFSX1JPV19GTEVYSUJMRTogJ21kYy10b29sYmFyLS1mbGV4aWJsZScsXG4gIEZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1I6ICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcicsXG4gIEZMRVhJQkxFX01BWDogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1zcGFjZS1tYXhpbWl6ZWQnLFxuICBGTEVYSUJMRV9NSU46ICdtZGMtdG9vbGJhci0tZmxleGlibGUtc3BhY2UtbWluaW1pemVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9vbGJhcl9fdGl0bGUnLFxuICBGSVJTVF9ST1dfU0VMRUNUT1I6ICcubWRjLXRvb2xiYXJfX3JvdzpmaXJzdC1jaGlsZCcsXG4gIENIQU5HRV9FVkVOVDogJ01EQ1Rvb2xiYXI6Y2hhbmdlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xuICBNQVhfVElUTEVfU0laRTogMi4xMjUsXG4gIE1JTl9USVRMRV9TSVpFOiAxLjI1LFxuICBUT09MQkFSX1JPV19IRUlHSFQ6IDY0LFxuICBUT09MQkFSX1JPV19NT0JJTEVfSEVJR0hUOiA1NixcbiAgVE9PTEJBUl9NT0JJTEVfQlJFQUtQT0lOVDogNjAwLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENUb29sYmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGdldFZpZXdwb3J0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldE9mZnNldEhlaWdodDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQ6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoLyogZXZ0RGF0YToge2ZsZXhpYmxlRXhwYW5zaW9uUmF0aW86IG51bWJlcn0gKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGU6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlRm9yVGl0bGVFbGVtZW50OiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVG9vbGJhckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5jaGVja1Jvd0hlaWdodF8oKTtcbiAgICB0aGlzLnNjcm9sbEhhbmRsZXJfID0gKCkgPT4gdGhpcy51cGRhdGVUb29sYmFyU3R5bGVzXygpO1xuICAgIHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8gPSAwO1xuICAgIHRoaXMuc2Nyb2xsRnJhbWVfID0gMDtcbiAgICB0aGlzLmV4ZWN1dGVkTGFzdENoYW5nZV8gPSBmYWxzZTtcblxuICAgIHRoaXMuY2FsY3VsYXRpb25zXyA9IHtcbiAgICAgIHRvb2xiYXJSb3dIZWlnaHQ6IDAsXG4gICAgICAvLyBDYWxjdWxhdGVkIEhlaWdodCByYXRpby4gV2UgdXNlIHJhdGlvIHRvIGNhbGN1bGF0ZSBjb3JyZXNwb25kaW5nIGhlaWdodHMgaW4gcmVzaXplIGV2ZW50LlxuICAgICAgdG9vbGJhclJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgdG9vbGJhciBoZWlnaHQgdG8gcm93IGhlaWdodFxuICAgICAgZmxleGlibGVFeHBhbnNpb25SYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIGZsZXhpYmxlIHNwYWNlIGhlaWdodCB0byByb3cgaGVpZ2h0XG4gICAgICBtYXhUcmFuc2xhdGVZUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiBtYXggdG9vbGJhciBtb3ZlIHVwIGRpc3RhbmNlIHRvIHJvdyBoZWlnaHRcbiAgICAgIHNjcm9sbFRocmVzaG9sZFJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgbWF4IHNjcm9sbFRvcCB0aGF0IHdlIHNob3VsZCBsaXN0ZW4gdG8gdG8gcm93IGhlaWdodFxuICAgICAgLy8gRGVyaXZlZCBIZWlnaHRzIGJhc2VkIG9uIHRoZSBhYm92ZSBrZXkgcmF0aW9zLlxuICAgICAgdG9vbGJhckhlaWdodDogMCxcbiAgICAgIGZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0OiAwLCAvLyBGbGV4aWJsZSByb3cgbWludXMgdG9vbGJhciBoZWlnaHQgKGRlcml2ZWQpXG4gICAgICBtYXhUcmFuc2xhdGVZRGlzdGFuY2U6IDAsIC8vIFdoZW4gdG9vbGJhciBvbmx5IGZpeCBsYXN0IHJvdyAoZGVyaXZlZClcbiAgICAgIHNjcm9sbFRocmVzaG9sZDogMCxcbiAgICB9O1xuICAgIC8vIFRvb2xiYXIgZml4ZWQgYmVoYXZpb3JcbiAgICAvLyBJZiB0b29sYmFyIGlzIGZpeGVkXG4gICAgdGhpcy5maXhlZF8gPSBmYWxzZTtcbiAgICAvLyBJZiBmaXhlZCBpcyB0YXJnZXRlZCBvbmx5IGF0IHRoZSBsYXN0IHJvd1xuICAgIHRoaXMuZml4ZWRMYXN0cm93XyA9IGZhbHNlO1xuICAgIC8vIFRvb2xiYXIgZmxleGlibGUgYmVoYXZpb3JcbiAgICAvLyBJZiB0aGUgZmlyc3Qgcm93IGlzIGZsZXhpYmxlXG4gICAgdGhpcy5oYXNGbGV4aWJsZVJvd18gPSBmYWxzZTtcbiAgICAvLyBJZiB1c2UgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICB0aGlzLnVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfID0gZmFsc2U7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuZml4ZWRfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEKTtcbiAgICB0aGlzLmZpeGVkTGFzdHJvd18gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfTEFTVFJPVykgJiB0aGlzLmZpeGVkXztcbiAgICB0aGlzLmhhc0ZsZXhpYmxlUm93XyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5UT09MQkFSX1JPV19GTEVYSUJMRSk7XG4gICAgaWYgKHRoaXMuaGFzRmxleGlibGVSb3dfKSB7XG4gICAgICB0aGlzLnVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1IpO1xuICAgIH1cbiAgICB0aGlzLmluaXRLZXlSYXRpb18oKTtcbiAgICB0aGlzLnNldEtleUhlaWdodHNfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG4gIHVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMoKSB7XG4gICAgaWYgKHRoaXMuZml4ZWRfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9yRml4ZWRBZGp1c3RFbGVtZW50KCdtYXJnaW4tdG9wJywgYCR7dGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJIZWlnaHR9cHhgKTtcbiAgICB9XG4gIH1cblxuICBnZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyhzY3JvbGxUb3ApIHtcbiAgICAvLyBUbyBwcmV2ZW50IGRpdmlzaW9uIGJ5IHplcm8gd2hlbiB0aGVyZSBpcyBubyBmbGV4aWJsZUV4cGFuc2lvbkhlaWdodFxuICAgIGNvbnN0IGRlbHRhID0gMC4wMDAxO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAxIC0gc2Nyb2xsVG9wIC8gKHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCArIGRlbHRhKSk7XG4gIH1cblxuICBjaGVja1Jvd0hlaWdodF8oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5jaGVja1Jvd0hlaWdodEZyYW1lXyk7XG4gICAgdGhpcy5jaGVja1Jvd0hlaWdodEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNldEtleUhlaWdodHNfKCkpO1xuICB9XG5cbiAgc2V0S2V5SGVpZ2h0c18oKSB7XG4gICAgY29uc3QgbmV3VG9vbGJhclJvd0hlaWdodCA9IHRoaXMuZ2V0Um93SGVpZ2h0XygpO1xuICAgIGlmIChuZXdUb29sYmFyUm93SGVpZ2h0ICE9PSB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodCkge1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQgPSBuZXdUb29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJIZWlnaHQgPSB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQgPVxuICAgICAgICB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25SYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlEaXN0YW5jZSA9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGQgPVxuICAgICAgICB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMudXBkYXRlQWRqdXN0RWxlbWVudFN0eWxlcygpO1xuICAgICAgdGhpcy51cGRhdGVUb29sYmFyU3R5bGVzXygpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXJTdHlsZXNfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsRnJhbWVfKTtcbiAgICB0aGlzLnNjcm9sbEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLmFkYXB0ZXJfLmdldFZpZXdwb3J0U2Nyb2xsWSgpO1xuICAgICAgY29uc3QgaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8oc2Nyb2xsVG9wKTtcblxuICAgICAgaWYgKGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQgJiYgdGhpcy5leGVjdXRlZExhc3RDaGFuZ2VfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmxleGlibGVFeHBhbnNpb25SYXRpbyA9IHRoaXMuZ2V0RmxleGlibGVFeHBhbnNpb25SYXRpb18oc2Nyb2xsVG9wKTtcblxuICAgICAgdGhpcy51cGRhdGVUb29sYmFyRmxleGlibGVTdGF0ZV8oZmxleGlibGVFeHBhbnNpb25SYXRpbyk7XG4gICAgICBpZiAodGhpcy5maXhlZExhc3Ryb3dfKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbGJhckZpeGVkU3RhdGVfKHNjcm9sbFRvcCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNGbGV4aWJsZVJvd18pIHtcbiAgICAgICAgdGhpcy51cGRhdGVGbGV4aWJsZVJvd0VsZW1lbnRTdHlsZXNfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlZExhc3RDaGFuZ2VfID0gaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZDtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKHtmbGV4aWJsZUV4cGFuc2lvblJhdGlvOiBmbGV4aWJsZUV4cGFuc2lvblJhdGlvfSk7XG4gICAgfSk7XG4gIH1cblxuICBzY3JvbGxlZE91dE9mVGhyZXNob2xkXyhzY3JvbGxUb3ApIHtcbiAgICByZXR1cm4gc2Nyb2xsVG9wID4gdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZDtcbiAgfVxuXG4gIGluaXRLZXlSYXRpb18oKSB7XG4gICAgY29uc3QgdG9vbGJhclJvd0hlaWdodCA9IHRoaXMuZ2V0Um93SGVpZ2h0XygpO1xuICAgIGNvbnN0IGZpcnN0Um93TWF4UmF0aW8gPSB0aGlzLmFkYXB0ZXJfLmdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodCgpIC8gdG9vbGJhclJvd0hlaWdodDtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRIZWlnaHQoKSAvIHRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPSBmaXJzdFJvd01heFJhdGlvIC0gMTtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWVJhdGlvID1cbiAgICAgIHRoaXMuZml4ZWRMYXN0cm93XyA/IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gLSBmaXJzdFJvd01heFJhdGlvIDogMDtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkUmF0aW8gPVxuICAgICAgKHRoaXMuZml4ZWRMYXN0cm93XyA/IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gOiBmaXJzdFJvd01heFJhdGlvKSAtIDE7XG4gIH1cblxuICBnZXRSb3dIZWlnaHRfKCkge1xuICAgIGNvbnN0IGJyZWFrcG9pbnQgPSBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLlRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQ7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRXaWR0aCgpIDwgYnJlYWtwb2ludCA/XG4gICAgICBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLlRPT0xCQVJfUk9XX01PQklMRV9IRUlHSFQgOiBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLlRPT0xCQVJfUk9XX0hFSUdIVDtcbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01BWCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01JTik7XG4gICAgaWYgKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPT09IDEpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NQVgpO1xuICAgIH0gZWxzZSBpZiAoZmxleGlibGVFeHBhbnNpb25SYXRpbyA9PT0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01JTik7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlVG9vbGJhckZpeGVkU3RhdGVfKHNjcm9sbFRvcCkge1xuICAgIGNvbnN0IHRyYW5zbGF0ZURpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oXG4gICAgICBzY3JvbGxUb3AgLSB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQsXG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWURpc3RhbmNlKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVkoJHstdHJhbnNsYXRlRGlzdGFuY2V9cHgpYCk7XG5cbiAgICBpZiAodHJhbnNsYXRlRGlzdGFuY2UgPT09IHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZRGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRF9BVF9MQVNUX1JPVyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRF9BVF9MQVNUX1JPVyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRmxleGlibGVSb3dFbGVtZW50U3R5bGVzXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKSB7XG4gICAgaWYgKHRoaXMuZml4ZWRfKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQgKiBmbGV4aWJsZUV4cGFuc2lvblJhdGlvO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudCgnaGVpZ2h0JyxcbiAgICAgICAgYCR7aGVpZ2h0ICsgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlRmxleERlZmF1bHRCZWhhdmlvcl8pIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudFN0eWxlc0RlZmF1bHRCZWhhdmlvcl8oZmxleGlibGVFeHBhbnNpb25SYXRpbyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudFN0eWxlc0RlZmF1bHRCZWhhdmlvcl8oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIGNvbnN0IG1heFRpdGxlU2l6ZSA9IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuTUFYX1RJVExFX1NJWkU7XG4gICAgY29uc3QgbWluVGl0bGVTaXplID0gTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5NSU5fVElUTEVfU0laRTtcbiAgICBjb25zdCBjdXJyZW50VGl0bGVTaXplID0gKG1heFRpdGxlU2l6ZSAtIG1pblRpdGxlU2l6ZSkgKiBmbGV4aWJsZUV4cGFuc2lvblJhdGlvICsgbWluVGl0bGVTaXplO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvclRpdGxlRWxlbWVudCgnZm9udC1zaXplJywgYCR7Y3VycmVudFRpdGxlU2l6ZX1yZW1gKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGFuZCBpZiBzbywgdXNlIHRoZW0uXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXIgY2xhc3M9XCJtZGMtdG9vbGJhci13cmFwcGVyXCI+XG4gICAgPCEtLVRvb2xiYXItLT5cbiAgICA8ZGl2IHJlZj1cInJvb3RcIiA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiIDpzdHlsZT1cInJvb3RTdHlsZXNcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZGl2PlxuICAgIDwhLS0gRml4ZWQgQWRqdXN0IEVsZW1lbnQtLT5cbiAgICA8ZGl2IHJlZj1cImZpeGVkLWFkanVzdFwiIGNsYXNzPVwibWRjLXRvb2xiYXItZml4ZWQtYWRqdXN0XCIgXG4gICAgICA6c3R5bGU9XCJhZGp1c3RTdHlsZXNcIlxuICAgICAgdi1pZj1cImZpeGVkIHx8IHdhdGVyZmFsbCB8fCBmaXhlZExhc3Ryb3dcIj48L2Rpdj5cbiAgPC9oZWFkZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTURDVG9vbGJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbidcbiAgaW1wb3J0ICogYXMgdXRpbCBmcm9tICdAbWF0ZXJpYWwvdG9vbGJhci91dGlsJ1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnbWRjLXRvb2xiYXInLFxuICAgIHByb3BzOiB7XG4gICAgICAnZml4ZWQnOiBCb29sZWFuLFxuICAgICAgJ3dhdGVyZmFsbCc6IEJvb2xlYW4sXG4gICAgICAnZml4ZWQtbGFzdHJvdyc6IEJvb2xlYW4sXG4gICAgICAnZmxleGlibGUnOiBCb29sZWFuLFxuICAgICAgJ2ZsZXhpYmxlLWRlZmF1bHQnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICAgIH0sXG4gICAgZGF0YSAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb290Q2xhc3Nlczoge1xuICAgICAgICAgICdtZGMtdG9vbGJhcic6IHRydWUsXG4gICAgICAgICAgJ21kYy10b29sYmFyLS1maXhlZCc6IHRoaXMuZml4ZWQgfHwgdGhpcy53YXRlcmZhbGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgICAnbWRjLXRvb2xiYXItLXdhdGVyZmFsbCc6IHRoaXMud2F0ZXJmYWxsLFxuICAgICAgICAgICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JzogdGhpcy5maXhlZExhc3Ryb3csXG4gICAgICAgICAgJ21kYy10b29sYmFyLS1mbGV4aWJsZSc6IHRoaXMuZmxleGlibGUsXG4gICAgICAgICAgJ21kYy10b29sYmFyLS1mbGV4aWJsZS1kZWZhdWx0LWJlaGF2aW9yJzogdGhpcy5mbGV4aWJsZSAmJlxuICAgICAgICAgICAgdGhpcy5mbGV4aWJsZURlZmF1bHRcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdFN0eWxlczoge30sXG4gICAgICAgIGFkanVzdFN0eWxlczoge1xuICAgICAgICAgIC8vIHRvIGF2b2lkIHRvcCBtYXJnaW4gY29sbGFwc2Ugd2l0aCA6YWZ0ZXIgZWxcbiAgICAgICAgICAvLyAwLjEgcHggc2hvdWxkIGJlIHJvdW5kZWQgdG8gMHB4XG4gICAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB0cmlja1xuICAgICAgICAgIC8vIGhlaWdodDogJzAuMXB4J1xuICAgICAgICB9LFxuICAgICAgICBmb3VuZGF0aW9uOiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkICgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUb29sYmFyRm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Vmlld3BvcnRXaWR0aDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICB9LFxuICAgICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9mZnNldEhlaWdodDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3Qub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodDogKCkgPT4ge1xuICAgICAgICAgIGxldCBlbCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLnN0cmluZ3MuRklSU1RfUk9XX1NFTEVDVE9SKVxuICAgICAgICAgIHJldHVybiAoZWwpID8gZWwub2Zmc2V0SGVpZ2h0IDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeUNoYW5nZTogKGV2dERhdGEpID0+IHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZTogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBsZXQgZWwgPSB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvcihNRENUb29sYmFyRm91bmRhdGlvbi5zdHJpbmdzLlRJVExFX1NFTEVDVE9SKVxuICAgICAgICAgIGlmIChlbCkgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBlbCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLnN0cmluZ3MuRklSU1RfUk9XX1NFTEVDVE9SKVxuICAgICAgICAgIGlmIChlbCkgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmFkanVzdFN0eWxlcywgcHJvcGVydHksIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveSAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgfVxuICB9XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy10b29sYmFyLXJvdyBtZGMtdG9vbGJhcl9fcm93XCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1yb3cnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtdG9vbGJhci1zZWN0aW9uIG1kYy10b29sYmFyX19zZWN0aW9uXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXNlY3Rpb24nLFxuICBwcm9wczoge1xuICAgICdhbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2FsaWduLWVuZCc6IEJvb2xlYW4sXG4gICAgJ3Nocmluay10by1maXQnOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdG9vbGJhcl9fc2VjdGlvbi0tYWxpZ24tc3RhcnQnOiB0aGlzLmFsaWduU3RhcnQsXG4gICAgICAgICdtZGMtdG9vbGJhcl9fc2VjdGlvbi0tYWxpZ24tZW5kJzogdGhpcy5hbGlnbkVuZCxcbiAgICAgICAgJ21kYy10b29sYmFyX19zZWN0aW9uLS1zaHJpbmstdG8tZml0JzogdGhpcy5zaHJpbmtUb0ZpdFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxhIGNsYXNzPVwibWRjLXRvb2xiYXItbWVudS1pY29uIG1kYy10b29sYmFyX19tZW51LWljb25cIlxuICAgIDpjbGFzcz1cInsnbWF0ZXJpYWwtaWNvbnMnOiEhaWNvbn1cIlxuICAgIEBjbGljaz1cImRpc3BhdGNoRXZlbnRcIj5cbiAgICA8c2xvdD57e2ljb259fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1tZW51LWljb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IHt0eXBlOiBTdHJpbmcsICdkZWZhdWx0JzogXCJtZW51XCJ9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxhIGNsYXNzPVwibWRjLXRvb2xiYXItdGl0bGUgbWRjLXRvb2xiYXJfX3RpdGxlXCIgQGNsaWNrPVwiZGlzcGF0Y2hFdmVudFwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7RGlzcGF0Y2hFdmVudE1peGlufSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci10aXRsZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBjbGFzcz1cIm1kYy10b29sYmFyLWljb24gbWRjLXRvb2xiYXJfX2ljb25cIiBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCJcbiAgICBAY2xpY2s9XCJkaXNwYXRjaEV2ZW50XCI+XG4gICAgPHNsb3Q+e3tpY29ufX08L3Nsb3Q+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQge0Rpc3BhdGNoRXZlbnRNaXhpbn0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXItaWNvbicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHtCYXNlUGx1Z2lufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1Rvb2xiYXIgZnJvbSAnLi9tZGMtdG9vbGJhci52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclJvdyBmcm9tICcuL21kYy10b29sYmFyLXJvdy52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclNlY3Rpb24gZnJvbSAnLi9tZGMtdG9vbGJhci1zZWN0aW9uLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyTWVudUljb24gZnJvbSAnLi9tZGMtdG9vbGJhci1tZW51LWljb24udnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJUaXRsZSBmcm9tICcuL21kYy10b29sYmFyLXRpdGxlLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFySWNvbiBmcm9tICcuL21kYy10b29sYmFyLWljb24udnVlJ1xuXG5leHBvcnQge1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59KVxuXG4iLCJjb25zdCB0eXBvcyA9IFtcbiAgJ2Rpc3BsYXk0JywgXG4gICdkaXNwbGF5MycsIFxuICAnZGlzcGxheTInLCBcbiAgJ2Rpc3BsYXkxJywgXG4gICdoZWFkbGluZScsXG4gICd0aXRsZScsXG4gICdzdWJoZWFkaW5nMScsXG4gICdzdWJoZWFkaW5nMicsXG4gICdib2R5MScsXG4gICdib2R5MicsXG4gICdjYXB0aW9uJyxcbiAgJ2J1dHRvbidcbl1cblxuZXhwb3J0IGNvbnN0IG1kY1R5cG9NaXhpbiA9IChuYW1lKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyIChjcmVhdGVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0aGlzLnRhZywge1xuICAgICAgICAnY2xhc3MnOiB7XG4gICAgICAgICAgJ21kYy10eXBvJzogdHJ1ZSxcbiAgICAgICAgICBbbmFtZV06IHRydWUsXG4gICAgICAgICAgW2BtZGMtdHlwb2dyYXBoeS0tJHt0aGlzLnR5cG99YF06IHRydWUsXG4gICAgICAgICAgJ21kYy10eXBvZ3JhcGh5LS1hZGp1c3QtbWFyZ2luJzogdGhpcy5hZGp1c3RNYXJnaW5cbiAgICAgICAgfSxcbiAgICAgICAgJ2F0dHJzJzogdGhpcy4kYXR0cnMsXG4gICAgICAgICdvbic6IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgfSxcbiAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHQgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWRjVHlwb1Byb3BNaXhpbihkZWZhdWx0VGFnLCBkZWZhdWx0VHlwbywgdmFsaWRUeXBvcykge1xuICByZXR1cm4gIHtcbiAgICBwcm9wczoge1xuICAgICAgJ3RhZyc6IHsgXG4gICAgICAgIHR5cGU6IFN0cmluZywgXG4gICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRUYWcgXG4gICAgICB9LFxuICAgICAgJ3R5cG8nOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdFR5cG8sXG4gICAgICAgIHZhbGlkYXRvcjogICh2YWx1ZSkgPT4gdmFsaWRUeXBvcy5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgIH0sXG4gICAgICAnYWRqdXN0LW1hcmdpbic6IHsgXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZGNUZXh0U2VjdGlvbiA9IHtcbiAgbmFtZTogJ21kYy10ZXh0LXNlY3Rpb24nLFxuICBwcm9wczoge1xuICAgICd0YWcnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsIFxuICAgICAgZGVmYXVsdDogJ3NlY3Rpb24nIFxuICAgIH0sXG4gIH0sXG4gIHJlbmRlciAoY3JlYXRlRWxlbWVudCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRoaXMudGFnLCB7XG4gICAgICAnY2xhc3MnOiB7XG4gICAgICAgICdtZGMtdHlwb2dyYXBoeSc6IHRydWUsXG4gICAgICAgICdtZGMtdGV4dC1zZWN0aW9uJzogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICAnYXR0cnMnOiB0aGlzLiRhdHRycyxcbiAgICAgICdvbic6IHRoaXMuJGxpc3RlbmVyc1xuICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQgKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZGNUZXh0ID0ge1xuICBuYW1lOiAnbWRjLXRleHQnLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy10ZXh0JyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ3AnLCAnYm9keTEnLCB0eXBvcylcbiAgXSxcbn1cblxuZXhwb3J0IGNvbnN0IG1kY0Rpc3BsYXkgPSB7XG4gIG5hbWU6ICdtZGMtZGlzcGxheScsXG4gIG1peGluczogWyBcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1kaXNwbGF5JyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gxJywgJ2Rpc3BsYXkxJywgWydkaXNwbGF5NCcsICdkaXNwbGF5MycsICdkaXNwbGF5MicsICdkaXNwbGF5MSddKV0sXG59XG5cbmV4cG9ydCBjb25zdCBtZGNIZWFkbGluZSA9IHtcbiAgbmFtZTogJ21kYy1oZWFkbGluZScsXG4gIG1peGluczogWyBcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1oZWFkbGluZScpLCBcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoMicsICdoZWFkbGluZScsIFsnaGVhZGxpbmUnXSldLFxufVxuXG5leHBvcnQgY29uc3QgbWRjVGl0bGUgPSB7XG4gIG5hbWU6ICdtZGMtdGl0bGUnLFxuICBtaXhpbnM6IFsgXG4gICAgbWRjVHlwb01peGluKCdtZGMtdGl0bGUnKSwgXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDMnLCAndGl0bGUnLCBbJ3RpdGxlJ10pXSxcbn1cblxuZXhwb3J0IGNvbnN0IG1kY1N1YkhlYWRpbmcgPSB7XG4gIG5hbWU6ICdtZGMtc3ViaGVhZGluZycsXG4gIG1peGluczogWyBcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1zdWJoZWFkaW5nJyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2g0JywgJ3N1YmhlYWRpbmcyJywgWydzdWJoZWFkaW5nMScsICdzdWJoZWFkaW5nMiddKV0sXG59XG5cbmV4cG9ydCBjb25zdCAgbWRjQm9keSA9IHtcbiAgbmFtZTogJ21kYy1ib2R5JyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtYm9keScpLCBcbiAgICBtZGNUeXBvUHJvcE1peGluKCdwJywgJ2JvZHkxJywgWydib2R5MScsICdib2R5MiddKV0sXG59XG5cbmV4cG9ydCBjb25zdCBtZGNDYXB0aW9uID0ge1xuICBuYW1lOiAnbWRjLWNhcHRpb24nLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1jYXB0aW9uJyksIFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ3NwYW4nLCAnY2FwdGlvbicsIFsnY2FwdGlvbiddKV0sXG59XG4iLCJpbXBvcnQge0Jhc2VQbHVnaW59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyAgXG4gIG1kY1RleHRTZWN0aW9uLFxuICBtZGNUZXh0LFxuICBtZGNCb2R5LFxuICBtZGNDYXB0aW9uLFxuICBtZGNEaXNwbGF5LFxuICBtZGNIZWFkbGluZSxcbiAgbWRjU3ViSGVhZGluZyxcbiAgbWRjVGl0bGVcbn0gZnJvbSAnLi9tZGMtdHlwb2dyYXBoeS5qcydcblxuZXhwb3J0IHtcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufSlcbiIsIi8vXG4vLyB2dWUgUGx1Z0luXG4vL1xuaW1wb3J0IFZ1ZU1EQ0J1dHRvbiBmcm9tICcuL2J1dHRvbidcbmltcG9ydCBWdWVNRENDYXJkIGZyb20gJy4vY2FyZCdcbmltcG9ydCBWdWVNRENDaGVja2JveCBmcm9tICcuL2NoZWNrYm94J1xuaW1wb3J0IFZ1ZU1EQ0NoaXBTZXQgZnJvbSAnLi9jaGlwcydcbmltcG9ydCBWdWVNRENEaWFsb2cgZnJvbSAnLi9kaWFsb2cnXG5pbXBvcnQgVnVlTURDRHJhd2VyIGZyb20gJy4vZHJhd2VyJ1xuaW1wb3J0IFZ1ZU1EQ0VsZXZhdGlvbiBmcm9tICcuL2VsZXZhdGlvbidcbmltcG9ydCBWdWVNRENGYWIgZnJvbSAnLi9mYWInXG5pbXBvcnQgVnVlTURDR3JpZExpc3QgZnJvbSAnLi9ncmlkLWxpc3QnXG5pbXBvcnQgVnVlTURDSWNvbiBmcm9tICcuL2ljb24nXG5pbXBvcnQgVnVlTURDSWNvblRvZ2dsZSBmcm9tICcuL2ljb24tdG9nZ2xlJ1xuaW1wb3J0IFZ1ZU1EQ0xheW91dEFwcCBmcm9tICcuL2xheW91dC1hcHAnXG5pbXBvcnQgVnVlTURDTGF5b3V0R3JpZCBmcm9tICcuL2xheW91dC1ncmlkJ1xuaW1wb3J0IFZ1ZU1EQ0xpbmVhclByb2dyZXNzIGZyb20gJy4vbGluZWFyLXByb2dyZXNzJ1xuaW1wb3J0IFZ1ZU1EQ0xpc3QgZnJvbSAnLi9saXN0J1xuaW1wb3J0IFZ1ZU1EQ01lbnUgZnJvbSAnLi9tZW51J1xuaW1wb3J0IFZ1ZU1EQ1JhZGlvIGZyb20gJy4vcmFkaW8nXG5pbXBvcnQgVnVlTURDUmlwcGxlIGZyb20gJy4vcmlwcGxlJ1xuaW1wb3J0IFZ1ZU1EQ1NlbGVjdCBmcm9tICcuL3NlbGVjdCdcbmltcG9ydCBWdWVNRENTbGlkZXIgZnJvbSAnLi9zbGlkZXInXG5pbXBvcnQgVnVlTURDU25hY2tiYXIgZnJvbSAnLi9zbmFja2JhcidcbmltcG9ydCBWdWVNRENTd2l0Y2ggZnJvbSAnLi9zd2l0Y2gnXG5pbXBvcnQgVnVlTURDVGFicyBmcm9tICcuL3RhYnMnXG5pbXBvcnQgVnVlTURDVGV4dGZpZWxkIGZyb20gJy4vdGV4dGZpZWxkJ1xuaW1wb3J0IFZ1ZU1EQ1RoZW1lIGZyb20gJy4vdGhlbWUnXG5pbXBvcnQgVnVlTURDVG9vbGJhciBmcm9tICcuL3Rvb2xiYXInXG5pbXBvcnQgVnVlTURDVHlwb2dyYXBoeSBmcm9tICcuL3R5cG9ncmFwaHknXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbjogJ19fVkVSU0lPTl9fJyxcbiAgaW5zdGFsbCAgKHZtKSB7XG4gICAgdm0udXNlKFZ1ZU1EQ0J1dHRvbilcbiAgICB2bS51c2UoVnVlTURDQ2FyZClcbiAgICB2bS51c2UoVnVlTURDQ2hlY2tib3gpXG4gICAgdm0udXNlKFZ1ZU1EQ0NoaXBTZXQpXG4gICAgdm0udXNlKFZ1ZU1EQ0RpYWxvZylcbiAgICB2bS51c2UoVnVlTURDRHJhd2VyKVxuICAgIHZtLnVzZShWdWVNRENFbGV2YXRpb24pXG4gICAgdm0udXNlKFZ1ZU1EQ0ZhYilcbiAgICB2bS51c2UoVnVlTURDR3JpZExpc3QpXG4gICAgdm0udXNlKFZ1ZU1EQ0ljb24pXG4gICAgdm0udXNlKFZ1ZU1EQ0ljb25Ub2dnbGUpXG4gICAgdm0udXNlKFZ1ZU1EQ0xheW91dEFwcClcbiAgICB2bS51c2UoVnVlTURDTGF5b3V0R3JpZClcbiAgICB2bS51c2UoVnVlTURDTGluZWFyUHJvZ3Jlc3MpXG4gICAgdm0udXNlKFZ1ZU1EQ0xpc3QpXG4gICAgdm0udXNlKFZ1ZU1EQ01lbnUpXG4gICAgdm0udXNlKFZ1ZU1EQ1JhZGlvKVxuICAgIHZtLnVzZShWdWVNRENSaXBwbGUpXG4gICAgdm0udXNlKFZ1ZU1EQ1NlbGVjdClcbiAgICB2bS51c2UoVnVlTURDU2xpZGVyKVxuICAgIHZtLnVzZShWdWVNRENTbmFja2JhcilcbiAgICB2bS51c2UoVnVlTURDU3dpdGNoKVxuICAgIHZtLnVzZShWdWVNRENUYWJzKVxuICAgIHZtLnVzZShWdWVNRENUZXh0ZmllbGQpXG4gICAgdm0udXNlKFZ1ZU1EQ1RoZW1lKVxuICAgIHZtLnVzZShWdWVNRENUb29sYmFyKVxuICAgIHZtLnVzZShWdWVNRENUeXBvZ3JhcGh5KVxuICB9XG59XG4iLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnXG5pbXBvcnQge2F1dG9Jbml0fSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgcGx1Z2luIGZyb20gJy4vaW5kZXguanMnXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cblxuYXV0b0luaXQocGx1Z2luKVxuIl0sIm5hbWVzIjpbImF1dG9Jbml0IiwicGx1Z2luIiwiX1Z1ZSIsIndpbmRvdyIsIlZ1ZSIsImdsb2JhbCIsInVzZSIsIkJhc2VQbHVnaW4iLCJjb21wb25lbnRzIiwidm0iLCJrZXkiLCJjb21wb25lbnQiLCJuYW1lIiwiQ3VzdG9tRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwicHJvcHMiLCJpcyIsInRhZyIsImRhdGEiLCJjaGlsZHJlbiIsIkN1c3RvbUVsZW1lbnRNaXhpbiIsIkN1c3RvbUxpbmsiLCJ0eXBlIiwiU3RyaW5nIiwiZGVmYXVsdCIsIk9iamVjdCIsImgiLCJlbGVtZW50IiwiYmFiZWxIZWxwZXJzLmV4dGVuZHMiLCJsaW5rIiwicGFyZW50IiwiJHJvdXRlciIsIiRyb290IiwiJG9wdGlvbnMiLCJvbiIsImNsaWNrIiwibmF0aXZlT24iLCJDdXN0b21MaW5rTWl4aW4iLCJCb29sZWFuIiwidG8iLCJleGFjdCIsImFwcGVuZCIsInJlcGxhY2UiLCJhY3RpdmVDbGFzcyIsImV4YWN0QWN0aXZlQ2xhc3MiLCJlbWl0Q3VzdG9tRXZlbnQiLCJlbCIsImV2dFR5cGUiLCJldnREYXRhIiwic2hvdWxkQnViYmxlIiwiZXZ0IiwiQ3VzdG9tRXZlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUJ1dHRvbiIsImF0dHJzIiwicm9sZSIsImhyZWYiLCJDdXN0b21CdXR0b25NaXhpbiIsImV4dHJhY3RJY29uUHJvcCIsImljb25Qcm9wIiwiQXJyYXkiLCJyZWR1Y2UiLCJyZXN1bHQiLCJ2YWx1ZSIsImNsYXNzTmFtZSIsInNwbGl0IiwidGV4dENvbnRlbnQiLCJEaXNwYXRjaEV2ZW50TWl4aW4iLCIkZW1pdCIsImV2ZW50IiwidGFyZ2V0IiwiZXZlbnRUYXJnZXQiLCJhcmdzIiwiZXZlbnRBcmdzIiwiRGlzcGF0Y2hGb2N1c01peGluIiwiaGFzRm9jdXMiLCJfYWN0aXZlIiwiZGlzcGF0Y2hGb2N1c0V2ZW50Iiwic2V0VGltZW91dCIsIiRlbCIsImFjdGl2ZUVsZW1lbnQiLCJjb250YWlucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkZvY3VzRXZlbnQiLCJvbkJsdXJFdmVudCIsIm9uTW91c2VEb3duIiwib25Nb3VzZVVwIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIk1EQ0ZvdW5kYXRpb24iLCJhZGFwdGVyIiwiYWRhcHRlcl8iLCJNRENSaXBwbGVBZGFwdGVyIiwiaGFuZGxlciIsInZhck5hbWUiLCJjc3NDbGFzc2VzIiwic3RyaW5ncyIsIm51bWJlcnMiLCJzdXBwb3J0c0Nzc1ZhcmlhYmxlc18iLCJzdXBwb3J0c1Bhc3NpdmVfIiwiZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1ZyIsIndpbmRvd09iaiIsIm5vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImhhc1BzZXVkb1ZhckJ1ZyIsImJvcmRlclRvcFN0eWxlIiwicmVtb3ZlIiwic3VwcG9ydHNDc3NWYXJpYWJsZXMiLCJmb3JjZVJlZnJlc2giLCJzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCIsIkNTUyIsInN1cHBvcnRzIiwiZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyIsIndlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cyIsImFwcGx5UGFzc2l2ZSIsImdsb2JhbE9iaiIsInVuZGVmaW5lZCIsImlzU3VwcG9ydGVkIiwicGFzc2l2ZSIsImUiLCJnZXRNYXRjaGVzUHJvcGVydHkiLCJIVE1MRWxlbWVudFByb3RvdHlwZSIsImZpbHRlciIsInAiLCJwb3AiLCJnZXROb3JtYWxpemVkRXZlbnRDb29yZHMiLCJldiIsInBhZ2VPZmZzZXQiLCJjbGllbnRSZWN0IiwieCIsInkiLCJkb2N1bWVudFgiLCJsZWZ0IiwiZG9jdW1lbnRZIiwidG9wIiwibm9ybWFsaXplZFgiLCJub3JtYWxpemVkWSIsImNoYW5nZWRUb3VjaGVzIiwicGFnZVgiLCJwYWdlWSIsIkFDVElWQVRJT05fRVZFTlRfVFlQRVMiLCJQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyIsImFjdGl2YXRlZFRhcmdldHMiLCJNRENSaXBwbGVGb3VuZGF0aW9uIiwiZGVmYXVsdEFkYXB0ZXIiLCJsYXlvdXRGcmFtZV8iLCJmcmFtZV8iLCJ3aWR0aCIsImhlaWdodCIsImFjdGl2YXRpb25TdGF0ZV8iLCJkZWZhdWx0QWN0aXZhdGlvblN0YXRlXyIsImluaXRpYWxTaXplXyIsIm1heFJhZGl1c18iLCJhY3RpdmF0ZUhhbmRsZXJfIiwiYWN0aXZhdGVfIiwiZGVhY3RpdmF0ZUhhbmRsZXJfIiwiZGVhY3RpdmF0ZV8iLCJmb2N1c0hhbmRsZXJfIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWRkQ2xhc3MiLCJCR19GT0NVU0VEIiwiYmx1ckhhbmRsZXJfIiwicmVtb3ZlQ2xhc3MiLCJyZXNpemVIYW5kbGVyXyIsImxheW91dCIsInVuYm91bmRlZENvb3Jkc18iLCJmZ1NjYWxlXyIsImFjdGl2YXRpb25UaW1lcl8iLCJmZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8iLCJhY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfIiwiYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfIiwicnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfIiwicHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfIiwiYnJvd3NlclN1cHBvcnRzQ3NzVmFycyIsImlzU3VwcG9ydGVkXyIsInJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsIlJPT1QiLCJVTkJPVU5ERUQiLCJpc1VuYm91bmRlZCIsImxheW91dEludGVybmFsXyIsImRlcmVnaXN0ZXJSb290SGFuZGxlcnNfIiwiZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsInJlbW92ZUNzc1ZhcnNfIiwiZm9yRWFjaCIsInJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwicmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyUmVzaXplSGFuZGxlciIsImRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlciIsImtleXMiLCJrIiwiaW5kZXhPZiIsInVwZGF0ZUNzc1ZhcmlhYmxlIiwiaXNTdXJmYWNlRGlzYWJsZWQiLCJhY3RpdmF0aW9uU3RhdGUiLCJpc0FjdGl2YXRlZCIsInByZXZpb3VzQWN0aXZhdGlvbkV2ZW50IiwiaXNTYW1lSW50ZXJhY3Rpb24iLCJpc1Byb2dyYW1tYXRpYyIsImFjdGl2YXRpb25FdmVudCIsIndhc0FjdGl2YXRlZEJ5UG9pbnRlciIsImhhc0FjdGl2YXRlZENoaWxkIiwibGVuZ3RoIiwic29tZSIsImNvbnRhaW5zRXZlbnRUYXJnZXQiLCJyZXNldEFjdGl2YXRpb25TdGF0ZV8iLCJwdXNoIiwicmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJ3YXNFbGVtZW50TWFkZUFjdGl2ZSIsImlzU3VyZmFjZUFjdGl2ZSIsImFuaW1hdGVBY3RpdmF0aW9uXyIsIlZBUl9GR19UUkFOU0xBVEVfU1RBUlQiLCJWQVJfRkdfVFJBTlNMQVRFX0VORCIsIkZHX0RFQUNUSVZBVElPTiIsIkZHX0FDVElWQVRJT04iLCJERUFDVElWQVRJT05fVElNRU9VVF9NUyIsInRyYW5zbGF0ZVN0YXJ0IiwidHJhbnNsYXRlRW5kIiwiZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXyIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsInJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXyIsImNvbXB1dGVCb3VuZGluZ1JlY3QiLCJnZXRXaW5kb3dQYWdlT2Zmc2V0IiwiaGFzRGVhY3RpdmF0aW9uVVhSdW4iLCJhY3RpdmF0aW9uSGFzRW5kZWQiLCJGR19ERUFDVElWQVRJT05fTVMiLCJUQVBfREVMQVlfTVMiLCJzdGF0ZSIsImV2dE9iamVjdCIsImFuaW1hdGVEZWFjdGl2YXRpb25fIiwibWF4RGltIiwiTWF0aCIsIm1heCIsImdldEJvdW5kZWRSYWRpdXMiLCJoeXBvdGVudXNlIiwic3FydCIsInBvdyIsIlBBRERJTkciLCJJTklUSUFMX09SSUdJTl9TQ0FMRSIsInVwZGF0ZUxheW91dENzc1ZhcnNfIiwiVkFSX0ZHX1NJWkUiLCJWQVJfTEVGVCIsIlZBUl9UT1AiLCJWQVJfRkdfU0NBTEUiLCJyb3VuZCIsInVuYm91bmRlZCIsIlJpcHBsZUJhc2UiLCJyZWYiLCJNQVRDSEVTIiwiX21hdGNoZXMiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsIm9wdGlvbnMiLCJkaXNhYmxlZCIsIiRzZXQiLCJjbGFzc2VzIiwiJGRlbGV0ZSIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJSaXBwbGVNaXhpbiIsInJpcHBsZSIsImluaXQiLCJkZXN0cm95IiwicmVuZGVyIiwibWRjQnV0dG9uQmFzZSIsInJhaXNlZCIsInVuZWxldmF0ZWQiLCJzdHJva2VkIiwiZGVuc2UiLCJjb21wYWN0IiwiYWNjZW50Iiwic3JjIiwic3F1YXJlIiwiZnVsbEJsZWVkIiwiaWNvbiIsIk1EQ0NvbXBvbmVudCIsInJvb3QiLCJmb3VuZGF0aW9uIiwicm9vdF8iLCJpbml0aWFsaXplIiwiZm91bmRhdGlvbl8iLCJnZXREZWZhdWx0Rm91bmRhdGlvbiIsImluaXRpYWxTeW5jV2l0aERPTSIsIkVycm9yIiwiTURDUmlwcGxlIiwidW5ib3VuZGVkXyIsInNldFVuYm91bmRlZCIsImFjdGl2YXRlIiwiZGVhY3RpdmF0ZSIsImNyZWF0ZUFkYXB0ZXIiLCJkYXRhc2V0Iiwic2V0VW5ib3VuZGVkXyIsImluc3RhbmNlIiwidXRpbCIsImNsYXNzTGlzdCIsImFkZCIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJNRENTZWxlY3Rpb25Db250cm9sIiwiTURDQ2hlY2tib3hBZGFwdGVyIiwiQ0JfUFJPVE9fUFJPUFMiLCJNRENDaGVja2JveEZvdW5kYXRpb24iLCJjdXJyZW50Q2hlY2tTdGF0ZV8iLCJUUkFOU0lUSU9OX1NUQVRFX0lOSVQiLCJjdXJyZW50QW5pbWF0aW9uQ2xhc3NfIiwiYW5pbUVuZExhdGNoVGltZXJfIiwiYW5pbUVuZEhhbmRsZXJfIiwiaGFuZGxlQW5pbWF0aW9uRW5kIiwiY2hhbmdlSGFuZGxlcl8iLCJoYW5kbGVDaGFuZ2UiLCJkZXRlcm1pbmVDaGVja1N0YXRlXyIsImdldE5hdGl2ZUNvbnRyb2xfIiwiVVBHUkFERUQiLCJyZWdpc3RlckNoYW5nZUhhbmRsZXIiLCJpbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18iLCJkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlciIsInVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfIiwiY2hlY2tlZCIsImluZGV0ZXJtaW5hdGUiLCJESVNBQkxFRCIsImRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyIiwiQU5JTV9FTkRfTEFUQ0hfTVMiLCJ0cmFuc2l0aW9uQ2hlY2tTdGF0ZV8iLCJuYXRpdmVDYiIsImNiUHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImNvbnRyb2xTdGF0ZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ2YWxpZERlc2NyaXB0b3IiLCJuYXRpdmVDYkRlc2MiLCJnZXQiLCJzZXQiLCJjYWxsIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5IiwiZ2V0TmF0aXZlQ29udHJvbCIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJmb3JjZUxheW91dCIsImdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18iLCJpc0F0dGFjaGVkVG9ET00iLCJyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIiLCJUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEUiLCJUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQiLCJUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCIsIkFOSU1fVU5DSEVDS0VEX0NIRUNLRUQiLCJBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFIiwiQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRCIsIkFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFIiwiQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQiLCJBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEIiwiaW5wdXRQcm9wRGVzYyIsIk1EQ0Zvcm1GaWVsZEFkYXB0ZXIiLCJNRENGb3JtRmllbGRGb3VuZGF0aW9uIiwiY2xpY2tIYW5kbGVyXyIsImhhbmRsZUNsaWNrXyIsImFjdGl2YXRlSW5wdXRSaXBwbGUiLCJkZWFjdGl2YXRlSW5wdXRSaXBwbGUiLCJldmVudFR5cGVNYXAiLCJjc3NQcm9wZXJ0eU1hcCIsImhhc1Byb3BlclNoYXBlIiwiZXZlbnRGb3VuZEluTWFwcyIsImV2ZW50VHlwZSIsImdldEphdmFTY3JpcHRFdmVudE5hbWUiLCJtYXAiLCJzdHlsZVByb3BlcnR5Iiwibm9QcmVmaXgiLCJ3ZWJraXRQcmVmaXgiLCJnZXRBbmltYXRpb25OYW1lIiwiZXZlbnROYW1lIiwidHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzIiwiZ2V0Q29ycmVjdEV2ZW50TmFtZSIsImdldENvcnJlY3RQcm9wZXJ0eU5hbWUiLCJsYWJlbCIsIiRzbG90cyIsImhhc0xhYmVsIiwiYWxpZ25FbmQiLCJzZXRDaGVja2VkIiwic2V0RGlzYWJsZWQiLCJzZXRJbmRldGVybWluYXRlIiwiJHJlZnMiLCJjb250cm9sIiwib2Zmc2V0V2lkdGgiLCJwYXJlbnROb2RlIiwiZm9ybUZpZWxkIiwiaXNJbmRldGVybWluYXRlIiwiaXNDaGVja2VkIiwiTURDQ2hpcEFkYXB0ZXIiLCJNRENDaGlwRm91bmRhdGlvbiIsImludGVyYWN0aW9uSGFuZGxlcl8iLCJoYW5kbGVJbnRlcmFjdGlvbl8iLCJrZXlDb2RlIiwibm90aWZ5SW50ZXJhY3Rpb24iLCJsZWFkaW5nSWNvbiIsImxlYWRpbmdJY29uQ2xhc3NlcyIsInRyYWlsaW5nSWNvbiIsInRyYWlsaW5nSWNvbkNsYXNzZXMiLCJNRENDaGlwU2V0QWRhcHRlciIsIk1EQ0NoaXBTZXRGb3VuZGF0aW9uIiwiTURDRGlhbG9nRm91bmRhdGlvbiIsImlzT3Blbl8iLCJjb21wb25lbnRDbGlja0hhbmRsZXJfIiwiZXZlbnRUYXJnZXRIYXNDbGFzcyIsIkJBQ0tEUk9QIiwiY2FuY2VsIiwiZGlhbG9nQ2xpY2tIYW5kbGVyXyIsImhhbmRsZURpYWxvZ0NsaWNrXyIsImRvY3VtZW50S2V5ZG93bkhhbmRsZXJfIiwidHJhbnNpdGlvbkVuZEhhbmRsZXJfIiwiaGFuZGxlVHJhbnNpdGlvbkVuZF8iLCJkZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyIiwidW50cmFwRm9jdXNPblN1cmZhY2UiLCJkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIiLCJBTklNQVRJTkciLCJPUEVOIiwiZW5hYmxlU2Nyb2xsXyIsImRpc2FibGVTY3JvbGxfIiwicmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyIiwicmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsInNob3VsZE5vdGlmeSIsIm5vdGlmeUFjY2VwdCIsImNsb3NlIiwibm90aWZ5Q2FuY2VsIiwiQUNDRVBUX0JUTiIsImFjY2VwdCIsIkNBTkNFTF9CVE4iLCJpc0RpYWxvZyIsInRyYXBGb2N1c09uU3VyZmFjZSIsImxheW91dEZvb3RlclJpcHBsZXMiLCJhZGRCb2R5Q2xhc3MiLCJTQ1JPTExfTE9DSyIsInJlbW92ZUJvZHlDbGFzcyIsIm1vZHVsZSIsImVsZW1lbnREb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJiYXNpY1RhYmJhYmxlcyIsIm9yZGVyZWRUYWJiYWJsZXMiLCJpc1VuYXZhaWxhYmxlIiwiY3JlYXRlSXNVbmF2YWlsYWJsZSIsImNhbmRpZGF0ZVNlbGVjdG9ycyIsImNhbmRpZGF0ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiam9pbiIsImluY2x1ZGVDb250YWluZXIiLCJtYXRjaGVzIiwiRWxlbWVudCIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiY2FuZGlkYXRlU2VsZWN0b3IiLCJzbGljZSIsImFwcGx5IiwidW5zaGlmdCIsImNhbmRpZGF0ZSIsImNhbmRpZGF0ZUluZGV4IiwiaSIsImwiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsInRhYkluZGV4IiwidGFnTmFtZSIsInRhYmJhYmxlTm9kZXMiLCJzb3J0IiwiYSIsImIiLCJpbmRleCIsImlzT2ZmQ2FjaGUiLCJpc09mZiIsIm5vZGVDb21wdXRlZFN0eWxlIiwiZGVmYXVsdFZpZXciLCJkaXNwbGF5IiwidmlzaWJpbGl0eSIsImxpc3RlbmluZ0ZvY3VzVHJhcCIsImZvY3VzVHJhcCIsInVzZXJPcHRpb25zIiwiZmlyc3RUYWJiYWJsZU5vZGUiLCJsYXN0VGFiYmFibGVOb2RlIiwibm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uIiwiYWN0aXZlIiwicGF1c2VkIiwidGFiRXZlbnQiLCJjb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiY29uZmlnIiwicmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUiLCJlc2NhcGVEZWFjdGl2YXRlcyIsInRyYXAiLCJwYXVzZSIsInVucGF1c2UiLCJhY3RpdmF0ZU9wdGlvbnMiLCJkZWZhdWx0ZWRBY3RpdmF0ZU9wdGlvbnMiLCJvbkFjdGl2YXRlIiwiZGVhY3RpdmF0ZU9wdGlvbnMiLCJkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucyIsInJldHVybkZvY3VzIiwib25EZWFjdGl2YXRlIiwiYWRkTGlzdGVuZXJzIiwiZmlyc3RGb2N1c05vZGUiLCJjaGVja0ZvY3VzIiwiY2hlY2tDbGljayIsImNoZWNrUG9pbnRlckRvd24iLCJjaGVja0tleSIsInJlbW92ZUxpc3RlbmVycyIsImdldE5vZGVGb3JPcHRpb24iLCJvcHRpb25OYW1lIiwib3B0aW9uVmFsdWUiLCJjbGlja091dHNpZGVEZWFjdGl2YXRlcyIsInByZXZlbnREZWZhdWx0Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYmx1ciIsImlzRXNjYXBlRXZlbnQiLCJoYW5kbGVUYWIiLCJoYXNBdHRyaWJ1dGUiLCJOdW1iZXIiLCJjdXJyZW50Rm9jdXNJbmRleCIsInNoaWZ0S2V5IiwidHJ5Rm9jdXMiLCJ1cGRhdGVUYWJiYWJsZU5vZGVzIiwidGFiYmFibGUiLCJyZWFkanVzdEZvY3VzIiwiZm9jdXMiLCJ0b0xvd2VyQ2FzZSIsInNlbGVjdCIsImNyZWF0ZUZvY3VzVHJhcEluc3RhbmNlIiwic3VyZmFjZUVsIiwiYWNjZXB0QnV0dG9uRWwiLCJmb2N1c1RyYXBGYWN0b3J5IiwiY3JlYXRlRm9jdXNUcmFwIiwicmVxdWlyZWQiLCJtZGNCdXR0b24iLCJkYXJrIiwic2Nyb2xsYWJsZSIsInN1cmZhY2UiLCIkbGlzdGVuZXJzIiwibm90aWZ5Iiwib3BlbiIsIkZPQ1VTQUJMRV9FTEVNRU5UUyIsIk1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiIsInJvb3RDc3NDbGFzcyIsImFuaW1hdGluZ0Nzc0NsYXNzIiwib3BlbkNzc0NsYXNzIiwicm9vdENzc0NsYXNzXyIsImFuaW1hdGluZ0Nzc0NsYXNzXyIsIm9wZW5Dc3NDbGFzc18iLCJpbmVydF8iLCJjb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8iLCJoYW5kbGVUb3VjaFN0YXJ0XyIsImNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfIiwiaGFuZGxlVG91Y2hNb3ZlXyIsImNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8iLCJoYW5kbGVUb3VjaEVuZF8iLCJoYXNDbGFzcyIsImhhc05lY2Vzc2FyeURvbSIsImRldGFiaW5hdGVfIiwicmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyIiwicmV0YWJpbmF0ZV8iLCJub3RpZnlPcGVuIiwibm90aWZ5Q2xvc2UiLCJlbGVtZW50cyIsImdldEZvY3VzYWJsZUVsZW1lbnRzIiwic2F2ZUVsZW1lbnRUYWJTdGF0ZSIsIm1ha2VFbGVtZW50VW50YWJiYWJsZSIsInJlc3RvcmVFbGVtZW50VGFiU3RhdGUiLCJwb2ludGVyVHlwZSIsImRpcmVjdGlvbl8iLCJpc1J0bCIsImRyYXdlcldpZHRoXyIsImdldERyYXdlcldpZHRoIiwic3RhcnRYXyIsInRvdWNoZXMiLCJjdXJyZW50WF8iLCJ1cGRhdGVSYWZfIiwidXBkYXRlRHJhd2VyXyIsImJpbmQiLCJwcmVwYXJlRm9yVG91Y2hFbmRfIiwiYWJzIiwibmV3UG9zaXRpb25fIiwic2V0VHJhbnNsYXRlWCIsImlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8iLCJuZXdQb3MiLCJtaW4iLCJNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiIsImlzRHJhd2VyIiwiVEFCX0RBVEEiLCJUQUJfREFUQV9IQU5ETEVEIiwic3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyIsInJlbWFwRXZlbnQiLCJnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJ0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJzdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJfcmVmcmVzaCIsImRyYXdlciIsImdldFByb3BlcnR5VmFsdWUiLCJNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIiwibmV3T3BhY2l0eSIsIk9QQUNJVFlfVkFSX05BTUUiLCJtZWRpYSIsIl9zbWFsbCIsIm1hdGNoTWVkaWEiLCJfbGFyZ2UiLCJ2YWwiLCJtZGNEcmF3ZXIiLCJtZGNQZXJtYW5lbnREcmF3ZXIiLCJtZGNQZXJzaXN0ZW50RHJhd2VyIiwibWRjVGVtcG9yYXJ5RHJhd2VyIiwicGVybWFuZW50IiwicGVyc2lzdGVudCIsInRlbXBvcmFyeSIsImRyYXdlclR5cGUiLCJzbWFsbCIsIm9wZW5fIiwiaXNQZXJtYW5lbnQiLCJpc09wZW4iLCJsYXJnZSIsImlzUmVzcG9uc2l2ZSIsInRvZ2dsZU9uIiwic291cmNlIiwidG9nZ2xlT25Tb3VyY2UiLCIkb24iLCJ0b2dnbGUiLCJvcGVuT24iLCJvcGVuT25Tb3VyY2UiLCJjbG9zZU9uIiwiY2xvc2VPblNvdXJjZSIsImFkZExpc3RlbmVyIiwicmVmcmVzaE1lZGlhIiwiJG5leHRUaWNrIiwicmVtb3ZlTGlzdGVuZXIiLCJpc1RlbXBvcmFyeSIsImlzUGVyc2lzdGVudCIsImFjdGl2YXRlZCIsInN0YXJ0SWNvbiIsInRlbXBvcmFyeUNsb3NlIiwibWluaSIsImFic29sdXRlIiwiZml4ZWQiLCJNRENHcmlkTGlzdEZvdW5kYXRpb24iLCJhbGlnbkNlbnRlciIsInJlc2l6ZUZyYW1lXyIsImFsaWduQ2VudGVyXyIsImdldE51bWJlck9mVGlsZXMiLCJncmlkV2lkdGgiLCJnZXRPZmZzZXRXaWR0aCIsIml0ZW1XaWR0aCIsImdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXgiLCJ0aWxlc1dpZHRoIiwiZmxvb3IiLCJzZXRTdHlsZUZvclRpbGVzRWxlbWVudCIsIm1kY0dyaWQiLCJuYXJyb3dHdXR0ZXIiLCJoZWFkZXJDYXB0aW9uIiwicmF0aW8iLCJpY29uQWxpZ25TdGFydCIsImljb25BbGlnbkVuZCIsIndpdGhTdXBwb3J0VGV4dCIsImludGVyYWN0aXZlIiwiZGVmYXVsdFdpZHRoIiwiVElMRV9TRUxFQ1RPUiIsInByb3BlcnR5IiwiVElMRVNfU0VMRUNUT1IiLCJzZWxlY3RlZCIsImVuZEljb24iLCJhZGRSaXBwbGUiLCJyZW1vdmVSaXBwbGUiLCJpc0ludGVyYWN0aXZlIiwibG9nIiwiTURDSWNvblRvZ2dsZUFkYXB0ZXIiLCJ0ZXh0IiwiTURDSWNvblRvZ2dsZUZvdW5kYXRpb24iLCJvbl8iLCJkaXNhYmxlZF8iLCJzYXZlZFRhYkluZGV4XyIsInRvZ2dsZU9uRGF0YV8iLCJ0b2dnbGVPZmZEYXRhXyIsInRvZ2dsZUZyb21FdnRfIiwiaXNIYW5kbGluZ0tleWRvd25fIiwia2V5ZG93bkhhbmRsZXJfIiwiaXNTcGFjZSIsImtleXVwSGFuZGxlcl8iLCJyZWZyZXNoVG9nZ2xlRGF0YSIsImdldFRhYkluZGV4IiwiREFUQV9UT0dHTEVfT04iLCJEQVRBX1RPR0dMRV9PRkYiLCJwYXJzZUpzb25EYXRhQXR0cl8iLCJpc09uIiwibm90aWZ5Q2hhbmdlIiwiQVJJQV9MQUJFTCIsIkFSSUFfUFJFU1NFRCIsInNldEF0dHIiLCJjbGFzc1RvUmVtb3ZlIiwiY3NzQ2xhc3MiLCJjb250ZW50Iiwic2V0VGV4dCIsImRhdGFBdHRyIiwiZ2V0QXR0ciIsIkpTT04iLCJwYXJzZSIsImlzRGlzYWJsZWQiLCJBUklBX0RJU0FCTEVEIiwic2V0VGFiSW5kZXgiLCJybUF0dHIiLCJrZXlib2FyZEtleSIsInN0cmluZ2lmeSIsInRvZ2dsZU9mZiIsImljb25DbGFzc2VzIiwiaXNLZXlib2FyZEFjdGl2YXRlZCIsImZpeGVkQ29sdW1uV2lkdGgiLCJzcGFuT3B0aW9ucyIsIm51bSIsImlzRmluaXRlIiwic3BhbiIsIm9yZGVyIiwicGhvbmUiLCJ0YWJsZXQiLCJkZXNrdG9wIiwiYWxpZ24iLCJNRENMaW5lYXJQcm9ncmVzc0ZvdW5kYXRpb24iLCJkZXRlcm1pbmF0ZV8iLCJJTkRFVEVSTUlOQVRFX0NMQVNTIiwicmV2ZXJzZV8iLCJSRVZFUlNFRF9DTEFTUyIsInByb2dyZXNzXyIsImlzRGV0ZXJtaW5hdGUiLCJzZXRTY2FsZV8iLCJnZXRQcmltYXJ5QmFyIiwiZ2V0QnVmZmVyIiwiaXNSZXZlcnNlZCIsIkNMT1NFRF9DTEFTUyIsInNjYWxlVmFsdWUiLCJ0cmFuc2Zvcm1TdHlsZVByb3BlcnR5Iiwic2V0U3R5bGUiLCJQcm9ncmVzc1Byb3BUeXBlIiwic2V0UHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInNldEJ1ZmZlciIsImJ1ZmZlciIsInNldERldGVybWluYXRlIiwic2V0UmV2ZXJzZSIsInJldmVyc2UiLCJwcmltYXJ5IiwibWRjTGlzdCIsImF2YXRhckxpc3QiLCJ0d29MaW5lIiwiYm9yZGVyZWQiLCJpbnNldCIsInBhZGRlZCIsIk1EQ01lbnVBZGFwdGVyIiwiYXR0cmlidXRlTmFtZSIsIm9yaWdpbiIsInBvc2l0aW9uIiwiYXR0ciIsIkNvcm5lckJpdCIsIkNvcm5lciIsIlJJR0hUIiwiQk9UVE9NIiwiRkxJUF9SVEwiLCJNRENNZW51Rm91bmRhdGlvbiIsImhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfIiwiaGFuZGxlS2V5Ym9hcmREb3duXyIsImhhbmRsZUtleWJvYXJkVXBfIiwiZG9jdW1lbnRDbGlja0hhbmRsZXJfIiwiaGFuZGxlRG9jdW1lbnRDbGlja18iLCJvcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8iLCJjbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfIiwic2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8iLCJhbmltYXRpb25SZXF1ZXN0SWRfIiwiZGltZW5zaW9uc18iLCJpdGVtSGVpZ2h0XyIsImFuY2hvckNvcm5lcl8iLCJUT1BfU1RBUlQiLCJhbmNob3JNYXJnaW5fIiwicmlnaHQiLCJib3R0b20iLCJtZWFzdXJlc18iLCJzZWxlY3RlZEluZGV4XyIsInJlbWVtYmVyU2VsZWN0aW9uXyIsInF1aWNrT3Blbl8iLCJrZXlEb3duV2l0aGluTWVudV8iLCJkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlciIsImNvcm5lciIsIm1hcmdpbiIsInJlbWVtYmVyU2VsZWN0aW9uIiwic2V0U2VsZWN0ZWRJbmRleCIsInF1aWNrT3BlbiIsImZvY3VzSW5kZXgiLCJmb2N1c0l0ZW1BdEluZGV4IiwiaXNGb2N1c2VkIiwiZ2V0SW5kZXhGb3JFdmVudFRhcmdldCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwiaXNUYWIiLCJpc0Fycm93VXAiLCJpc0Fycm93RG93biIsImlzRW50ZXIiLCJmb2N1c2VkSXRlbUluZGV4IiwiZ2V0Rm9jdXNlZEl0ZW1JbmRleCIsImxhc3RJdGVtSW5kZXgiLCJnZXROdW1iZXJPZkl0ZW1zIiwiaXNFc2NhcGUiLCJnZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldCIsIkFSSUFfRElTQUJMRURfQVRUUiIsInRhcmdldEluZGV4Iiwibm90aWZ5U2VsZWN0ZWQiLCJTRUxFQ1RFRF9UUklHR0VSX0RFTEFZIiwiYW5jaG9yUmVjdCIsImdldEFuY2hvckRpbWVuc2lvbnMiLCJ2aWV3cG9ydCIsImdldFdpbmRvd0RpbWVuc2lvbnMiLCJUT1BfTEVGVCIsInZpZXdwb3J0RGlzdGFuY2UiLCJhbmNob3JIZWlnaHQiLCJhbmNob3JXaWR0aCIsIm1lbnVIZWlnaHQiLCJtZW51V2lkdGgiLCJpc0JvdHRvbUFsaWduZWQiLCJhdmFpbGFibGVUb3AiLCJhdmFpbGFibGVCb3R0b20iLCJ0b3BPdmVyZmxvdyIsImJvdHRvbU92ZXJmbG93IiwiaXNGbGlwUnRsIiwiYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCIsImlzQWxpZ25lZFJpZ2h0IiwiYXZhaWxhYmxlTGVmdCIsImF2YWlsYWJsZVJpZ2h0IiwibGVmdE92ZXJmbG93IiwicmlnaHRPdmVyZmxvdyIsImlzUmlnaHRBbGlnbmVkIiwicmlnaHRPZmZzZXQiLCJsZWZ0T2Zmc2V0IiwiTUFSR0lOX1RPX0VER0UiLCJhdm9pZFZlcnRpY2FsT3ZlcmxhcCIsImNhbk92ZXJsYXBWZXJ0aWNhbGx5IiwibWF4SGVpZ2h0IiwiaGFzQW5jaG9yIiwiZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18iLCJnZXRPcmlnaW5Db3JuZXJfIiwibWF4TWVudUhlaWdodCIsImdldE1lbnVNYXhIZWlnaHRfIiwidmVydGljYWxBbGlnbm1lbnQiLCJob3Jpem9udGFsQWxpZ25tZW50IiwiaG9yaXpvbnRhbE9mZnNldCIsImdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfIiwidmVydGljYWxPZmZzZXQiLCJnZXRWZXJ0aWNhbE9yaWdpbk9mZnNldF8iLCJBTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTyIsIk9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTyIsInZlcnRpY2FsT2Zmc2V0UGVyY2VudCIsIm9yaWdpblBlcmNlbnQiLCJzZXRUcmFuc2Zvcm1PcmlnaW4iLCJzZXRQb3NpdGlvbiIsInNldE1heEhlaWdodCIsInNhdmVGb2N1cyIsIkFOSU1BVElOR19PUEVOIiwiZ2V0SW5uZXJEaW1lbnNpb25zIiwiYXV0b1Bvc2l0aW9uXyIsImZvY3VzT25PcGVuXyIsInJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlciIsIlRSQU5TSVRJT05fT1BFTl9EVVJBVElPTiIsInRhcmdldElzRGlzYWJsZWQiLCJBTklNQVRJTkdfQ0xPU0VEIiwiVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTiIsInJlc3RvcmVGb2N1cyIsInByZXZTZWxlY3RlZEluZGV4Iiwicm1BdHRyRm9yT3B0aW9uQXRJbmRleCIsInJtQ2xhc3NGb3JPcHRpb25BdEluZGV4IiwiU0VMRUNURURfTElTVF9JVEVNIiwic2V0QXR0ckZvck9wdGlvbkF0SW5kZXgiLCJhZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXgiLCJvcGVuRnJvbVRvcExlZnQiLCJvcGVuRnJvbVRvcFJpZ2h0Iiwib3BlbkZyb21Cb3R0b21MZWZ0Iiwib3BlbkZyb21Cb3R0b21SaWdodCIsInJlZnJlc2hJdGVtcyIsIml0ZW1zIiwic2xvdE9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiX3ByZXZpb3VzRm9jdXMiLCJvZmZzZXRIZWlnaHQiLCJwYXJlbnRFbGVtZW50IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiU0VMRUNURURfRVZFTlQiLCJDQU5DRUxfRVZFTlQiLCJkaXNjb25uZWN0IiwiTURDUmFkaW9BZGFwdGVyIiwiTURDUmFkaW9Gb3VuZGF0aW9uIiwic2V0VmFsdWUiLCJwaWNrZWQiLCJnZXRWYWx1ZSIsInN5bmMiLCJNRENNZW51IiwicHJldmlvdXNGb2N1c18iLCJzZXRBbmNob3JDb3JuZXIiLCJzZXRBbmNob3JNYXJnaW4iLCJpdGVtc0NvbnRhaW5lcl8iLCJpdGVtc0NvbnRhaW5lciIsImVtaXQiLCJJVEVNU19TRUxFQ1RPUiIsImdldFNlbGVjdGVkSW5kZXgiLCJzZXRSZW1lbWJlclNlbGVjdGlvbiIsInNldFF1aWNrT3BlbiIsIk9QRU5FUl9LRVlTIiwiZm9yVHlwZSIsIk1EQ1NlbGVjdEZvdW5kYXRpb24iLCJjdHhfIiwiaXNGb2N1c2VkXyIsImRpc3BsYXlIYW5kbGVyXyIsImlzTWVudU9wZW4iLCJkaXNwbGF5VmlhS2V5Ym9hcmRIYW5kbGVyXyIsImhhbmRsZURpc3BsYXlWaWFLZXlib2FyZF8iLCJzZWxlY3Rpb25IYW5kbGVyXyIsImRldGFpbCIsImNsb3NlXyIsImNhbmNlbEhhbmRsZXJfIiwiZmxvYXRMYWJlbCIsImNyZWF0ZTJkUmVuZGVyaW5nQ29udGV4dCIsInJlZ2lzdGVyTWVudUludGVyYWN0aW9uSGFuZGxlciIsInJlc2l6ZSIsImRlcmVnaXN0ZXJNZW51SW50ZXJhY3Rpb25IYW5kbGVyIiwiZ2V0VmFsdWVGb3JPcHRpb25BdEluZGV4IiwiZ2V0TnVtYmVyT2ZPcHRpb25zIiwic2VsZWN0ZWRUZXh0Q29udGVudCIsImdldFRleHRGb3JPcHRpb25BdEluZGV4IiwidHJpbSIsInNldFNlbGVjdGVkVGV4dENvbnRlbnQiLCJtYWtlVW50YWJiYWJsZSIsIm1ha2VUYWJiYWJsZSIsImZvbnQiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJsZXR0ZXJTcGFjaW5nIiwicGFyc2VGbG9hdCIsInByaW1hcnlGb250RmFtaWx5IiwiZm9udFNpemUiLCJtYXhUZXh0TGVuZ3RoIiwic3VyZmFjZVBhZGRpbmdSaWdodCIsInN1cmZhY2VQYWRkaW5nTGVmdCIsInNlbGVjdEJveEFkZGVkUGFkZGluZyIsInR4dCIsIm1lYXN1cmVUZXh0IiwiYWRkZWRTcGFjZSIsImNlaWwiLCJzZXRNZW51U3R5bGVzRm9yT3BlbkF0SW5kZXhfIiwiYWRkQ2xhc3NUb0JvdHRvbUxpbmUiLCJCT1RUT01fTElORV9BQ1RJVkUiLCJvcGVuTWVudSIsImdldFdpbmRvd0lubmVySGVpZ2h0Iiwic2V0TWVudUVsQXR0ciIsInNldE1lbnVFbFN0eWxlIiwiZ2V0TWVudUVsT2Zmc2V0SGVpZ2h0IiwiaXRlbU9mZnNldFRvcCIsImdldE9mZnNldFRvcEZvck9wdGlvbkF0SW5kZXgiLCJybU1lbnVFbEF0dHIiLCJhZGp1c3RlZFRvcCIsIm92ZXJmbG93c1RvcCIsIm92ZXJmbG93c0JvdHRvbSIsInJlbW92ZUNsYXNzRnJvbUJvdHRvbUxpbmUiLCJFVkVOVF9QSEFTRV9BVF9UQVJHRVQiLCJldmVudFBoYXNlIiwiaXNTcGFjZURvd24iLCJpc09wZW5lcktleSIsIk1EQ1NlbGVjdExhYmVsQWRhcHRlciIsIk1EQ1NlbGVjdExhYmVsRm91bmRhdGlvbiIsIkxBQkVMX0ZMT0FUX0FCT1ZFIiwiYm94IiwibWRjTWVudSIsInJlZnJlc2hJbmRleCIsIm1lbnUiLCJsYWJlbENsYXNzZXMiLCJsYWJlbEZvdW5kYXRpb24iLCJzdHlsZUZsb2F0IiwiYm90dG9tTGluZUNsYXNzZXMiLCJib3R0b21MaW5lIiwicHJvcCIsInByb3BlcnR5TmFtZSIsInN1cmZhY2VTdHlsZXMiLCJnZXRDb250ZXh0Iiwic2hvdyIsIm9mZnNldFRvcCIsImxhYmVsVHh0IiwiZm91bmRhdGlvbkxhYmVsIiwic2Nyb2xsIiwiY291bnQiLCJzaXplIiwicmVmcmVzaFNpemUiLCJtYXhTaXplIiwiX21vYmlsZSIsIm1kY1NlbGVjdCIsIk1EQ05hdGl2ZVNlbGVjdCIsIk1EQ01lbnVTZWxlY3QiLCJNRENNdWx0aVNlbGVjdCIsIm1vYmlsZSIsIm11bHRpcGxlIiwiaXNOYXRpdmUiLCJuYXRpdmUiLCJNRENOYXRpdmVPcHRpb24iLCJNRENNdWx0aU9wdGlvbiIsIk1EQ01lbnVPcHRpb24iLCJNRENTbGlkZXJBZGFwdGVyIiwibnVtTWFya2VycyIsIktFWV9JRFMiLCJNT1ZFX0VWRU5UX01BUCIsIkRPV05fRVZFTlRTIiwiVVBfRVZFTlRTIiwiTURDU2xpZGVyRm91bmRhdGlvbiIsInJlY3RfIiwiTmFOIiwiYWN0aXZlXyIsImluVHJhbnNpdF8iLCJpc0Rpc2NyZXRlXyIsImhhc1RyYWNrTWFya2VyXyIsImhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfIiwibWluXyIsIm1heF8iLCJzdGVwXyIsInZhbHVlXyIsInByZXZlbnRGb2N1c1N0YXRlXyIsInVwZGF0ZVVJRnJhbWVfIiwidGh1bWJDb250YWluZXJQb2ludGVySGFuZGxlcl8iLCJpbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8iLCJoYW5kbGVEb3duXyIsImhhbmRsZUtleWRvd25fIiwiaGFuZGxlRm9jdXNfIiwiaGFuZGxlQmx1cl8iLCJJU19ESVNDUkVURSIsIkhBU19UUkFDS19NQVJLRVIiLCJldnROYW1lIiwicmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsImdldFN0ZXAiLCJkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJnZXRNaW4iLCJnZXRNYXgiLCJzdGVwIiwiaW5kaXZpc2libGUiLCJyZW1vdmVUcmFja01hcmtlcnMiLCJhcHBlbmRUcmFja01hcmtlcnMiLCJsYXN0U3RlcFJhdGlvIiwiZmxleCIsInNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5IiwidXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfIiwic2V0VmFsdWVfIiwiQVJJQV9WQUxVRU1BWCIsInNldHVwVHJhY2tNYXJrZXIiLCJBUklBX1ZBTFVFTUlOIiwidG9nZ2xlQ2xhc3NfIiwiaXNOYU4iLCJzZXRJblRyYW5zaXRfIiwic2V0QWN0aXZlXyIsIm1vdmVIYW5kbGVyIiwiaGFuZGxlTW92ZV8iLCJ1cEhhbmRsZXIiLCJoYW5kbGVVcF8iLCJkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlciIsInNldFZhbHVlRnJvbUV2dF8iLCJ0YXJnZXRUb3VjaGVzIiwiZ2V0UGFnZVhfIiwiY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyIsInhQb3MiLCJwY3RDb21wbGV0ZSIsImlzUlRMIiwia2V5SWQiLCJnZXRLZXlJZF8iLCJnZXRWYWx1ZUZvcktleUlkXyIsIkZPQ1VTIiwia2JkRXZ0IiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiQVJST1dfVVAiLCJBUlJPV19ET1dOIiwiSE9NRSIsIkVORCIsIlBBR0VfVVAiLCJQQUdFX0RPV04iLCJkZWx0YSIsInZhbHVlTmVlZHNUb0JlRmxpcHBlZCIsIlBBR0VfRkFDVE9SIiwic2hvdWxkRmlyZUlucHV0IiwiZm9yY2UiLCJ2YWx1ZVNldFRvQm91bmRhcnkiLCJxdWFudGl6ZV8iLCJBUklBX1ZBTFVFTk9XIiwibm90aWZ5SW5wdXQiLCJzZXRNYXJrZXJWYWx1ZSIsIm51bVN0ZXBzIiwicXVhbnRpemVkVmFsIiwidHJhbnNsYXRlUHgiLCJ0cmFuc2Zvcm1Qcm9wIiwidHJhbnNpdGlvbmVuZEV2dE5hbWUiLCJvblRyYW5zaXRpb25FbmQiLCJzZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkiLCJzZXRUcmFja1N0eWxlUHJvcGVydHkiLCJBQ1RJVkUiLCJpblRyYW5zaXQiLCJJTl9UUkFOU0lUIiwic2hvdWxkQmVQcmVzZW50IiwiZGlzcGxheU1hcmtlcnMiLCJzZXRNaW4iLCJzZXRNYXgiLCJzZXRTdGVwIiwidGh1bWJDb250YWluZXIiLCJ0aHVtYlN0eWxlcyIsInRyYWNrU3R5bGVzIiwibWFya2VyVmFsdWUiLCJsYXN0VHJhY2tNYXJrZXJzU3R5bGVzIiwiaGFzTWFya2VycyIsImxheW91dE9uIiwibGF5b3V0T25Tb3VyY2UiLCJNRENTbmFja2JhckZvdW5kYXRpb24iLCJhY3Rpb25XYXNDbGlja2VkXyIsImRpc21pc3NPbkFjdGlvbl8iLCJmaXJzdEZvY3VzXyIsInBvaW50ZXJEb3duUmVjb2duaXplZF8iLCJzbmFja2Jhckhhc0ZvY3VzXyIsInNuYWNrYmFyRGF0YV8iLCJxdWV1ZV8iLCJhY3Rpb25DbGlja0hhbmRsZXJfIiwiaW52b2tlQWN0aW9uXyIsInZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyIsInRpbWVvdXRJZF8iLCJ2aXNpYmlsaXR5SXNIaWRkZW4iLCJjbGVhbnVwXyIsInRpbWVvdXQiLCJNRVNTQUdFX1RJTUVPVVQiLCJoYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfIiwicmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIiLCJzZXRBcmlhSGlkZGVuIiwic2V0QWN0aW9uQXJpYUhpZGRlbiIsImRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIiLCJkZXJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlciIsImRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlciIsImRpc21pc3NPbkFjdGlvbiIsIm1lc3NhZ2UiLCJhY3Rpb25IYW5kbGVyIiwiYWN0aW9uVGV4dCIsInJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIiLCJyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXIiLCJyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyIiwiTVVMVElMSU5FIiwiQUNUSU9OX09OX0JPVFRPTSIsInNldE1lc3NhZ2VUZXh0IiwibXVsdGlsaW5lIiwiYWN0aW9uT25Cb3R0b20iLCJzZXRBY3Rpb25UZXh0IiwiYWN0aW9uSGFuZGxlcl8iLCJzZXRBY3Rpb25IaWRkZW5fIiwidW5zZXRBcmlhSGlkZGVuIiwibm90aWZ5U2hvdyIsImhpamFja0ZvY3VzIiwic2V0Rm9jdXNPbkFjdGlvbl8iLCJzZXRGb2N1cyIsImFsbG93RGlzbWlzc2FsIiwibm90aWZ5SGlkZSIsInNob3dOZXh0XyIsInNoaWZ0IiwiaXNIaWRkZW4iLCJ1bnNldEFjdGlvbkFyaWFIaWRkZW4iLCJhbGlnblN0YXJ0IiwiaGlkZGVuIiwiYWN0aW9uSGlkZGVuIiwiYnV0dG9uIiwiZXZlbnRTb3VyY2UiLCJzZXREaXNtaXNzT25BY3Rpb24iLCJkaXNtaXNzZXNPbkFjdGlvbiIsIk1EQ1RhYkZvdW5kYXRpb24iLCJjb21wdXRlZFdpZHRoXyIsImNvbXB1dGVkTGVmdF8iLCJpc0FjdGl2ZV8iLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2tfIiwiaXNBY3RpdmUiLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJnZXRPZmZzZXRMZWZ0IiwiZ2V0Q29tcHV0ZWRXaWR0aCIsImdldENvbXB1dGVkTGVmdCIsInNldEFjdGl2ZSIsInByZXZlbnRzRGVmYXVsdE9uQ2xpY2siLCJzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJtZWFzdXJlU2VsZiIsIm9mZnNldExlZnQiLCJ0YWIiLCJNRENUYWJCYXJGb3VuZGF0aW9uIiwiaXNJbmRpY2F0b3JTaG93bl8iLCJhY3RpdmVUYWJJbmRleF8iLCJiaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50IiwiYWN0aXZlVGFiSW5kZXgiLCJmaW5kQWN0aXZlVGFiSW5kZXhfIiwidW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50IiwiZm9yRWFjaFRhYkluZGV4XyIsIm1lYXN1cmVUYWJBdEluZGV4IiwibGF5b3V0SW5kaWNhdG9yXyIsImlzSW5kaWNhdG9yRmlyc3RSZW5kZXIiLCJzZXRTdHlsZUZvckluZGljYXRvciIsInRyYW5zbGF0ZUFtdEZvckFjdGl2ZVRhYkxlZnQiLCJnZXRDb21wdXRlZExlZnRGb3JUYWJBdEluZGV4Iiwic2NhbGVBbXRGb3JBY3RpdmVUYWJXaWR0aCIsImdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4IiwidHJhbnNmb3JtVmFsdWUiLCJnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvciIsImlzVGFiQWN0aXZlQXRJbmRleCIsIml0ZXJhdG9yIiwibnVtVGFicyIsImdldE51bWJlck9mVGFicyIsInNob3VsZEJyZWFrIiwicHJldkFjdGl2ZVRhYkluZGV4Iiwic2V0VGFiQWN0aXZlQXRJbmRleCIsImluZGljYXRvclByaW1hcnkiLCJpbmRpY2F0b3JBY2NlbnQiLCJ0YWJzIiwic3dpdGNoVG9UYWJBdEluZGV4Iiwib25TZWxlY3QiLCJpbmRpY2F0b3JTdHlsZXMiLCJpbmRpY2F0b3IiLCJpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrIiwicmVzZXRUYWJzIiwidGFiRWxlbWVudHMiLCJUQUJfU0VMRUNUT1IiLCJfX3Z1ZV9fIiwiaGFzVGV4dCIsImhhc0ljb24iLCJnZXRBY3RpdmVUYWJJbmRleCIsIk1EQ0xpbmVSaXBwbGVBZGFwdGVyIiwiTURDTGluZVJpcHBsZUZvdW5kYXRpb24iLCJoYW5kbGVUcmFuc2l0aW9uRW5kIiwicmVnaXN0ZXJFdmVudEhhbmRsZXIiLCJkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyIiwiTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HIiwiTElORV9SSVBQTEVfQUNUSVZFIiwieENvb3JkaW5hdGUiLCJhdHRyaWJ1dGVTdHJpbmciLCJpc0RlYWN0aXZhdGluZyIsIk1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIiwiTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24iLCJzZXRDb250ZW50IiwiSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCIsImlzVmFsaWRhdGlvbiIsIkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHIiwicmVtb3ZlQXR0ciIsIkFSSUFfSElEREVOIiwiaW5wdXRJc1ZhbGlkIiwiaGVscGVyVGV4dElzUGVyc2lzdGVudCIsImhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2ciLCJ2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5IiwiUk9MRSIsImhpZGVfIiwiTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXIiLCJNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiIsImhhbmRsZUludGVyYWN0aW9uIiwibm90aWZ5SWNvbkFjdGlvbiIsIk1EQ1RleHRGaWVsZExhYmVsQWRhcHRlciIsIk1EQ1RleHRGaWVsZExhYmVsRm91bmRhdGlvbiIsImdldFdpZHRoIiwiaXNWYWxpZCIsIkxBQkVMX1NIQUtFIiwiaXNCYWRJbnB1dCIsIk1EQ1RleHRGaWVsZE91dGxpbmVBZGFwdGVyIiwiTURDVGV4dEZpZWxkT3V0bGluZUZvdW5kYXRpb24iLCJsYWJlbFdpZHRoIiwicmFkaXVzU3R5bGVWYWx1ZSIsImdldElkbGVPdXRsaW5lU3R5bGVWYWx1ZSIsInJhZGl1cyIsImdldEhlaWdodCIsImNvcm5lcldpZHRoIiwibGVhZGluZ1N0cm9rZUxlbmd0aCIsInBhZGRlZExhYmVsV2lkdGgiLCJwYXRoTWlkZGxlIiwicGF0aCIsInNldE91dGxpbmVQYXRoQXR0ciIsIk1EQ1RleHRGaWVsZEFkYXB0ZXIiLCJNRENUZXh0RmllbGRGb3VuZGF0aW9uIiwiZm91bmRhdGlvbk1hcCIsImhlbHBlclRleHRfIiwiaGVscGVyVGV4dCIsImljb25fIiwibGFiZWxfIiwib3V0bGluZV8iLCJvdXRsaW5lIiwicmVjZWl2ZWRVc2VySW5wdXRfIiwidXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ18iLCJpc1ZhbGlkXyIsImlucHV0Rm9jdXNIYW5kbGVyXyIsImFjdGl2YXRlRm9jdXMiLCJpbnB1dEJsdXJIYW5kbGVyXyIsImRlYWN0aXZhdGVGb2N1cyIsImlucHV0SW5wdXRIYW5kbGVyXyIsImF1dG9Db21wbGV0ZUZvY3VzIiwic2V0UG9pbnRlclhPZmZzZXRfIiwidGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyIsImhhbmRsZVRleHRGaWVsZEludGVyYWN0aW9uIiwiaXNCYWRJbnB1dF8iLCJyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyIiwiZ2V0TmF0aXZlSW5wdXQiLCJpc0RlbnNlIiwiREVOU0UiLCJsYWJlbFNjYWxlIiwiREVOU0VfTEFCRUxfU0NBTEUiLCJMQUJFTF9TQ0FMRSIsInVwZGF0ZVN2Z1BhdGgiLCJzdHlsZUZvY3VzZWRfIiwiYWN0aXZhdGVMaW5lUmlwcGxlIiwidXBkYXRlT3V0bGluZSIsInN0eWxlU2hha2UiLCJzaG93VG9TY3JlZW5SZWFkZXIiLCJ0YXJnZXRDbGllbnRSZWN0IiwiZXZ0Q29vcmRzIiwiY2xpZW50WCIsImNsaWVudFkiLCJzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luIiwiZGVhY3RpdmF0ZUxpbmVSaXBwbGUiLCJpbnB1dCIsImdldE5hdGl2ZUlucHV0XyIsInNob3VsZFJlbW92ZUxhYmVsRmxvYXQiLCJzdHlsZVZhbGlkaXR5XyIsImlzTmF0aXZlSW5wdXRWYWxpZF8iLCJzdHlsZURpc2FibGVkXyIsImlzUmVxdWlyZWQiLCJ2YWxpZGl0eSIsImJhZElucHV0IiwidmFsaWQiLCJJTlZBTElEIiwic2V0VmFsaWRpdHkiLCJGT0NVU0VEIiwiZnVsbHdpZHRoIiwiaGVscHRleHRQZXJzaXN0ZW50IiwiaGVscHRleHRWYWxpZGF0aW9uIiwic2V0UmVxdWlyZWQiLCJzZXRWYWxpZCIsInJvb3RDbGFzc2VzIiwiaGVscGVyVGV4dEZvdW5kYXRpb24iLCJzZXRQZXJzaXN0ZW50Iiwic2V0VmFsaWRhdGlvbiIsInJlYWRvbmx5IiwiYXV0b2NvbXBsZXRlIiwiYXV0b2ZvY3VzIiwiaGVscCIsIl91aWQiLCJoYXNPdXRsaW5lIiwiYm90dG9tTGluZUZvdW5kYXRpb24iLCJib3R0b21DbGFzc2VzIiwiaGVscENsYXNzZXMiLCJoYXNMZWFkaW5nSWNvbiIsImhhc1RyYWlsaW5nSWNvbiIsImljb25Gb3VuZGF0aW9uIiwib3V0bGluZUZvdW5kYXRpb24iLCJvdXRsaW5lUGF0aEF0dHIiLCJpZGxlT3V0bGluZUVsZW1lbnQiLCJvdXRsaW5lSWRsZSIsIk1EQ1RleHRmaWVsZEZvdW5kYXRpb24iLCJzZXRSaXBwbGVDZW50ZXIiLCJ0ZXh0Ym94IiwiVEhFTUVfQ09MT1JTIiwiVEhFTUVfU1RZTEVTIiwiY29sb3IiLCJiYWNrZ3JvdW5kIiwiTURDVG9vbGJhckZvdW5kYXRpb24iLCJjaGVja1Jvd0hlaWdodF8iLCJzY3JvbGxIYW5kbGVyXyIsInVwZGF0ZVRvb2xiYXJTdHlsZXNfIiwiY2hlY2tSb3dIZWlnaHRGcmFtZV8iLCJzY3JvbGxGcmFtZV8iLCJleGVjdXRlZExhc3RDaGFuZ2VfIiwiY2FsY3VsYXRpb25zXyIsImZpeGVkXyIsImZpeGVkTGFzdHJvd18iLCJoYXNGbGV4aWJsZVJvd18iLCJ1c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyIsIkZJWEVEIiwiRklYRURfTEFTVFJPVyIsIlRPT0xCQVJfUk9XX0ZMRVhJQkxFIiwiRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUiIsImluaXRLZXlSYXRpb18iLCJzZXRLZXlIZWlnaHRzXyIsInJlZ2lzdGVyU2Nyb2xsSGFuZGxlciIsImRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyIiwic2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQiLCJ0b29sYmFySGVpZ2h0Iiwic2Nyb2xsVG9wIiwiZmxleGlibGVFeHBhbnNpb25IZWlnaHQiLCJuZXdUb29sYmFyUm93SGVpZ2h0IiwiZ2V0Um93SGVpZ2h0XyIsInRvb2xiYXJSb3dIZWlnaHQiLCJ0b29sYmFyUmF0aW8iLCJmbGV4aWJsZUV4cGFuc2lvblJhdGlvIiwibWF4VHJhbnNsYXRlWURpc3RhbmNlIiwibWF4VHJhbnNsYXRlWVJhdGlvIiwic2Nyb2xsVGhyZXNob2xkIiwic2Nyb2xsVGhyZXNob2xkUmF0aW8iLCJ1cGRhdGVBZGp1c3RFbGVtZW50U3R5bGVzIiwiZ2V0Vmlld3BvcnRTY3JvbGxZIiwiaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZCIsInNjcm9sbGVkT3V0T2ZUaHJlc2hvbGRfIiwiZ2V0RmxleGlibGVFeHBhbnNpb25SYXRpb18iLCJ1cGRhdGVUb29sYmFyRmxleGlibGVTdGF0ZV8iLCJ1cGRhdGVUb29sYmFyRml4ZWRTdGF0ZV8iLCJ1cGRhdGVGbGV4aWJsZVJvd0VsZW1lbnRTdHlsZXNfIiwiZmlyc3RSb3dNYXhSYXRpbyIsImdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodCIsImdldE9mZnNldEhlaWdodCIsImJyZWFrcG9pbnQiLCJUT09MQkFSX01PQklMRV9CUkVBS1BPSU5UIiwiZ2V0Vmlld3BvcnRXaWR0aCIsIlRPT0xCQVJfUk9XX01PQklMRV9IRUlHSFQiLCJUT09MQkFSX1JPV19IRUlHSFQiLCJGTEVYSUJMRV9NQVgiLCJGTEVYSUJMRV9NSU4iLCJ0cmFuc2xhdGVEaXN0YW5jZSIsIkZJWEVEX0FUX0xBU1RfUk9XIiwic2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQiLCJ1cGRhdGVFbGVtZW50U3R5bGVzRGVmYXVsdEJlaGF2aW9yXyIsIm1heFRpdGxlU2l6ZSIsIk1BWF9USVRMRV9TSVpFIiwibWluVGl0bGVTaXplIiwiTUlOX1RJVExFX1NJWkUiLCJjdXJyZW50VGl0bGVTaXplIiwic2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQiLCJ3YXRlcmZhbGwiLCJmaXhlZExhc3Ryb3ciLCJmbGV4aWJsZSIsImZsZXhpYmxlRGVmYXVsdCIsIkZJUlNUX1JPV19TRUxFQ1RPUiIsInJvb3RTdHlsZXMiLCJUSVRMRV9TRUxFQ1RPUiIsImFkanVzdFN0eWxlcyIsInNocmlua1RvRml0IiwidHlwb3MiLCJtZGNUeXBvTWl4aW4iLCJ0eXBvIiwiYWRqdXN0TWFyZ2luIiwiJGF0dHJzIiwibWRjVHlwb1Byb3BNaXhpbiIsImRlZmF1bHRUYWciLCJkZWZhdWx0VHlwbyIsInZhbGlkVHlwb3MiLCJtZGNUZXh0U2VjdGlvbiIsIm1kY1RleHQiLCJtZGNEaXNwbGF5IiwibWRjSGVhZGxpbmUiLCJtZGNUaXRsZSIsIm1kY1N1YkhlYWRpbmciLCJtZGNCb2R5IiwibWRjQ2FwdGlvbiIsIlZ1ZU1EQ0J1dHRvbiIsIlZ1ZU1EQ0NhcmQiLCJWdWVNRENDaGVja2JveCIsIlZ1ZU1EQ0NoaXBTZXQiLCJWdWVNRENEaWFsb2ciLCJWdWVNRENEcmF3ZXIiLCJWdWVNRENFbGV2YXRpb24iLCJWdWVNRENGYWIiLCJWdWVNRENHcmlkTGlzdCIsIlZ1ZU1EQ0ljb24iLCJWdWVNRENJY29uVG9nZ2xlIiwiVnVlTURDTGF5b3V0QXBwIiwiVnVlTURDTGF5b3V0R3JpZCIsIlZ1ZU1EQ0xpbmVhclByb2dyZXNzIiwiVnVlTURDTGlzdCIsIlZ1ZU1EQ01lbnUiLCJWdWVNRENSYWRpbyIsIlZ1ZU1EQ1JpcHBsZSIsIlZ1ZU1EQ1NlbGVjdCIsIlZ1ZU1EQ1NsaWRlciIsIlZ1ZU1EQ1NuYWNrYmFyIiwiVnVlTURDU3dpdGNoIiwiVnVlTURDVGFicyIsIlZ1ZU1EQ1RleHRmaWVsZCIsIlZ1ZU1EQ1RoZW1lIiwiVnVlTURDVG9vbGJhciIsIlZ1ZU1EQ1R5cG9ncmFwaHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTyxTQUFTQSxRQUFULENBQW1CQyxNQUFuQixFQUEyQjs7TUFFNUJDLE9BQU8sSUFBWDtNQUNJLE9BQU9DLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7V0FDMUJBLE9BQU9DLEdBQWQ7R0FERixNQUVPLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUF0QixFQUFtQzs7V0FFakNBLE9BQU9ELEdBQWQ7O01BRUVGLElBQUosRUFBVTtTQUNISSxHQUFMLENBQVNMLE1BQVQ7Ozs7QUNWRyxTQUFTTSxVQUFULENBQXFCQyxVQUFyQixFQUFpQztTQUMvQjthQUNJLFFBREo7YUFFSSxpQkFBQ0MsRUFBRCxFQUFRO1dBQ1YsSUFBSUMsR0FBVCxJQUFnQkYsVUFBaEIsRUFBNEI7WUFDdEJHLFlBQVlILFdBQVdFLEdBQVgsQ0FBaEI7V0FDS0MsU0FBSCxDQUFhQSxVQUFVQyxJQUF2QixFQUE0QkQsU0FBNUI7O0tBTEQ7O0dBQVA7OztBQ0RLLElBQU1FLGdCQUFnQjtjQUNmLElBRGU7UUFBQSxrQkFFbkJDLGFBRm1CLEVBRUpDLE9BRkksRUFFSztXQUN2QkQsY0FDTEMsUUFBUUMsS0FBUixDQUFjQyxFQUFkLElBQW9CRixRQUFRQyxLQUFSLENBQWNFLEdBQWxDLElBQXlDLEtBRHBDLEVBRUxILFFBQVFJLElBRkgsRUFHTEosUUFBUUssUUFISCxDQUFQOztDQUhHOztBQVVQLEFBQU8sSUFBTUMscUJBQXFCO2NBQ3BCOzs7Q0FEUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
